import { ApiOptions, Instrumentation } from "@locker/instrumentation";
declare const ArrayCtor: ArrayConstructor;
// Used by '@locker/near-membrane-dom'.
declare const ArrayProtoIncludes: (searchElement: any, fromIndex?: number | undefined) => boolean, ArrayProtoMap: <U>(callbackfn: (value: any, index: number, array: any[]) => U, thisArg?: any) => U[], ArrayProtoSplice: {
    (start: number, deleteCount?: number | undefined): any[];
    (start: number, deleteCount: number, ...items: any[]): any[];
}, ArrayProtoSort: (compareFn?: ((a: any, b: any) => number) | undefined) => any[], ArrayProtoUnshift: (...items: any[]) => number;
declare const ArrayProtoFilter: {
    <S extends any>(predicate: (value: any, index: number, array: any[]) => value is S, thisArg?: any): S[];
    (predicate: (value: any, index: number, array: any[]) => unknown, thisArg?: any): any[];
}, ArrayProtoFind: {
    <S extends any>(predicate: (value: any, index: number, obj: any[]) => value is S, thisArg?: any): S | undefined;
    (predicate: (value: any, index: number, obj: any[]) => unknown, thisArg?: any): any;
}, ArrayProtoIndexOf: (searchElement: any, fromIndex?: number | undefined) => number, ArrayProtoJoin: (separator?: string | undefined) => string, ArrayProtoPush: (...items: any[]) => number, ArrayProtoShift: () => any, ArrayProtoSlice: (start?: number | undefined, end?: number | undefined) => any[], ArrayProtoToString: () => string;
declare const ArrayIsArray: (arg: any) => arg is any[];
declare function ArrayConcat(array: any[] | readonly any[], ...args: Parameters<typeof Array.prototype.concat>): ReturnType<typeof Array.prototype.concat>;
declare function toSafeArray<T extends any[]>(array: T): T;
declare const ArrayBufferIsView: (arg: any) => arg is ArrayBufferView;
type Getter = () => any;
interface GetterSetterDescriptor {
    configurable?: boolean;
    enumerable?: boolean;
    get: Getter;
    set: Setter;
}
type NearMembraneSerializedValue = bigint | boolean | number | string | symbol | undefined;
// eslint-disable-next-line no-shadow
declare const enum ProxyHandlerTraps {
    None = 0,
    Apply = 1,
    Construct = 2,
    DefineProperty = 4,
    DeleteProperty = 8,
    Get = 16,
    GetOwnPropertyDescriptor = 32,
    GetPrototypeOf = 64,
    Has = 128,
    IsExtensible = 256,
    OwnKeys = 512,
    PreventExtensions = 1024,
    Set = 2048,
    SetPrototypeOf = 4096
}
type ProxyTarget = CallableFunction | NewableFunction | any[] | object;
interface ProxyTrapInvokers {
    // We can add more trap invokers as needed.
    apply?: typeof Reflect.apply;
    construct?: typeof Reflect.construct;
    defineProperty?: typeof Reflect.defineProperty;
    get?: <T extends object, P extends PropertyKey>(target: T, propertyKey: P, receiver?: unknown, handshake?: boolean) => P extends keyof T ? T[P] : any;
    getOwnPropertyDescriptor?: typeof Reflect.getOwnPropertyDescriptor;
    has?: typeof Reflect.has;
    set?: typeof Reflect.set;
}
type SandboxKey = string;
interface SandboxRecord {
    BASIC_INSTRUMENTATION_DATA: ApiOptions;
    LOCKER_INSTRUMENTATION_FLAG: boolean;
    LOCKER_VERBOSE_INSTRUMENTATION_FLAG: boolean;
    UNCOMPILED_CONTEXT: any;
    context: any;
    document: any;
    distortions: WeakMap<any, any>;
    endowments: object;
    globalObject: typeof globalThis;
    helpers: any;
    instrumentation: Instrumentation;
    key: SandboxKey;
    root: SandboxRecord;
    sandboxEvaluator: Function;
    type: number;
    virtualEnvironmentEvaluator: Function;
}
// eslint-disable-next-line no-shadow
declare const enum SandboxType {
    External = 0,
    Internal = 1
}
type Setter = (value: any) => void;
// eslint-disable-next-line no-shadow
declare const enum TargetTraits {
    None = 0,
    IsArray = 1,
    IsArrayBufferView = 2,
    IsFunction = 4,
    IsArrowFunction = 8,
    IsObject = 16,
    IsTypedArray = 32,
    Revoked = 64
}
declare const ArrayBufferProtoByteLengthGetter: Getter;
declare function getBrand(value: any): string;
declare const getTimestamp: any;
// Based on Acorn strictDirective() parser utility.
// Copyright 2012-2022. Released under MIT License.
// https://github.com/acornjs/acorn/blob/master/acorn/src/parseutil.js
declare function indexOfPragma(source: string, pragma: string): number;
// https://caniuse.com/bigint
declare const SUPPORTS_BIG_INT: boolean;
declare const BigIntProtoValueOf: (() => bigint) | undefined;
declare const BooleanProtoValueOf: () => boolean;
declare function partialStructuredClone(value: any): any;
declare function shallowCloneArray<T>(array: T[] | readonly T[]): T[];
declare function shallowCloneOptions<T extends {}>(options: T): T;
declare function consoleWarn(...args: Parameters<typeof console.warn>): void;
// Locker build constants.
declare const LOCKER_IDENTIFIER_MARKER = "$LWS";
// This package is bundled by third-parties that have their own build time
// replacement logic. Instead of customizing each build system to be aware
// of this package we implement a two phase debug mode by performing small
// runtime checks to determine phase one, our code is unminified, and
// phase two, the user opted-in to custom devtools formatters. Phase one
// is used for light weight initialization time debug while phase two is
// reserved for post initialization runtime
declare const LOCKER_UNMINIFIED_FLAG: boolean;
// Locker key constants.
declare const LOCKER_SERVICE_KEY = "LSKey";
declare const LOCKER_SERVICE_KEY_LOWERED = "lskey";
// Character constants.
declare const CHAR_QUOTE_DOUBLE = "\"";
declare const CHAR_QUOTE_SINGLE = "'";
// Compiler constants.
declare const UNCOMPILED_LOCATION_NAME = "uncompiledLocation$LWS";
declare const UNCOMPILED_TOP_NAME = "uncompiledTop$LWS";
declare const WEBPACK_REQUIRE_NAME = "__webpack_require__";
// Error message constants.
declare const ERR_ILLEGAL_PROPERTY_ACCESS = "Illegal property access.";
declare const ERR_INVALID_SANDBOX_KEY = "Invalid sandbox key.";
// Near-membrane constants.
declare const LOCKER_NEAR_MEMBRANE_IS_MASKED_SYMBOL: symbol;
declare const LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL: symbol;
declare const LOCKER_NEAR_MEMBRANE_SYMBOL: symbol;
declare const LOCKER_NEAR_MEMBRANE_UNMASKED_VALUE_SYMBOL: symbol;
declare const SYMBOL_LIVE_OBJECT: symbol;
// Object brand constants.
declare const TO_STRING_BRAND_ARRAY = "[object Array]";
declare const TO_STRING_BRAND_ARRAY_BUFFER = "[object ArrayBuffer]";
declare const TO_STRING_BRAND_BIG_INT = "[object BigInt]";
declare const TO_STRING_BRAND_BOOLEAN = "[object Boolean]";
declare const TO_STRING_BRAND_DATE = "[object Date]";
declare const TO_STRING_BRAND_ERROR = "[object Error]";
declare const TO_STRING_BRAND_FUNCTION = "[object Function]";
declare const TO_STRING_BRAND_MAP = "[object Map]";
declare const TO_STRING_BRAND_NULL = "[object Null]";
declare const TO_STRING_BRAND_NUMBER = "[object Number]";
declare const TO_STRING_BRAND_OBJECT = "[object Object]";
declare const TO_STRING_BRAND_REG_EXP = "[object RegExp]";
declare const TO_STRING_BRAND_SET = "[object Set]";
declare const TO_STRING_BRAND_STRING = "[object String]";
declare const TO_STRING_BRAND_SYMBOL = "[object Symbol]";
declare const TO_STRING_BRAND_UNDEFINED = "[object Undefined]";
declare const TO_STRING_BRAND_WEAK_MAP = "[object WeakMap]";
declare const TO_STRING_BRAND_WEAK_SET = "[object WeakSet]";
// Sandbox constants.
declare const SANDBOX_EVAL_CONTEXT_NAME = "$lockerEvalContext$";
declare const SANDBOX_EVAL_HELPERS_NAME = "$lockerEvalHelpers$";
declare const DateNow: () => number;
declare const DateProtoValueOf: () => number;
// Used by '@locker/near-membrane-base'
declare const ErrorCtor: ErrorConstructor;
// Used by '@locker/near-membrane-' packages.
declare const TypeErrorCtor: TypeErrorConstructor;
declare class LockerSecurityError extends Error {
    constructor(message: string);
}
declare const FunctionProtoBind: (this: Function, thisArg: any, ...argArray: any[]) => any, FunctionProtoToString: () => string;
declare function createUnmaskableTraps(func: Function): {
    defineProperty(target: ProxyTarget, key: PropertyKey, desc: PropertyDescriptor): boolean;
    get(target: ProxyTarget, key: PropertyKey, receiver?: unknown, handshake?: boolean): any;
    getOwnPropertyDescriptor(target: ProxyTarget, key: PropertyKey): TypedPropertyDescriptor<any> | undefined;
    has(target: ProxyTarget, key: PropertyKey): boolean;
    set(target: ProxyTarget, key: PropertyKey, value: any, receiver: any): boolean;
};
declare function getUnmaskedFunction<T extends Function>(func: T): T;
declare function identity<T>(value: T): T;
declare function isMaskedFunction(value: any): boolean;
declare function maskFunction<T extends Function>(func: Function, maskFunc: T, trapInvokers?: ProxyTrapInvokers): T;
declare function noop(): void;
declare function registerGaterEnabledFeatures(lockerGaterEnabledFeatures: string[]): void;
declare function deregisterGaterEnabledFeatures(lockerGaterEnabledFeatures: string[]): void;
declare function clearGaterEnabledFeatures(): void;
declare function isGaterEnabledFeature(featureName: string): boolean;
declare const ENABLE_MAX_PERF_MODE_GATE = "enableMaxPerfMode";
declare const ENABLE_SANDBOXED_SAMEORIGIN_IFRAME_GATE = "enableSandboxedSameOriginIframe";
declare function isAllowedToOverrideGaterEnabledFeature(sandboxKey: SandboxKey, featureName: string): boolean;
declare function isNotAllowedToOverrideGaterEnabledFeature(...args: Parameters<typeof isAllowedToOverrideGaterEnabledFeature>): boolean;
declare const JSONParse: (text: string, reviver?: ((this: any, key: string, value: any) => any) | undefined) => any;
// Used by '@locker/near-membrane-dom'.
declare const JSONStringify: {
    (value: any, replacer?: ((this: any, key: string, value: any) => any) | undefined, space?: string | number | undefined): string;
    (value: any, replacer?: (string | number)[] | null | undefined, space?: string | number | undefined): string;
};
declare function isTargetLive(target: ProxyTarget, targetTraits?: TargetTraits): boolean;
declare function markTargetAsLive<T extends ProxyTarget>(target: T): T;
declare function trackAsLiveTarget<T extends ProxyTarget>(target: T): T;
declare function registerLockerFeature(featureName: string, value: any): void;
declare function isLockerFeatureEnabled(featureName: string): any;
declare const MapCtor: MapConstructor;
declare const MapProtoEntries: () => IterableIterator<[
    any,
    any
]>, MapProtoSet: (key: any, value: any) => Map<any, any>;
declare const MapProtoSizeGetter: Getter;
declare function toSafeMap<T extends Map<any, any>>(map: T): T;
// Used by '@locker/near-membrane-dom'.
declare const MathMin: (...values: number[]) => number;
declare function getNamespaceMarker(namespace: SandboxKey): string;
declare function getStorageNamespaceMarker(namespace: SandboxKey): string;
declare function prependNamespaceMarker(key: string, namespace: SandboxKey): string;
declare function prependStorageNamespaceMarker(key: string, namespace: SandboxKey): string;
declare function removeNamespaceMarker(key: string, namespace: SandboxKey): string;
declare function removeStorageNamespaceMarker(key: string, namespace: SandboxKey): string;
declare function startsWithNamespaceMarker(key: string, namespace: string): boolean;
declare function startsWithStorageNamespaceMarker(key: string, namespace: string): boolean;
declare function getNearMembraneProxySerializedValue(object: object): NearMembraneSerializedValue;
declare function isNearMembraneProxy(value: any): boolean;
// Used by '@locker/near-membrane-dom'.
declare const NumberIsFinite: (number: unknown) => boolean, NumberIsInteger: (number: unknown) => boolean, NumberIsNaN: (number: unknown) => boolean;
declare const NumberProtoToFixed: (fractionDigits?: number | undefined) => string, NumberProtoValueOf: () => number;
declare const ObjectCtor: ObjectConstructor;
declare const ObjectAssign: {
    <T extends {}, U>(target: T, source: U): T & U;
    <T_1 extends {}, U_1, V>(target: T_1, source1: U_1, source2: V): T_1 & U_1 & V;
    <T_2 extends {}, U_2, V_1, W>(target: T_2, source1: U_2, source2: V_1, source3: W): T_2 & U_2 & V_1 & W;
    (target: object, ...sources: any[]): any;
}, ObjectFreeze: {
    <T extends Function>(f: T): T;
    <T_1 extends {
        [idx: string]: object | U | null | undefined;
    }, U extends string | number | bigint | boolean | symbol>(o: T_1): Readonly<T_1>;
    <T_2>(o: T_2): Readonly<T_2>;
}, ObjectDefineProperties: <T>(o: T, properties: PropertyDescriptorMap & ThisType<any>) => T, ObjectGetOwnPropertyDescriptors: <T>(o: T) => {
    [P in keyof T]: TypedPropertyDescriptor<T[P]>;
} & {
    [x: string]: PropertyDescriptor;
}, ObjectGetOwnPropertySymbols: (o: any) => symbol[], ObjectKeys: {
    (o: object): string[];
    (o: {}): string[];
}, ObjectPreventExtensions: <T>(o: T) => T, ObjectProto: Object;
declare const ObjectProtoToString: () => string;
declare function isObject(value: any): boolean;
declare function isObjectLike(value: any): boolean;
declare const ObjectHasOwn: (object: any, key: PropertyKey) => boolean;
declare function ObjectLookupOwnGetter(object: any, key: PropertyKey): Getter | undefined;
declare function ObjectLookupOwnSetter(object: any, key: PropertyKey): Setter | undefined;
declare function ObjectLookupOwnValue(object: any, key: PropertyKey): any;
declare const PromiseCtor: PromiseConstructor;
declare const PromiseProtoCatch: <TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null | undefined) => Promise<any>, PromiseProtoThen: <TResult1 = any, TResult2 = never>(onfulfilled?: ((value: any) => TResult1 | PromiseLike<TResult1>) | null | undefined, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined) => Promise<TResult1 | TResult2>;
declare const PromiseResolve: {
    (): Promise<void>;
    <T>(value: T): Promise<Awaited<T>>;
    <T_1>(value: T_1 | PromiseLike<T_1>): Promise<Awaited<T_1>>;
};
declare const PromiseReject: <T = never>(reason?: any) => Promise<T>;
declare const ProxyCtor: ProxyConstructor;
declare function createRevokedProxy(object: any): any;
declare function isRevokedProxy(value: any): boolean;
declare const ReflectApply: typeof Reflect.apply, ReflectConstruct: typeof Reflect.construct, ReflectDefineProperty: typeof Reflect.defineProperty, ReflectDeleteProperty: typeof Reflect.deleteProperty, ReflectGet: typeof Reflect.get, ReflectGetOwnPropertyDescriptor: typeof Reflect.getOwnPropertyDescriptor, ReflectGetPrototypeOf: typeof Reflect.getPrototypeOf, ReflectHas: typeof Reflect.has, ReflectIsExtensible: typeof Reflect.isExtensible, ReflectOwnKeys: typeof Reflect.ownKeys, ReflectPreventExtensions: typeof Reflect.preventExtensions, ReflectSet: typeof Reflect.set, ReflectSetPrototypeOf: typeof Reflect.setPrototypeOf;
declare const RegExpCtor: RegExpConstructor;
declare const RegExpProto: RegExp;
declare const RegExpProtoExec: (string: string) => RegExpExecArray | null, RegExpProtoTest: (string: string) => boolean;
declare const RegExpProtoSourceGetter: Getter;
declare function toRegExpEscapedIdentifierName(identifier: string): string;
declare function toRegExpEscapedString(string: string): string;
declare const SetCtor: SetConstructor;
declare const SetProtoAdd: (value: any) => Set<any>, SetProtoValues: () => IterableIterator<any>;
declare const SetProtoSizeGetter: Getter;
declare function toSafeSet<T extends Set<any>>(set: T): T;
declare const StringCtor: StringConstructor;
declare const StringProtoCharAt: (pos: number) => string, StringProtoCharCodeAt: (index: number) => number, StringProtoEndsWith: (searchString: string, endPosition?: number | undefined) => boolean, StringProtoIncludes: (searchString: string, position?: number | undefined) => boolean, StringProtoIndexOf: (searchString: string, position?: number | undefined) => number, StringProtoLastIndexOf: (searchString: string, position?: number | undefined) => number, StringProtoMatch: {
    (regexp: string | RegExp): RegExpMatchArray | null;
    (matcher: {
        [Symbol.match](string: string): RegExpMatchArray | null;
    }): RegExpMatchArray | null;
}, StringProtoReplace: {
    (searchValue: string | RegExp, replaceValue: string): string;
    (searchValue: string | RegExp, replacer: (substring: string, ...args: any[]) => string): string;
    (searchValue: {
        [Symbol.replace](string: string, replaceValue: string): string;
    }, replaceValue: string): string;
    (searchValue: {
        [Symbol.replace](string: string, replacer: (substring: string, ...args: any[]) => string): string;
    }, replacer: (substring: string, ...args: any[]) => string): string;
}, StringProtoSlice: (start?: number | undefined, end?: number | undefined) => string, StringProtoSplit: {
    (separator: string | RegExp, limit?: number | undefined): string[];
    (splitter: {
        [Symbol.split](string: string, limit?: number | undefined): string[];
    }, limit?: number | undefined): string[];
}, StringProtoStartsWith: (searchString: string, position?: number | undefined) => boolean, StringProtoSubstring: (start: number, end?: number | undefined) => string, StringProtoToLowerCase: () => string, StringProtoToUpperCase: () => string, StringProtoValueOf: () => string;
declare function capitalizeFirstChar(string: string): string;
declare function enquote(string: string, quoteChar?: string): string;
declare function extractFunctionBodySource(func: Function): string;
// Use `toSafeStringValue()` to coerce values using the default string concatenation
// operation. This must be done ONLY once on incoming values to avoid creating
// shape-shifting exploits, ie. passing { toString() {...} } where a string
// is otherwise expected.
declare function toSafeStringValue(value: any): string;
// Use `toSafeTemplateStringValue()` for values embedded in template strings,
// like error messages, because it coerces more values, including symbols,
// to strings without throwing exceptions.
declare function toSafeTemplateStringValue(value: any): string;
declare const SymbolAsyncIterator: symbol, SymbolFor: (key: string) => symbol, SymbolIterator: symbol, SymbolToStringTag: symbol, SymbolUnscopables: symbol;
declare const SymbolProtoToString: () => string, SymbolProtoValueOf: () => symbol;
declare const WeakMapCtor: WeakMapConstructor;
declare const WeakMapProtoHas: (key: object) => boolean;
declare function toSafeWeakMap<T extends WeakMap<any, any>>(weakMap: T): T;
declare const WeakSetCtor: WeakSetConstructor;
declare const WeakSetProtoHas: (value: object) => boolean;
declare function toSafeWeakSet<T extends WeakSet<any>>(weakSet: T): T;
export { ArrayCtor, ArrayProtoIncludes, ArrayProtoMap, ArrayProtoSplice, ArrayProtoSort, ArrayProtoUnshift, ArrayProtoFilter, ArrayProtoFind, ArrayProtoIndexOf, ArrayProtoJoin, ArrayProtoPush, ArrayProtoShift, ArrayProtoSlice, ArrayProtoToString, ArrayIsArray, ArrayConcat, toSafeArray, ArrayBufferIsView, ArrayBufferProtoByteLengthGetter, getBrand, getTimestamp, indexOfPragma, SUPPORTS_BIG_INT, BigIntProtoValueOf, BooleanProtoValueOf, partialStructuredClone, shallowCloneArray, shallowCloneOptions, consoleWarn, LOCKER_IDENTIFIER_MARKER, LOCKER_UNMINIFIED_FLAG, LOCKER_SERVICE_KEY, LOCKER_SERVICE_KEY_LOWERED, CHAR_QUOTE_DOUBLE, CHAR_QUOTE_SINGLE, UNCOMPILED_LOCATION_NAME, UNCOMPILED_TOP_NAME, WEBPACK_REQUIRE_NAME, ERR_ILLEGAL_PROPERTY_ACCESS, ERR_INVALID_SANDBOX_KEY, LOCKER_NEAR_MEMBRANE_IS_MASKED_SYMBOL, LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL, LOCKER_NEAR_MEMBRANE_SYMBOL, LOCKER_NEAR_MEMBRANE_UNMASKED_VALUE_SYMBOL, SYMBOL_LIVE_OBJECT, TO_STRING_BRAND_ARRAY, TO_STRING_BRAND_ARRAY_BUFFER, TO_STRING_BRAND_BIG_INT, TO_STRING_BRAND_BOOLEAN, TO_STRING_BRAND_DATE, TO_STRING_BRAND_ERROR, TO_STRING_BRAND_FUNCTION, TO_STRING_BRAND_MAP, TO_STRING_BRAND_NULL, TO_STRING_BRAND_NUMBER, TO_STRING_BRAND_OBJECT, TO_STRING_BRAND_REG_EXP, TO_STRING_BRAND_SET, TO_STRING_BRAND_STRING, TO_STRING_BRAND_SYMBOL, TO_STRING_BRAND_UNDEFINED, TO_STRING_BRAND_WEAK_MAP, TO_STRING_BRAND_WEAK_SET, SANDBOX_EVAL_CONTEXT_NAME, SANDBOX_EVAL_HELPERS_NAME, DateNow, DateProtoValueOf, ErrorCtor, TypeErrorCtor, LockerSecurityError, FunctionProtoBind, FunctionProtoToString, createUnmaskableTraps, getUnmaskedFunction, identity, isMaskedFunction, maskFunction, noop, registerGaterEnabledFeatures, deregisterGaterEnabledFeatures, clearGaterEnabledFeatures, isGaterEnabledFeature, ENABLE_MAX_PERF_MODE_GATE, ENABLE_SANDBOXED_SAMEORIGIN_IFRAME_GATE, isAllowedToOverrideGaterEnabledFeature, isNotAllowedToOverrideGaterEnabledFeature, JSONParse, JSONStringify, isTargetLive, markTargetAsLive, trackAsLiveTarget, registerLockerFeature, isLockerFeatureEnabled, MapCtor, MapProtoEntries, MapProtoSet, MapProtoSizeGetter, toSafeMap, MathMin, getNamespaceMarker, getStorageNamespaceMarker, prependNamespaceMarker, prependStorageNamespaceMarker, removeNamespaceMarker, removeStorageNamespaceMarker, startsWithNamespaceMarker, startsWithStorageNamespaceMarker, getNearMembraneProxySerializedValue, isNearMembraneProxy, NumberIsFinite, NumberIsInteger, NumberIsNaN, NumberProtoToFixed, NumberProtoValueOf, ObjectCtor, ObjectAssign, ObjectFreeze, ObjectDefineProperties, ObjectGetOwnPropertyDescriptors, ObjectGetOwnPropertySymbols, ObjectKeys, ObjectPreventExtensions, ObjectProto, ObjectProtoToString, isObject, isObjectLike, ObjectHasOwn, ObjectLookupOwnGetter, ObjectLookupOwnSetter, ObjectLookupOwnValue, PromiseCtor, PromiseProtoCatch, PromiseProtoThen, PromiseResolve, PromiseReject, ProxyCtor, createRevokedProxy, isRevokedProxy, ReflectApply, ReflectConstruct, ReflectDefineProperty, ReflectDeleteProperty, ReflectGet, ReflectGetOwnPropertyDescriptor, ReflectGetPrototypeOf, ReflectHas, ReflectIsExtensible, ReflectOwnKeys, ReflectPreventExtensions, ReflectSet, ReflectSetPrototypeOf, RegExpCtor, RegExpProto, RegExpProtoExec, RegExpProtoTest, RegExpProtoSourceGetter, toRegExpEscapedIdentifierName, toRegExpEscapedString, SetCtor, SetProtoAdd, SetProtoValues, SetProtoSizeGetter, toSafeSet, StringCtor, StringProtoCharAt, StringProtoCharCodeAt, StringProtoEndsWith, StringProtoIncludes, StringProtoIndexOf, StringProtoLastIndexOf, StringProtoMatch, StringProtoReplace, StringProtoSlice, StringProtoSplit, StringProtoStartsWith, StringProtoSubstring, StringProtoToLowerCase, StringProtoToUpperCase, StringProtoValueOf, capitalizeFirstChar, enquote, extractFunctionBodySource, toSafeStringValue, toSafeTemplateStringValue, SymbolAsyncIterator, SymbolFor, SymbolIterator, SymbolToStringTag, SymbolUnscopables, SymbolProtoToString, SymbolProtoValueOf, Getter, GetterSetterDescriptor, NearMembraneSerializedValue, ProxyHandlerTraps, ProxyTarget, ProxyTrapInvokers, SandboxKey, SandboxRecord, SandboxType, Setter, TargetTraits, WeakMapCtor, WeakMapProtoHas, toSafeWeakMap, WeakSetCtor, WeakSetProtoHas, toSafeWeakSet };
//# sourceMappingURL=index.cjs.d.ts.map