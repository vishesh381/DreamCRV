/*!
 * Copyright (C) 2019 salesforce.com, inc.
 */
'use strict';

var _TrustedHTMLCtor$prot$LWS, _TrustedScriptCtor$pr$LWS, _URLCtor$prototype$LWS;
Object.defineProperty(exports, '__esModule', {
  value: true
});
const {
  apply: ReflectApply$LWS,
  construct: ReflectConstruct$LWS,
  defineProperty: ReflectDefineProperty$LWS,
  deleteProperty: ReflectDeleteProperty$LWS,
  get: ReflectGet$LWS,
  getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor$LWS,
  getPrototypeOf: ReflectGetPrototypeOf$LWS,
  has: ReflectHas$LWS,
  isExtensible: ReflectIsExtensible$LWS,
  ownKeys: ReflectOwnKeys$LWS,
  preventExtensions: ReflectPreventExtensions$LWS,
  set: ReflectSet$LWS,
  setPrototypeOf: ReflectSetPrototypeOf$LWS
} = Reflect;
const ObjectCtor$LWS = Object;
const {
  assign: ObjectAssign$LWS,
  freeze: ObjectFreeze$LWS,
  defineProperties: ObjectDefineProperties$LWS,
  getOwnPropertyDescriptors: ObjectGetOwnPropertyDescriptors$LWS,
  getOwnPropertySymbols: ObjectGetOwnPropertySymbols$LWS,
  keys: ObjectKeys$LWS,
  preventExtensions: ObjectPreventExtensions$LWS,
  prototype: ObjectProto$LWS
} = ObjectCtor$LWS;
const {
  hasOwn: OriginalObjectHasOwn$LWS
} = ObjectCtor$LWS;
const {
  __lookupGetter__: ObjectProtoLookupGetter$LWS,
  __lookupSetter__: ObjectProtoLookupSetter$LWS,
  hasOwnProperty: ObjectProtoHasOwnProperty$LWS
} = ObjectProto$LWS;
const {
  toString: ObjectProtoToString$LWS
} = ObjectProto$LWS;
function isObject$LWS(value$LWS) {
  return typeof value$LWS === 'object' && value$LWS !== null;
}
function isObjectLike$LWS(value$LWS) {
  return typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function';
}
const ObjectHasOwn$LWS = typeof OriginalObjectHasOwn$LWS === 'function' ? OriginalObjectHasOwn$LWS : /* istanbul ignore next: currently unreachable via tests */function ObjectHasOwn$LWS(object$LWS, key$LWS) {
  return ReflectApply$LWS(ObjectProtoHasOwnProperty$LWS, object$LWS, [key$LWS]);
};
function ObjectLookupOwnGetter$LWS(object$LWS, key$LWS) {
  return object$LWS === null || object$LWS === undefined || !ObjectHasOwn$LWS(object$LWS, key$LWS) ? undefined : ReflectApply$LWS(ObjectProtoLookupGetter$LWS, object$LWS, [key$LWS]);
}
function ObjectLookupOwnSetter$LWS(object$LWS, key$LWS) {
  return object$LWS === null || object$LWS === undefined || !ObjectHasOwn$LWS(object$LWS, key$LWS) ? undefined : ReflectApply$LWS(ObjectProtoLookupSetter$LWS, object$LWS, [key$LWS]);
}
function ObjectLookupOwnValue$LWS(object$LWS, key$LWS) {
  return object$LWS === null || object$LWS === undefined || !ObjectHasOwn$LWS(object$LWS, key$LWS) ? undefined : object$LWS[key$LWS];
}
const SymbolCtor$LWS = Symbol;
const {
  asyncIterator: SymbolAsyncIterator$LWS,
  for: SymbolFor$LWS,
  iterator: SymbolIterator$LWS,
  toStringTag: SymbolToStringTag$LWS,
  unscopables: SymbolUnscopables$LWS
} = SymbolCtor$LWS;
const {
  toString: SymbolProtoToString$LWS,
  valueOf: SymbolProtoValueOf$LWS
} = SymbolCtor$LWS.prototype;
const ArrayCtor$LWS = Array;
const {
  prototype: ArrayProto$LWS
} = ArrayCtor$LWS;
const {
  at: ArrayProtoAt$LWS,
  concat: ArrayProtoConcat$LWS,
  copyWithin: ArrayProtoCopyWithin$LWS,
  entries: ArrayProtoEntries$LWS,
  every: ArrayProtoEvery$LWS,
  fill: ArrayProtoFill$LWS,
  findIndex: ArrayProtoFindIndex$LWS,
  flat: ArrayProtoFlat$LWS,
  flatMap: ArrayProtoFlatMap$LWS,
  forEach: ArrayProtoForEach$LWS,
  keys: ArrayProtoKeys$LWS,
  lastIndexOf: ArrayProtoLastIndexOf$LWS,
  pop: ArrayProtoPop$LWS,
  reduce: ArrayProtoReduce$LWS,
  reduceRight: ArrayProtoReduceRight$LWS,
  reverse: ArrayProtoReverse$LWS,
  some: ArrayProtoSome$LWS,
  toLocaleString: ArrayProtoToLocaleString$LWS,
  values: ArrayProtoValues$LWS,
  [SymbolIterator$LWS]: ArrayProtoSymbolIterator$LWS
} = ArrayProto$LWS;
const ArrayUnscopables$LWS = ObjectFreeze$LWS(ObjectAssign$LWS({
  __proto__: null
}, ArrayProto$LWS[SymbolUnscopables$LWS]));
// Used by '@locker/near-membrane-dom'.
const {
  includes: ArrayProtoIncludes$LWS,
  map: ArrayProtoMap$LWS,
  splice: ArrayProtoSplice$LWS,
  sort: ArrayProtoSort$LWS,
  unshift: ArrayProtoUnshift$LWS
} = ArrayProto$LWS;
const {
  filter: ArrayProtoFilter$LWS,
  find: ArrayProtoFind$LWS,
  indexOf: ArrayProtoIndexOf$LWS,
  join: ArrayProtoJoin$LWS,
  push: ArrayProtoPush$LWS,
  shift: ArrayProtoShift$LWS,
  slice: ArrayProtoSlice$LWS,
  toString: ArrayProtoToString$LWS
} = ArrayProto$LWS;
const {
  isArray: ArrayIsArray$LWS
} = ArrayCtor$LWS;
function ArrayConcat$LWS(array$LWS, ...args$LWS) {
  // Re-implement Array#concat to avoid prototype poisoning from Symbol.isConcatSpreadable.
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/isConcatSpreadable
  const result$LWS = ReflectApply$LWS(ArrayProtoSlice$LWS, array$LWS, [0]);
  for (let i$LWS = 0, {
      length: length$LWS
    } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const value$LWS = args$LWS[i$LWS];
    if (ArrayIsArray$LWS(value$LWS)) {
      ReflectApply$LWS(ArrayProtoPush$LWS, result$LWS, value$LWS);
    } else {
      result$LWS[result$LWS.length] = value$LWS;
    }
  }
  return result$LWS;
}
function toSafeArray$LWS(array$LWS) {
  ReflectSetPrototypeOf$LWS(array$LWS, null);
  array$LWS.at = ArrayProtoAt$LWS;
  array$LWS.concat = ArrayProtoConcat$LWS;
  // *** DO NOT SET THE ARRAY CONSTRUCTOR PROPERTY ***
  // https://bugs.chromium.org/p/v8/issues/detail?id=13202
  // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/lookup.cc;l=196-215?q=IsArraySpeciesLookupChainIntact
  //
  // In V8 setting the constructor property of an array, promise, regexp, or
  // typed array triggers a de-opt because it could change an instance's
  // @@species. This de-opt affects at least `Array#splice` and occurs even
  // if the prototype of the array is change or nulled beforehand. Further,
  // the de-opt persists after a page refresh. It is not until navigating to
  // a different page that the performance of `Array#splice` is restored.
  array$LWS.copyWithin = ArrayProtoCopyWithin$LWS;
  array$LWS.entries = ArrayProtoEntries$LWS;
  array$LWS.every = ArrayProtoEvery$LWS;
  array$LWS.fill = ArrayProtoFill$LWS;
  array$LWS.filter = ArrayProtoFilter$LWS;
  array$LWS.find = ArrayProtoFind$LWS;
  array$LWS.findIndex = ArrayProtoFindIndex$LWS;
  array$LWS.flat = ArrayProtoFlat$LWS;
  array$LWS.flatMap = ArrayProtoFlatMap$LWS;
  array$LWS.forEach = ArrayProtoForEach$LWS;
  array$LWS.includes = ArrayProtoIncludes$LWS;
  array$LWS.indexOf = ArrayProtoIndexOf$LWS;
  array$LWS.join = ArrayProtoJoin$LWS;
  array$LWS.keys = ArrayProtoKeys$LWS;
  array$LWS.lastIndexOf = ArrayProtoLastIndexOf$LWS;
  array$LWS.map = ArrayProtoMap$LWS;
  array$LWS.pop = ArrayProtoPop$LWS;
  array$LWS.push = ArrayProtoPush$LWS;
  array$LWS.reduce = ArrayProtoReduce$LWS;
  array$LWS.reduceRight = ArrayProtoReduceRight$LWS;
  array$LWS.reverse = ArrayProtoReverse$LWS;
  array$LWS.shift = ArrayProtoShift$LWS;
  array$LWS.slice = ArrayProtoSlice$LWS;
  array$LWS.some = ArrayProtoSome$LWS;
  array$LWS.sort = ArrayProtoSort$LWS;
  array$LWS.splice = ArrayProtoSplice$LWS;
  array$LWS.toLocaleString = ArrayProtoToLocaleString$LWS;
  array$LWS.toString = ArrayProtoToString$LWS;
  array$LWS.unshift = ArrayProtoUnshift$LWS;
  array$LWS.values = ArrayProtoValues$LWS;
  array$LWS[SymbolIterator$LWS] = ArrayProtoSymbolIterator$LWS;
  array$LWS[SymbolUnscopables$LWS] = ArrayUnscopables$LWS;
  ReflectSetPrototypeOf$LWS(array$LWS, ArrayProto$LWS);
  return array$LWS;
}
const ArrayBufferCtor$LWS = ArrayBuffer;
const {
  isView: ArrayBufferIsView$LWS
} = ArrayBufferCtor$LWS;
const ArrayBufferProtoByteLengthGetter$LWS = ObjectLookupOwnGetter$LWS(ArrayBufferCtor$LWS.prototype, 'byteLength');

// https://caniuse.com/bigint
const SUPPORTS_BIG_INT$LWS = typeof BigInt === 'function';
const BigIntProtoValueOf$LWS = SUPPORTS_BIG_INT$LWS ? BigInt.prototype.valueOf : /* istanbul ignore next: currently unreachable via tests */undefined;
const {
  valueOf: BooleanProtoValueOf$LWS
} = Boolean.prototype;

// Locker build constants.
const LOCKER_IDENTIFIER_MARKER$LWS = '$LWS';
// This package is bundled by third-parties that have their own build time
// replacement logic. Instead of customizing each build system to be aware
// of this package we implement a two phase debug mode by performing small
// runtime checks to determine phase one, our code is unminified, and
// phase two, the user opted-in to custom devtools formatters. Phase one
// is used for light weight initialization time debug while phase two is
// reserved for post initialization runtime
const LOCKER_UNMINIFIED_FLAG$LWS =
// eslint-disable-next-line @typescript-eslint/naming-convention
/* istanbul ignore next */
`${function LOCKER_UNMINIFIED_FLAG$LWS() {
  return LOCKER_UNMINIFIED_FLAG$LWS.name;
}()}`.includes('LOCKER_UNMINIFIED_FLAG');
// Locker key constants.
const LOCKER_SERVICE_KEY$LWS = 'LSKey';
const LOCKER_SERVICE_KEY_LOWERED$LWS = 'lskey';
// Character constants.
const CHAR_QUOTE_DOUBLE$LWS = '"';
const CHAR_QUOTE_SINGLE$LWS = "'";
// Compiler constants.
const UNCOMPILED_LOCATION_NAME$LWS = `uncompiledLocation${LOCKER_IDENTIFIER_MARKER$LWS}`;
const UNCOMPILED_TOP_NAME$LWS = `uncompiledTop${LOCKER_IDENTIFIER_MARKER$LWS}`;
const WEBPACK_REQUIRE_NAME$LWS = '__webpack_require__';
// Error message constants.
const ERR_ILLEGAL_PROPERTY_ACCESS$LWS = 'Illegal property access.';
const ERR_INVALID_SANDBOX_KEY$LWS = 'Invalid sandbox key.';
// Near-membrane constants.
const LOCKER_NEAR_MEMBRANE_IS_MASKED_SYMBOL$LWS = SymbolFor$LWS('@@lockerNearMembraneIsMasked');
const LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS = SymbolFor$LWS('@@lockerNearMembraneSerializedValue');
const LOCKER_NEAR_MEMBRANE_SYMBOL$LWS = SymbolFor$LWS('@@lockerNearMembrane');
const LOCKER_NEAR_MEMBRANE_UNMASKED_VALUE_SYMBOL$LWS = SymbolFor$LWS('@@lockerNearMembraneUnmaskedValue');
const SYMBOL_LIVE_OBJECT$LWS = SymbolFor$LWS('@@lockerLiveValue');
// Object brand constants.
const TO_STRING_BRAND_ARRAY$LWS = '[object Array]';
const TO_STRING_BRAND_ARRAY_BUFFER$LWS = '[object ArrayBuffer]';
const TO_STRING_BRAND_BIG_INT$LWS = '[object BigInt]';
const TO_STRING_BRAND_BOOLEAN$LWS = '[object Boolean]';
const TO_STRING_BRAND_DATE$LWS = '[object Date]';
const TO_STRING_BRAND_ERROR$LWS = '[object Error]';
const TO_STRING_BRAND_FUNCTION$LWS = '[object Function]';
const TO_STRING_BRAND_MAP$LWS = '[object Map]';
const TO_STRING_BRAND_NULL$LWS = '[object Null]';
const TO_STRING_BRAND_NUMBER$LWS = '[object Number]';
const TO_STRING_BRAND_OBJECT$LWS = '[object Object]';
const TO_STRING_BRAND_REG_EXP$LWS = '[object RegExp]';
const TO_STRING_BRAND_SET$LWS = '[object Set]';
const TO_STRING_BRAND_STRING$LWS = '[object String]';
const TO_STRING_BRAND_SYMBOL$LWS = '[object Symbol]';
const TO_STRING_BRAND_UNDEFINED$LWS = '[object Undefined]';
const TO_STRING_BRAND_WEAK_MAP$LWS = '[object WeakMap]';
const TO_STRING_BRAND_WEAK_SET$LWS = '[object WeakSet]';
// Sandbox constants.
const SANDBOX_EVAL_CONTEXT_NAME$LWS = '$lockerEvalContext$';
const SANDBOX_EVAL_HELPERS_NAME$LWS = '$lockerEvalHelpers$';
const DateCtor$LWS = Date;
const {
  now: DateNow$LWS
} = DateCtor$LWS;
const {
  valueOf: DateProtoValueOf$LWS
} = DateCtor$LWS.prototype;

// Used by '@locker/near-membrane-base'
const ErrorCtor$LWS = Error;
// Used by '@locker/near-membrane-' packages.
const TypeErrorCtor$LWS = TypeError;
class LockerSecurityError$LWS extends Error {
  constructor(message$LWS) {
    super(`Lightning Web Security: ${message$LWS}`);
  }
}
const ProxyCtor$LWS = Proxy;
const {
  revocable: ProxyRevocable$LWS
} = ProxyCtor$LWS;
function createRevokedProxy$LWS(object$LWS) {
  const revocable$LWS = ProxyRevocable$LWS(object$LWS, {
    __proto__: null
  });
  revocable$LWS.revoke();
  return revocable$LWS.proxy;
}
function isRevokedProxy$LWS(value$LWS) {
  try {
    // 7.2.2 IsArray ( argument )
    // https://tc39.es/ecma262/#sec-isarray
    // Step 3a: Perform ? ValidateNonRevokedProxy(argument).
    ArrayIsArray$LWS(value$LWS);
    return false;
    // eslint-disable-next-line no-empty
  } catch (_unused$LWS) {}
  return true;
}
const {
  bind: FunctionProtoBind$LWS,
  toString: FunctionProtoToString$LWS
} = Function.prototype;
function createUnmaskableTraps$LWS(func$LWS) {
  let handshakeUnmaskFlag$LWS = false;
  return {
    defineProperty(target$LWS, key$LWS, desc$LWS) {
      // Defining forgeries of handshake properties is not allowed.
      // istanbul ignore else: it is unnecessary to cover the else path here
      if (key$LWS === LOCKER_NEAR_MEMBRANE_UNMASKED_VALUE_SYMBOL$LWS) {
        throw new TypeErrorCtor$LWS(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
      }
      return ReflectDefineProperty$LWS(target$LWS, key$LWS, desc$LWS);
    },
    get(target$LWS, key$LWS, receiver$LWS, handshake$LWS = false) {
      // Only allow accessing handshake property values if the "has"
      // trap has been triggered immediately BEFORE and the property
      // does NOT exist.
      handshakeUnmaskFlag$LWS && (handshakeUnmaskFlag$LWS = handshake$LWS);
      const isUnmaskedSymbol$LWS = key$LWS === LOCKER_NEAR_MEMBRANE_UNMASKED_VALUE_SYMBOL$LWS;
      // istanbul ignore else: it is unnecessary to cover the else path here
      if (handshakeUnmaskFlag$LWS) {
        // Exit without performing a [[Get]] for
        // `LOCKER_NEAR_MEMBRANE_UNMASKED_VALUE_SYMBOL` properties
        // because we know that when the
        // `handshakeUnmaskFlag` is ON that
        // there are NO shadowed values.
        // istanbul ignore else: it is unnecessary to cover the else path here
        if (isUnmaskedSymbol$LWS) {
          return func$LWS;
        }
      }
      const result$LWS = ReflectGet$LWS(target$LWS, key$LWS, receiver$LWS);
      // Getting forged values of `LOCKER_NEAR_MEMBRANE_UNMASKED_VALUE_SYMBOL`
      // properties is not allowed.
      // istanbul ignore else: it is unnecessary to cover the else path here
      if (result$LWS !== undefined && isUnmaskedSymbol$LWS) {
        throw new TypeErrorCtor$LWS(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
      }
      return result$LWS;
    },
    getOwnPropertyDescriptor(target$LWS, key$LWS) {
      const result$LWS = ReflectGetOwnPropertyDescriptor$LWS(target$LWS, key$LWS);
      // Getting forged descriptors of handshake properties is not allowed.
      // istanbul ignore else: it is unnecessary to cover the else path here
      if (result$LWS && key$LWS === LOCKER_NEAR_MEMBRANE_UNMASKED_VALUE_SYMBOL$LWS) {
        throw new TypeErrorCtor$LWS(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
      }
      return result$LWS;
    },
    has(target$LWS, key$LWS) {
      const result$LWS = ReflectHas$LWS(target$LWS, key$LWS);
      const isUnmaskedSymbol$LWS = key$LWS === LOCKER_NEAR_MEMBRANE_UNMASKED_VALUE_SYMBOL$LWS;
      if (result$LWS) {
        handshakeUnmaskFlag$LWS = false;
        // Checking the existence of forged `LOCKER_NEAR_MEMBRANE_UNMASKED_VALUE_SYMBOL`
        // properties is not allowed.
        // istanbul ignore else: it is unnecessary to cover the else path here
        if (isUnmaskedSymbol$LWS) {
          throw new TypeErrorCtor$LWS(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
        }
      } else {
        // The `handshakeUnmaskFlag` is ON if the
        // handshake property does NOT exist on the object or its
        // [[Prototype]].
        handshakeUnmaskFlag$LWS = isUnmaskedSymbol$LWS;
      }
      return result$LWS;
    },
    set(target$LWS, key$LWS, value$LWS, receiver$LWS) {
      // Setting forged values of handshake properties is not allowed.
      // istanbul ignore else: it is unnecessary to cover the else path here
      if (key$LWS === LOCKER_NEAR_MEMBRANE_UNMASKED_VALUE_SYMBOL$LWS) {
        throw new TypeErrorCtor$LWS(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
      }
      return ReflectSet$LWS(target$LWS, key$LWS, value$LWS, receiver$LWS);
    }
  };
}
function getUnmaskedFunction$LWS(func$LWS) {
  const unmasked$LWS = LOCKER_NEAR_MEMBRANE_UNMASKED_VALUE_SYMBOL$LWS in func$LWS ? /* istanbul ignore next */undefined : func$LWS[LOCKER_NEAR_MEMBRANE_UNMASKED_VALUE_SYMBOL$LWS];
  return unmasked$LWS === undefined ? func$LWS : unmasked$LWS;
}
function identity$LWS(value$LWS) {
  return value$LWS;
}
function isMaskedFunction$LWS(value$LWS) {
  // To extract the flag value of a blue near-membrane proxy we must perform
  // a two step handshake. First, we trigger the "has" trap for the
  // `LOCKER_NEAR_MEMBRANE_IS_MASKED_SYMBOL` property which must report
  // `false`. Second, we trigger the "get" trap to return the flag value.
  return typeof value$LWS === 'function' && !(LOCKER_NEAR_MEMBRANE_IS_MASKED_SYMBOL$LWS in value$LWS) && value$LWS[LOCKER_NEAR_MEMBRANE_IS_MASKED_SYMBOL$LWS] === true;
}
function maskFunction$LWS(func$LWS, maskFunc$LWS, trapInvokers$LWS) {
  let applyTrapInvoker$LWS = ReflectApply$LWS;
  let constructTrapInvoker$LWS = ReflectConstruct$LWS;
  let definePropertyTrapInvoker$LWS = ReflectDefineProperty$LWS;
  let getTrapInvoker$LWS = ReflectGet$LWS;
  let getOwnPropertyDescriptorTrapInvoker$LWS = ReflectGetOwnPropertyDescriptor$LWS;
  let hasTrapInvoker$LWS = ReflectHas$LWS;
  let setTrapInvoker$LWS = ReflectSet$LWS;
  if (trapInvokers$LWS) {
    ({
      apply: applyTrapInvoker$LWS = ReflectApply$LWS,
      construct: constructTrapInvoker$LWS = ReflectConstruct$LWS,
      defineProperty: definePropertyTrapInvoker$LWS = ReflectDefineProperty$LWS,
      get: getTrapInvoker$LWS = ReflectGet$LWS,
      getOwnPropertyDescriptor: getOwnPropertyDescriptorTrapInvoker$LWS = ReflectGetOwnPropertyDescriptor$LWS,
      has: hasTrapInvoker$LWS = ReflectHas$LWS,
      set: setTrapInvoker$LWS = ReflectSet$LWS
    } = trapInvokers$LWS);
  }
  let handshakeFlag$LWS = false;
  let handshakeProxyMaskedFlag$LWS = false;
  let lastProxyTrapCalled$LWS = 0 /* ProxyHandlerTraps.None */;
  const proxy$LWS = new ProxyCtor$LWS(maskFunc$LWS, {
    apply(_target$LWS, thisArg$LWS, args$LWS) {
      lastProxyTrapCalled$LWS = 1 /* ProxyHandlerTraps.Apply */;
      if (thisArg$LWS === proxy$LWS || thisArg$LWS === maskFunc$LWS) {
        thisArg$LWS = func$LWS;
      }
      return applyTrapInvoker$LWS(func$LWS, thisArg$LWS, args$LWS);
    },
    construct(_target$LWS, args$LWS, newTarget$LWS) {
      lastProxyTrapCalled$LWS = 2 /* ProxyHandlerTraps.Construct */;
      if (newTarget$LWS === proxy$LWS || newTarget$LWS === maskFunc$LWS) {
        newTarget$LWS = func$LWS;
      }
      return constructTrapInvoker$LWS(func$LWS, args$LWS, newTarget$LWS);
    },
    defineProperty(target$LWS, key$LWS, desc$LWS) {
      lastProxyTrapCalled$LWS = 4 /* ProxyHandlerTraps.DefineProperty */;
      // Defining forgeries of handshake properties is not allowed.
      if (key$LWS === LOCKER_NEAR_MEMBRANE_IS_MASKED_SYMBOL$LWS) {
        throw new TypeErrorCtor$LWS(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
      }
      return definePropertyTrapInvoker$LWS(target$LWS, key$LWS, desc$LWS);
    },
    deleteProperty(target$LWS, key$LWS) {
      lastProxyTrapCalled$LWS = 32 /* ProxyHandlerTraps.GetOwnPropertyDescriptor */;
      return ReflectDeleteProperty$LWS(target$LWS, key$LWS);
    },
    get(target$LWS, key$LWS, receiver$LWS) {
      // Only allow accessing handshake property values if the "has"
      // trap has been triggered immediately BEFORE and the property does
      // NOT exist.
      handshakeFlag$LWS && (handshakeFlag$LWS = lastProxyTrapCalled$LWS === 128 /* ProxyHandlerTraps.Has */);
      handshakeProxyMaskedFlag$LWS && (handshakeProxyMaskedFlag$LWS = handshakeFlag$LWS);
      lastProxyTrapCalled$LWS = 16 /* ProxyHandlerTraps.Get */;
      const isProxyMaskedSymbol$LWS = key$LWS === LOCKER_NEAR_MEMBRANE_IS_MASKED_SYMBOL$LWS;
      if (handshakeProxyMaskedFlag$LWS) {
        // Exit without performing a [[Get]] for
        // `LOCKER_NEAR_MEMBRANE_IS_MASKED_SYMBOL` properties
        // because we know that when the `handshakeProxyMaskedFlag`
        // is ON that there are NO shadowed values.
        // istanbul ignore else: returns immediately
        if (isProxyMaskedSymbol$LWS) {
          return true;
        }
      }
      const result$LWS = getTrapInvoker$LWS(target$LWS, key$LWS, receiver$LWS, handshakeFlag$LWS);
      // Getting forged values of handshake properties is not allowed.
      if (result$LWS !== undefined && isProxyMaskedSymbol$LWS) {
        throw new TypeErrorCtor$LWS(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
      }
      return result$LWS;
    },
    getOwnPropertyDescriptor(target$LWS, key$LWS) {
      lastProxyTrapCalled$LWS = 32 /* ProxyHandlerTraps.GetOwnPropertyDescriptor */;
      const result$LWS = getOwnPropertyDescriptorTrapInvoker$LWS(target$LWS, key$LWS);
      // Getting forged descriptors of handshake properties is not allowed.
      if (result$LWS && key$LWS === LOCKER_NEAR_MEMBRANE_IS_MASKED_SYMBOL$LWS) {
        throw new TypeErrorCtor$LWS(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
      }
      return result$LWS;
    },
    getPrototypeOf(target$LWS) {
      lastProxyTrapCalled$LWS = 64 /* ProxyHandlerTraps.GetPrototypeOf */;
      return ReflectGetPrototypeOf$LWS(target$LWS);
    },
    has(target$LWS, key$LWS) {
      lastProxyTrapCalled$LWS = 128 /* ProxyHandlerTraps.Has */;
      const result$LWS = hasTrapInvoker$LWS(target$LWS, key$LWS);
      const isProxyMaskedSymbol$LWS = key$LWS === LOCKER_NEAR_MEMBRANE_IS_MASKED_SYMBOL$LWS;
      if (result$LWS) {
        handshakeFlag$LWS = false;
        // Checking the existence of forged handshake properties is not allowed.
        if (isProxyMaskedSymbol$LWS) {
          throw new TypeErrorCtor$LWS(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
        }
      } else {
        // The `handshakeFlag` is ON if the handshake property does NOT
        // exist on the object or its [[Prototype]].
        handshakeFlag$LWS = true;
        handshakeProxyMaskedFlag$LWS = isProxyMaskedSymbol$LWS;
      }
      return result$LWS;
    },
    isExtensible(target$LWS) {
      lastProxyTrapCalled$LWS = 256 /* ProxyHandlerTraps.IsExtensible */;
      return ReflectIsExtensible$LWS(target$LWS);
    },
    ownKeys(target$LWS) {
      lastProxyTrapCalled$LWS = 512 /* ProxyHandlerTraps.OwnKeys */;
      return ReflectOwnKeys$LWS(target$LWS);
    },
    preventExtensions(target$LWS) {
      lastProxyTrapCalled$LWS = 1024 /* ProxyHandlerTraps.PreventExtensions */;
      return ReflectPreventExtensions$LWS(target$LWS);
    },
    set(target$LWS, key$LWS, value$LWS, receiver$LWS) {
      lastProxyTrapCalled$LWS = 2048 /* ProxyHandlerTraps.Set */;
      // Setting forged values of handshake properties is not allowed.
      if (key$LWS === LOCKER_NEAR_MEMBRANE_IS_MASKED_SYMBOL$LWS) {
        throw new TypeErrorCtor$LWS(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
      }
      return setTrapInvoker$LWS(target$LWS, key$LWS, value$LWS, receiver$LWS);
    },
    setPrototypeOf(target$LWS, proto$LWS) {
      lastProxyTrapCalled$LWS = 4096 /* ProxyHandlerTraps.SetPrototypeOf */;
      return ReflectSetPrototypeOf$LWS(target$LWS, proto$LWS);
    }
  });
  return proxy$LWS;
}
function noop$LWS() {
  // No operation performed.
}
const MapCtor$LWS = Map;
const {
  prototype: MapProto$LWS
} = MapCtor$LWS;
const {
  clear: MapProtoClear$LWS,
  delete: MapProtoDelete$LWS,
  forEach: MapProtoForEach$LWS,
  get: MapProtoGet$LWS,
  has: MapProtoHas$LWS,
  keys: MapProtoKeys$LWS,
  values: MapProtoValues$LWS,
  [SymbolIterator$LWS]: MapProtoSymbolIterator$LWS,
  [SymbolToStringTag$LWS]: MapProtoSymbolToStringTag$LWS
} = MapProto$LWS;
const {
  entries: MapProtoEntries$LWS,
  set: MapProtoSet$LWS
} = MapProto$LWS;
const MapProtoSizeGetter$LWS = ObjectLookupOwnGetter$LWS(MapProto$LWS, 'size');
function toSafeMap$LWS(map$LWS) {
  ReflectSetPrototypeOf$LWS(map$LWS, null);
  map$LWS.clear = MapProtoClear$LWS;
  map$LWS.delete = MapProtoDelete$LWS;
  map$LWS.entries = MapProtoEntries$LWS;
  map$LWS.forEach = MapProtoForEach$LWS;
  map$LWS.get = MapProtoGet$LWS;
  map$LWS.has = MapProtoHas$LWS;
  map$LWS.keys = MapProtoKeys$LWS;
  map$LWS.set = MapProtoSet$LWS;
  ReflectDefineProperty$LWS(map$LWS, 'size', {
    __proto__: null,
    configurable: true,
    enumerable: true,
    get: MapProtoSizeGetter$LWS,
    set: undefined
  });
  map$LWS.values = MapProtoValues$LWS;
  map$LWS[SymbolIterator$LWS] = MapProtoSymbolIterator$LWS;
  map$LWS[SymbolToStringTag$LWS] = MapProtoSymbolToStringTag$LWS;
  ReflectSetPrototypeOf$LWS(map$LWS, MapProto$LWS);
  return map$LWS;
}
const NumberCtor$LWS = Number;
// Used by '@locker/near-membrane-dom'.
const {
  isFinite: NumberIsFinite$LWS,
  isInteger: NumberIsInteger$LWS,
  isNaN: NumberIsNaN$LWS
} = NumberCtor$LWS;
const {
  toFixed: NumberProtoToFixed$LWS,
  valueOf: NumberProtoValueOf$LWS
} = NumberCtor$LWS.prototype;

// @ts-nocheck
const StringCtor$LWS = String;
const {
  prototype: StringProto$LWS
} = StringCtor$LWS;
const {
  charAt: StringProtoCharAt$LWS,
  charCodeAt: StringProtoCharCodeAt$LWS,
  endsWith: StringProtoEndsWith$LWS,
  includes: StringProtoIncludes$LWS,
  indexOf: StringProtoIndexOf$LWS,
  lastIndexOf: StringProtoLastIndexOf$LWS,
  match: StringProtoMatch$LWS,
  replace: StringProtoReplace$LWS,
  slice: StringProtoSlice$LWS,
  split: StringProtoSplit$LWS,
  startsWith: StringProtoStartsWith$LWS,
  substring: StringProtoSubstring$LWS,
  toLowerCase: StringProtoToLowerCase$LWS,
  toUpperCase: StringProtoToUpperCase$LWS,
  valueOf: StringProtoValueOf$LWS
} = StringProto$LWS;
const quoteCharRegExpRegistry$LWS = {
  __proto__: null,
  [CHAR_QUOTE_DOUBLE$LWS]: /\\?"/g,
  [CHAR_QUOTE_SINGLE$LWS]: /\\?'/g
};
const TrustedHTMLCtor$LWS = typeof TrustedHTML === 'function' ? TrustedHTML : /* istanbul ignore next: unreachable in test env */undefined;
// istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
const TrustedHTMLProtoToString$LWS = TrustedHTMLCtor$LWS == null || (_TrustedHTMLCtor$prot$LWS = TrustedHTMLCtor$LWS.prototype) == null ? void 0 : _TrustedHTMLCtor$prot$LWS.toString;
const TrustedScriptCtor$LWS = typeof TrustedScript === 'function' ? TrustedScript : /* istanbul ignore next: unreachable in test env */undefined;
// istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
const TrustedScriptProtoToString$LWS = TrustedScriptCtor$LWS == null || (_TrustedScriptCtor$pr$LWS = TrustedScriptCtor$LWS.prototype) == null ? void 0 : _TrustedScriptCtor$pr$LWS.toString;
const URLCtor$LWS = typeof URL === 'function' ? URL : /* istanbul ignore next: unreachable in test env */undefined;
// istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
const URLProtoToString$LWS = URLCtor$LWS == null || (_URLCtor$prototype$LWS = URLCtor$LWS.prototype) == null ? void 0 : _URLCtor$prototype$LWS.toString;
// To extract the function body start the match from the beginning of the
// source code with the character class `[\s\S]` instead of `.` because `[\s\S]`
// matches everything including newlines where as `.` matches everything except
// newlines. Next, continue matching past the opening left curly bracket of the
// function and beyond optional whitespace and newline. Finally, capture the
// function body up to, but not including, optional newline and whitespace by
// the closing right curly bracket at the end of the source code. The alternate
// pattern matches arrow functions without brackets.
const funcBodyRegExp$LWS = /^[\s\S]+?\{[\t ]*(?:\r?\n)?([\s\S]*?)(?:\r?\n)?[\t ]*\}$|[\s\S]+?=>\s*([\s\S]+?)\s*$/;
function capitalizeFirstChar$LWS(string$LWS) {
  const {
    length: length$LWS
  } = string$LWS;
  if (length$LWS) {
    const upper$LWS = ReflectApply$LWS(StringProtoToUpperCase$LWS, string$LWS[0], []);
    return length$LWS === 1 ? upper$LWS : upper$LWS + ReflectApply$LWS(StringProtoSlice$LWS, string$LWS, [1]);
  }
  return '';
}
function enquote$LWS(string$LWS, quoteChar$LWS = CHAR_QUOTE_SINGLE$LWS) {
  return quoteChar$LWS + ReflectApply$LWS(StringProtoReplace$LWS, string$LWS, [quoteCharRegExpRegistry$LWS[quoteChar$LWS], `\\${quoteChar$LWS}`]) + quoteChar$LWS;
}
function extractFunctionBodySource$LWS(func$LWS) {
  var _ref$LWS, _match$$LWS;
  const source$LWS = ReflectApply$LWS(FunctionProtoToString$LWS, func$LWS, []);
  const match$LWS = ReflectApply$LWS(StringProtoMatch$LWS, source$LWS, [funcBodyRegExp$LWS]);
  // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
  return (_ref$LWS = (_match$$LWS = match$LWS == null ? void 0 : match$LWS[1]) != null ? _match$$LWS : match$LWS == null ? void 0 : match$LWS[2]) != null ? _ref$LWS : '';
}
// Use `toSafeStringValue()` to coerce values using the default string concatenation
// operation. This must be done ONLY once on incoming values to avoid creating
// shape-shifting exploits, ie. passing { toString() {...} } where a string
// is otherwise expected.
function toSafeStringValue$LWS(value$LWS) {
  return typeof value$LWS === 'string' ? value$LWS :
  // Attempt to coerce `value` to a string with the ToString operation.
  // Section 7.1.17 ToString ( argument )
  // https://tc39.es/ecma262/#sec-tostring
  `${value$LWS}`;
}
// Use `toSafeTemplateStringValue()` for values embedded in template strings,
// like error messages, because it coerces more values, including symbols,
// to strings without throwing exceptions.
function toSafeTemplateStringValue$LWS(value$LWS) {
  if (typeof value$LWS === 'string') {
    return value$LWS;
  }
  try {
    if (typeof value$LWS === 'function') {
      return ReflectApply$LWS(FunctionProtoToString$LWS, value$LWS, []);
    }
    if (typeof value$LWS === 'object' && value$LWS !== null) {
      /* istanbul ignore next: unreachable in test env */
      if (TrustedHTMLCtor$LWS && value$LWS instanceof TrustedHTMLCtor$LWS) {
        return ReflectApply$LWS(TrustedHTMLProtoToString$LWS, value$LWS, []);
      }
      /* istanbul ignore next: unreachable in test env */
      if (TrustedScriptCtor$LWS && value$LWS instanceof TrustedScriptCtor$LWS) {
        return ReflectApply$LWS(TrustedScriptProtoToString$LWS, value$LWS, []);
      }
      if (URLCtor$LWS && value$LWS instanceof URLCtor$LWS) {
        return ReflectApply$LWS(URLProtoToString$LWS, value$LWS, []);
      }
      const result$LWS = ReflectApply$LWS(ObjectProtoToString$LWS, value$LWS, []);
      return result$LWS === TO_STRING_BRAND_SYMBOL$LWS ? ReflectApply$LWS(SymbolProtoToString$LWS, value$LWS, []) : result$LWS;
    }
    if (typeof value$LWS === 'symbol') {
      return ReflectApply$LWS(SymbolProtoToString$LWS, value$LWS, []);
    }
    // Attempt to coerce `value` to a string with the String() constructor.
    // Section 22.1.1.1 String ( value )
    // https://tc39.es/ecma262/#sec-string-constructor-string-value
    return StringCtor$LWS(value$LWS);
    // eslint-disable-next-line no-empty
  } catch (_unused2$LWS) {}
  return '[object Unknown]';
}
const RegExpCtor$LWS = RegExp;
const {
  prototype: RegExpProto$LWS
} = RegExpCtor$LWS;
const {
  exec: RegExpProtoExec$LWS,
  test: RegExpProtoTest$LWS
} = RegExpProto$LWS;
const RegExpProtoSourceGetter$LWS = ObjectLookupOwnGetter$LWS(RegExpProto$LWS, 'source');
const endsWithWordCharRegExp$LWS = /\w$/;
const specialCharRegExp$LWS = /[\\^$.*+?()[\]{}|]/g;
const startsWithWordCharRegExp$LWS = /^\w/;
function toRegExpEscapedIdentifierName$LWS(identifier$LWS) {
  return (startsWithWordCharRegExp$LWS.test(identifier$LWS) ? '\\b' : '') + toRegExpEscapedString$LWS(identifier$LWS) + (endsWithWordCharRegExp$LWS.test(identifier$LWS) ? '\\b' : '');
}
function toRegExpEscapedString$LWS(string$LWS) {
  return ReflectApply$LWS(StringProtoReplace$LWS, string$LWS, [specialCharRegExp$LWS, '\\$&']);
}
const SetCtor$LWS = Set;
const {
  prototype: SetProto$LWS
} = SetCtor$LWS;
const {
  clear: SetProtoClear$LWS,
  delete: SetProtoDelete$LWS,
  entries: SetProtoEntries$LWS,
  forEach: SetProtoForEach$LWS,
  has: SetProtoHas$LWS,
  keys: SetProtoKeys$LWS,
  [SymbolIterator$LWS]: SetProtoSymbolIterator$LWS,
  [SymbolToStringTag$LWS]: SetProtoSymbolToStringTag$LWS
} = SetProto$LWS;
const {
  add: SetProtoAdd$LWS,
  values: SetProtoValues$LWS
} = SetProto$LWS;
const SetProtoSizeGetter$LWS = ObjectLookupOwnGetter$LWS(SetProto$LWS, 'size');
function toSafeSet$LWS(set$LWS) {
  ReflectSetPrototypeOf$LWS(set$LWS, null);
  set$LWS.add = SetProtoAdd$LWS;
  set$LWS.clear = SetProtoClear$LWS;
  set$LWS.delete = SetProtoDelete$LWS;
  set$LWS.entries = SetProtoEntries$LWS;
  set$LWS.forEach = SetProtoForEach$LWS;
  set$LWS.has = SetProtoHas$LWS;
  set$LWS.keys = SetProtoKeys$LWS;
  ReflectDefineProperty$LWS(set$LWS, 'size', {
    __proto__: null,
    configurable: true,
    enumerable: true,
    get: SetProtoSizeGetter$LWS,
    set: undefined
  });
  set$LWS.values = SetProtoValues$LWS;
  set$LWS[SymbolIterator$LWS] = SetProtoSymbolIterator$LWS;
  set$LWS[SymbolToStringTag$LWS] = SetProtoSymbolToStringTag$LWS;
  ReflectSetPrototypeOf$LWS(set$LWS, SetProto$LWS);
  return set$LWS;
}
const WeakMapCtor$LWS = WeakMap;
const {
  prototype: WeakMapProto$LWS
} = WeakMapCtor$LWS;
const {
  has: WeakMapProtoHas$LWS
} = WeakMapProto$LWS;
const {
  delete: WeakMapProtoDelete$LWS,
  get: WeakMapProtoGet$LWS,
  set: WeakMapProtoSet$LWS,
  [SymbolToStringTag$LWS]: WeakMapProtoSymbolToStringTag$LWS
} = WeakMapProto$LWS;
function toSafeWeakMap$LWS(weakMap$LWS) {
  ReflectSetPrototypeOf$LWS(weakMap$LWS, null);
  weakMap$LWS.delete = WeakMapProtoDelete$LWS;
  weakMap$LWS.get = WeakMapProtoGet$LWS;
  weakMap$LWS.has = WeakMapProtoHas$LWS;
  weakMap$LWS.set = WeakMapProtoSet$LWS;
  weakMap$LWS[SymbolToStringTag$LWS] = WeakMapProtoSymbolToStringTag$LWS;
  ReflectSetPrototypeOf$LWS(weakMap$LWS, WeakMapProto$LWS);
  return weakMap$LWS;
}
const WeakSetCtor$LWS = WeakSet;
const {
  prototype: WeakSetProto$LWS
} = WeakSetCtor$LWS;
const {
  has: WeakSetProtoHas$LWS
} = WeakSetProto$LWS;
const {
  add: WeakSetProtoAdd$LWS,
  delete: WeakSetProtoDelete$LWS,
  [SymbolToStringTag$LWS]: WeakSetProtoSymbolToStringTag$LWS
} = WeakSetProto$LWS;
function toSafeWeakSet$LWS(weakSet$LWS) {
  ReflectSetPrototypeOf$LWS(weakSet$LWS, null);
  weakSet$LWS.add = WeakSetProtoAdd$LWS;
  weakSet$LWS.delete = WeakSetProtoDelete$LWS;
  weakSet$LWS.has = WeakSetProtoHas$LWS;
  weakSet$LWS[SymbolToStringTag$LWS] = WeakSetProtoSymbolToStringTag$LWS;
  ReflectSetPrototypeOf$LWS(weakSet$LWS, WeakSetProto$LWS);
  return weakSet$LWS;
}
const {
  toStringTag: TO_STRING_TAG_SYMBOL$LWS
} = Symbol;
// Regular expressions from Acorn:
//     acorn/src/parseutil.js
//     acorn/src/whitespace.js
const expressionCharRegExp$LWS = /[(`.[+\-/*%<>=,?^&]/;
const lineBreakRegExp$LWS = /\r\n?|\n|\u2028|\u2029/;
const skipWhiteSpacesRegExp$LWS = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
const stringLiteralRegExp$LWS = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
function getBrandByTrialAndError$LWS(value$LWS) {
  // Trail and error attempts are performed in order of most likely,
  // e.g. those values that have a @@toStringTag defined by default,
  // to least likely.
  //
  // Internally these brand checks rely on native methods that throw and catch
  // an exception when they operate on values with unexpected internal slot
  // entries.
  // Section 25.1.5.1 get ArrayBuffer.prototype.byteLength
  // https://tc39.es/ecma262/#sec-get-arraybuffer.prototype.bytelength
  // Step 2: Perform RequireInternalSlot(O, [[ArrayBufferData]]).
  try {
    if ('byteLength' in value$LWS) {
      ReflectApply$LWS(ArrayBufferProtoByteLengthGetter$LWS, value$LWS, []);
      return TO_STRING_BRAND_ARRAY_BUFFER$LWS;
    }
    // eslint-disable-next-line no-empty
  } catch (_unused3$LWS) {}
  // Section 21.4.4 Properties of the Date Prototype Object
  // https://tc39.es/ecma262/#thistimevalue
  // Step 1: If Type(value) is Object and value has a [[DateValue]] internal slot, then
  //     a. Return value.[[DateValue]].
  // Step 2: Throw a TypeError exception.
  try {
    if ('toLocaleDateString' in value$LWS) {
      ReflectApply$LWS(DateProtoValueOf$LWS, value$LWS, []);
      return TO_STRING_BRAND_DATE$LWS;
    }
    // eslint-disable-next-line no-empty
  } catch (_unused4$LWS) {}
  // Section 24.1.3.10 get Map.prototype.size
  // https://tc39.es/ecma262/#sec-get-map.prototype.size
  // Step 2: Perform ? RequireInternalSlot(M, [[MapData]]).
  try {
    if ('get' in value$LWS && 'size' in value$LWS) {
      ReflectApply$LWS(MapProtoSizeGetter$LWS, value$LWS, []);
      return TO_STRING_BRAND_MAP$LWS;
    }
    // eslint-disable-next-line no-empty
  } catch (_unused5$LWS) {}
  // Section 24.2.3.9 get Set.prototype.size
  // https://tc39.es/ecma262/#sec-get-set.prototype.size
  // Step 2: Perform ? RequireInternalSlot(S, [[SetData]]).
  try {
    if ('add' in value$LWS && 'size' in value$LWS) {
      ReflectApply$LWS(SetProtoSizeGetter$LWS, value$LWS, []);
      return TO_STRING_BRAND_SET$LWS;
    }
    // eslint-disable-next-line no-empty
  } catch (_unused6$LWS) {}
  // Section 24.3.3.4 WeakMap.prototype.has ( key )
  // https://tc39.es/ecma262/#sec-weakmap.prototype.has
  // Step 2: Perform RequireInternalSlot(M, [[WeakMapData]]).
  try {
    if ('get' in value$LWS && !('size' in value$LWS)) {
      ReflectApply$LWS(WeakMapProtoHas$LWS, value$LWS, []);
      return TO_STRING_BRAND_WEAK_MAP$LWS;
    }
    // eslint-disable-next-line no-empty
  } catch (_unused7$LWS) {}
  // Section 24.4.3.4 WeakSet.prototype.has ( value )
  // https://tc39.es/ecma262/#sec-weakset.prototype.has
  // Step 2: 2. Perform RequireInternalSlot(S, [[WeakSetData]]).
  try {
    if ('add' in value$LWS && !('size' in value$LWS)) {
      ReflectApply$LWS(WeakSetProtoHas$LWS, value$LWS, []);
      return TO_STRING_BRAND_WEAK_SET$LWS;
    }
    // eslint-disable-next-line no-empty
  } catch (_unused8$LWS) {}
  // The following checks are for the rare occurrence of object, i.e. boxed,
  // primitive values or those objects without a default @@toStringTag.
  // Section 21.1.3 Properties of the Number Prototype Object
  // https://tc39.es/ecma262/#thisnumbervalue
  // Step 2: If Type(value) is Object and value has a [[NumberData]] internal slot, then
  //     a. Let n be value.[[NumberData]].
  //     b. Assert: Type(n) is Number.
  try {
    if ('toPrecision' in value$LWS) {
      ReflectApply$LWS(NumberProtoValueOf$LWS, value$LWS, []);
      return TO_STRING_BRAND_NUMBER$LWS;
    }
    // eslint-disable-next-line no-empty
  } catch (_unused9$LWS) {}
  // Section 20.4.3 Properties of the Symbol Prototype Object
  // https://tc39.es/ecma262/#thissymbolvalue
  // Step 2: If Type(value) is Object and value has a [[SymbolData]] internal slot, then
  //     a. Let s be value.[[SymbolData]].
  //     b. Assert: Type(s) is Symbol.
  try {
    if ('description' in value$LWS) {
      ReflectApply$LWS(SymbolProtoValueOf$LWS, value$LWS, []);
      return TO_STRING_BRAND_SYMBOL$LWS;
    }
    // eslint-disable-next-line no-empty
  } catch (_unused10$LWS) {}
  // Perform heavier checks last.
  // Section 22.2.6.13 get RegExp.prototype.source
  // https://tc39.es/ecma262/#sec-get-regexp.prototype.source
  // Step 3: If R does not have an [[OriginalSource]] internal slot, then
  //     a. If SameValue(R, %RegExp.prototype%) is true, return "(?:)".
  //     b. Otherwise, throw a TypeError exception.
  try {
    if (ObjectHasOwn$LWS(value$LWS, 'lastIndex')) {
      ReflectApply$LWS(RegExpProtoSourceGetter$LWS, value$LWS, []);
      return TO_STRING_BRAND_REG_EXP$LWS;
    }
    // eslint-disable-next-line no-empty
  } catch (_unused11$LWS) {}
  // Section 22.1.3 Properties of the String Prototype Object
  // https://tc39.es/ecma262/#thisstringvalue
  // Step 2: If Type(value) is Object and value has a [[StringData]] internal slot, then
  //     a. Let s be value.[[StringData]].
  //     b. Assert: Type(s) is String.
  try {
    if (ObjectHasOwn$LWS(value$LWS, 'length')) {
      ReflectApply$LWS(StringProtoValueOf$LWS, value$LWS, []);
      return TO_STRING_BRAND_STRING$LWS;
    }
    // eslint-disable-next-line no-empty
  } catch (_unused12$LWS) {}
  // Section 20.3.3 Properties of the Boolean Prototype Object
  // https://tc39.es/ecma262/#thisbooleanvalue
  // Step 2: If Type(value) is Object and value has a [[BooleanData]] internal slot, then
  //     a. Let b be value.[[BooleanData]].
  //     b. Assert: Type(b) is Boolean.
  try {
    ReflectApply$LWS(BooleanProtoValueOf$LWS, value$LWS, []);
    return TO_STRING_BRAND_BOOLEAN$LWS;
    // eslint-disable-next-line no-empty
  } catch (_unused13$LWS) {}
  // istanbul ignore else: All platforms that LWS runs tests in support BigInt
  if (SUPPORTS_BIG_INT$LWS) {
    try {
      // Section 21.2.3 Properties of the BigInt Prototype Object
      // https://tc39.es/ecma262/#thisbigintvalue
      // Step 2: If Type(value) is Object and value has a [[BigIntData]] internal slot, then
      //     a. Assert: Type(value.[[BigIntData]]) is BigInt.
      ReflectApply$LWS(BigIntProtoValueOf$LWS, value$LWS, []);
      return TO_STRING_BRAND_BIG_INT$LWS;
      // eslint-disable-next-line no-empty
    } catch (_unused14$LWS) {}
  }
  // Cannot detect brands for Arguments and Error objects.
  return TO_STRING_BRAND_OBJECT$LWS;
}
function getBrand$LWS(value$LWS) {
  // Section 20.1.3.6 Object.prototype.toString ( )
  // https://tc39.es/ecma262/#sec-object.prototype.tostring
  if (value$LWS === null) {
    return TO_STRING_BRAND_NULL$LWS;
  }
  if (value$LWS === undefined) {
    return TO_STRING_BRAND_UNDEFINED$LWS;
  }
  // eslint-disable-next-line default-case
  switch (typeof value$LWS) {
    case 'bigint':
      return TO_STRING_BRAND_BIG_INT$LWS;
    case 'boolean':
      return TO_STRING_BRAND_BOOLEAN$LWS;
    case 'function':
      return TO_STRING_BRAND_FUNCTION$LWS;
    case 'number':
      return TO_STRING_BRAND_NUMBER$LWS;
    case 'string':
      return TO_STRING_BRAND_STRING$LWS;
    case 'symbol':
      return TO_STRING_BRAND_SYMBOL$LWS;
  }
  if (ArrayIsArray$LWS(value$LWS)) {
    return TO_STRING_BRAND_ARRAY$LWS;
  }
  return TO_STRING_TAG_SYMBOL$LWS in value$LWS ? getBrandByTrialAndError$LWS(value$LWS) : ReflectApply$LWS(ObjectProtoToString$LWS, value$LWS, []);
}
const getTimestamp$LWS = typeof performance === 'undefined' ? /* istanbul ignore next: unreachable in test env */DateNow$LWS : ReflectApply$LWS(FunctionProtoBind$LWS, performance.now, [performance]);
// Based on Acorn strictDirective() parser utility.
// Copyright 2012-2022. Released under MIT License.
// https://github.com/acornjs/acorn/blob/master/acorn/src/parseutil.js
function indexOfPragma$LWS(source$LWS, pragma$LWS) {
  let pos$LWS = 0;
  // eslint-disable-next-line no-constant-condition
  while (true) {
    skipWhiteSpacesRegExp$LWS.lastIndex = pos$LWS;
    pos$LWS += ReflectApply$LWS(RegExpProtoExec$LWS, skipWhiteSpacesRegExp$LWS, [source$LWS])[0].length;
    const stringLiteralMatch$LWS = ReflectApply$LWS(RegExpProtoExec$LWS, stringLiteralRegExp$LWS, [ReflectApply$LWS(StringProtoSlice$LWS, source$LWS, [pos$LWS])]);
    if (stringLiteralMatch$LWS === null) {
      return -1;
    }
    if ((stringLiteralMatch$LWS[1] || stringLiteralMatch$LWS[2]) === pragma$LWS) {
      skipWhiteSpacesRegExp$LWS.lastIndex = pos$LWS + stringLiteralMatch$LWS[0].length;
      const spaceAfterMatch$LWS = ReflectApply$LWS(RegExpProtoExec$LWS, skipWhiteSpacesRegExp$LWS, [source$LWS]);
      const end$LWS = spaceAfterMatch$LWS.index + spaceAfterMatch$LWS[0].length;
      const nextChar$LWS = source$LWS[end$LWS];
      if (nextChar$LWS === ';' || nextChar$LWS === '}') {
        return pos$LWS;
      }
      const indexAfterNext$LWS = end$LWS + 1;
      if (ReflectApply$LWS(RegExpProtoTest$LWS, lineBreakRegExp$LWS, [spaceAfterMatch$LWS[0]]) && !(nextChar$LWS === '!' && indexAfterNext$LWS < source$LWS.length && source$LWS[indexAfterNext$LWS] === '=' || ReflectApply$LWS(RegExpProtoTest$LWS, expressionCharRegExp$LWS, [nextChar$LWS]))) {
        return pos$LWS;
      }
    }
    pos$LWS += stringLiteralMatch$LWS[0].length;
    // Skip semicolon, if any.
    skipWhiteSpacesRegExp$LWS.lastIndex = pos$LWS;
    pos$LWS += ReflectApply$LWS(RegExpProtoExec$LWS, skipWhiteSpacesRegExp$LWS, [source$LWS])[0].length;
    if (source$LWS[pos$LWS] === ';') {
      pos$LWS += 1;
    }
  }
}
const {
  parse: JSONParse$LWS
} = JSON;
// Used by '@locker/near-membrane-dom'.
const {
  stringify: JSONStringify$LWS
} = JSON;
function getNearMembraneProxySerializedValue$LWS(object$LWS) {
  if (typeof object$LWS === 'object' && object$LWS !== null || typeof object$LWS === 'function') {
    // To extract the serialized value of a blue near-membrane proxy we must
    // perform a two step handshake. First, we trigger the "has" trap for
    // the `LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL` property which
    // must report `false`. Second, we trigger the "get" trap to return the
    // serialized value.
    return LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS in object$LWS ? undefined : object$LWS[LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS];
  }
  return undefined;
}
function isNearMembraneProxy$LWS(value$LWS) {
  if (typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function') {
    // To extract the flag value of a blue near-membrane proxy we must
    // perform a two step handshake. First, we trigger the "has" trap for
    // the `LOCKER_NEAR_MEMBRANE_SYMBOL` property which must report `false`.
    // Second, we trigger the "get" trap to return the flag value.
    return !(LOCKER_NEAR_MEMBRANE_SYMBOL$LWS in value$LWS) && value$LWS[LOCKER_NEAR_MEMBRANE_SYMBOL$LWS] === true;
  }
  return false;
}
const SEEN_OBJECTS$LWS = toSafeMap$LWS(new MapCtor$LWS());
// istanbul ignore next: this may be dead code, further investigation needed
function cloneBoxedPrimitive$LWS(object$LWS) {
  return ObjectCtor$LWS(getNearMembraneProxySerializedValue$LWS(object$LWS));
}
function cloneMap$LWS(map$LWS, queue$LWS) {
  // Section 2.7.3 StructuredSerializeInternal:
  // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
  // Step 26.1.1: Let copiedList be a new empty List.
  const clone$LWS = new MapCtor$LWS();
  // Step 26.1.2: For each Record { [[Key]], [[Value]] } entry of value.[[MapData]]...
  const entriesIterable$LWS = ReflectApply$LWS(MapProtoEntries$LWS, map$LWS, []);
  // Step 26.1.3 For each Record { [[Key]], [[Value]] } entry of copiedList:
  let {
    length: queueOffset$LWS
  } = queue$LWS;
  // eslint-disable-next-line no-constant-condition
  while (true) {
    const {
      done: done$LWS,
      value: subKeyValuePair$LWS
    } = entriesIterable$LWS.next();
    if (done$LWS) {
      break;
    }
    const {
      0: subKey$LWS,
      1: subValue$LWS
    } = subKeyValuePair$LWS;
    let subCloneKey$LWS;
    // Step 26.1.3.1: Let serializedKey be ? StructuredSerializeInternal(entry.[[Key]], forStorage, memory).
    queue$LWS[queueOffset$LWS++] = [subClone$LWS => {
      subCloneKey$LWS = subClone$LWS;
    }, subKey$LWS];
    // Step 26.1.3.2: Let serializedValue be ? StructuredSerializeInternal(entry.[[Value]], forStorage, memory).
    queue$LWS[queueOffset$LWS++] = [subCloneValue$LWS => {
      ReflectApply$LWS(MapProtoSet$LWS, clone$LWS, [subCloneKey$LWS, subCloneValue$LWS]);
    }, subValue$LWS];
  }
  return clone$LWS;
}
// istanbul ignore next: this may be dead code, further investigation needed
function cloneRegExp$LWS(regexp$LWS) {
  const {
    flags: flags$LWS,
    source: source$LWS
  } = JSONParse$LWS(getNearMembraneProxySerializedValue$LWS(regexp$LWS));
  return new RegExpCtor$LWS(source$LWS, flags$LWS);
}
function cloneSet$LWS(set$LWS, queue$LWS) {
  // Section 2.7.3 StructuredSerializeInternal:
  // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
  // Step 26.2.1: Let copiedList be a new empty List.
  const clone$LWS = new SetCtor$LWS();
  // Step 26.2.2: For each entry of value.[[SetData]]...
  const valuesIterable$LWS = ReflectApply$LWS(SetProtoValues$LWS, set$LWS, []);
  // Step 26.2.3: For each entry of copiedList:
  let {
    length: queueOffset$LWS
  } = queue$LWS;
  // eslint-disable-next-line no-constant-condition
  while (true) {
    const {
      done: done$LWS,
      value: subValue$LWS
    } = valuesIterable$LWS.next();
    if (done$LWS) {
      break;
    }
    // Step 26.2.3.1: Let serializedEntry be ? StructuredSerializeInternal(entry, forStorage, memory).
    queue$LWS[queueOffset$LWS++] = [subCloneValue$LWS => {
      ReflectApply$LWS(SetProtoAdd$LWS, clone$LWS, [subCloneValue$LWS]);
    }, subValue$LWS];
  }
  return clone$LWS;
}
function enqueue$LWS(queue$LWS, originalValue$LWS, cloneValue$LWS) {
  // Section 2.7.3 StructuredSerializeInternal:
  // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
  // Step 26.4: Otherwise, for each key in ! EnumerableOwnPropertyNames(value, key)...
  // Note: Object.keys() performs EnumerableOwnPropertyNames() internally as
  // defined in ECMA262:
  // https://tc39.es/ecma262/#sec-object.keys
  const keys$LWS = ObjectKeys$LWS(originalValue$LWS);
  let {
    length: queueOffset$LWS
  } = queue$LWS;
  for (let i$LWS = 0, {
      length: length$LWS
    } = keys$LWS; i$LWS < length$LWS; i$LWS += 1) {
    // Step 26.4.1.1: Let inputValue be ? value.[[Get]](key, value).
    // The [[Get]] operation is defined in ECMA262 for ordinary objects,
    // argument objects, integer-indexed exotic objects, module namespace
    // objects, and proxy objects.
    // https://tc39.es/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-get-p-receiver
    const key$LWS = keys$LWS[i$LWS];
    const subValue$LWS = originalValue$LWS[key$LWS];
    queue$LWS[queueOffset$LWS++] = [subCloneValue$LWS => {
      // Step 26.4.1.3: Property descriptor attributes are not
      // preserved during deserialization because only keys and
      // values are captured in serialized.[[Properties]].
      cloneValue$LWS[key$LWS] = subCloneValue$LWS;
    }, subValue$LWS];
  }
}
// This function is the unguarded internal variant of `partialStructuredClone()`.
// Any error thrown that is captured by `partialStructuredClone()` is treated as
// a `DataCloneError`. This function clones blue membrane proxied arrays, plain
// objects, maps, regexps, sets, and boxed primitives. The following non-membrane
// proxied objects are set by reference instead of cloning:
//   ArrayBuffer
//   BigInt64Array
//   BigUint64Array
//   Blob
//   DataView
//   Date
//   DOMException
//   DOMMatrix
//   DOMMatrixReadOnly
//   DOMPoint
//   DOMPointReadOnly
//   DOMQuad
//   DOMRect
//   DOMRectReadOnly
//   Error
//   EvalError
//   File
//   FileList
//   Float32Array
//   Float64Array
//   ImageBitMap
//   ImageData
//   Int8Array
//   Int16Array
//   Int32Array
//   RangeError
//   ReferenceError
//   SyntaxError
//   TypeError
//   Uint8Array
//   Uint8ClampedArray
//   Uint16Array
//   Uint32Array
//   URIError
//
// Note:
// This function performs brand checks using `Object.prototype.toString`. The
// results can be faked with `Symbol.toStringTag` property values and are a poor
// substitute for native internal slot checks. However, for our purposes they
// are perfectly fine and avoid having to repeatedly walk the prototype of proxied
// values. Cloned values should be passed to native methods, like `postMessage()`,
// which perform their own validation with internal slot checks.
function partialStructuredCloneInternal$LWS(value$LWS) {
  // Using a queue instead of recursive function calls avoids call stack limits
  // and enables cloning more complex and deeply nested objects.
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Too_much_recursion
  let result$LWS;
  const queue$LWS = [[subClone$LWS => {
    result$LWS = subClone$LWS;
  }, value$LWS]];
  // eslint-disable-next-line no-labels
  queueLoop: while (queue$LWS.length) {
    // Section 2.7.3 StructuredSerializeInternal:
    // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
    // prettier-ignore
    const {
      0: setter$LWS,
      1: originalValue$LWS
    } = ReflectApply$LWS(ArrayProtoShift$LWS, queue$LWS, []);
    // Step 4: If Type(value) is Undefined, Null, Boolean, Number, BigInt, or String
    if (originalValue$LWS === null || originalValue$LWS === undefined || typeof originalValue$LWS === 'boolean' || typeof originalValue$LWS === 'number' || typeof originalValue$LWS === 'string' || typeof originalValue$LWS === 'bigint') {
      setter$LWS(originalValue$LWS);
      // eslint-disable-next-line no-continue, no-extra-label, no-labels
      continue queueLoop;
    }
    // Step 5: If Type(value) is Symbol, then throw a 'DataCloneError' DOMException.
    if (typeof originalValue$LWS === 'symbol') {
      // Stop cloning and set the original value and defer throwing to
      // native methods.
      setter$LWS(originalValue$LWS);
      // eslint-disable-next-line no-extra-label, no-labels
      break queueLoop;
    }
    // To support circular references check if the original value has been
    // seen. If it has then use the clone associated with its record instead
    // of creating a new clone.
    let cloneValue$LWS = SEEN_OBJECTS$LWS.get(originalValue$LWS);
    if (cloneValue$LWS) {
      setter$LWS(cloneValue$LWS);
      // eslint-disable-next-line no-continue, no-extra-label, no-labels
      continue queueLoop;
    }
    // Perform a brand check on originalValue.
    const brand$LWS = getBrand$LWS(originalValue$LWS);
    // eslint-disable-next-line default-case
    switch (brand$LWS) {
      // Step 19: Otherwise, if value is a platform object...
      case TO_STRING_BRAND_OBJECT$LWS:
        {
          const proto$LWS = ReflectGetPrototypeOf$LWS(originalValue$LWS);
          if (proto$LWS === ObjectProto$LWS || proto$LWS === null ||
          // Possible `Object.prototype` from another document.
          ReflectGetPrototypeOf$LWS(proto$LWS) === null) {
            cloneValue$LWS = {};
            // Step 19.4: Set deep to true.
            enqueue$LWS(queue$LWS, originalValue$LWS, cloneValue$LWS);
          }
          break;
        }
      // Step 18: Otherwise, if value is an Array exotic object...
      case TO_STRING_BRAND_ARRAY$LWS:
        // Step 18.1 Let valueLenDescriptor be ? OrdinaryGetOwnProperty(value, 'length').
        // Note: Rather than perform the more complex OrdinaryGetOwnProperty()
        // operation for 'length' because it is a non-configurable property
        // we can access it with the simpler [[Get]]() operation defined
        // in ECMA262.
        // https://tc39.es/ecma262/#sec-integer-indexed-exotic-objects-get-p-receiver
        cloneValue$LWS = ArrayCtor$LWS(originalValue$LWS.length);
        // Step 18.4: Set deep to true.
        enqueue$LWS(queue$LWS, originalValue$LWS, cloneValue$LWS);
        break;
      // Step 15: Otherwise, if value has [[MapData]] internal slot...
      // Step 15.2: Set deep to true.
      case TO_STRING_BRAND_MAP$LWS:
        cloneValue$LWS = cloneMap$LWS(originalValue$LWS, queue$LWS);
        break;
      // Step 16: Otherwise, if value has [[SetData]] internal slot...
      // Step 16.2: Set deep to true.
      case TO_STRING_BRAND_SET$LWS:
        cloneValue$LWS = cloneSet$LWS(originalValue$LWS, queue$LWS);
        break;
    }
    if (cloneValue$LWS === undefined) {
      // istanbul ignore else
      if (!isNearMembraneProxy$LWS(originalValue$LWS)) {
        // Skip cloning non-membrane proxied objects.
        SEEN_OBJECTS$LWS.set(originalValue$LWS, originalValue$LWS);
        setter$LWS(originalValue$LWS);
        // eslint-disable-next-line no-extra-label, no-labels
        continue queueLoop;
      }
      // Cases ordered by a guestimate on frequency of encounter.
      // eslint-disable-next-line default-case
      switch (brand$LWS) {
        // Step 12: Otherwise, if value has a [[RegExpMatcher]] internal slot...
        case TO_STRING_BRAND_REG_EXP$LWS:
          // istanbul ignore next: this may be dead code, further investigation needed
          cloneValue$LWS = cloneRegExp$LWS(originalValue$LWS);
          // istanbul ignore next: this may be dead code, further investigation needed
          break;
        // Step 7: If value has a [[BooleanData]] internal slot...
        case TO_STRING_BRAND_BOOLEAN$LWS:
        // Step 8: Otherwise, if value has a [[NumberData]] internal slot...
        // eslint-disable-next-line no-fallthrough
        case TO_STRING_BRAND_NUMBER$LWS:
        // Step 9: Otherwise, if value has a [[BigIntData]] internal slot...
        // eslint-disable-next-line no-fallthrough
        case TO_STRING_BRAND_BIG_INT$LWS:
        // Step 10: Otherwise, if value has a [[StringData]] internal slot...
        // eslint-disable-next-line no-fallthrough
        case TO_STRING_BRAND_STRING$LWS:
          // istanbul ignore next: this may be dead code, further investigation needed
          cloneValue$LWS = cloneBoxedPrimitive$LWS(originalValue$LWS);
          // istanbul ignore next: this may be dead code, further investigation needed
          break;
      }
    }
    // Step 21: Otherwise, if IsCallable(value) is true, then throw a 'DataCloneError'
    // Step 20: Otherwise, if value is a platform object, then throw a 'DataCloneError'
    if (cloneValue$LWS === undefined) {
      // Stop cloning and set the original value and defer throwing to
      // native methods.
      setter$LWS(originalValue$LWS);
      // eslint-disable-next-line no-extra-label, no-labels
      break queueLoop;
    }
    SEEN_OBJECTS$LWS.set(originalValue$LWS, cloneValue$LWS);
    setter$LWS(cloneValue$LWS);
  }
  return result$LWS;
}
function partialStructuredClone$LWS(value$LWS) {
  let result$LWS = value$LWS;
  if (typeof value$LWS === 'object' && value$LWS !== null) {
    try {
      result$LWS = partialStructuredCloneInternal$LWS(value$LWS);
      // eslint-disable-next-line no-empty
    } catch (_unused15$LWS) {}
    SEEN_OBJECTS$LWS.clear();
  }
  return result$LWS;
}
function shallowCloneArray$LWS(array$LWS) {
  return ReflectApply$LWS(ArrayProtoSlice$LWS, array$LWS, [0]);
}
function shallowCloneOptions$LWS(options$LWS) {
  const ownKeys$LWS = ReflectOwnKeys$LWS(options$LWS);
  const clone$LWS = {
    __proto__: null
  };
  for (let i$LWS = 0, {
      length: length$LWS
    } = ownKeys$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const key$LWS = ownKeys$LWS[i$LWS];
    clone$LWS[key$LWS] = options$LWS[key$LWS];
  }
  return clone$LWS;
}
const consoleRef$LWS = console;
const {
  warn: consoleWarnRef$LWS
} = consoleRef$LWS;
function consoleWarn$LWS(...args$LWS) {
  ReflectApply$LWS(consoleWarnRef$LWS, consoleRef$LWS, args$LWS);
}
const gaterEnabledFeatures$LWS = toSafeSet$LWS(new SetCtor$LWS());
const FEATURE_NAME_PREFIX$LWS = 'com.salesforce.locker.';
const fullName$LWS = featureName$LWS => featureName$LWS.startsWith(FEATURE_NAME_PREFIX$LWS) ? featureName$LWS : `${FEATURE_NAME_PREFIX$LWS}${featureName$LWS}`;
function registerGaterEnabledFeatures$LWS(lockerGaterEnabledFeatures$LWS) {
  if (ArrayIsArray$LWS(lockerGaterEnabledFeatures$LWS)) {
    lockerGaterEnabledFeatures$LWS.forEach(feature$LWS => gaterEnabledFeatures$LWS.add(fullName$LWS(feature$LWS)));
  }
}
function deregisterGaterEnabledFeatures$LWS(lockerGaterEnabledFeatures$LWS) {
  if (ArrayIsArray$LWS(lockerGaterEnabledFeatures$LWS)) {
    lockerGaterEnabledFeatures$LWS.forEach(feature$LWS => gaterEnabledFeatures$LWS.delete(fullName$LWS(feature$LWS)));
  }
}
function clearGaterEnabledFeatures$LWS() {
  gaterEnabledFeatures$LWS.clear();
}
function isGaterEnabledFeature$LWS(featureName$LWS) {
  return gaterEnabledFeatures$LWS.has(fullName$LWS(featureName$LWS));
}
const ENABLE_MAX_PERF_MODE_GATE$LWS = 'enableMaxPerfMode';
const ENABLE_SANDBOXED_SAMEORIGIN_IFRAME_GATE$LWS = 'enableSandboxedSameOriginIframe';
const omniStudioPredicates$LWS = [key$LWS => key$LWS === 'omnistudio', key$LWS => ReflectApply$LWS(StringProtoStartsWith$LWS, key$LWS, ['devopsimpkg'])];
const gaterEnabledOverrideRegistry$LWS = {
  __proto__: null,
  $lwsBogusFeatureDisabledTrue: [() => true],
  $lwsBogusFeatureDisabledFalse: [() => false],
  [ENABLE_MAX_PERF_MODE_GATE$LWS]: omniStudioPredicates$LWS,
  // Temporarily disable this feature gate
  // Ref:
  //  "W-17049687: [LWS] Temporarily disable same origin iframe sandbox security fix for OS and devopsimpkg"
  //  https://gus.lightning.force.com/lightning/r/ADM_Work__c/a07EE000023unysYAA/view
  [ENABLE_SANDBOXED_SAMEORIGIN_IFRAME_GATE$LWS]: omniStudioPredicates$LWS
};
function isAllowedToOverrideGaterEnabledFeature$LWS(sandboxKey$LWS, featureName$LWS) {
  var _gaterEnabledOverride$LWS;
  const gaterEnabledOverridePredicates$LWS = toSafeArray$LWS((_gaterEnabledOverride$LWS = gaterEnabledOverrideRegistry$LWS[featureName$LWS]) != null ? _gaterEnabledOverride$LWS : []);
  return gaterEnabledOverridePredicates$LWS.some(predicate$LWS => predicate$LWS(sandboxKey$LWS));
}
function isNotAllowedToOverrideGaterEnabledFeature$LWS(...args$LWS) {
  return !isAllowedToOverrideGaterEnabledFeature$LWS(...args$LWS);
}
const trackedLiveTargets$LWS = toSafeWeakSet$LWS(new WeakSetCtor$LWS());
function isTargetLive$LWS(target$LWS, targetTraits$LWS = 0 /* TargetTraits.None */) {
  if (targetTraits$LWS & 1 /* TargetTraits.IsArray */ || targetTraits$LWS & 2 /* TargetTraits.IsArrayBufferView */ || targetTraits$LWS & 64 /* TargetTraits.Revoked */ || target$LWS === null || target$LWS === undefined || target$LWS === ObjectProto$LWS || target$LWS === RegExpProto$LWS) {
    return false;
  }
  if (typeof target$LWS === 'function') {
    try {
      return trackedLiveTargets$LWS.has(target$LWS) || ObjectHasOwn$LWS(target$LWS, SYMBOL_LIVE_OBJECT$LWS);
      // eslint-disable-next-line no-empty
    } catch (_unused16$LWS) {}
    return false;
  }
  if (typeof target$LWS === 'object') {
    try {
      if (trackedLiveTargets$LWS.has(target$LWS) || ObjectHasOwn$LWS(target$LWS, SYMBOL_LIVE_OBJECT$LWS)) {
        return true;
      }
      // eslint-disable-next-line no-empty
    } catch (_unused17$LWS) {}
    let constructor$LWS;
    try {
      ({
        constructor: constructor$LWS
      } = target$LWS);
      if (constructor$LWS === ObjectCtor$LWS) {
        // If the constructor, own or inherited, points to `Object`
        // then `target` is not likely a prototype object.
        return true;
      }
      // eslint-disable-next-line no-empty
    } catch (_unused18$LWS) {}
    try {
      if (ReflectGetPrototypeOf$LWS(target$LWS) === null && (
      // Ensure `target` is not an `Object.prototype` from an iframe.
      typeof constructor$LWS !== 'function' || constructor$LWS.prototype !== target$LWS)) {
        return true;
      }
      // eslint-disable-next-line no-empty
    } catch (_unused19$LWS) {}
    if (targetTraits$LWS === 0 /* TargetTraits.None */) {
      try {
        if (ArrayIsArray$LWS(target$LWS)) {
          return true;
        }
      } catch (_unused20$LWS) {
        // The target is a revoked proxy.
        return false;
      }
      if (ArrayBufferIsView$LWS(target$LWS)) {
        return true;
      }
    }
    // Section 25.1.5.1 get ArrayBuffer.prototype.byteLength
    // https://tc39.es/ecma262/#sec-get-regexp.prototype.source
    // Step 3: If R does not have an [[OriginalSource]] internal slot, then
    //     a. If SameValue(R, %RegExp.prototype%) is true, return "(?:)".
    //     b. Otherwise, throw a TypeError exception.
    try {
      if (ObjectHasOwn$LWS(target$LWS, 'lastIndex')) {
        ReflectApply$LWS(RegExpProtoSourceGetter$LWS, target$LWS, []);
        return true;
      }
      // eslint-disable-next-line no-empty
    } catch (_unused21$LWS) {}
    // Section 25.1.5.1 get ArrayBuffer.prototype.byteLength
    // https://tc39.es/ecma262/#sec-get-arraybuffer.prototype.bytelength
    // Step 2: Perform RequireInternalSlot(O, [[ArrayBufferData]]).
    try {
      if ('byteLength' in target$LWS) {
        ReflectApply$LWS(ArrayBufferProtoByteLengthGetter$LWS, target$LWS, []);
        return true;
      }
      // eslint-disable-next-line no-empty
    } catch (_unused22$LWS) {}
  }
  return false;
}
function markTargetAsLive$LWS(target$LWS) {
  if ((typeof target$LWS === 'object' && target$LWS !== null || typeof target$LWS === 'function') && !isTargetLive$LWS(target$LWS)) {
    ReflectDefineProperty$LWS(target$LWS, SYMBOL_LIVE_OBJECT$LWS, {
      __proto__: null,
      value: undefined
    });
  }
  return target$LWS;
}
function trackAsLiveTarget$LWS(target$LWS) {
  trackedLiveTargets$LWS.add(target$LWS);
  return target$LWS;
}
const lockerFeatures$LWS = {};
function registerLockerFeature$LWS(featureName$LWS, value$LWS) {
  lockerFeatures$LWS[featureName$LWS] = value$LWS;
}
function isLockerFeatureEnabled$LWS(featureName$LWS) {
  return lockerFeatures$LWS[featureName$LWS];
}

// Used by '@locker/near-membrane-dom'.
const {
  min: MathMin$LWS
} = Math;
const NS_HEAD$LWS = `${LOCKER_SERVICE_KEY$LWS}-`;
const NS_TAIL$LWS = '$';
const STORAGE_NS_HEAD$LWS = `${LOCKER_SERVICE_KEY$LWS}[`;
const STORAGE_NS_TAIL$LWS = ']';
function getNamespaceMarker$LWS(namespace$LWS) {
  return `${NS_HEAD$LWS}${namespace$LWS}${NS_TAIL$LWS}`;
}
function getStorageNamespaceMarker$LWS(namespace$LWS) {
  return `${STORAGE_NS_HEAD$LWS}${namespace$LWS}${STORAGE_NS_TAIL$LWS}`;
}
function prependNamespaceMarker$LWS(key$LWS, namespace$LWS) {
  return `${getNamespaceMarker$LWS(namespace$LWS)}${key$LWS}`;
}
function prependStorageNamespaceMarker$LWS(key$LWS, namespace$LWS) {
  return `${getStorageNamespaceMarker$LWS(namespace$LWS)}${key$LWS}`;
}
function removeNamespaceMarker$LWS(key$LWS, namespace$LWS) {
  if (typeof key$LWS === 'string') {
    const marker$LWS = getNamespaceMarker$LWS(namespace$LWS);
    return ReflectApply$LWS(StringProtoStartsWith$LWS, key$LWS, [marker$LWS]) ? ReflectApply$LWS(StringProtoSlice$LWS, key$LWS, [marker$LWS.length]) : key$LWS;
  }
  return '';
}
function removeStorageNamespaceMarker$LWS(key$LWS, namespace$LWS) {
  if (typeof key$LWS === 'string') {
    const marker$LWS = getStorageNamespaceMarker$LWS(namespace$LWS);
    return ReflectApply$LWS(StringProtoStartsWith$LWS, key$LWS, [marker$LWS]) ? ReflectApply$LWS(StringProtoSlice$LWS, key$LWS, [marker$LWS.length]) : key$LWS;
  }
  return '';
}
function startsWithNamespaceMarker$LWS(key$LWS, namespace$LWS) {
  return typeof key$LWS === 'string' && ReflectApply$LWS(StringProtoStartsWith$LWS, key$LWS, [getNamespaceMarker$LWS(namespace$LWS)]);
}
function startsWithStorageNamespaceMarker$LWS(key$LWS, namespace$LWS) {
  return typeof key$LWS === 'string' && ReflectApply$LWS(StringProtoStartsWith$LWS, key$LWS, [getStorageNamespaceMarker$LWS(namespace$LWS)]);
}
const PromiseCtor$LWS = Promise;
const {
  catch: PromiseProtoCatch$LWS,
  then: PromiseProtoThen$LWS
} = PromiseCtor$LWS.prototype;
const PromiseResolve$LWS = PromiseCtor$LWS.resolve.bind(PromiseCtor$LWS);
const PromiseReject$LWS = PromiseCtor$LWS.reject.bind(PromiseCtor$LWS);
exports.ArrayBufferIsView = ArrayBufferIsView$LWS;
exports.ArrayBufferProtoByteLengthGetter = ArrayBufferProtoByteLengthGetter$LWS;
exports.ArrayConcat = ArrayConcat$LWS;
exports.ArrayCtor = ArrayCtor$LWS;
exports.ArrayIsArray = ArrayIsArray$LWS;
exports.ArrayProtoFilter = ArrayProtoFilter$LWS;
exports.ArrayProtoFind = ArrayProtoFind$LWS;
exports.ArrayProtoIncludes = ArrayProtoIncludes$LWS;
exports.ArrayProtoIndexOf = ArrayProtoIndexOf$LWS;
exports.ArrayProtoJoin = ArrayProtoJoin$LWS;
exports.ArrayProtoMap = ArrayProtoMap$LWS;
exports.ArrayProtoPush = ArrayProtoPush$LWS;
exports.ArrayProtoShift = ArrayProtoShift$LWS;
exports.ArrayProtoSlice = ArrayProtoSlice$LWS;
exports.ArrayProtoSort = ArrayProtoSort$LWS;
exports.ArrayProtoSplice = ArrayProtoSplice$LWS;
exports.ArrayProtoToString = ArrayProtoToString$LWS;
exports.ArrayProtoUnshift = ArrayProtoUnshift$LWS;
exports.BigIntProtoValueOf = BigIntProtoValueOf$LWS;
exports.BooleanProtoValueOf = BooleanProtoValueOf$LWS;
exports.CHAR_QUOTE_DOUBLE = CHAR_QUOTE_DOUBLE$LWS;
exports.CHAR_QUOTE_SINGLE = CHAR_QUOTE_SINGLE$LWS;
exports.DateNow = DateNow$LWS;
exports.DateProtoValueOf = DateProtoValueOf$LWS;
exports.ENABLE_MAX_PERF_MODE_GATE = ENABLE_MAX_PERF_MODE_GATE$LWS;
exports.ENABLE_SANDBOXED_SAMEORIGIN_IFRAME_GATE = ENABLE_SANDBOXED_SAMEORIGIN_IFRAME_GATE$LWS;
exports.ERR_ILLEGAL_PROPERTY_ACCESS = ERR_ILLEGAL_PROPERTY_ACCESS$LWS;
exports.ERR_INVALID_SANDBOX_KEY = ERR_INVALID_SANDBOX_KEY$LWS;
exports.ErrorCtor = ErrorCtor$LWS;
exports.FunctionProtoBind = FunctionProtoBind$LWS;
exports.FunctionProtoToString = FunctionProtoToString$LWS;
exports.JSONParse = JSONParse$LWS;
exports.JSONStringify = JSONStringify$LWS;
exports.LOCKER_IDENTIFIER_MARKER = LOCKER_IDENTIFIER_MARKER$LWS;
exports.LOCKER_NEAR_MEMBRANE_IS_MASKED_SYMBOL = LOCKER_NEAR_MEMBRANE_IS_MASKED_SYMBOL$LWS;
exports.LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL = LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS;
exports.LOCKER_NEAR_MEMBRANE_SYMBOL = LOCKER_NEAR_MEMBRANE_SYMBOL$LWS;
exports.LOCKER_NEAR_MEMBRANE_UNMASKED_VALUE_SYMBOL = LOCKER_NEAR_MEMBRANE_UNMASKED_VALUE_SYMBOL$LWS;
exports.LOCKER_SERVICE_KEY = LOCKER_SERVICE_KEY$LWS;
exports.LOCKER_SERVICE_KEY_LOWERED = LOCKER_SERVICE_KEY_LOWERED$LWS;
exports.LOCKER_UNMINIFIED_FLAG = LOCKER_UNMINIFIED_FLAG$LWS;
exports.LockerSecurityError = LockerSecurityError$LWS;
exports.MapCtor = MapCtor$LWS;
exports.MapProtoEntries = MapProtoEntries$LWS;
exports.MapProtoSet = MapProtoSet$LWS;
exports.MapProtoSizeGetter = MapProtoSizeGetter$LWS;
exports.MathMin = MathMin$LWS;
exports.NumberIsFinite = NumberIsFinite$LWS;
exports.NumberIsInteger = NumberIsInteger$LWS;
exports.NumberIsNaN = NumberIsNaN$LWS;
exports.NumberProtoToFixed = NumberProtoToFixed$LWS;
exports.NumberProtoValueOf = NumberProtoValueOf$LWS;
exports.ObjectAssign = ObjectAssign$LWS;
exports.ObjectCtor = ObjectCtor$LWS;
exports.ObjectDefineProperties = ObjectDefineProperties$LWS;
exports.ObjectFreeze = ObjectFreeze$LWS;
exports.ObjectGetOwnPropertyDescriptors = ObjectGetOwnPropertyDescriptors$LWS;
exports.ObjectGetOwnPropertySymbols = ObjectGetOwnPropertySymbols$LWS;
exports.ObjectHasOwn = ObjectHasOwn$LWS;
exports.ObjectKeys = ObjectKeys$LWS;
exports.ObjectLookupOwnGetter = ObjectLookupOwnGetter$LWS;
exports.ObjectLookupOwnSetter = ObjectLookupOwnSetter$LWS;
exports.ObjectLookupOwnValue = ObjectLookupOwnValue$LWS;
exports.ObjectPreventExtensions = ObjectPreventExtensions$LWS;
exports.ObjectProto = ObjectProto$LWS;
exports.ObjectProtoToString = ObjectProtoToString$LWS;
exports.PromiseCtor = PromiseCtor$LWS;
exports.PromiseProtoCatch = PromiseProtoCatch$LWS;
exports.PromiseProtoThen = PromiseProtoThen$LWS;
exports.PromiseReject = PromiseReject$LWS;
exports.PromiseResolve = PromiseResolve$LWS;
exports.ProxyCtor = ProxyCtor$LWS;
exports.ReflectApply = ReflectApply$LWS;
exports.ReflectConstruct = ReflectConstruct$LWS;
exports.ReflectDefineProperty = ReflectDefineProperty$LWS;
exports.ReflectDeleteProperty = ReflectDeleteProperty$LWS;
exports.ReflectGet = ReflectGet$LWS;
exports.ReflectGetOwnPropertyDescriptor = ReflectGetOwnPropertyDescriptor$LWS;
exports.ReflectGetPrototypeOf = ReflectGetPrototypeOf$LWS;
exports.ReflectHas = ReflectHas$LWS;
exports.ReflectIsExtensible = ReflectIsExtensible$LWS;
exports.ReflectOwnKeys = ReflectOwnKeys$LWS;
exports.ReflectPreventExtensions = ReflectPreventExtensions$LWS;
exports.ReflectSet = ReflectSet$LWS;
exports.ReflectSetPrototypeOf = ReflectSetPrototypeOf$LWS;
exports.RegExpCtor = RegExpCtor$LWS;
exports.RegExpProto = RegExpProto$LWS;
exports.RegExpProtoExec = RegExpProtoExec$LWS;
exports.RegExpProtoSourceGetter = RegExpProtoSourceGetter$LWS;
exports.RegExpProtoTest = RegExpProtoTest$LWS;
exports.SANDBOX_EVAL_CONTEXT_NAME = SANDBOX_EVAL_CONTEXT_NAME$LWS;
exports.SANDBOX_EVAL_HELPERS_NAME = SANDBOX_EVAL_HELPERS_NAME$LWS;
exports.SUPPORTS_BIG_INT = SUPPORTS_BIG_INT$LWS;
exports.SYMBOL_LIVE_OBJECT = SYMBOL_LIVE_OBJECT$LWS;
exports.SetCtor = SetCtor$LWS;
exports.SetProtoAdd = SetProtoAdd$LWS;
exports.SetProtoSizeGetter = SetProtoSizeGetter$LWS;
exports.SetProtoValues = SetProtoValues$LWS;
exports.StringCtor = StringCtor$LWS;
exports.StringProtoCharAt = StringProtoCharAt$LWS;
exports.StringProtoCharCodeAt = StringProtoCharCodeAt$LWS;
exports.StringProtoEndsWith = StringProtoEndsWith$LWS;
exports.StringProtoIncludes = StringProtoIncludes$LWS;
exports.StringProtoIndexOf = StringProtoIndexOf$LWS;
exports.StringProtoLastIndexOf = StringProtoLastIndexOf$LWS;
exports.StringProtoMatch = StringProtoMatch$LWS;
exports.StringProtoReplace = StringProtoReplace$LWS;
exports.StringProtoSlice = StringProtoSlice$LWS;
exports.StringProtoSplit = StringProtoSplit$LWS;
exports.StringProtoStartsWith = StringProtoStartsWith$LWS;
exports.StringProtoSubstring = StringProtoSubstring$LWS;
exports.StringProtoToLowerCase = StringProtoToLowerCase$LWS;
exports.StringProtoToUpperCase = StringProtoToUpperCase$LWS;
exports.StringProtoValueOf = StringProtoValueOf$LWS;
exports.SymbolAsyncIterator = SymbolAsyncIterator$LWS;
exports.SymbolFor = SymbolFor$LWS;
exports.SymbolIterator = SymbolIterator$LWS;
exports.SymbolProtoToString = SymbolProtoToString$LWS;
exports.SymbolProtoValueOf = SymbolProtoValueOf$LWS;
exports.SymbolToStringTag = SymbolToStringTag$LWS;
exports.SymbolUnscopables = SymbolUnscopables$LWS;
exports.TO_STRING_BRAND_ARRAY = TO_STRING_BRAND_ARRAY$LWS;
exports.TO_STRING_BRAND_ARRAY_BUFFER = TO_STRING_BRAND_ARRAY_BUFFER$LWS;
exports.TO_STRING_BRAND_BIG_INT = TO_STRING_BRAND_BIG_INT$LWS;
exports.TO_STRING_BRAND_BOOLEAN = TO_STRING_BRAND_BOOLEAN$LWS;
exports.TO_STRING_BRAND_DATE = TO_STRING_BRAND_DATE$LWS;
exports.TO_STRING_BRAND_ERROR = TO_STRING_BRAND_ERROR$LWS;
exports.TO_STRING_BRAND_FUNCTION = TO_STRING_BRAND_FUNCTION$LWS;
exports.TO_STRING_BRAND_MAP = TO_STRING_BRAND_MAP$LWS;
exports.TO_STRING_BRAND_NULL = TO_STRING_BRAND_NULL$LWS;
exports.TO_STRING_BRAND_NUMBER = TO_STRING_BRAND_NUMBER$LWS;
exports.TO_STRING_BRAND_OBJECT = TO_STRING_BRAND_OBJECT$LWS;
exports.TO_STRING_BRAND_REG_EXP = TO_STRING_BRAND_REG_EXP$LWS;
exports.TO_STRING_BRAND_SET = TO_STRING_BRAND_SET$LWS;
exports.TO_STRING_BRAND_STRING = TO_STRING_BRAND_STRING$LWS;
exports.TO_STRING_BRAND_SYMBOL = TO_STRING_BRAND_SYMBOL$LWS;
exports.TO_STRING_BRAND_UNDEFINED = TO_STRING_BRAND_UNDEFINED$LWS;
exports.TO_STRING_BRAND_WEAK_MAP = TO_STRING_BRAND_WEAK_MAP$LWS;
exports.TO_STRING_BRAND_WEAK_SET = TO_STRING_BRAND_WEAK_SET$LWS;
exports.TypeErrorCtor = TypeErrorCtor$LWS;
exports.UNCOMPILED_LOCATION_NAME = UNCOMPILED_LOCATION_NAME$LWS;
exports.UNCOMPILED_TOP_NAME = UNCOMPILED_TOP_NAME$LWS;
exports.WEBPACK_REQUIRE_NAME = WEBPACK_REQUIRE_NAME$LWS;
exports.WeakMapCtor = WeakMapCtor$LWS;
exports.WeakMapProtoHas = WeakMapProtoHas$LWS;
exports.WeakSetCtor = WeakSetCtor$LWS;
exports.WeakSetProtoHas = WeakSetProtoHas$LWS;
exports.capitalizeFirstChar = capitalizeFirstChar$LWS;
exports.clearGaterEnabledFeatures = clearGaterEnabledFeatures$LWS;
exports.consoleWarn = consoleWarn$LWS;
exports.createRevokedProxy = createRevokedProxy$LWS;
exports.createUnmaskableTraps = createUnmaskableTraps$LWS;
exports.deregisterGaterEnabledFeatures = deregisterGaterEnabledFeatures$LWS;
exports.enquote = enquote$LWS;
exports.extractFunctionBodySource = extractFunctionBodySource$LWS;
exports.getBrand = getBrand$LWS;
exports.getNamespaceMarker = getNamespaceMarker$LWS;
exports.getNearMembraneProxySerializedValue = getNearMembraneProxySerializedValue$LWS;
exports.getStorageNamespaceMarker = getStorageNamespaceMarker$LWS;
exports.getTimestamp = getTimestamp$LWS;
exports.getUnmaskedFunction = getUnmaskedFunction$LWS;
exports.identity = identity$LWS;
exports.indexOfPragma = indexOfPragma$LWS;
exports.isAllowedToOverrideGaterEnabledFeature = isAllowedToOverrideGaterEnabledFeature$LWS;
exports.isGaterEnabledFeature = isGaterEnabledFeature$LWS;
exports.isLockerFeatureEnabled = isLockerFeatureEnabled$LWS;
exports.isMaskedFunction = isMaskedFunction$LWS;
exports.isNearMembraneProxy = isNearMembraneProxy$LWS;
exports.isNotAllowedToOverrideGaterEnabledFeature = isNotAllowedToOverrideGaterEnabledFeature$LWS;
exports.isObject = isObject$LWS;
exports.isObjectLike = isObjectLike$LWS;
exports.isRevokedProxy = isRevokedProxy$LWS;
exports.isTargetLive = isTargetLive$LWS;
exports.markTargetAsLive = markTargetAsLive$LWS;
exports.maskFunction = maskFunction$LWS;
exports.noop = noop$LWS;
exports.partialStructuredClone = partialStructuredClone$LWS;
exports.prependNamespaceMarker = prependNamespaceMarker$LWS;
exports.prependStorageNamespaceMarker = prependStorageNamespaceMarker$LWS;
exports.registerGaterEnabledFeatures = registerGaterEnabledFeatures$LWS;
exports.registerLockerFeature = registerLockerFeature$LWS;
exports.removeNamespaceMarker = removeNamespaceMarker$LWS;
exports.removeStorageNamespaceMarker = removeStorageNamespaceMarker$LWS;
exports.shallowCloneArray = shallowCloneArray$LWS;
exports.shallowCloneOptions = shallowCloneOptions$LWS;
exports.startsWithNamespaceMarker = startsWithNamespaceMarker$LWS;
exports.startsWithStorageNamespaceMarker = startsWithStorageNamespaceMarker$LWS;
exports.toRegExpEscapedIdentifierName = toRegExpEscapedIdentifierName$LWS;
exports.toRegExpEscapedString = toRegExpEscapedString$LWS;
exports.toSafeArray = toSafeArray$LWS;
exports.toSafeMap = toSafeMap$LWS;
exports.toSafeSet = toSafeSet$LWS;
exports.toSafeStringValue = toSafeStringValue$LWS;
exports.toSafeTemplateStringValue = toSafeTemplateStringValue$LWS;
exports.toSafeWeakMap = toSafeWeakMap$LWS;
exports.toSafeWeakSet = toSafeWeakSet$LWS;
exports.trackAsLiveTarget = trackAsLiveTarget$LWS;
/*! version: 0.23.6 */
