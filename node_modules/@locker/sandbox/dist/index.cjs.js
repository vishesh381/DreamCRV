/*!
 * Copyright (C) 2019 salesforce.com, inc.
 */
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var shared$LWS = require('@locker/shared');
var sharedDom$LWS = require('@locker/shared-dom');
var distortion$LWS = require('@locker/distortion');
var trustedTypes$LWS = require('@locker/trusted-types');
var sharedUrl$LWS = require('@locker/shared-url');
var htmlSanitizer$LWS = require('@locker/html-sanitizer');
const rootSandboxRegistry$LWS = {
  __proto__: null
};
const documentSandboxRegistryCache$LWS = shared$LWS.toSafeWeakMap(new shared$LWS.WeakMapCtor([[sharedDom$LWS.rootDocument, rootSandboxRegistry$LWS]]));
const opaqueWindowSandboxRegistryCache$LWS = shared$LWS.toSafeWeakMap(new shared$LWS.WeakMapCtor());
function getOpaqueSandboxRegistry$LWS(globalObject$LWS) {
  // Use the `document` as the key because a window object maintains its
  // identity continuity when its location changes and while the
  // non-configurable document property does not.
  let sandboxRegistry$LWS = opaqueWindowSandboxRegistryCache$LWS.get(globalObject$LWS);
  // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false
  if (sandboxRegistry$LWS === undefined) {
    sandboxRegistry$LWS = {
      __proto__: null
    };
    opaqueWindowSandboxRegistryCache$LWS.set(globalObject$LWS, sandboxRegistry$LWS);
  }
  return sandboxRegistry$LWS;
}
function getSandboxRegistry$LWS(document$LWS) {
  // Use the `document` as the key because a window object maintains its
  // identity continuity when its location changes and while the
  // non-configurable document property does not.
  let sandboxRegistry$LWS = documentSandboxRegistryCache$LWS.get(document$LWS);
  if (sandboxRegistry$LWS === undefined) {
    sandboxRegistry$LWS = {
      __proto__: null
    };
    documentSandboxRegistryCache$LWS.set(document$LWS, sandboxRegistry$LWS);
  }
  return sandboxRegistry$LWS;
}
const LightningWebSecurity$LWS = {
  __proto__: null
};
// Flag to allow distortions to be "toggle-able".
const ENABLE_DISTORTION_TOGGLE_SWITCHES$LWS = shared$LWS.LOCKER_UNMINIFIED_FLAG || /* istanbul ignore next */false || /* istanbul ignore next */false;
const distortionFactoryToToggleSwitch$LWS = ENABLE_DISTORTION_TOGGLE_SWITCHES$LWS ? shared$LWS.toSafeWeakMap(new shared$LWS.WeakMapCtor()) : /* istanbul ignore next */null;
const sandboxToDistortionEntryToToggleSwitchRegistry$LWS = ENABLE_DISTORTION_TOGGLE_SWITCHES$LWS ? shared$LWS.toSafeWeakMap(
// The value must be a Map because its entries are iterated over in lws.ts
new shared$LWS.WeakMapCtor()) : /* istanbul ignore next */null;
const sandboxToDisabledDistortionToggleSwitches$LWS = shared$LWS.toSafeMap(new shared$LWS.MapCtor());
function setSandboxDistortionToggleState$LWS(record$LWS, toggleSwitchName$LWS, state$LWS) {
  const disabledDistortionToggleSwitches$LWS = sandboxToDisabledDistortionToggleSwitches$LWS.get(record$LWS);
  if (state$LWS) {
    disabledDistortionToggleSwitches$LWS == null || disabledDistortionToggleSwitches$LWS.delete(toggleSwitchName$LWS);
  } else {
    disabledDistortionToggleSwitches$LWS == null || disabledDistortionToggleSwitches$LWS.add(toggleSwitchName$LWS);
  }
}
function getSandboxDistortionToggleState$LWS(record$LWS, toggleSwitchName$LWS) {
  const disabledDistortionToggleSwitches$LWS = sandboxToDisabledDistortionToggleSwitches$LWS.get(record$LWS);
  // If there are active toggle switches, check for the presense of the specific
  // toggle switch name in question. If the toggle switch name is present, then
  // the distortion is disabled:
  //
  // Distortion is enabled? Return true
  // Distortion is disabled? Return false
  return !disabledDistortionToggleSwitches$LWS.has(toggleSwitchName$LWS);
}
// Will be assigned the composed object value as:
//
// namespaces = {
//      ...ns = {
//          distortions: {
//              ...distortion toggle switch flag: true | false
//          }
//      }
// }
//
// This is created once and only upon the first access of $LWS.namespaces
let namespaces$LWS = null;
// This should only be created in DEBUG/COVERAGE mode
if (ENABLE_DISTORTION_TOGGLE_SWITCHES$LWS) {
  shared$LWS.ReflectDefineProperty(LightningWebSecurity$LWS, 'namespaces', {
    __proto__: null,
    enumerable: true,
    configurable: false,
    get() {
      // Ensure that the above described namespaces object is only createed once.
      if (!namespaces$LWS) {
        namespaces$LWS = {
          __proto__: null
        };
        // Use the current document to get the sandbox registry to derive a list
        // of all sandbox keys corresponding to all created sandboxes.
        const registry$LWS = getSandboxRegistry$LWS(document);
        const sandboxKeys$LWS = shared$LWS.ReflectApply(shared$LWS.ObjectKeys, null, [registry$LWS]);
        // Construct a list of distortion flags (as object accessors) for each sandbox,
        // accessible by sandbox key.
        for (const sandboxKey$LWS of sandboxKeys$LWS) {
          const record$LWS = registry$LWS[sandboxKey$LWS];
          // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
          const distortionToggleSwitchRegistry$LWS = sandboxToDistortionEntryToToggleSwitchRegistry$LWS == null ? void 0 : sandboxToDistortionEntryToToggleSwitchRegistry$LWS.get(record$LWS);
          const seenFlags$LWS = shared$LWS.toSafeSet(new shared$LWS.SetCtor());
          const distortions$LWS = {
            __proto__: null
          };
          namespaces$LWS[sandboxKey$LWS] = {
            __proto__: null,
            distortions: distortions$LWS
          };
          for (const {
            1: flag$LWS
          } of distortionToggleSwitchRegistry$LWS) {
            if (!seenFlags$LWS.has(flag$LWS)) {
              seenFlags$LWS.add(flag$LWS);
              shared$LWS.ReflectDefineProperty(namespaces$LWS[sandboxKey$LWS].distortions, flag$LWS, {
                __proto__: null,
                enumerable: true,
                configurable: false,
                get() {
                  return getSandboxDistortionToggleState$LWS(record$LWS, flag$LWS);
                },
                set(flagValue$LWS) {
                  return setSandboxDistortionToggleState$LWS(record$LWS, flag$LWS, flagValue$LWS);
                }
              });
            }
          }
          shared$LWS.ObjectPreventExtensions(distortions$LWS);
        }
        shared$LWS.ObjectPreventExtensions(namespaces$LWS);
      }
      return namespaces$LWS;
    }
  });
  shared$LWS.ReflectDefineProperty(window, '$LWS', {
    __proto__: null,
    enumerable: false,
    configurable: false,
    writable: false,
    value: LightningWebSecurity$LWS
  });
}
shared$LWS.ObjectFreeze(LightningWebSecurity$LWS);
// If ENABLE_DISTORTION_TOGGLE_SWITCHES = false, this will just be undefined
const $LWS = window.$LWS;
function createDistortionToggleSwitchWrapper$LWS(sandboxKey$LWS, toggleSwitchName$LWS, proxyMaskedFunctionDistortion$LWS, originalValue$LWS) {
  // The distortion function value wrapper is necessary because these switches can only be activated _after_
  // the sandbox is created, which means the distortion registry has already been processed, with redefined
  // descriptors already set. Once that is done, there is no way to affect the behavior of a distortion
  // during runtime without wrapping the distortion function value with a function that side channel communicates
  // with the exposed flags interface.
  // eslint-disable-next-line @typescript-eslint/no-loop-func
  return function (...args$LWS) {
    var _root$LWS$namespaces$LWS;
    const {
      $LWS: root$LWS
    } = sharedDom$LWS.rootWindow;
    // If no toggleSwitchName is defined, then always use the distorted value
    // If a toggleSwitchName exists and the corresponding flag in this sandbox
    // has been set to false, then the distortion is toggled off and we need to
    // use the undistorted value
    let useDistortedValue$LWS = root$LWS == null || (_root$LWS$namespaces$LWS = root$LWS.namespaces) == null || (_root$LWS$namespaces$LWS = _root$LWS$namespaces$LWS[sandboxKey$LWS]) == null ? void 0 : _root$LWS$namespaces$LWS.distortions[toggleSwitchName$LWS];
    // If there is a toggleSwitchName, but there is currently no
    // boolean value for that toggleSwitchName, then use the distorted value.
    if (useDistortedValue$LWS === undefined) {
      useDistortedValue$LWS = true;
    }
    const constructOrApplyTarget$LWS = useDistortedValue$LWS ? proxyMaskedFunctionDistortion$LWS : originalValue$LWS;
    if (new.target) {
      return shared$LWS.ReflectConstruct(constructOrApplyTarget$LWS, args$LWS, new.target);
    }
    return shared$LWS.ReflectApply(constructOrApplyTarget$LWS, this, args$LWS);
  };
}
const distortionFactoriesCache$LWS = shared$LWS.toSafeWeakMap(new shared$LWS.WeakMapCtor());
const opaqueWindowPostMessageDistortionFactoryCache$LWS = shared$LWS.toSafeWeakMap(new shared$LWS.WeakMapCtor());
// WebKit based browsers have a bug that prematurely removes distortion entries
// from the distortions weak map.
const SUPPORTS_DISTORTIONS_WEAK_MAP$LWS = !sharedDom$LWS.IS_WEBKIT_BROWSER;
function createDistortionEntries$LWS(record$LWS, factories$LWS) {
  const distortionEntryToToggleSwitch$LWS = shared$LWS.toSafeMap(new shared$LWS.MapCtor());
  const entries$LWS = [];
  for (let i$LWS = 0, {
      length: length$LWS
    } = factories$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const factory$LWS = factories$LWS[i$LWS];
    const entry$LWS = factory$LWS(record$LWS);
    if (entry$LWS) {
      const {
        0: originalValue$LWS,
        1: distortedValue$LWS
      } = entry$LWS;
      if (typeof originalValue$LWS === 'function') {
        const proxyMaskedFunctionDistortion$LWS = proxyMaskFunctionDistortion$LWS(record$LWS, factory$LWS, distortedValue$LWS, originalValue$LWS);
        const toggleSwitchName$LWS = ENABLE_DISTORTION_TOGGLE_SWITCHES$LWS && ( /* istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator */distortionFactoryToToggleSwitch$LWS == null ? void 0 : distortionFactoryToToggleSwitch$LWS.get(factory$LWS));
        let distortionToggleSwitchWrapperOrProxyMaskedFunction$LWS = proxyMaskedFunctionDistortion$LWS;
        if (ENABLE_DISTORTION_TOGGLE_SWITCHES$LWS && toggleSwitchName$LWS) {
          distortionToggleSwitchWrapperOrProxyMaskedFunction$LWS = createDistortionToggleSwitchWrapper$LWS(record$LWS.key, toggleSwitchName$LWS, proxyMaskedFunctionDistortion$LWS, originalValue$LWS);
          // If the distorted API originated in a window created via window.open or
          // document.open, it may be marked as an unsafe property. If so, we need
          // to transfer the original value's marker to the wrapped toggle switch
          // function to ensure that the distortion itself can find the marker when
          // checking if it needs to be blocked.
          if (originalValue$LWS[sharedDom$LWS.CHILD_WINDOW_BLOCKED_PROPERTY_SYMBOL]) {
            const descriptor$LWS = shared$LWS.ReflectGetOwnPropertyDescriptor(originalValue$LWS, sharedDom$LWS.CHILD_WINDOW_BLOCKED_PROPERTY_SYMBOL);
            shared$LWS.ReflectDefineProperty(distortionToggleSwitchWrapperOrProxyMaskedFunction$LWS, sharedDom$LWS.CHILD_WINDOW_BLOCKED_PROPERTY_SYMBOL, descriptor$LWS);
          }
        }
        entries$LWS[entries$LWS.length] = [originalValue$LWS, toggleSwitchName$LWS ? distortionToggleSwitchWrapperOrProxyMaskedFunction$LWS : proxyMaskedFunctionDistortion$LWS];
      } else {
        // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false
        if (typeof originalValue$LWS === 'object' && originalValue$LWS !== null) {
          // TODO: we may need to make this assigned value a proxy when ENABLE_DISTORTION_TOGGLE_SWITCHES is true,
          // allowing us to change which value is provided for the distortion.
          entries$LWS[entries$LWS.length] = entry$LWS;
        }
      }
      if (ENABLE_DISTORTION_TOGGLE_SWITCHES$LWS) {
        /* istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator */
        const toggleSwitchName$LWS = distortionFactoryToToggleSwitch$LWS == null ? void 0 : distortionFactoryToToggleSwitch$LWS.get(factory$LWS);
        if (toggleSwitchName$LWS) {
          // Map the just added distortion entry to this toggle switch name
          distortionEntryToToggleSwitch$LWS.set(entries$LWS[entries$LWS.length - 1], toggleSwitchName$LWS);
        }
      }
    }
  }
  if (ENABLE_DISTORTION_TOGGLE_SWITCHES$LWS) {
    sandboxToDistortionEntryToToggleSwitchRegistry$LWS == null || sandboxToDistortionEntryToToggleSwitchRegistry$LWS.set(record$LWS, distortionEntryToToggleSwitch$LWS);
    sandboxToDisabledDistortionToggleSwitches$LWS.set(record$LWS, shared$LWS.toSafeSet(new shared$LWS.SetCtor()));
  }
  return entries$LWS;
}
function createDistortionMap$LWS(entries$LWS) {
  return SUPPORTS_DISTORTIONS_WEAK_MAP$LWS ? shared$LWS.toSafeWeakMap(new shared$LWS.WeakMapCtor(entries$LWS)) :
  // istanbul ignore next: this code is not reachable in the coverage run.
  shared$LWS.toSafeMap(new shared$LWS.MapCtor(entries$LWS));
}
function getDistortionFactories$LWS(record$LWS) {
  const {
    document: document$LWS,
    globalObject: globalObject$LWS,
    type: type$LWS
  } = record$LWS;
  let factories$LWS = distortionFactoriesCache$LWS.get(document$LWS);
  if (factories$LWS) {
    return factories$LWS;
  }
  const {
    Document: Document$LWS,
    Element: Element$LWS,
    Event: Event$LWS,
    HTMLElement: HTMLElement$LWS,
    HTMLIFrameElement: HTMLIFrameElement$LWS,
    HTMLScriptElement: HTMLScriptElement$LWS,
    SVGElement: SVGElement$LWS,
    UIEvent: UIEvent$LWS,
    XSLTProcessor: XSLTProcessor$LWS
  } = globalObject$LWS;
  const initializers$LWS = type$LWS === 1 /* SandboxType.Internal */ ?
  // instanbul ignore next: coverage is collected on the external sandbox test run
  shared$LWS.ArrayConcat(distortion$LWS.internalDistortionFactoryInitializers, distortion$LWS.internalKeyedDistortionFactoryInitializers) : shared$LWS.ArrayConcat(distortion$LWS.externalDistortionFactoryInitializers, distortion$LWS.externalKeyedDistortionFactoryInitializers);
  distortion$LWS.addBlockedAttributeDistortionFactoryInitializers(HTMLElement$LWS, 'HTMLElement', distortion$LWS.HTMLElementBlockedAttributes, initializers$LWS);
  distortion$LWS.addBlockedAttributeDistortionFactoryInitializers(HTMLIFrameElement$LWS, 'HTMLIFrameElement', distortion$LWS.HTMLIFrameElementBlockedAttributes, initializers$LWS);
  distortion$LWS.addBlockedAttributeDistortionFactoryInitializers(HTMLScriptElement$LWS, 'HTMLScriptElement', distortion$LWS.HTMLScriptElementBlockedAttributes, initializers$LWS);
  distortion$LWS.addBlockedAttributeDistortionFactoryInitializers(SVGElement$LWS, 'SVGElement', distortion$LWS.SVGElementBlockedAttributes, initializers$LWS);
  distortion$LWS.addBlockedPropertyDistortionFactoryInitializers(record$LWS, DataTransfer.prototype, distortion$LWS.DataTransferBlockedProperties, initializers$LWS);
  distortion$LWS.addBlockedPropertyDistortionFactoryInitializers(record$LWS, Document$LWS.prototype, distortion$LWS.DocumentBlockedProperties, initializers$LWS);
  distortion$LWS.addBlockedPropertyDistortionFactoryInitializers(record$LWS, Element$LWS.prototype, distortion$LWS.ElementBlockedProperties, initializers$LWS);
  distortion$LWS.addBlockedPropertyDistortionFactoryInitializers(record$LWS, Event$LWS.prototype, distortion$LWS.EventBlockedProperties, initializers$LWS);
  distortion$LWS.addBlockedPropertyDistortionFactoryInitializers(record$LWS, HTMLElement$LWS.prototype, distortion$LWS.HTMLElementBlockedProperties, initializers$LWS);
  distortion$LWS.addBlockedPropertyDistortionFactoryInitializers(record$LWS, HTMLIFrameElement$LWS.prototype, distortion$LWS.HTMLIFrameElementBlockedProperties, initializers$LWS);
  distortion$LWS.addBlockedPropertyDistortionFactoryInitializers(record$LWS, HTMLEmbedElement.prototype, distortion$LWS.HTMLEmbedElementBlockedProperties, initializers$LWS);
  distortion$LWS.addBlockedPropertyDistortionFactoryInitializers(record$LWS, HTMLObjectElement.prototype, distortion$LWS.HTMLObjectElementBlockedProperties, initializers$LWS);
  distortion$LWS.addBlockedPropertyDistortionFactoryInitializers(record$LWS, HTMLScriptElement$LWS.prototype, distortion$LWS.HTMLScriptElementBlockedProperties, initializers$LWS);
  distortion$LWS.addBlockedPropertyDistortionFactoryInitializers(record$LWS, SVGElement$LWS.prototype, distortion$LWS.SVGElementBlockedProperties, initializers$LWS);
  distortion$LWS.addBlockedPropertyDistortionFactoryInitializers(record$LWS, UIEvent$LWS.prototype, distortion$LWS.UIEventBlockedProperties, initializers$LWS);
  distortion$LWS.addBlockedPropertyDistortionFactoryInitializers(record$LWS, globalObject$LWS, distortion$LWS.WindowBlockedProperties, initializers$LWS);
  // istanbul ignore else: this is a safety precaution that is unreachable via tests
  if (typeof XSLTProcessor$LWS === 'function') {
    distortion$LWS.addBlockedPropertyDistortionFactoryInitializers(record$LWS, XSLTProcessor$LWS.prototype, distortion$LWS.XSLTProcessorBlockedProperties, initializers$LWS);
  }
  distortion$LWS.patchGlobalObject(globalObject$LWS, document$LWS);
  // Reuse the `initializers` array as the `factories` array.
  factories$LWS = initializers$LWS;
  for (let i$LWS = 0, {
      length: length$LWS
    } = factories$LWS; i$LWS < length$LWS; i$LWS += 1) {
    let toggleSwitchName$LWS;
    // Restrict this operation to debug/development/coverage mode only
    if (ENABLE_DISTORTION_TOGGLE_SWITCHES$LWS) {
      toggleSwitchName$LWS = distortion$LWS.distortionFactoryInitializerToggleSwitches.get(initializers$LWS[i$LWS]);
    }
    factories$LWS[i$LWS] = initializers$LWS[i$LWS](record$LWS);
    // Restrict this operation to debug/development/coverage mode only.
    // Since we actually need the _factory_ to when creating the toggle-able
    // distortion wrapper, map the factory provided by the initializer to the
    // toggle switch name.
    if (ENABLE_DISTORTION_TOGGLE_SWITCHES$LWS && toggleSwitchName$LWS) {
      distortionFactoryToToggleSwitch$LWS == null || distortionFactoryToToggleSwitch$LWS.set(factories$LWS[i$LWS], toggleSwitchName$LWS);
    }
  }
  // Finalize attribute distortions last because the attribute registry is
  // populated by the other distortion factories.
  factories$LWS[factories$LWS.length] = distortion$LWS.finalizeAttributeDistortions;
  distortionFactoriesCache$LWS.set(document$LWS, factories$LWS);
  return factories$LWS;
}
function getOpaqueWindowPostMessageDistortionFactory$LWS(record$LWS) {
  const {
    globalObject: globalObject$LWS
  } = record$LWS;
  let opaqueWindowPostMessageDistortionFactory$LWS = opaqueWindowPostMessageDistortionFactoryCache$LWS.get(globalObject$LWS);
  // istanbul ignore next: this is a safety precaution that is unreachable via tests
  if (opaqueWindowPostMessageDistortionFactory$LWS) {
    return opaqueWindowPostMessageDistortionFactory$LWS;
  }
  opaqueWindowPostMessageDistortionFactory$LWS = distortion$LWS.initDistortionWindowPostMessage(record$LWS);
  opaqueWindowPostMessageDistortionFactoryCache$LWS.set(globalObject$LWS, opaqueWindowPostMessageDistortionFactory$LWS);
  return opaqueWindowPostMessageDistortionFactory$LWS;
}
function proxyMaskFunctionDistortion$LWS({
  LOCKER_VERBOSE_INSTRUMENTATION_FLAG: LOCKER_VERBOSE_INSTRUMENTATION_FLAG$LWS,
  instrumentation: instrumentation$LWS,
  key: sandboxKey$LWS
}, distortionFactory$LWS, distortionFunc$LWS, maskFunc$LWS) {
  return shared$LWS.maskFunction(distortionFunc$LWS, maskFunc$LWS, {
    apply: function (target$LWS, thisArg$LWS, args$LWS) {
      const activity$LWS = undefined;
      try {
        return shared$LWS.ReflectApply(target$LWS, thisArg$LWS, args$LWS);
      } catch (error) {
        // istanbul ignore next: instrumentation is not tested
        activity$LWS == null || activity$LWS.error({
          sandboxKey: sandboxKey$LWS,
          error
        });
        // istanbul ignore next: instrumentation is not tested
        activity$LWS == null || activity$LWS.stop();
        throw error;
      } finally {
        // istanbul ignore next: instrumentation is not tested
        activity$LWS == null || activity$LWS.stop();
      }
    },
    construct: function (target$LWS, args$LWS, newTarget$LWS) {
      const activity$LWS = undefined;
      try {
        return shared$LWS.ReflectConstruct(target$LWS, args$LWS, newTarget$LWS);
      } catch (error) {
        // istanbul ignore next: instrumentation is not tested
        activity$LWS == null || activity$LWS.error({
          sandboxKey: sandboxKey$LWS,
          error
        });
        // istanbul ignore next: instrumentation is not tested
        activity$LWS == null || activity$LWS.stop();
        throw error;
      } finally {
        // istanbul ignore next: instrumentation is not tested
        activity$LWS == null || activity$LWS.stop();
      }
    }
  });
}
let lockerEvalContextValue$LWS;
let lockerEvalHelpersValue$LWS;
function clearEvalContext$LWS() {
  const evalContext$LWS = lockerEvalContextValue$LWS;
  lockerEvalContextValue$LWS = undefined;
  return evalContext$LWS;
}
function clearEvalHelpers$LWS() {
  const evalHelpers$LWS = lockerEvalHelpersValue$LWS;
  lockerEvalHelpersValue$LWS = undefined;
  return evalHelpers$LWS;
}
function setEvalContext$LWS(evalContext$LWS) {
  lockerEvalContextValue$LWS = evalContext$LWS;
}
function setEvalHelpers$LWS(evalHelpers$LWS) {
  lockerEvalHelpersValue$LWS = evalHelpers$LWS;
}
const CORE_SANDBOX_KEY$LWS = 'lws-core-sandbox';
const DEFAULT_ENDOWMENTS_DESCRIPTOR_MAP$LWS = {
  [shared$LWS.SANDBOX_EVAL_CONTEXT_NAME]: {
    __proto__: null,
    get() {
      return clearEvalContext$LWS();
    }
  },
  [shared$LWS.SANDBOX_EVAL_HELPERS_NAME]: {
    __proto__: null,
    get() {
      return clearEvalHelpers$LWS();
    }
  }
};
const EMPTY_DISTORTIONS_MAP$LWS = createDistortionMap$LWS();
const EMPTY_OBJECT$LWS = {};
const ROOT_UNCOMPILED_CONTEXT$LWS = {
  [shared$LWS.UNCOMPILED_LOCATION_NAME]: sharedDom$LWS.rootWindowLocation,
  [shared$LWS.UNCOMPILED_TOP_NAME]: sharedDom$LWS.rootWindowTop,
  // The following context entries are explicitly added because the
  // UNCOMPILED_*_NAME entries will only be added to the contextNames
  // via transforms when the fully qualified member expression is detected
  // in the code, eg. window.location, or window.top.
  // See complete explanation in packages/@locker/shared-dom/src/source-transformations.ts.
  location: sharedDom$LWS.rootWindowLocation,
  top: sharedDom$LWS.rootWindowTop
};
const {
  apply: ReflectApply$LWS,
  defineProperty: ReflectDefineProperty$LWS,
  deleteProperty: ReflectDeleteProperty$LWS,
  getPrototypeOf: ReflectGetPrototypeOf$LWS,
  ownKeys: ReflectOwnKeys$LWS,
  setPrototypeOf: ReflectSetPrototypeOf$LWS
} = Reflect;
const ObjectCtor$LWS = Object;
const {
  assign: ObjectAssign$LWS,
  freeze: ObjectFreeze$LWS,
  keys: ObjectKeys$LWS,
  prototype: ObjectProto$LWS
} = ObjectCtor$LWS;
const {
  hasOwn: OriginalObjectHasOwn$LWS
} = ObjectCtor$LWS;
const {
  __lookupGetter__: ObjectProtoLookupGetter$LWS,
  __lookupSetter__: ObjectProtoLookupSetter$LWS,
  hasOwnProperty: ObjectProtoHasOwnProperty$LWS
} = ObjectProto$LWS;
const ObjectHasOwn$LWS = typeof OriginalObjectHasOwn$LWS === 'function' ? OriginalObjectHasOwn$LWS : /* istanbul ignore next: currently unreachable via tests */function ObjectHasOwn$LWS(object$LWS, key$LWS) {
  return ReflectApply$LWS(ObjectProtoHasOwnProperty$LWS, object$LWS, [key$LWS]);
};
const {
  toString: ObjectProtoToString$LWS
} = ObjectProto$LWS;
function isObject$LWS(value$LWS) {
  return typeof value$LWS === 'object' && value$LWS !== null;
}
function ObjectLookupOwnGetter$LWS(object$LWS, key$LWS) {
  return object$LWS === null || object$LWS === undefined || !ObjectHasOwn$LWS(object$LWS, key$LWS) ? undefined : ReflectApply$LWS(ObjectProtoLookupGetter$LWS, object$LWS, [key$LWS]);
}
const SymbolCtor$LWS = Symbol;
const {
  for: SymbolFor$LWS,
  iterator: SymbolIterator$LWS,
  toStringTag: SymbolToStringTag$LWS,
  unscopables: SymbolUnscopables$LWS
} = SymbolCtor$LWS;
const ArrayCtor$LWS = Array;
const {
  prototype: ArrayProto$LWS
} = ArrayCtor$LWS;
const {
  at: ArrayProtoAt$LWS,
  concat: ArrayProtoConcat$LWS,
  copyWithin: ArrayProtoCopyWithin$LWS,
  entries: ArrayProtoEntries$LWS,
  every: ArrayProtoEvery$LWS,
  fill: ArrayProtoFill$LWS,
  findIndex: ArrayProtoFindIndex$LWS,
  flat: ArrayProtoFlat$LWS,
  flatMap: ArrayProtoFlatMap$LWS,
  forEach: ArrayProtoForEach$LWS,
  join: ArrayProtoJoin$LWS,
  keys: ArrayProtoKeys$LWS,
  lastIndexOf: ArrayProtoLastIndexOf$LWS,
  pop: ArrayProtoPop$LWS,
  reduce: ArrayProtoReduce$LWS,
  reduceRight: ArrayProtoReduceRight$LWS,
  reverse: ArrayProtoReverse$LWS,
  slice: ArrayProtoSlice$LWS,
  some: ArrayProtoSome$LWS,
  toLocaleString: ArrayProtoToLocaleString$LWS,
  toString: ArrayProtoToString$LWS,
  values: ArrayProtoValues$LWS,
  [SymbolIterator$LWS]: ArrayProtoSymbolIterator$LWS
} = ArrayProto$LWS;
const ArrayUnscopables$LWS = ObjectFreeze$LWS(ObjectAssign$LWS({
  __proto__: null
}, ArrayProto$LWS[SymbolUnscopables$LWS]));
const {
  filter: ArrayProtoFilter$LWS,
  find: ArrayProtoFind$LWS,
  includes: ArrayProtoIncludes$LWS,
  indexOf: ArrayProtoIndexOf$LWS,
  map: ArrayProtoMap$LWS,
  push: ArrayProtoPush$LWS,
  shift: ArrayProtoShift$LWS,
  splice: ArrayProtoSplice$LWS,
  sort: ArrayProtoSort$LWS,
  unshift: ArrayProtoUnshift$LWS
} = ArrayProto$LWS;
const {
  isArray: ArrayIsArray$LWS
} = ArrayCtor$LWS;
function toSafeArray$LWS(array$LWS) {
  ReflectSetPrototypeOf$LWS(array$LWS, null);
  array$LWS.at = ArrayProtoAt$LWS;
  array$LWS.concat = ArrayProtoConcat$LWS;
  // *** DO NOT SET THE ARRAY CONSTRUCTOR PROPERTY ***
  // https://bugs.chromium.org/p/v8/issues/detail?id=13202
  // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/lookup.cc;l=196-215?q=IsArraySpeciesLookupChainIntact
  //
  // In V8 setting the constructor property of an array, promise, regexp, or
  // typed array triggers a de-opt because it could change an instance's
  // @@species. This de-opt affects at least `Array#splice` and occurs even
  // if the prototype of the array is change or nulled beforehand. Further,
  // the de-opt persists after a page refresh. It is not until navigating to
  // a different page that the performance of `Array#splice` is restored.
  array$LWS.copyWithin = ArrayProtoCopyWithin$LWS;
  array$LWS.entries = ArrayProtoEntries$LWS;
  array$LWS.every = ArrayProtoEvery$LWS;
  array$LWS.fill = ArrayProtoFill$LWS;
  array$LWS.filter = ArrayProtoFilter$LWS;
  array$LWS.find = ArrayProtoFind$LWS;
  array$LWS.findIndex = ArrayProtoFindIndex$LWS;
  array$LWS.flat = ArrayProtoFlat$LWS;
  array$LWS.flatMap = ArrayProtoFlatMap$LWS;
  array$LWS.forEach = ArrayProtoForEach$LWS;
  array$LWS.includes = ArrayProtoIncludes$LWS;
  array$LWS.indexOf = ArrayProtoIndexOf$LWS;
  array$LWS.join = ArrayProtoJoin$LWS;
  array$LWS.keys = ArrayProtoKeys$LWS;
  array$LWS.lastIndexOf = ArrayProtoLastIndexOf$LWS;
  array$LWS.map = ArrayProtoMap$LWS;
  array$LWS.pop = ArrayProtoPop$LWS;
  array$LWS.push = ArrayProtoPush$LWS;
  array$LWS.reduce = ArrayProtoReduce$LWS;
  array$LWS.reduceRight = ArrayProtoReduceRight$LWS;
  array$LWS.reverse = ArrayProtoReverse$LWS;
  array$LWS.shift = ArrayProtoShift$LWS;
  array$LWS.slice = ArrayProtoSlice$LWS;
  array$LWS.some = ArrayProtoSome$LWS;
  array$LWS.sort = ArrayProtoSort$LWS;
  array$LWS.splice = ArrayProtoSplice$LWS;
  array$LWS.toLocaleString = ArrayProtoToLocaleString$LWS;
  array$LWS.toString = ArrayProtoToString$LWS;
  array$LWS.unshift = ArrayProtoUnshift$LWS;
  array$LWS.values = ArrayProtoValues$LWS;
  array$LWS[SymbolIterator$LWS] = ArrayProtoSymbolIterator$LWS;
  array$LWS[SymbolUnscopables$LWS] = ArrayUnscopables$LWS;
  ReflectSetPrototypeOf$LWS(array$LWS, ArrayProto$LWS);
  return array$LWS;
}
ObjectLookupOwnGetter$LWS(ArrayBuffer.prototype, 'byteLength');
// This package is bundled by third-parties that have their own build time
// replacement logic. Instead of customizing each build system to be aware
// of this package we implement a two phase debug mode by performing small
// runtime checks to determine phase one, our code is unminified, and
// phase two, the user opted-in to custom devtools formatters. Phase one
// is used for light weight initialization time debug while phase two is
// reserved for post initialization runtime
const LOCKER_UNMINIFIED_FLAG$LWS =
// eslint-disable-next-line @typescript-eslint/naming-convention
/* istanbul ignore next */
`${function LOCKER_UNMINIFIED_FLAG$LWS() {
  return LOCKER_UNMINIFIED_FLAG$LWS.name;
}()}`.includes('LOCKER_UNMINIFIED_FLAG');
// Character constants.
const CHAR_ELLIPSIS$LWS = '\u2026';
// Near-membrane constants.
const LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS = SymbolFor$LWS('@@lockerNearMembraneSerializedValue');
const LOCKER_NEAR_MEMBRANE_SYMBOL$LWS = SymbolFor$LWS('@@lockerNearMembrane');
SymbolFor$LWS('@@lockerLiveValue');
const TO_STRING_BRAND_BIG_INT$LWS = '[object BigInt]';
const TO_STRING_BRAND_BOOLEAN$LWS = '[object Boolean]';
const TO_STRING_BRAND_NUMBER$LWS = '[object Number]';
const TO_STRING_BRAND_STRING$LWS = '[object String]';
const TO_STRING_BRAND_SYMBOL$LWS = '[object Symbol]';
const MapCtor$LWS = Map;
const {
  prototype: MapProto$LWS
} = MapCtor$LWS;
const {
  clear: MapProtoClear$LWS,
  delete: MapProtoDelete$LWS,
  forEach: MapProtoForEach$LWS,
  get: MapProtoGet$LWS,
  has: MapProtoHas$LWS,
  keys: MapProtoKeys$LWS,
  values: MapProtoValues$LWS,
  [SymbolIterator$LWS]: MapProtoSymbolIterator$LWS,
  [SymbolToStringTag$LWS]: MapProtoSymbolToStringTag$LWS
} = MapProto$LWS;
const {
  entries: MapProtoEntries$LWS,
  set: MapProtoSet$LWS
} = MapProto$LWS;
const MapProtoSizeGetter$LWS = ObjectLookupOwnGetter$LWS(MapProto$LWS, 'size');
function toSafeMap$LWS(map$LWS) {
  ReflectSetPrototypeOf$LWS(map$LWS, null);
  map$LWS.clear = MapProtoClear$LWS;
  map$LWS.delete = MapProtoDelete$LWS;
  map$LWS.entries = MapProtoEntries$LWS;
  map$LWS.forEach = MapProtoForEach$LWS;
  map$LWS.get = MapProtoGet$LWS;
  map$LWS.has = MapProtoHas$LWS;
  map$LWS.keys = MapProtoKeys$LWS;
  map$LWS.set = MapProtoSet$LWS;
  ReflectDefineProperty$LWS(map$LWS, 'size', {
    __proto__: null,
    configurable: true,
    enumerable: true,
    get: MapProtoSizeGetter$LWS,
    set: undefined
  });
  map$LWS.values = MapProtoValues$LWS;
  map$LWS[SymbolIterator$LWS] = MapProtoSymbolIterator$LWS;
  map$LWS[SymbolToStringTag$LWS] = MapProtoSymbolToStringTag$LWS;
  ReflectSetPrototypeOf$LWS(map$LWS, MapProto$LWS);
  return map$LWS;
}
const NumberCtor$LWS = Number;
const {
  isFinite: NumberIsFinite$LWS,
  isInteger: NumberIsInteger$LWS,
  isNaN: NumberIsNaN$LWS
} = NumberCtor$LWS;
const RegExpCtor$LWS = RegExp;
const {
  prototype: RegExpProto$LWS
} = RegExpCtor$LWS;
const {
  test: RegExpProtoTest$LWS
} = RegExpProto$LWS;
ObjectLookupOwnGetter$LWS(RegExpProto$LWS, 'source');
const SetCtor$LWS = Set;
const {
  prototype: SetProto$LWS
} = SetCtor$LWS;
const {
  add: SetProtoAdd$LWS,
  has: SetProtoHas$LWS,
  values: SetProtoValues$LWS
} = SetProto$LWS;
ObjectLookupOwnGetter$LWS(SetProto$LWS, 'size');
const StringCtor$LWS = String;
const {
  prototype: StringProto$LWS
} = StringCtor$LWS;
const {
  slice: StringProtoSlice$LWS,
  valueOf: StringProtoValueOf$LWS
} = StringProto$LWS;
const WeakMapCtor$LWS = WeakMap;
const {
  prototype: WeakMapProto$LWS
} = WeakMapCtor$LWS;
const {
  has: WeakMapProtoHas$LWS
} = WeakMapProto$LWS;
const {
  delete: WeakMapProtoDelete$LWS,
  get: WeakMapProtoGet$LWS,
  set: WeakMapProtoSet$LWS,
  [SymbolToStringTag$LWS]: WeakMapProtoSymbolToStringTag$LWS
} = WeakMapProto$LWS;
function toSafeWeakMap$LWS(weakMap$LWS) {
  ReflectSetPrototypeOf$LWS(weakMap$LWS, null);
  weakMap$LWS.delete = WeakMapProtoDelete$LWS;
  weakMap$LWS.get = WeakMapProtoGet$LWS;
  weakMap$LWS.has = WeakMapProtoHas$LWS;
  weakMap$LWS.set = WeakMapProtoSet$LWS;
  weakMap$LWS[SymbolToStringTag$LWS] = WeakMapProtoSymbolToStringTag$LWS;
  ReflectSetPrototypeOf$LWS(weakMap$LWS, WeakMapProto$LWS);
  return weakMap$LWS;
}
const WeakSetCtor$LWS = WeakSet;
const {
  prototype: WeakSetProto$LWS
} = WeakSetCtor$LWS;
const {
  has: WeakSetProtoHas$LWS
} = WeakSetProto$LWS;
const {
  add: WeakSetProtoAdd$LWS,
  delete: WeakSetProtoDelete$LWS,
  [SymbolToStringTag$LWS]: WeakSetProtoSymbolToStringTag$LWS
} = WeakSetProto$LWS;
function toSafeWeakSet$LWS(weakSet$LWS) {
  ReflectSetPrototypeOf$LWS(weakSet$LWS, null);
  weakSet$LWS.add = WeakSetProtoAdd$LWS;
  weakSet$LWS.delete = WeakSetProtoDelete$LWS;
  weakSet$LWS.has = WeakSetProtoHas$LWS;
  weakSet$LWS[SymbolToStringTag$LWS] = WeakSetProtoSymbolToStringTag$LWS;
  ReflectSetPrototypeOf$LWS(weakSet$LWS, WeakSetProto$LWS);
  return weakSet$LWS;
}
// Used by '@locker/near-membrane-dom'.
const {
  stringify: JSONStringify$LWS
} = JSON;
function getNearMembraneProxySerializedValue$LWS(object$LWS) {
  if (typeof object$LWS === 'object' && object$LWS !== null || typeof object$LWS === 'function') {
    // To extract the serialized value of a blue near-membrane proxy we must
    // perform a two step handshake. First, we trigger the "has" trap for
    // the `LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL` property which
    // must report `false`. Second, we trigger the "get" trap to return the
    // serialized value.
    return LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS in object$LWS ? undefined : object$LWS[LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS];
  }
  return undefined;
}
function isNearMembraneProxy$LWS(value$LWS) {
  if (typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function') {
    // To extract the flag value of a blue near-membrane proxy we must
    // perform a two step handshake. First, we trigger the "has" trap for
    // the `LOCKER_NEAR_MEMBRANE_SYMBOL` property which must report `false`.
    // Second, we trigger the "get" trap to return the flag value.
    return !(LOCKER_NEAR_MEMBRANE_SYMBOL$LWS in value$LWS) && value$LWS[LOCKER_NEAR_MEMBRANE_SYMBOL$LWS] === true;
  }
  return false;
}
toSafeMap$LWS(new MapCtor$LWS());
const ErrorCtor$LWS = Error;
const TypeErrorCtor$LWS = TypeError;
function noop$LWS() {
  // No operation performed.
}

// Used by '@locker/near-membrane-dom'.
const {
  min: MathMin$LWS
} = Math;
const rootWindow$LWS = window;
const {
  // We don't cherry-pick the 'userAgent' property from `navigator` here
  // to avoid triggering its getter.
  navigator: navigator$LWS,
  navigator: {
    userAgentData: userAgentData$LWS
  }
} = rootWindow$LWS;
// The user-agent client hints API is experimental and subject to change.
// https://caniuse.com/mdn-api_navigator_useragentdata
// istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
const brands$LWS = userAgentData$LWS == null ? void 0 : userAgentData$LWS.brands;
// Note: Chromium identifies itself as Chrome in its user-agent string.
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent
const chromiumUserAgentRegExp$LWS = / (?:Headless)?Chrome\/\d+/;
let userAgent$LWS;
function getUserAgent$LWS() {
  if (userAgent$LWS === undefined) {
    userAgent$LWS = navigator$LWS.userAgent;
  }
  return userAgent$LWS;
}
const IS_CHROMIUM_BROWSER$LWS =
// While experimental, `navigator.userAgentData.brands` may be defined as an
// empty array in headless Chromium based browsers.
ArrayIsArray$LWS(brands$LWS) && brands$LWS.length ?
// Use user-agent client hints API if available to avoid deprecation
// warnings.
// https://developer.mozilla.org/en-US/docs/Web/API/User-Agent_Client_Hints_API
// istanbul ignore next: this code is not reachable in the coverage run.
ReflectApply$LWS(ArrayProtoFind$LWS, brands$LWS, [
// prettier-ignore
item$LWS => (item$LWS == null ? void 0 : item$LWS.brand) === 'Chromium']) !== undefined :
// Fallback to a standard user-agent string sniff.
ReflectApply$LWS(RegExpProtoTest$LWS, chromiumUserAgentRegExp$LWS, [getUserAgent$LWS()]);
const IS_OLD_CHROMIUM_BROWSER$LWS = IS_CHROMIUM_BROWSER$LWS &&
// Chromium added support for `navigator.userAgentData` in v90.
// https://caniuse.com/mdn-api_navigator_useragentdata
userAgentData$LWS === undefined;
const {
  prototype: DocumentProto$LWS
} = Document;
const {
  close: DocumentProtoClose$LWS,
  createElement: DocumentProtoCreateElement$LWS,
  open: DocumentProtoOpen$LWS
} = DocumentProto$LWS;
const DocumentProtoBodyGetter$LWS = ObjectLookupOwnGetter$LWS(DocumentProto$LWS, 'body');

// The DOMException constructor was exposed in Edge 12 but wasn't invocable
// until Edge 79. As long as this is used for instanceof checks it should be fine.
// https://developer.mozilla.org/en-US/docs/Web/API/DOMException#browser_compatibility
const DOMExceptionCtor$LWS = DOMException;
ObjectLookupOwnGetter$LWS(DOMExceptionCtor$LWS.prototype, 'code');
const {
  remove: ElementProtoRemove$LWS,
  setAttribute: ElementProtoSetAttribute$LWS
} = Element.prototype;
const HTMLElementProtoStyleGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLElement.prototype, 'style');
const HTMLIFrameElementProtoContentWindowGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLIFrameElement.prototype, 'contentWindow');
const {
  prototype: NodeProto$LWS
} = Node;
const {
  appendChild: NodeProtoAppendChild$LWS
} = NodeProto$LWS;
const NodeProtoLastChildGetter$LWS = ObjectLookupOwnGetter$LWS(NodeProto$LWS, 'lastChild');

// This package is bundled by third-parties that have their own build time
// replacement logic. Instead of customizing each build system to be aware
// of this package we implement a two phase debug mode by performing small
// runtime checks to determine phase one, our code is unminified, and
// phase two, the user opted-in to custom devtools formatters. Phase one
// is used for light weight initialization time debug while phase two is
// reserved for post initialization runtime.
// istanbul ignore else: not avoidable via tests
if (LOCKER_UNMINIFIED_FLAG$LWS) {
  // We passed the phase one gate so we know our code is unminified and we can
  // install Locker's custom devtools formatter.
  let lockerDebugModeSymbolFlag$LWS = true;
  const LOCKER_DEBUG_MODE_SYMBOL$LWS = SymbolFor$LWS('@@lockerDebugMode');
  const MAX_ARRAY_DISPLAY$LWS = 100;
  const MAX_OBJECT_DISPLAY$LWS = 5;
  const MAX_STRING_DISPLAY$LWS = 100;
  const MID_STRING_DISPLAY$LWS = MAX_STRING_DISPLAY$LWS / 2;
  const headerCSSText$LWS = 'display: inline-block; margin-bottom: 3px; margin-left: -3px; word-break: break-all; word-wrap: wrap;';
  const bodyItemStyleObject$LWS = {
    style: 'margin-left:15px; margin-bottom: 3px;'
  };
  const bodyStyleObject$LWS = {
    style: 'display: inline-block; margin-left:12px; word-break: break-all; word-wrap: wrap;'
  };
  const keyEnumerableStringStyleObject$LWS = {
    style: 'color: #9d288c; font-weight: bold'
  };
  const keyNonEnumerableOrSymbolStyleObject$LWS = {
    style: 'color: #b17ab0'
  };
  const primitiveBlueColorStyleObject$LWS = {
    style: 'color: #16239f'
  };
  const primitiveGreenColorStyleObject$LWS = {
    style: 'color: #236d25'
  };
  const primitiveGreyColorStyleObject$LWS = {
    style: 'color: #606367'
  };
  const primitiveOrangeColorStyleObject$LWS = {
    style: 'color: #b82619'
  };
  // istanbul ignore next: currently unreachable via tests
  const formatValue$LWS = function formatValue$LWS(value$LWS) {
    if (value$LWS === null || value$LWS === undefined) {
      return ['span', primitiveGreyColorStyleObject$LWS, `${value$LWS}`];
    }
    if (typeof value$LWS === 'boolean') {
      return ['span', primitiveBlueColorStyleObject$LWS, value$LWS];
    }
    if (typeof value$LWS === 'number') {
      return NumberIsFinite$LWS(value$LWS) ? ['span', primitiveBlueColorStyleObject$LWS, value$LWS] : ['span', primitiveBlueColorStyleObject$LWS, `${value$LWS >= 0 ? '' : '-'}Infinity`];
    }
    if (typeof value$LWS === 'bigint') {
      return ['span', primitiveGreenColorStyleObject$LWS, `${value$LWS}n`];
    }
    if (typeof value$LWS === 'string') {
      let string$LWS = value$LWS;
      const {
        length: length$LWS
      } = string$LWS;
      if (length$LWS > MAX_STRING_DISPLAY$LWS) {
        const firstChunk$LWS = ReflectApply$LWS(StringProtoSlice$LWS, string$LWS, [0, MID_STRING_DISPLAY$LWS]);
        const lastChunk$LWS = ReflectApply$LWS(StringProtoSlice$LWS, string$LWS, [length$LWS - MID_STRING_DISPLAY$LWS - 1, length$LWS]);
        string$LWS = firstChunk$LWS + CHAR_ELLIPSIS$LWS + lastChunk$LWS;
      }
      // @TODO: Default to using single quotes on main header and double
      // quotes on body.
      return ['span', primitiveOrangeColorStyleObject$LWS, JSONStringify$LWS(string$LWS)];
    }
    if (ArrayIsArray$LWS(value$LWS)) {
      return ['span', {}, `Array(${value$LWS.length})`];
    }
    if (isObject$LWS(value$LWS)) {
      return ['span', {}, `{${CHAR_ELLIPSIS$LWS}}`];
    }
    // Symbol will be coerced to a string.
    return ['span', primitiveOrangeColorStyleObject$LWS, StringCtor$LWS(value$LWS)];
  };
  // istanbul ignore next: currently unreachable via tests
  const formatHeader$LWS = function formatHeader$LWS(object$LWS, config$LWS) {
    const isChildElement$LWS = config$LWS == null ? void 0 : config$LWS.isChildElement;
    const formattedHeader$LWS = [];
    let formattedHeaderOffset$LWS = 0;
    if (isChildElement$LWS) {
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', keyEnumerableStringStyleObject$LWS, config$LWS.childKey];
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, ': '];
    }
    const brand$LWS = ReflectApply$LWS(ObjectProtoToString$LWS, object$LWS, []);
    let keys$LWS = ObjectKeys$LWS(object$LWS);
    if (brand$LWS === TO_STRING_BRAND_SYMBOL$LWS) {
      if (!ReflectApply$LWS(ArrayProtoIncludes$LWS, keys$LWS, ['description'])) {
        ReflectApply$LWS(ArrayProtoUnshift$LWS, keys$LWS, ['description']);
      }
    } else if (brand$LWS === TO_STRING_BRAND_STRING$LWS) {
      const {
        length: length$LWS
      } = object$LWS;
      keys$LWS = ReflectApply$LWS(ArrayProtoFilter$LWS, keys$LWS, [key$LWS => {
        const possibleIndex$LWS = typeof key$LWS === 'string' ? +key$LWS : -1;
        return possibleIndex$LWS < 0 || possibleIndex$LWS >= length$LWS || !NumberIsInteger$LWS(possibleIndex$LWS);
      }]);
    }
    const ownKeysRaw$LWS = ReflectOwnKeys$LWS(object$LWS);
    const ownKeys$LWS = ReflectApply$LWS(ArrayProtoMap$LWS, ownKeysRaw$LWS, [StringCtor$LWS]);
    const {
      length: ownKeysLength$LWS
    } = ownKeys$LWS;
    if (ArrayIsArray$LWS(object$LWS)) {
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, `(${object$LWS.length}) [`];
      for (let i$LWS = 0, length$LWS = MathMin$LWS(ownKeysLength$LWS, MAX_ARRAY_DISPLAY$LWS); i$LWS < length$LWS; i$LWS += 1) {
        const ownKeyRaw$LWS = ownKeysRaw$LWS[i$LWS];
        const ownKey$LWS = ownKeys$LWS[i$LWS];
        const value$LWS = object$LWS[ownKeyRaw$LWS];
        if (ownKey$LWS !== 'length') {
          if (!NumberIsNaN$LWS(NumberCtor$LWS(ownKey$LWS))) {
            formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, i$LWS ? ', ' : ''];
            formattedHeader$LWS[formattedHeaderOffset$LWS++] = formatValue$LWS(value$LWS);
          } else {
            formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, i$LWS ? ', ' : ''];
            formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', primitiveGreyColorStyleObject$LWS, StringCtor$LWS(ownKey$LWS)];
            formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, ': '];
            formattedHeader$LWS[formattedHeaderOffset$LWS++] = formatValue$LWS(value$LWS);
          }
        }
      }
      if (ownKeysLength$LWS > MAX_ARRAY_DISPLAY$LWS) {
        formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', null, ['span', {}, `, ${CHAR_ELLIPSIS$LWS}`]];
      }
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, ']'];
      return formattedHeader$LWS;
    }
    let boxedHeaderEntry$LWS;
    let headerOpening$LWS = '{';
    // eslint-disable-next-line default-case
    switch (brand$LWS) {
      case TO_STRING_BRAND_BIG_INT$LWS:
      case TO_STRING_BRAND_BOOLEAN$LWS:
      case TO_STRING_BRAND_NUMBER$LWS:
      case TO_STRING_BRAND_STRING$LWS:
      case TO_STRING_BRAND_SYMBOL$LWS:
        {
          let colorStyleObject$LWS = primitiveBlueColorStyleObject$LWS;
          if (brand$LWS === TO_STRING_BRAND_BIG_INT$LWS) {
            colorStyleObject$LWS = primitiveGreenColorStyleObject$LWS;
          } else if (brand$LWS === TO_STRING_BRAND_SYMBOL$LWS) {
            colorStyleObject$LWS = primitiveOrangeColorStyleObject$LWS;
          }
          headerOpening$LWS = `${ReflectApply$LWS(StringProtoSlice$LWS, brand$LWS, [8, -1])} {`;
          boxedHeaderEntry$LWS = ['span', colorStyleObject$LWS, `${StringCtor$LWS(getNearMembraneProxySerializedValue$LWS(object$LWS))}`];
          break;
        }
    }
    formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, headerOpening$LWS];
    if (boxedHeaderEntry$LWS) {
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = boxedHeaderEntry$LWS;
      if (ownKeysLength$LWS) {
        formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, ', '];
      }
    }
    for (let i$LWS = 0, length$LWS = MathMin$LWS(ownKeysLength$LWS, MAX_OBJECT_DISPLAY$LWS); i$LWS < length$LWS; i$LWS += 1) {
      const ownKeyRaw$LWS = ownKeysRaw$LWS[i$LWS];
      const ownKey$LWS = ownKeys$LWS[i$LWS];
      const value$LWS = object$LWS[ownKeyRaw$LWS];
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, i$LWS ? ', ' : ''];
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', primitiveGreyColorStyleObject$LWS, ownKey$LWS];
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, ': '];
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = formatValue$LWS(value$LWS);
    }
    if (ownKeysLength$LWS > MAX_OBJECT_DISPLAY$LWS) {
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', null, ['span', {}, `, ${CHAR_ELLIPSIS$LWS}`]];
    }
    formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, '}'];
    return formattedHeader$LWS;
  };
  // istanbul ignore next: currently unreachable via tests
  const formatBody$LWS = function formatBody$LWS(object$LWS) {
    // @TODO: Arrays are broken into groups of 100.
    const ownKeysRaw$LWS = ReflectOwnKeys$LWS(object$LWS);
    const ownKeys$LWS = ReflectApply$LWS(ArrayProtoMap$LWS, ownKeysRaw$LWS, [StringCtor$LWS]);
    // Put 'length' at the end of array.
    const isArray$LWS = ArrayIsArray$LWS(object$LWS);
    if (isArray$LWS) {
      const lengthIndex$LWS = ReflectApply$LWS(ArrayProtoIndexOf$LWS, ownKeys$LWS, ['length']);
      const lengthKeyRaw$LWS = ReflectApply$LWS(ArrayProtoSplice$LWS, ownKeysRaw$LWS, [lengthIndex$LWS, 1])[0];
      ReflectApply$LWS(ArrayProtoPush$LWS, ownKeysRaw$LWS, [lengthKeyRaw$LWS]);
      const lengthKey$LWS = ReflectApply$LWS(ArrayProtoSplice$LWS, ownKeys$LWS, [lengthIndex$LWS, 1])[0];
      ReflectApply$LWS(ArrayProtoPush$LWS, ownKeys$LWS, [lengthKey$LWS]);
    }
    const formattedBody$LWS = [];
    let formattedBodyOffset$LWS = 0;
    for (let i$LWS = 0, {
        length: length$LWS
      } = ownKeys$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const ownKeyRaw$LWS = ownKeysRaw$LWS[i$LWS];
      const ownKey$LWS = ownKeys$LWS[i$LWS];
      const value$LWS = object$LWS[ownKeyRaw$LWS];
      if (isObject$LWS(value$LWS)) {
        formattedBody$LWS[formattedBodyOffset$LWS++] = ['div', {}, ['object', {
          object: value$LWS,
          config: {
            childKey: StringCtor$LWS(ownKey$LWS),
            isChildElement: true
          }
        }]];
      } else {
        let currentKeyStyle$LWS = keyEnumerableStringStyleObject$LWS;
        if (isArray$LWS && ownKey$LWS === 'length') {
          currentKeyStyle$LWS = keyNonEnumerableOrSymbolStyleObject$LWS;
        }
        formattedBody$LWS[formattedBodyOffset$LWS++] = ['div', bodyItemStyleObject$LWS, ['span', currentKeyStyle$LWS, ownKey$LWS], ['span', {}, ': '], formatValue$LWS(value$LWS)];
      }
    }
    return formattedBody$LWS;
  };
  let {
    devtoolsFormatters: devtoolsFormatters$LWS
  } = rootWindow$LWS;
  if (!ArrayIsArray$LWS(devtoolsFormatters$LWS)) {
    devtoolsFormatters$LWS = [];
    ReflectDefineProperty$LWS(rootWindow$LWS, 'devtoolsFormatters', {
      __proto__: null,
      configurable: true,
      value: devtoolsFormatters$LWS,
      writable: true
    });
  }
  // Append our custom formatter to the array of devtools formatters.
  // istanbul ignore next: currently unreachable via tests
  devtoolsFormatters$LWS[devtoolsFormatters$LWS.length] = {
    // istanbul ignore next: currently unreachable via tests
    header(object$LWS, config$LWS) {
      if (lockerDebugModeSymbolFlag$LWS) {
        // We passed the second phase gate so we know that the user has
        // opted-in to custom devtools formatters. Close the gate and
        // define the @@lockerDebugMode symbol on window.
        lockerDebugModeSymbolFlag$LWS = false;
        ReflectDefineProperty$LWS(rootWindow$LWS, LOCKER_DEBUG_MODE_SYMBOL$LWS, {
          __proto__: null,
          configurable: true,
          value: true,
          writable: true
        });
      }
      if (!isNearMembraneProxy$LWS(object$LWS)) {
        return null;
      }
      const headerDiv$LWS = ['div', {
        style: `${headerCSSText$LWS}${config$LWS != null && config$LWS.isChildElement ? '' : 'font-style: italic;'}`
      }];
      ReflectApply$LWS(ArrayProtoPush$LWS, headerDiv$LWS, formatHeader$LWS(object$LWS, config$LWS));
      return ['div', {}, headerDiv$LWS];
    },
    // istanbul ignore next: currently unreachable via tests
    hasBody() {
      return true;
    },
    // istanbul ignore next: currently unreachable via tests
    body(object$LWS) {
      const bodyDiv$LWS = ['div', bodyStyleObject$LWS];
      ReflectApply$LWS(ArrayProtoPush$LWS, bodyDiv$LWS, formatBody$LWS(object$LWS));
      return bodyDiv$LWS;
    }
  };
}

/**
 * This file contains an exportable (portable) function `init()` used to initialize
 * one side of a membrane on any realm. The only prerequisite is the ability to
 * evaluate the sourceText of the `init()` function there. Once evaluated, the
 * function will return a set of values that can be used to wire up the side of
 * the membrane with another existing `init()` function from another realm, in
 * which case they will exchange callable functions that are required to connect
 * the two realms via the membrane.
 *
 * About the mechanics of the membrane, there are few important considerations:
 *
 * 1. Pointers are the way to pass reference to object and functions.
 * 2. A dedicated symbol (LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL) is needed
 *    to represent the absence of a value.
 * 3. The realm that owns the object or function is responsible for projecting
 *    the proxy onto the other side (via callablePushTarget), which returns a
 *    Pointer that can be used by the realm to pass the reference to the same
 *    proxy over and over again.
 * 4. The realm that owns the proxy (after the other side projects it into it)
 *    will hold a Pointer alongside the proxy to signal what original object or
 *    function should the foreign operation operates, it is always the first
 *    argument of the foreign callable for proxies, and the other side can use
 *    it via `selectedTarget!`.
 */
const proxyTargetToLazyPropertyDescriptorStateMap$LWS = toSafeWeakMap$LWS(new WeakMapCtor$LWS());
// istanbul ignore next
function createMembraneMarshall$LWS(globalObject$LWS) {
  var _ref$LWS, _ref2$LWS, _ReflectApply$LWS, _globalThisRef$BigInt$LWS, _globalThisRef$BigUin$LWS;
  /* eslint-disable prefer-object-spread */
  const ArrayCtor$LWS = Array;
  const ArrayBufferCtor$LWS = ArrayBuffer;
  const ErrorCtor$LWS = Error;
  const NumberCtor$LWS = Number;
  const ObjectCtor$LWS = Object;
  const ProxyCtor$LWS = Proxy;
  const ReflectRef$LWS = Reflect;
  const RegExpCtor$LWS = RegExp;
  const StringCtor$LWS = String;
  const SymbolCtor$LWS = Symbol;
  const TypeErrorCtor$LWS = TypeError;
  // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow
  const WeakMapCtor$LWS = WeakMap;
  const WeakSetCtor$LWS = WeakSet;
  const {
    for: SymbolFor$LWS,
    toStringTag: SymbolToStringTag$LWS
  } = SymbolCtor$LWS;
  const {
    // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow
    apply: ReflectApply$LWS,
    construct: ReflectConstruct$LWS,
    defineProperty: ReflectDefineProperty$LWS,
    deleteProperty: ReflectDeleteProperty$LWS,
    get: ReflectGet$LWS,
    getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor$LWS,
    getPrototypeOf: ReflectGetPrototypeOf$LWS,
    has: ReflectHas$LWS,
    isExtensible: ReflectIsExtensible$LWS,
    ownKeys: ReflectOwnKeys$LWS,
    preventExtensions: ReflectPreventExtensions$LWS,
    set: ReflectSet$LWS,
    // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow
    setPrototypeOf: ReflectSetPrototypeOf$LWS
  } = ReflectRef$LWS;
  const {
    assign: ObjectAssign$LWS,
    defineProperties: ObjectDefineProperties$LWS,
    freeze: ObjectFreeze$LWS,
    getOwnPropertyDescriptor: ObjectGetOwnPropertyDescriptor$LWS,
    getOwnPropertyDescriptors: ObjectGetOwnPropertyDescriptors$LWS,
    isFrozen: ObjectIsFrozen$LWS,
    isSealed: ObjectIsSealed$LWS,
    keys: ObjectKeys$LWS,
    prototype: ObjectProto$LWS,
    seal: ObjectSeal$LWS
  } = ObjectCtor$LWS;
  const {
    hasOwnProperty: ObjectProtoHasOwnProperty$LWS,
    propertyIsEnumerable: ObjectProtoPropertyIsEnumerable$LWS,
    toString: ObjectProtoToString$LWS
  } = ObjectProto$LWS;
  const {
    hasOwn: OriginalObjectHasOwn$LWS
  } = ObjectCtor$LWS;
  const {
    __defineGetter__: ObjectProtoDefineGetter$LWS,
    __defineSetter__: ObjectProtoDefineSetter$LWS,
    __lookupGetter__: ObjectProtoLookupGetter$LWS,
    __lookupSetter__: ObjectProtoLookupSetter$LWS
  } = ObjectProto$LWS;
  const ObjectHasOwn$LWS = typeof OriginalObjectHasOwn$LWS === 'function' ? OriginalObjectHasOwn$LWS : (object$LWS, key$LWS) => ReflectApply$LWS(ObjectProtoHasOwnProperty$LWS, object$LWS, [key$LWS]);
  const globalThisRef$LWS = (_ref$LWS = (_ref2$LWS = globalObject$LWS != null ? globalObject$LWS :
  // Support for globalThis was added in Chrome 71.
  // https://caniuse.com/mdn-javascript_builtins_globalthisfor
  typeof globalThis !== 'undefined' ? globalThis : undefined) != null ? _ref2$LWS :
  // However, environments like Android emulators are running Chrome 69.
  // eslint-disable-next-line no-restricted-globals
  typeof self !== 'undefined' ? self : undefined) != null ? _ref$LWS : (
  // See https://mathiasbynens.be/notes/globalthis for more details.
  ReflectDefineProperty$LWS(ObjectProto$LWS, 'globalThis', {
    __proto__: null,
    configurable: true,
    get() {
      ReflectDeleteProperty$LWS(ObjectProto$LWS, 'globalThis');
      // Safari 12 on iOS 12.1 has a `this` of `undefined` so we
      // fallback to `self`.
      // eslint-disable-next-line no-restricted-globals
      return this != null ? this : self;
    }
  }), globalThis);
  const IS_IN_SHADOW_REALM$LWS = typeof globalObject$LWS !== 'object' || globalObject$LWS === null;
  const IS_NOT_IN_SHADOW_REALM$LWS = !IS_IN_SHADOW_REALM$LWS;
  const LOCKER_DEBUG_MODE_SYMBOL$LWS = IS_NOT_IN_SHADOW_REALM$LWS ? SymbolFor$LWS('@@lockerDebugMode') : undefined;
  const LOCKER_IDENTIFIER_MARKER$LWS = '$LWS';
  const LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS = IS_NOT_IN_SHADOW_REALM$LWS ? SymbolFor$LWS('@@lockerNearMembraneSerializedValue') : undefined;
  const LOCKER_NEAR_MEMBRANE_SYMBOL$LWS = IS_NOT_IN_SHADOW_REALM$LWS ? SymbolFor$LWS('@@lockerNearMembrane') : undefined;
  const LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS = SymbolFor$LWS('@@lockerNearMembraneUndefinedValue');
  // The default stack trace limit in Chrome is 10.
  // Set to 20 to account for stack trace filtering.
  const LOCKER_STACK_TRACE_LIMIT$LWS = 20;
  // This package is bundled by third-parties that have their own build time
  // replacement logic. Instead of customizing each build system to be aware
  // of this package we implement a two phase debug mode by performing small
  // runtime checks to determine phase one, our code is unminified, and
  // phase two, the user opted-in to custom devtools formatters. Phase one
  // is used for light weight initialization time debug while phase two is
  // reserved for post initialization runtime.
  // eslint-disable-next-line @typescript-eslint/naming-convention
  const LOCKER_UNMINIFIED_FLAG$LWS = `${function LOCKER_UNMINIFIED_FLAG$LWS() {
    return LOCKER_UNMINIFIED_FLAG$LWS.name;
  }()}`.includes('LOCKER_UNMINIFIED_FLAG');
  // Indicate whether debug support is available.
  const LOCKER_DEBUGGABLE_FLAG$LWS = LOCKER_UNMINIFIED_FLAG$LWS && IS_NOT_IN_SHADOW_REALM$LWS;
  const ERR_ILLEGAL_PROPERTY_ACCESS$LWS = 'Illegal property access.';
  // BigInt is not supported in Safari 13.1.
  // https://caniuse.com/bigint
  const FLAGS_REG_EXP$LWS = IS_IN_SHADOW_REALM$LWS ? /\w*$/ : undefined;
  // Minification safe references to the private `BoundaryProxyHandler`
  // 'apply' and 'construct' trap variant's property names.
  let MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS;
  const SUPPORTS_BIG_INT$LWS = typeof BigInt === 'function';
  const {
    isArray: isArrayOrThrowForRevoked$LWS
  } = ArrayCtor$LWS;
  const {
    includes: ArrayProtoIncludes$LWS,
    indexOf: ArrayProtoIndexOf$LWS,
    slice: ArrayProtoSlice$LWS
  } = ArrayCtor$LWS.prototype;
  const {
    isView: ArrayBufferIsView$LWS
  } = ArrayBufferCtor$LWS;
  const BigIntProtoValueOf$LWS = SUPPORTS_BIG_INT$LWS ? BigInt.prototype.valueOf : undefined;
  const {
    valueOf: BooleanProtoValueOf$LWS
  } = Boolean.prototype;
  const {
    toString: ErrorProtoToString$LWS
  } = ErrorCtor$LWS.prototype;
  const {
    bind: FunctionProtoBind$LWS,
    toString: FunctionProtoToString$LWS
  } = Function.prototype;
  const {
    stringify: JSONStringify$LWS
  } = JSON;
  const {
    isInteger: NumberIsInteger$LWS
  } = NumberCtor$LWS;
  const {
    valueOf: NumberProtoValueOf$LWS
  } = NumberCtor$LWS.prototype;
  const {
    revocable: ProxyRevocable$LWS
  } = ProxyCtor$LWS;
  const {
    prototype: RegExpProto$LWS
  } = RegExpCtor$LWS;
  const {
    exec: RegExpProtoExec$LWS,
    test: RegExpProtoTest$LWS,
    toString: RegExProtoToString$LWS
  } = RegExpProto$LWS;
  // Edge 15 does not support RegExp.prototype.flags.
  // https://caniuse.com/mdn-javascript_builtins_regexp_flags
  const RegExpProtoFlagsGetter$LWS = IS_IN_SHADOW_REALM$LWS ? (_ReflectApply$LWS = ReflectApply$LWS(ObjectProtoLookupGetter$LWS, RegExpProto$LWS, ['flags'])) != null ? _ReflectApply$LWS : function flags$LWS() {
    const string$LWS = ReflectApply$LWS(RegExProtoToString$LWS, this, []);
    return ReflectApply$LWS(RegExpProtoExec$LWS, FLAGS_REG_EXP$LWS, [string$LWS])[0];
  } : undefined;
  const RegExpProtoSourceGetter$LWS = ReflectApply$LWS(ObjectProtoLookupGetter$LWS, RegExpProto$LWS, ['source']);
  const {
    replace: StringProtoReplace$LWS,
    slice: StringProtoSlice$LWS,
    valueOf: StringProtoValueOf$LWS
  } = StringCtor$LWS.prototype;
  const {
    toString: SymbolProtoToString$LWS,
    valueOf: SymbolProtoValueOf$LWS
  } = SymbolCtor$LWS.prototype;
  const BigInt64ArrayProto$LWS = (_globalThisRef$BigInt$LWS = globalThisRef$LWS.BigInt64Array) == null ? void 0 : _globalThisRef$BigInt$LWS.prototype;
  const BigUint64ArrayProto$LWS = (_globalThisRef$BigUin$LWS = globalThisRef$LWS.BigUint64Array) == null ? void 0 : _globalThisRef$BigUin$LWS.prototype;
  const {
    prototype: Float32ArrayProto$LWS
  } = Float32Array;
  const {
    prototype: Float64ArrayProto$LWS
  } = Float64Array;
  const {
    prototype: Int8ArrayProto$LWS
  } = Int8Array;
  const {
    prototype: Int16ArrayProto$LWS
  } = Int16Array;
  const {
    prototype: Int32ArrayProto$LWS
  } = Int32Array;
  const {
    prototype: Uint8ArrayProto$LWS
  } = Uint8Array;
  const {
    prototype: Uint16ArrayProto$LWS
  } = Uint16Array;
  const {
    prototype: Uint32ArrayProto$LWS
  } = Uint32Array;
  // eslint-disable-next-line no-proto
  const TypedArrayProto$LWS = Uint8ArrayProto$LWS.__proto__;
  const TypedArrayProtoLengthGetter$LWS = ReflectApply$LWS(ObjectProtoLookupGetter$LWS, TypedArrayProto$LWS, ['length']);
  const {
    prototype: WeakMapProto$LWS
  } = WeakMapCtor$LWS;
  const {
    delete: WeakMapProtoDelete$LWS,
    has: WeakMapProtoHas$LWS,
    set: WeakMapProtoSet$LWS,
    [SymbolToStringTag$LWS]: WeakMapProtoSymbolToStringTag$LWS
  } = WeakMapProto$LWS;
  const {
    prototype: WeakSetProto$LWS
  } = WeakSetCtor$LWS;
  const {
    add: WeakSetProtoAdd$LWS,
    has: WeakSetProtoHas$LWS,
    delete: WeakSetProtoDelete$LWS,
    [SymbolToStringTag$LWS]: WeakSetProtoSymbolToStringTag$LWS
  } = WeakSetProto$LWS;
  const consoleObject$LWS = IS_NOT_IN_SHADOW_REALM$LWS && typeof console === 'object' && console !== null ? console : undefined;
  const consoleInfo$LWS = consoleObject$LWS == null ? void 0 : consoleObject$LWS.info;
  const localEval$LWS = IS_IN_SHADOW_REALM$LWS ? eval : undefined;
  // Install flags to ensure things are installed once per realm.
  let installedErrorPrepareStackTraceFlag$LWS = false;
  let installedPropertyDescriptorMethodWrappersFlag$LWS = false;
  function alwaysFalse$LWS() {
    return false;
  }
  const installErrorPrepareStackTrace$LWS = LOCKER_UNMINIFIED_FLAG$LWS ? () => {
    if (installedErrorPrepareStackTraceFlag$LWS) {
      return;
    }
    installedErrorPrepareStackTraceFlag$LWS = true;
    // Feature detect the V8 stack trace API.
    // https://v8.dev/docs/stack-trace-api
    const CallSite$LWS = (() => {
      try {
        var _callSites$$LWS;
        ErrorCtor$LWS.prepareStackTrace = (_error$LWS, callSites) => callSites;
        const callSites = new ErrorCtor$LWS().stack;
        ReflectDeleteProperty$LWS(ErrorCtor$LWS, 'prepareStackTrace');
        return isArrayOrThrowForRevoked$LWS(callSites) && callSites.length > 0 ? (_callSites$$LWS = callSites[0]) == null ? void 0 : _callSites$$LWS.constructor : undefined;
        // eslint-disable-next-line no-empty
      } catch (_unused$LWS) {}
      return undefined;
    })();
    if (typeof CallSite$LWS !== 'function') {
      return;
    }
    const {
      getEvalOrigin: CallSiteProtoGetEvalOrigin$LWS,
      getFunctionName: CallSiteProtoGetFunctionName$LWS,
      toString: CallSiteProtoToString$LWS
    } = CallSite$LWS.prototype;
    // A regexp to detect call sites containing LOCKER_IDENTIFIER_MARKER.
    const lockerFunctionNameMarkerRegExp$LWS = new RegExpCtor$LWS(`${
    // Escape regexp special characters in LOCKER_IDENTIFIER_MARKER.
    ReflectApply$LWS(StringProtoReplace$LWS, LOCKER_IDENTIFIER_MARKER$LWS, [/[\\^$.*+?()[\]{}|]/g, '\\$&'])
    // Function name references in call sites also contain
    // the name of the class they belong to,
    // e.g. myClassName.myFunctionName.
    }(?=\\.|$)`);
    const formatStackTrace = function formatStackTrace(error, callSites) {
      // Based on V8's default stack trace formatting:
      // https://chromium.googlesource.com/v8/v8.git/+/refs/heads/main/src/execution/messages.cc#371
      let stackTrace$LWS = '';
      try {
        stackTrace$LWS = ReflectApply$LWS(ErrorProtoToString$LWS, error, []);
      } catch (_unused2$LWS) {
        stackTrace$LWS = '<error>';
      }
      let consecutive$LWS = false;
      for (let i$LWS = 0, {
          length: length$LWS
        } = callSites; i$LWS < length$LWS; i$LWS += 1) {
        const callSite$LWS = callSites[i$LWS];
        const funcName$LWS = ReflectApply$LWS(CallSiteProtoGetFunctionName$LWS, callSite$LWS, []);
        let isMarked$LWS = false;
        if (typeof funcName$LWS === 'string' && funcName$LWS !== 'eval' && ReflectApply$LWS(RegExpProtoTest$LWS, lockerFunctionNameMarkerRegExp$LWS, [funcName$LWS])) {
          isMarked$LWS = true;
        }
        if (!isMarked$LWS) {
          const evalOrigin$LWS = ReflectApply$LWS(CallSiteProtoGetEvalOrigin$LWS, callSite$LWS, []);
          if (typeof evalOrigin$LWS === 'string' && ReflectApply$LWS(RegExpProtoTest$LWS, lockerFunctionNameMarkerRegExp$LWS, [evalOrigin$LWS])) {
            isMarked$LWS = true;
          }
        }
        // Only write a single LWS entry per consecutive LWS stacks.
        if (isMarked$LWS) {
          if (!consecutive$LWS) {
            consecutive$LWS = true;
            stackTrace$LWS += '\n    at LWS';
          }
          continue;
        } else {
          consecutive$LWS = false;
        }
        try {
          stackTrace$LWS += `\n    at ${ReflectApply$LWS(CallSiteProtoToString$LWS, callSite$LWS, [])}`;
          // eslint-disable-next-line no-empty
        } catch (_unused3$LWS) {}
      }
      return stackTrace$LWS;
    };
    try {
      // Error.prepareStackTrace cannot be a bound or proxy wrapped
      // function, so to obscure its source we wrap the call to
      // formatStackTrace().
      ErrorCtor$LWS.prepareStackTrace = function prepareStackTrace(error, callSites) {
        return formatStackTrace(error, callSites);
      };
      // eslint-disable-next-line no-empty
    } catch (_unused4$LWS) {}
    try {
      const {
        stackTraceLimit: stackTraceLimit$LWS
      } = ErrorCtor$LWS;
      if (typeof stackTraceLimit$LWS !== 'number' || stackTraceLimit$LWS < LOCKER_STACK_TRACE_LIMIT$LWS) {
        ErrorCtor$LWS.stackTraceLimit = LOCKER_STACK_TRACE_LIMIT$LWS;
      }
      // eslint-disable-next-line no-empty
    } catch (_unused5$LWS) {}
  } : noop$LWS;
  function noop$LWS() {
    // No-operation.
  }
  const serializeBigIntObject$LWS = IS_IN_SHADOW_REALM$LWS ? bigIntObject$LWS =>
  // Section 21.2.3 Properties of the BigInt Prototype Object
  // https://tc39.es/ecma262/#thisbigintvalue
  // Step 2: If Type(value) is Object and value has a [[BigIntData]] internal slot, then
  //     a. Assert: Type(value.[[BigIntData]]) is BigInt.
  ReflectApply$LWS(BigIntProtoValueOf$LWS, bigIntObject$LWS, []) : noop$LWS;
  const serializeBooleanObject$LWS = IS_IN_SHADOW_REALM$LWS ? booleanObject$LWS =>
  // Section 20.3.3 Properties of the Boolean Prototype Object
  // https://tc39.es/ecma262/#thisbooleanvalue
  // Step 2: If Type(value) is Object and value has a [[BooleanData]] internal slot, then
  //     a. Let b be value.[[BooleanData]].
  //     b. Assert: Type(b) is Boolean.
  ReflectApply$LWS(BooleanProtoValueOf$LWS, booleanObject$LWS, []) : noop$LWS;
  const serializeNumberObject$LWS = IS_IN_SHADOW_REALM$LWS ? numberObject$LWS =>
  // 21.1.3 Properties of the Number Prototype Object
  // https://tc39.es/ecma262/#thisnumbervalue
  // Step 2: If Type(value) is Object and value has a [[NumberData]] internal slot, then
  //     a. Let n be value.[[NumberData]].
  //     b. Assert: Type(n) is Number.
  ReflectApply$LWS(NumberProtoValueOf$LWS, numberObject$LWS, []) : noop$LWS;
  const serializeRegExp$LWS = IS_IN_SHADOW_REALM$LWS ? value$LWS => {
    // 22.2.5.12 get RegExp.prototype.source
    // https://tc39.es/ecma262/#sec-get-regexp.prototype.source
    // Step 3: If R does not have an [[OriginalSource]] internal slot, then
    //     a. If SameValue(R, %RegExp.prototype%) is true, return "(?:)".
    //     b. Otherwise, throw a TypeError exception.
    if (value$LWS !== RegExpProto$LWS) {
      const source$LWS = ReflectApply$LWS(RegExpProtoSourceGetter$LWS, value$LWS, []);
      return JSONStringify$LWS({
        __proto__: null,
        flags: ReflectApply$LWS(RegExpProtoFlagsGetter$LWS, value$LWS, []),
        source: source$LWS
      });
    }
    return undefined;
  } : noop$LWS;
  const serializeStringObject$LWS = IS_IN_SHADOW_REALM$LWS ? stringObject$LWS =>
  // 22.1.3 Properties of the String Prototype Object
  // https://tc39.es/ecma262/#thisstringvalue
  // Step 2: If Type(value) is Object and value has a [[StringData]] internal slot, then
  //     a. Let s be value.[[StringData]].
  //     b. Assert: Type(s) is String.
  ReflectApply$LWS(StringProtoValueOf$LWS, stringObject$LWS, []) : noop$LWS;
  const serializeSymbolObject$LWS = IS_IN_SHADOW_REALM$LWS ? symbolObject$LWS =>
  // 20.4.3 Properties of the Symbol Prototype Object
  // https://tc39.es/ecma262/#thissymbolvalue
  // Step 2: If Type(value) is Object and value has a [[SymbolData]] internal slot, then
  //     a. Let s be value.[[SymbolData]].
  //     b. Assert: Type(s) is Symbol.
  ReflectApply$LWS(SymbolProtoValueOf$LWS, symbolObject$LWS, []) : noop$LWS;
  const serializeTargetByBrand$LWS = IS_IN_SHADOW_REALM$LWS ? target$LWS => {
    const brand$LWS = ReflectApply$LWS(ObjectProtoToString$LWS, target$LWS, []);
    switch (brand$LWS) {
      // The brand checks below represent boxed primitives of
      // `ESGlobalKeys` in packages/near-membrane-base/src/intrinsics.ts
      // which are not remapped or reflective.
      case '[object Boolean]':
        return serializeBooleanObject$LWS(target$LWS);
      case '[object Number]':
        return serializeNumberObject$LWS(target$LWS);
      case '[object RegExp]':
        return serializeRegExp$LWS(target$LWS);
      case '[object String]':
        return serializeStringObject$LWS(target$LWS);
      case '[object Object]':
        try {
          // Symbol.prototype[@@toStringTag] is defined by default so
          // must have been removed.
          // https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
          return serializeSymbolObject$LWS(target$LWS);
          // eslint-disable-next-line no-empty
        } catch (_unused6$LWS) {}
        if (SUPPORTS_BIG_INT$LWS) {
          // BigInt.prototype[@@toStringTag] is defined by default so
          // must have been removed.
          // https://tc39.es/ecma262/#sec-bigint.prototype-@@tostringtag
          try {
            return serializeBigIntObject$LWS(target$LWS);
            // eslint-disable-next-line no-empty
          } catch (_unused7$LWS) {}
        }
      // eslint-disable-next-line no-fallthrough
      default:
        return undefined;
    }
  } : noop$LWS;
  const serializeTargetByTrialAndError$LWS = IS_IN_SHADOW_REALM$LWS ? target$LWS => {
    // The serialization attempts below represent boxed primitives of
    // `ESGlobalKeys` in packages/near-membrane-base/src/intrinsics.ts
    // which are not remapped or reflective.
    try {
      // Symbol.prototype[@@toStringTag] is defined by default so
      // attempted before others.
      // https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
      return serializeSymbolObject$LWS(target$LWS);
      // eslint-disable-next-line no-empty
    } catch (_unused8$LWS) {}
    if (SUPPORTS_BIG_INT$LWS) {
      // BigInt.prototype[@@toStringTag] is defined by default so
      // attempted before others.
      // https://tc39.es/ecma262/#sec-bigint.prototype-@@tostringtag
      try {
        return serializeBigIntObject$LWS(target$LWS);
        // eslint-disable-next-line no-empty
      } catch (_unused9$LWS) {}
    }
    try {
      return serializeBooleanObject$LWS(target$LWS);
      // eslint-disable-next-line no-empty
    } catch (_unused10$LWS) {}
    try {
      return serializeNumberObject$LWS(target$LWS);
      // eslint-disable-next-line no-empty
    } catch (_unused11$LWS) {}
    try {
      return serializeRegExp$LWS(target$LWS);
      // eslint-disable-next-line no-empty
    } catch (_unused12$LWS) {}
    try {
      return serializeStringObject$LWS(target$LWS);
      // eslint-disable-next-line no-empty
    } catch (_unused13$LWS) {}
    return undefined;
  } : noop$LWS;
  function toSafeTemplateStringValue$LWS(value$LWS) {
    if (typeof value$LWS === 'string') {
      return value$LWS;
    }
    try {
      if (typeof value$LWS === 'object' && value$LWS !== null) {
        const result$LWS = ReflectApply$LWS(ObjectProtoToString$LWS, value$LWS, []);
        return result$LWS === '[object Symbol]' ? ReflectApply$LWS(SymbolProtoToString$LWS, value$LWS, []) : result$LWS;
      }
      if (typeof value$LWS === 'function') {
        return ReflectApply$LWS(FunctionProtoToString$LWS, value$LWS, []);
      }
      // Attempt to coerce `value` to a string with the String() constructor.
      // Section 22.1.1.1 String ( value )
      // https://tc39.es/ecma262/#sec-string-constructor-string-value
      return StringCtor$LWS(value$LWS);
      // eslint-disable-next-line no-empty
    } catch (_unused14$LWS) {}
    return '[Object Unknown]';
  }
  // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow
  function toSafeWeakMap$LWS(weakMap$LWS) {
    ReflectSetPrototypeOf$LWS(weakMap$LWS, null);
    weakMap$LWS.delete = WeakMapProtoDelete$LWS;
    weakMap$LWS.has = WeakMapProtoHas$LWS;
    weakMap$LWS.set = WeakMapProtoSet$LWS;
    weakMap$LWS[SymbolToStringTag$LWS] = WeakMapProtoSymbolToStringTag$LWS;
    ReflectSetPrototypeOf$LWS(weakMap$LWS, WeakMapProto$LWS);
    return weakMap$LWS;
  }
  function toSafeWeakSet$LWS(weakSet$LWS) {
    ReflectSetPrototypeOf$LWS(weakSet$LWS, null);
    weakSet$LWS.add = WeakSetProtoAdd$LWS;
    weakSet$LWS.delete = WeakSetProtoDelete$LWS;
    weakSet$LWS.has = WeakSetProtoHas$LWS;
    weakSet$LWS[SymbolToStringTag$LWS] = WeakSetProtoSymbolToStringTag$LWS;
    ReflectSetPrototypeOf$LWS(weakSet$LWS, WeakSetProto$LWS);
    return weakSet$LWS;
  }
  return function createHooksCallback$LWS(color$LWS, foreignCallableHooksCallback$LWS, options$LWS) {
    if (IS_IN_SHADOW_REALM$LWS) {
      options$LWS = undefined;
    }
    const {
      distortionCallback: distortionCallback$LWS,
      liveTargetCallback: liveTargetCallback$LWS,
      revokedProxyCallback: revokedProxyCallback$LWS
      // eslint-disable-next-line prefer-object-spread
    } = ObjectAssign$LWS({
      __proto__: null
    }, options$LWS);
    const applyTrapNameRegistry$LWS = {
      // Populated in the returned connector function below.
      __proto__: null,
      0: undefined,
      1: undefined,
      2: undefined,
      3: undefined,
      4: undefined,
      n: undefined
    };
    const constructTrapNameRegistry$LWS = {
      // Populated in the returned connector function below.
      __proto__: null,
      0: undefined,
      1: undefined,
      2: undefined,
      3: undefined,
      4: undefined,
      n: undefined
    };
    const lazyPropertyDescriptorStateCache$LWS = toSafeWeakMap$LWS(new WeakMapCtor$LWS());
    const proxyPointerCache$LWS = toSafeWeakMap$LWS(new WeakMapCtor$LWS());
    let foreignCallablePushErrorTarget$LWS;
    let foreignCallablePushTarget$LWS;
    let foreignCallableApply$LWS;
    let foreignCallableConstruct$LWS;
    let foreignCallableDefineProperty$LWS;
    let foreignCallableDeleteProperty$LWS;
    let foreignCallableGet$LWS;
    let foreignCallableGetOwnPropertyDescriptor$LWS;
    let foreignCallableGetPrototypeOf$LWS;
    let foreignCallableHas$LWS;
    let foreignCallableIsExtensible$LWS;
    let foreignCallableOwnKeys$LWS;
    let foreignCallablePreventExtensions$LWS;
    let foreignCallableSet$LWS;
    let foreignCallableSetPrototypeOf$LWS;
    let foreignCallableDebugInfo$LWS;
    let foreignCallableGetPropertyValue$LWS;
    let foreignCallableGetLazyPropertyDescriptorStateByTarget$LWS;
    let foreignCallableGetTargetIntegrityTraits$LWS;
    let foreignCallableGetToStringTagOfTarget$LWS;
    let foreignCallableInstallErrorPrepareStackTrace$LWS;
    let foreignCallableIsTargetLive$LWS;
    let foreignCallableIsTargetRevoked$LWS;
    let foreignCallableSerializeTarget$LWS;
    let foreignCallableSetLazyPropertyDescriptorStateByTarget$LWS;
    let foreignCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS;
    let foreignCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS;
    let foreignCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS;
    let fastForeignTargetPointers$LWS;
    let foreignPointerBigInt64ArrayProto$LWS;
    let foreignPointerBigUint64ArrayProto$LWS;
    let foreignPointerFloat32ArrayProto$LWS;
    let foreignPointerFloat64ArrayProto$LWS;
    let foreignPointerInt8ArrayProto$LWS;
    let foreignPointerInt16ArrayProto$LWS;
    let foreignPointerInt32ArrayProto$LWS;
    let foreignPointerObjectProto$LWS;
    let foreignPointerTypedArrayProto$LWS;
    let foreignPointerUint8ArrayProto$LWS;
    let foreignPointerUint16ArrayProto$LWS;
    let foreignPointerUint32ArrayProto$LWS;
    let selectedTarget$LWS;
    let lastProxyTrapCalled$LWS = 0 /* ProxyHandlerTraps.None */;
    let handshakePropertyFlag$LWS = false;
    let useFastForeignTargetPath$LWS = IS_IN_SHADOW_REALM$LWS;
    let useFastForeignTargetPathForTypedArrays$LWS = IS_IN_SHADOW_REALM$LWS;
    const activateLazyOwnPropertyDefinition$LWS = IS_IN_SHADOW_REALM$LWS ? (target$LWS, key$LWS, state$LWS) => {
      state$LWS[key$LWS] = false;
      const foreignTargetPointer$LWS = getTransferablePointer$LWS(target$LWS);
      let safeDesc$LWS;
      try {
        foreignCallableGetOwnPropertyDescriptor$LWS(foreignTargetPointer$LWS, key$LWS, (_key$LWS, configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS) => {
          safeDesc$LWS = createDescriptorFromMeta$LWS(configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS);
        });
      } catch (error) {
        var _selectedTarget$LWS;
        const errorToThrow$LWS = (_selectedTarget$LWS = selectedTarget$LWS) != null ? _selectedTarget$LWS : error;
        selectedTarget$LWS = undefined;
        throw errorToThrow$LWS;
      }
      if (safeDesc$LWS) {
        ReflectDefineProperty$LWS(target$LWS, key$LWS, safeDesc$LWS);
      } else {
        ReflectDeleteProperty$LWS(target$LWS, key$LWS);
      }
    } : noop$LWS;
    let checkDebugMode$LWS = LOCKER_DEBUGGABLE_FLAG$LWS ? () => {
      try {
        if (ObjectHasOwn$LWS(globalThisRef$LWS, LOCKER_DEBUG_MODE_SYMBOL$LWS)) {
          checkDebugMode$LWS = () => true;
          installErrorPrepareStackTrace$LWS();
          foreignCallableInstallErrorPrepareStackTrace$LWS();
        }
      } catch (_unused15$LWS) {
        checkDebugMode$LWS = alwaysFalse$LWS;
      }
      return false;
    } : alwaysFalse$LWS;
    const clearFastForeignTargetPointers$LWS = IS_IN_SHADOW_REALM$LWS ? () => {
      fastForeignTargetPointers$LWS = toSafeWeakSet$LWS(new WeakSetCtor$LWS());
    } : noop$LWS;
    function copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget$LWS(foreignTargetPointer$LWS, shadowTarget$LWS) {
      let protoPointerOrNull$LWS;
      try {
        protoPointerOrNull$LWS = foreignCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS(foreignTargetPointer$LWS, (...descriptorTuples$LWS) => {
          const descriptors$LWS = {};
          for (let i$LWS = 0, {
              length: length$LWS
            } = descriptorTuples$LWS; i$LWS < length$LWS; i$LWS += 7) {
            const key$LWS = descriptorTuples$LWS[i$LWS];
            descriptors$LWS[key$LWS] = createDescriptorFromMeta$LWS(descriptorTuples$LWS[i$LWS + 1],
            // configurable
            descriptorTuples$LWS[i$LWS + 2],
            // enumerable
            descriptorTuples$LWS[i$LWS + 3],
            // writable
            descriptorTuples$LWS[i$LWS + 4],
            // valuePointer
            descriptorTuples$LWS[i$LWS + 5],
            // getterPointer
            descriptorTuples$LWS[i$LWS + 6] // setterPointer
            );
          }
          // Use `ObjectDefineProperties()` instead of individual
          // `ReflectDefineProperty()` calls for better performance.
          ObjectDefineProperties$LWS(shadowTarget$LWS, descriptors$LWS);
        });
      } catch (error) {
        var _selectedTarget2$LWS;
        const errorToThrow$LWS = (_selectedTarget2$LWS = selectedTarget$LWS) != null ? _selectedTarget2$LWS : error;
        selectedTarget$LWS = undefined;
        throw errorToThrow$LWS;
      }
      let proto$LWS;
      if (typeof protoPointerOrNull$LWS === 'function') {
        protoPointerOrNull$LWS();
        proto$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
      } else {
        proto$LWS = null;
      }
      ReflectSetPrototypeOf$LWS(shadowTarget$LWS, proto$LWS);
    }
    function createApplyOrConstructTrapForZeroOrMoreArgs$LWS(proxyTrapEnum$LWS) {
      const isApplyTrap$LWS = proxyTrapEnum$LWS & 1 /* ProxyHandlerTraps.Apply */;
      const arityToApplyOrConstructTrapNameRegistry$LWS = isApplyTrap$LWS ? applyTrapNameRegistry$LWS : constructTrapNameRegistry$LWS;
      const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
      return function applyOrConstructTrap$LWS(_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
        lastProxyTrapCalled$LWS = proxyTrapEnum$LWS;
        const args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
        const {
          length: length$LWS
        } = args$LWS;
        if (length$LWS !== 0) {
          var _arityToApplyOrConstr$LWS;
          return this[(_arityToApplyOrConstr$LWS = arityToApplyOrConstructTrapNameRegistry$LWS[length$LWS]) != null ? _arityToApplyOrConstr$LWS : arityToApplyOrConstructTrapNameRegistry$LWS.n](_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS);
        }
        // @ts-ignore: Prevent private property access error.
        const {
          foreignTargetPointer: foreignTargetPointer$LWS
        } = this;
        const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
        let pointerOrPrimitive$LWS;
        try {
          pointerOrPrimitive$LWS = foreignCallableApplyOrConstruct$LWS(foreignTargetPointer$LWS,
          // Inline getTransferableValue().
          typeof thisArgOrNewTarget$LWS === 'object' && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === 'function' ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof thisArgOrNewTarget$LWS === 'undefined' ? undefined : thisArgOrNewTarget$LWS);
        } catch (error) {
          var _selectedTarget3$LWS;
          const errorToThrow$LWS = (_selectedTarget3$LWS = selectedTarget$LWS) != null ? _selectedTarget3$LWS : error;
          selectedTarget$LWS = undefined;
          throw errorToThrow$LWS;
        }
        let result$LWS;
        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          result$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          result$LWS = pointerOrPrimitive$LWS;
        }
        return result$LWS;
      };
    }
    function createApplyOrConstructTrapForOneOrMoreArgs$LWS(proxyTrapEnum$LWS) {
      const isApplyTrap$LWS = proxyTrapEnum$LWS & 1 /* ProxyHandlerTraps.Apply */;
      const arityToApplyOrConstructTrapNameRegistry$LWS = isApplyTrap$LWS ? applyTrapNameRegistry$LWS : constructTrapNameRegistry$LWS;
      const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
      return function applyOrConstructTrapForOneOrMoreArgs$LWS(_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
        lastProxyTrapCalled$LWS = proxyTrapEnum$LWS;
        const args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
        const {
          length: length$LWS
        } = args$LWS;
        if (length$LWS !== 1) {
          var _arityToApplyOrConstr2$LWS;
          return this[(_arityToApplyOrConstr2$LWS = arityToApplyOrConstructTrapNameRegistry$LWS[length$LWS]) != null ? _arityToApplyOrConstr2$LWS : arityToApplyOrConstructTrapNameRegistry$LWS.n](_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS);
        }
        // @ts-ignore: Prevent private property access error.
        const {
          foreignTargetPointer: foreignTargetPointer$LWS
        } = this;
        const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
        let pointerOrPrimitive$LWS;
        try {
          const {
            0: arg0$LWS
          } = args$LWS;
          pointerOrPrimitive$LWS = foreignCallableApplyOrConstruct$LWS(foreignTargetPointer$LWS,
          // Inline getTransferableValue().
          typeof thisArgOrNewTarget$LWS === 'object' && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === 'function' ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof thisArgOrNewTarget$LWS === 'undefined' ? undefined : thisArgOrNewTarget$LWS,
          // Inline getTransferableValue().
          typeof arg0$LWS === 'object' && arg0$LWS !== null || typeof arg0$LWS === 'function' ? getTransferablePointer$LWS(arg0$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg0$LWS === 'undefined' ? undefined : arg0$LWS);
        } catch (error) {
          var _selectedTarget4$LWS;
          const errorToThrow$LWS = (_selectedTarget4$LWS = selectedTarget$LWS) != null ? _selectedTarget4$LWS : error;
          selectedTarget$LWS = undefined;
          throw errorToThrow$LWS;
        }
        let result$LWS;
        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          result$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          result$LWS = pointerOrPrimitive$LWS;
        }
        return result$LWS;
      };
    }
    function createApplyOrConstructTrapForTwoOrMoreArgs$LWS(proxyTrapEnum$LWS) {
      const isApplyTrap$LWS = proxyTrapEnum$LWS & 1 /* ProxyHandlerTraps.Apply */;
      const arityToApplyOrConstructTrapNameRegistry$LWS = isApplyTrap$LWS ? applyTrapNameRegistry$LWS : constructTrapNameRegistry$LWS;
      const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
      return function applyOrConstructTrapForTwoOrMoreArgs$LWS(_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
        lastProxyTrapCalled$LWS = proxyTrapEnum$LWS;
        const args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
        const {
          length: length$LWS
        } = args$LWS;
        if (length$LWS !== 2) {
          var _arityToApplyOrConstr3$LWS;
          return this[(_arityToApplyOrConstr3$LWS = arityToApplyOrConstructTrapNameRegistry$LWS[length$LWS]) != null ? _arityToApplyOrConstr3$LWS : arityToApplyOrConstructTrapNameRegistry$LWS.n](_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS);
        }
        // @ts-ignore: Prevent private property access error.
        const {
          foreignTargetPointer: foreignTargetPointer$LWS
        } = this;
        const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
        let pointerOrPrimitive$LWS;
        try {
          const {
            0: arg0$LWS,
            1: arg1$LWS
          } = args$LWS;
          pointerOrPrimitive$LWS = foreignCallableApplyOrConstruct$LWS(foreignTargetPointer$LWS,
          // Inline getTransferableValue().
          typeof thisArgOrNewTarget$LWS === 'object' && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === 'function' ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof thisArgOrNewTarget$LWS === 'undefined' ? undefined : thisArgOrNewTarget$LWS,
          // Inline getTransferableValue().
          typeof arg0$LWS === 'object' && arg0$LWS !== null || typeof arg0$LWS === 'function' ? getTransferablePointer$LWS(arg0$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg0$LWS === 'undefined' ? undefined : arg0$LWS,
          // Inline getTransferableValue().
          typeof arg1$LWS === 'object' && arg1$LWS !== null || typeof arg1$LWS === 'function' ? getTransferablePointer$LWS(arg1$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg1$LWS === 'undefined' ? undefined : arg1$LWS);
        } catch (error) {
          var _selectedTarget5$LWS;
          const errorToThrow$LWS = (_selectedTarget5$LWS = selectedTarget$LWS) != null ? _selectedTarget5$LWS : error;
          selectedTarget$LWS = undefined;
          throw errorToThrow$LWS;
        }
        let result$LWS;
        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          result$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          result$LWS = pointerOrPrimitive$LWS;
        }
        return result$LWS;
      };
    }
    function createApplyOrConstructTrapForThreeOrMoreArgs$LWS(proxyTrapEnum$LWS) {
      const isApplyTrap$LWS = proxyTrapEnum$LWS & 1 /* ProxyHandlerTraps.Apply */;
      const arityToApplyOrConstructTrapNameRegistry$LWS = isApplyTrap$LWS ? applyTrapNameRegistry$LWS : constructTrapNameRegistry$LWS;
      const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
      return function applyOrConstructTrapForTwoOrMoreArgs$LWS(_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
        lastProxyTrapCalled$LWS = proxyTrapEnum$LWS;
        const args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
        const {
          length: length$LWS
        } = args$LWS;
        if (length$LWS !== 3) {
          var _arityToApplyOrConstr4$LWS;
          return this[(_arityToApplyOrConstr4$LWS = arityToApplyOrConstructTrapNameRegistry$LWS[length$LWS]) != null ? _arityToApplyOrConstr4$LWS : arityToApplyOrConstructTrapNameRegistry$LWS.n](_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS);
        }
        // @ts-ignore: Prevent private property access error.
        const {
          foreignTargetPointer: foreignTargetPointer$LWS
        } = this;
        const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
        let pointerOrPrimitive$LWS;
        try {
          const {
            0: arg0$LWS,
            1: arg1$LWS,
            2: arg2$LWS
          } = args$LWS;
          pointerOrPrimitive$LWS = foreignCallableApplyOrConstruct$LWS(foreignTargetPointer$LWS,
          // Inline getTransferableValue().
          typeof thisArgOrNewTarget$LWS === 'object' && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === 'function' ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof thisArgOrNewTarget$LWS === 'undefined' ? undefined : thisArgOrNewTarget$LWS,
          // Inline getTransferableValue().
          typeof arg0$LWS === 'object' && arg0$LWS !== null || typeof arg0$LWS === 'function' ? getTransferablePointer$LWS(arg0$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg0$LWS === 'undefined' ? undefined : arg0$LWS,
          // Inline getTransferableValue().
          typeof arg1$LWS === 'object' && arg1$LWS !== null || typeof arg1$LWS === 'function' ? getTransferablePointer$LWS(arg1$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg1$LWS === 'undefined' ? undefined : arg1$LWS,
          // Inline getTransferableValue().
          typeof arg2$LWS === 'object' && arg2$LWS !== null || typeof arg2$LWS === 'function' ? getTransferablePointer$LWS(arg2$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg2$LWS === 'undefined' ? undefined : arg2$LWS);
        } catch (error) {
          var _selectedTarget6$LWS;
          const errorToThrow$LWS = (_selectedTarget6$LWS = selectedTarget$LWS) != null ? _selectedTarget6$LWS : error;
          selectedTarget$LWS = undefined;
          throw errorToThrow$LWS;
        }
        let result$LWS;
        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          result$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          result$LWS = pointerOrPrimitive$LWS;
        }
        return result$LWS;
      };
    }
    function createApplyOrConstructTrapForFourOrMoreArgs$LWS(proxyTrapEnum$LWS) {
      const isApplyTrap$LWS = proxyTrapEnum$LWS & 1 /* ProxyHandlerTraps.Apply */;
      const arityToApplyOrConstructTrapNameRegistry$LWS = isApplyTrap$LWS ? applyTrapNameRegistry$LWS : constructTrapNameRegistry$LWS;
      const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
      return function applyOrConstructTrapForTwoOrMoreArgs$LWS(_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
        lastProxyTrapCalled$LWS = proxyTrapEnum$LWS;
        const args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
        const {
          length: length$LWS
        } = args$LWS;
        if (length$LWS !== 4) {
          var _arityToApplyOrConstr5$LWS;
          return this[(_arityToApplyOrConstr5$LWS = arityToApplyOrConstructTrapNameRegistry$LWS[length$LWS]) != null ? _arityToApplyOrConstr5$LWS : arityToApplyOrConstructTrapNameRegistry$LWS.n](_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS);
        }
        // @ts-ignore: Prevent private property access error.
        const {
          foreignTargetPointer: foreignTargetPointer$LWS
        } = this;
        const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
        let pointerOrPrimitive$LWS;
        try {
          const {
            0: arg0$LWS,
            1: arg1$LWS,
            2: arg2$LWS,
            3: arg3$LWS
          } = args$LWS;
          pointerOrPrimitive$LWS = foreignCallableApplyOrConstruct$LWS(foreignTargetPointer$LWS,
          // Inline getTransferableValue().
          typeof thisArgOrNewTarget$LWS === 'object' && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === 'function' ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof thisArgOrNewTarget$LWS === 'undefined' ? undefined : thisArgOrNewTarget$LWS,
          // Inline getTransferableValue().
          typeof arg0$LWS === 'object' && arg0$LWS !== null || typeof arg0$LWS === 'function' ? getTransferablePointer$LWS(arg0$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg0$LWS === 'undefined' ? undefined : arg0$LWS,
          // Inline getTransferableValue().
          typeof arg1$LWS === 'object' && arg1$LWS !== null || typeof arg1$LWS === 'function' ? getTransferablePointer$LWS(arg1$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg1$LWS === 'undefined' ? undefined : arg1$LWS,
          // Inline getTransferableValue().
          typeof arg2$LWS === 'object' && arg2$LWS !== null || typeof arg2$LWS === 'function' ? getTransferablePointer$LWS(arg2$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg2$LWS === 'undefined' ? undefined : arg2$LWS,
          // Inline getTransferableValue().
          typeof arg3$LWS === 'object' && arg3$LWS !== null || typeof arg3$LWS === 'function' ? getTransferablePointer$LWS(arg3$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg3$LWS === 'undefined' ? undefined : arg3$LWS);
        } catch (error) {
          var _selectedTarget7$LWS;
          const errorToThrow$LWS = (_selectedTarget7$LWS = selectedTarget$LWS) != null ? _selectedTarget7$LWS : error;
          selectedTarget$LWS = undefined;
          throw errorToThrow$LWS;
        }
        let result$LWS;
        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          result$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          result$LWS = pointerOrPrimitive$LWS;
        }
        return result$LWS;
      };
    }
    function createApplyOrConstructTrapForFiveOrMoreArgs$LWS(proxyTrapEnum$LWS) {
      const isApplyTrap$LWS = proxyTrapEnum$LWS & 1 /* ProxyHandlerTraps.Apply */;
      const arityToApplyOrConstructTrapNameRegistry$LWS = isApplyTrap$LWS ? applyTrapNameRegistry$LWS : constructTrapNameRegistry$LWS;
      const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
      return function applyOrConstructTrapForTwoOrMoreArgs$LWS(_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
        lastProxyTrapCalled$LWS = proxyTrapEnum$LWS;
        const args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
        const {
          length: length$LWS
        } = args$LWS;
        if (length$LWS !== 5) {
          var _arityToApplyOrConstr6$LWS;
          return this[(_arityToApplyOrConstr6$LWS = arityToApplyOrConstructTrapNameRegistry$LWS[length$LWS]) != null ? _arityToApplyOrConstr6$LWS : arityToApplyOrConstructTrapNameRegistry$LWS.n](_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS);
        }
        // @ts-ignore: Prevent private property access error.
        const {
          foreignTargetPointer: foreignTargetPointer$LWS
        } = this;
        const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
        let pointerOrPrimitive$LWS;
        try {
          const {
            0: arg0$LWS,
            1: arg1$LWS,
            2: arg2$LWS,
            3: arg3$LWS,
            4: arg4$LWS
          } = args$LWS;
          pointerOrPrimitive$LWS = foreignCallableApplyOrConstruct$LWS(foreignTargetPointer$LWS,
          // Inline getTransferableValue().
          typeof thisArgOrNewTarget$LWS === 'object' && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === 'function' ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof thisArgOrNewTarget$LWS === 'undefined' ? undefined : thisArgOrNewTarget$LWS,
          // Inline getTransferableValue().
          typeof arg0$LWS === 'object' && arg0$LWS !== null || typeof arg0$LWS === 'function' ? getTransferablePointer$LWS(arg0$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg0$LWS === 'undefined' ? undefined : arg0$LWS,
          // Inline getTransferableValue().
          typeof arg1$LWS === 'object' && arg1$LWS !== null || typeof arg1$LWS === 'function' ? getTransferablePointer$LWS(arg1$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg1$LWS === 'undefined' ? undefined : arg1$LWS,
          // Inline getTransferableValue().
          typeof arg2$LWS === 'object' && arg2$LWS !== null || typeof arg2$LWS === 'function' ? getTransferablePointer$LWS(arg2$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg2$LWS === 'undefined' ? undefined : arg2$LWS,
          // Inline getTransferableValue().
          typeof arg3$LWS === 'object' && arg3$LWS !== null || typeof arg3$LWS === 'function' ? getTransferablePointer$LWS(arg3$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg3$LWS === 'undefined' ? undefined : arg3$LWS,
          // Inline getTransferableValue().
          typeof arg4$LWS === 'object' && arg4$LWS !== null || typeof arg4$LWS === 'function' ? getTransferablePointer$LWS(arg4$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg4$LWS === 'undefined' ? undefined : arg4$LWS);
        } catch (error) {
          var _selectedTarget8$LWS;
          const errorToThrow$LWS = (_selectedTarget8$LWS = selectedTarget$LWS) != null ? _selectedTarget8$LWS : error;
          selectedTarget$LWS = undefined;
          throw errorToThrow$LWS;
        }
        let result$LWS;
        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          result$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          result$LWS = pointerOrPrimitive$LWS;
        }
        return result$LWS;
      };
    }
    function createApplyOrConstructTrapForAnyNumberOfArgs$LWS(proxyTrapEnum$LWS) {
      const isApplyTrap$LWS = proxyTrapEnum$LWS & 1 /* ProxyHandlerTraps.Apply */;
      const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
      return function applyOrConstructTrapForAnyNumberOfArgs$LWS(_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
        lastProxyTrapCalled$LWS = proxyTrapEnum$LWS;
        // @ts-ignore: Prevent private property access error.
        const {
          foreignTargetPointer: foreignTargetPointer$LWS
        } = this;
        const args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
        const {
          length: length$LWS
        } = args$LWS;
        const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
        let combinedOffset$LWS = 2;
        const combinedArgs$LWS = new ArrayCtor$LWS(length$LWS + combinedOffset$LWS);
        combinedArgs$LWS[0] = foreignTargetPointer$LWS;
        let pointerOrPrimitive$LWS;
        try {
          combinedArgs$LWS[1] = typeof thisArgOrNewTarget$LWS === 'object' && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === 'function' ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof thisArgOrNewTarget$LWS === 'undefined' ? undefined : thisArgOrNewTarget$LWS;
          for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
            const arg$LWS = args$LWS[i$LWS];
            // Inlining `getTransferableValue()`.
            combinedArgs$LWS[combinedOffset$LWS++] = typeof arg$LWS === 'object' && arg$LWS !== null || typeof arg$LWS === 'function' ? getTransferablePointer$LWS(arg$LWS) :
            // Intentionally ignoring `document.all`.
            // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
            // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
            typeof arg$LWS === 'undefined' ? undefined : arg$LWS;
          }
          pointerOrPrimitive$LWS = ReflectApply$LWS(foreignCallableApplyOrConstruct$LWS, undefined, combinedArgs$LWS);
        } catch (error) {
          var _selectedTarget9$LWS;
          const errorToThrow$LWS = (_selectedTarget9$LWS = selectedTarget$LWS) != null ? _selectedTarget9$LWS : error;
          selectedTarget$LWS = undefined;
          throw errorToThrow$LWS;
        }
        let result$LWS;
        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          result$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          result$LWS = pointerOrPrimitive$LWS;
        }
        return result$LWS;
      };
    }
    function createDescriptorFromMeta$LWS(configurable$LWS, enumerable$LWS, writable$LWS, valuePointerOrPrimitive$LWS, getterPointerOrPrimitive$LWS, setterPointerOrPrimitive$LWS) {
      const safeDesc$LWS = {
        __proto__: null
      };
      if (configurable$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
        safeDesc$LWS.configurable = configurable$LWS;
      }
      if (enumerable$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
        safeDesc$LWS.enumerable = enumerable$LWS;
      }
      if (writable$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
        safeDesc$LWS.writable = writable$LWS;
      }
      if (getterPointerOrPrimitive$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
        if (typeof getterPointerOrPrimitive$LWS === 'function') {
          getterPointerOrPrimitive$LWS();
          safeDesc$LWS.get = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          safeDesc$LWS.get = undefined;
        }
      }
      if (setterPointerOrPrimitive$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
        if (typeof setterPointerOrPrimitive$LWS === 'function') {
          setterPointerOrPrimitive$LWS();
          safeDesc$LWS.set = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          safeDesc$LWS.set = undefined;
        }
      }
      if (valuePointerOrPrimitive$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
        if (typeof valuePointerOrPrimitive$LWS === 'function') {
          valuePointerOrPrimitive$LWS();
          safeDesc$LWS.value = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          safeDesc$LWS.value = valuePointerOrPrimitive$LWS;
        }
      }
      return safeDesc$LWS;
    }
    function createPointer$LWS(originalTarget$LWS) {
      const pointer$LWS = () => {
        // assert: selectedTarget is undefined
        selectedTarget$LWS = originalTarget$LWS;
      };
      return pointer$LWS;
    }
    const disableFastForeignTargetPointers$LWS = IS_IN_SHADOW_REALM$LWS ? () => {
      useFastForeignTargetPath$LWS = false;
      useFastForeignTargetPathForTypedArrays$LWS = false;
      clearFastForeignTargetPointers$LWS();
    } : noop$LWS;
    const getLazyPropertyDescriptorStateByTarget$LWS = IS_IN_SHADOW_REALM$LWS ? target$LWS => {
      let state$LWS = lazyPropertyDescriptorStateCache$LWS.get(target$LWS);
      if (state$LWS === undefined) {
        const statePointerOrUndefined$LWS = foreignCallableGetLazyPropertyDescriptorStateByTarget$LWS(getTransferablePointer$LWS(target$LWS));
        if (typeof statePointerOrUndefined$LWS === 'function') {
          statePointerOrUndefined$LWS();
          state$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
          if (state$LWS) {
            lazyPropertyDescriptorStateCache$LWS.set(target$LWS, state$LWS);
          }
        }
      }
      return state$LWS;
    } : noop$LWS;
    const isForeignPointerOfObjectProto$LWS = IS_IN_SHADOW_REALM$LWS ?
    // eslint-disable-next-line no-return-assign
    foreignTargetPointer$LWS => foreignTargetPointer$LWS === (foreignPointerObjectProto$LWS === undefined ? foreignPointerObjectProto$LWS = getTransferablePointer$LWS(ObjectProto$LWS) : foreignPointerObjectProto$LWS) : alwaysFalse$LWS;
    const isForeignPointerOfTypedArrayProto$LWS = IS_IN_SHADOW_REALM$LWS ?
    // eslint-disable-next-line no-return-assign
    foreignTargetPointer$LWS => foreignTargetPointer$LWS === (foreignPointerFloat32ArrayProto$LWS === undefined ? foreignPointerFloat32ArrayProto$LWS = getTransferablePointer$LWS(Float32ArrayProto$LWS) : foreignPointerFloat32ArrayProto$LWS) || foreignTargetPointer$LWS === (foreignPointerFloat64ArrayProto$LWS === undefined ? foreignPointerFloat64ArrayProto$LWS = getTransferablePointer$LWS(Float64ArrayProto$LWS) : foreignPointerFloat64ArrayProto$LWS) || foreignTargetPointer$LWS === (foreignPointerInt8ArrayProto$LWS === undefined ? foreignPointerInt8ArrayProto$LWS = getTransferablePointer$LWS(Int8ArrayProto$LWS) : foreignPointerInt8ArrayProto$LWS) || foreignTargetPointer$LWS === (foreignPointerInt16ArrayProto$LWS === undefined ? foreignPointerInt16ArrayProto$LWS = getTransferablePointer$LWS(Int16ArrayProto$LWS) : foreignPointerInt16ArrayProto$LWS) || foreignTargetPointer$LWS === (foreignPointerInt32ArrayProto$LWS === undefined ? foreignPointerInt32ArrayProto$LWS = getTransferablePointer$LWS(Int32ArrayProto$LWS) : foreignPointerInt32ArrayProto$LWS) || foreignTargetPointer$LWS === (foreignPointerUint8ArrayProto$LWS === undefined ? foreignPointerUint8ArrayProto$LWS = getTransferablePointer$LWS(Uint8ArrayProto$LWS) : foreignPointerUint8ArrayProto$LWS) || foreignTargetPointer$LWS === (foreignPointerUint16ArrayProto$LWS === undefined ? foreignPointerUint16ArrayProto$LWS = getTransferablePointer$LWS(Uint16ArrayProto$LWS) : foreignPointerUint16ArrayProto$LWS) || foreignTargetPointer$LWS === (foreignPointerUint32ArrayProto$LWS === undefined ? foreignPointerUint32ArrayProto$LWS = getTransferablePointer$LWS(Uint32ArrayProto$LWS) : foreignPointerUint32ArrayProto$LWS) || foreignTargetPointer$LWS === (foreignPointerTypedArrayProto$LWS === undefined ? foreignPointerTypedArrayProto$LWS = getTransferablePointer$LWS(TypedArrayProto$LWS) : foreignPointerTypedArrayProto$LWS) || foreignTargetPointer$LWS === (foreignPointerBigInt64ArrayProto$LWS === undefined ? foreignPointerBigInt64ArrayProto$LWS = BigInt64ArrayProto$LWS ? getTransferablePointer$LWS(BigInt64ArrayProto$LWS) : noop$LWS : foreignPointerBigInt64ArrayProto$LWS) || foreignTargetPointer$LWS === (foreignPointerBigUint64ArrayProto$LWS === undefined ? foreignPointerBigUint64ArrayProto$LWS = BigUint64ArrayProto$LWS ? getTransferablePointer$LWS(BigUint64ArrayProto$LWS) : noop$LWS : foreignPointerBigUint64ArrayProto$LWS) : alwaysFalse$LWS;
    function getTransferablePointer$LWS(originalTarget$LWS, foreignCallablePusher$LWS = foreignCallablePushTarget$LWS) {
      let proxyPointer$LWS = proxyPointerCache$LWS.get(originalTarget$LWS);
      if (proxyPointer$LWS) {
        return proxyPointer$LWS;
      }
      let targetFunctionArity$LWS = 0;
      let targetFunctionName$LWS = '';
      let targetTypedArrayLength$LWS = 0;
      if (revokedProxyCallback$LWS && revokedProxyCallback$LWS(originalTarget$LWS)) {
        proxyPointer$LWS = foreignCallablePusher$LWS(createPointer$LWS(originalTarget$LWS), 64 /* TargetTraits.Revoked */, targetFunctionArity$LWS, targetFunctionName$LWS, targetTypedArrayLength$LWS);
        proxyPointerCache$LWS.set(originalTarget$LWS, proxyPointer$LWS);
        return proxyPointer$LWS;
      }
      let distortionTarget$LWS;
      let targetTraits$LWS = 16 /* TargetTraits.IsObject */;
      if (distortionCallback$LWS) {
        distortionTarget$LWS = distortionCallback$LWS(originalTarget$LWS);
        // If a distortion entry is found, it must be a valid proxy target.
        if (distortionTarget$LWS !== originalTarget$LWS && typeof distortionTarget$LWS !== typeof originalTarget$LWS) {
          throw new TypeErrorCtor$LWS(`Invalid distortion ${toSafeTemplateStringValue$LWS(originalTarget$LWS)}.`);
        }
      } else {
        distortionTarget$LWS = originalTarget$LWS;
      }
      let isPossiblyRevoked$LWS = true;
      if (typeof distortionTarget$LWS === 'function') {
        isPossiblyRevoked$LWS = false;
        targetFunctionArity$LWS = 0;
        targetTraits$LWS = 4 /* TargetTraits.IsFunction */;
        try {
          // Detect arrow functions.
          if (!('prototype' in distortionTarget$LWS)) {
            targetTraits$LWS |= 8 /* TargetTraits.IsArrowFunction */;
          }
          const safeLengthDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(originalTarget$LWS, 'length');
          if (safeLengthDesc$LWS) {
            ReflectSetPrototypeOf$LWS(safeLengthDesc$LWS, null);
            const {
              value: safeLengthDescValue$LWS
            } = safeLengthDesc$LWS;
            if (typeof safeLengthDescValue$LWS === 'number') {
              targetFunctionArity$LWS = safeLengthDescValue$LWS;
            }
          }
          const safeNameDesc$LWS = false ? ReflectGetOwnPropertyDescriptor$LWS(originalTarget$LWS, 'name') : undefined;
          if (safeNameDesc$LWS) ;
        } catch (_unused16$LWS) {
          isPossiblyRevoked$LWS = true;
        }
      } else if (ArrayBufferIsView$LWS(distortionTarget$LWS)) {
        isPossiblyRevoked$LWS = false;
        targetTraits$LWS = 2 /* TargetTraits.IsArrayBufferView */;
        try {
          targetTypedArrayLength$LWS = ReflectApply$LWS(TypedArrayProtoLengthGetter$LWS, distortionTarget$LWS, []);
          targetTraits$LWS |= 32 /* TargetTraits.IsTypedArray */;
          // eslint-disable-next-line no-empty
        } catch (_unused17$LWS) {
          // Could be a DataView object or a revoked proxy.
          isPossiblyRevoked$LWS = true;
        }
      }
      if (isPossiblyRevoked$LWS) {
        try {
          if (isArrayOrThrowForRevoked$LWS(distortionTarget$LWS)) {
            targetTraits$LWS = 1 /* TargetTraits.IsArray */;
          }
        } catch (_unused18$LWS) {
          targetTraits$LWS = 64 /* TargetTraits.Revoked */;
        }
      }
      proxyPointer$LWS = foreignCallablePusher$LWS(createPointer$LWS(distortionTarget$LWS), targetTraits$LWS, targetFunctionArity$LWS, targetFunctionName$LWS, targetTypedArrayLength$LWS);
      proxyPointerCache$LWS.set(originalTarget$LWS, proxyPointer$LWS);
      return proxyPointer$LWS;
    }
    const installPropertyDescriptorMethodWrappers$LWS = IS_IN_SHADOW_REALM$LWS ? unforgeableGlobalThisKeys$LWS => {
      if (installedPropertyDescriptorMethodWrappersFlag$LWS) {
        return;
      }
      installedPropertyDescriptorMethodWrappersFlag$LWS = true;
      // We wrap property descriptor methods to activate lazy
      // descriptors and/or workaround browser bugs. The following
      // methods are wrapped:
      //   Object.getOwnPropertyDescriptors()
      //   Object.getOwnPropertyDescriptor()
      //   Reflect.defineProperty()
      //   Reflect.getOwnPropertyDescriptor()
      //   Object.prototype.__defineGetter__()
      //   Object.prototype.__defineSetter__()
      //   Object.prototype.__lookupGetter__()
      //   Object.prototype.__lookupSetter__()
      //
      // Chromium based browsers have a bug that nulls the result
      // of `window` getters in detached iframes when the property
      // descriptor of `window.window` is retrieved.
      // https://bugs.chromium.org/p/chromium/issues/detail?id=1305302
      //
      // Methods may be poisoned when they interact with the `window`
      // object and retrieve property descriptors, like 'window',
      // that contain the `window` object itself. The following
      // built-in methods are susceptible to this issue:
      //     console.log(window);
      //     Object.getOwnPropertyDescriptors(window);
      //     Object.getOwnPropertyDescriptor(window, 'window');
      //     Reflect.getOwnPropertyDescriptor(window, 'window');
      //     window.__lookupGetter__('window');
      //     window.__lookupSetter__('window');
      //
      // We side step issues with `console` by mapping it to the
      // primary realm's `console`. Since we're already wrapping
      // property descriptor methods to activate lazy descriptors
      // we use the wrapper to workaround the `window` getter
      // nulling bug.
      const shouldFixChromeBug$LWS = isArrayOrThrowForRevoked$LWS(unforgeableGlobalThisKeys$LWS) && unforgeableGlobalThisKeys$LWS.length > 0;
      // Lazily populated by `getUnforgeableGlobalThisGetter()`;
      const keyToGlobalThisGetterRegistry$LWS = shouldFixChromeBug$LWS ? {
        __proto__: null
      } : undefined;
      const getFixedDescriptor$LWS = shouldFixChromeBug$LWS ? (target$LWS, key$LWS) => ReflectApply$LWS(ArrayProtoIncludes$LWS, unforgeableGlobalThisKeys$LWS, [key$LWS]) ? {
        configurable: false,
        enumerable: ReflectApply$LWS(ObjectProtoPropertyIsEnumerable$LWS, target$LWS, [key$LWS]),
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        get: getUnforgeableGlobalThisGetter$LWS(key$LWS),
        set: undefined
      } : ReflectGetOwnPropertyDescriptor$LWS(target$LWS, key$LWS) : undefined;
      const getUnforgeableGlobalThisGetter$LWS = shouldFixChromeBug$LWS ? key$LWS => {
        let globalThisGetter$LWS = keyToGlobalThisGetterRegistry$LWS[key$LWS];
        if (globalThisGetter$LWS === undefined) {
          // We can't access the original getter to mask
          // with `proxyMaskFunction()`, so instead we wrap
          // `unboundGlobalThisGetter` in bound function
          // to obscure the getter source as "[native code]".
          globalThisGetter$LWS = ReflectApply$LWS(FunctionProtoBind$LWS,
          // eslint-disable-next-line @typescript-eslint/no-use-before-define
          unboundGlobalThisGetter$LWS, []);
          // Preserve identity continuity of getters.
          keyToGlobalThisGetterRegistry$LWS[key$LWS] = globalThisGetter$LWS;
        }
        return globalThisGetter$LWS;
      } : undefined;
      const lookupFixedGetter$LWS = shouldFixChromeBug$LWS ? (target$LWS, key$LWS) => ReflectApply$LWS(ArrayProtoIncludes$LWS, unforgeableGlobalThisKeys$LWS, [key$LWS]) ? getUnforgeableGlobalThisGetter$LWS(key$LWS) : ReflectApply$LWS(ObjectProtoLookupGetter$LWS, target$LWS, [key$LWS]) : undefined;
      const lookupFixedSetter$LWS = shouldFixChromeBug$LWS ? (target$LWS, key$LWS) => ReflectApply$LWS(ArrayProtoIncludes$LWS, unforgeableGlobalThisKeys$LWS, [key$LWS]) ? undefined : ReflectApply$LWS(ObjectProtoLookupSetter$LWS, target$LWS, [key$LWS]) : undefined;
      const unboundGlobalThisGetter$LWS = shouldFixChromeBug$LWS ? () => globalThisRef$LWS : undefined;
      const wrapDefineAccessOrProperty$LWS = originalFunc$LWS => {
        const {
          length: originalFuncLength$LWS
        } = originalFunc$LWS;
        // `__defineGetter__()` and `__defineSetter__()` have
        // function lengths of 2 while `Reflect.defineProperty()`
        // has a function length of 3.
        const useThisArgAsTarget$LWS = originalFuncLength$LWS === 2;
        return new ProxyCtor$LWS(originalFunc$LWS, {
          apply(_originalFunc$LWS, thisArg$LWS, args$LWS) {
            if (args$LWS.length >= originalFuncLength$LWS) {
              const target$LWS = useThisArgAsTarget$LWS ? thisArg$LWS : args$LWS[0];
              if (typeof target$LWS === 'object' && target$LWS !== null || typeof target$LWS === 'function') {
                const key$LWS = useThisArgAsTarget$LWS ? args$LWS[0] : args$LWS[1];
                const state$LWS = getLazyPropertyDescriptorStateByTarget$LWS(target$LWS);
                if (state$LWS != null && state$LWS[key$LWS]) {
                  // Activate the descriptor by triggering
                  // its getter.
                  // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                  target$LWS[key$LWS];
                }
              }
            }
            return ReflectApply$LWS(originalFunc$LWS, thisArg$LWS, args$LWS);
          }
        });
      };
      const wrapLookupAccessor$LWS = (originalFunc$LWS, lookupFixedAccessor$LWS) => new ProxyCtor$LWS(originalFunc$LWS, {
        apply(_originalFunc$LWS, thisArg$LWS, args$LWS) {
          if (args$LWS.length && (typeof thisArg$LWS === 'object' && thisArg$LWS !== null || typeof thisArg$LWS === 'function')) {
            const {
              0: key$LWS
            } = args$LWS;
            const state$LWS = getLazyPropertyDescriptorStateByTarget$LWS(thisArg$LWS);
            if (state$LWS != null && state$LWS[key$LWS]) {
              // Activate the descriptor by triggering
              // its getter.
              // eslint-disable-next-line @typescript-eslint/no-unused-expressions
              thisArg$LWS[key$LWS];
            }
            if (shouldFixChromeBug$LWS && thisArg$LWS === globalThisRef$LWS) {
              return lookupFixedAccessor$LWS(thisArg$LWS, key$LWS);
            }
          }
          return ReflectApply$LWS(originalFunc$LWS, thisArg$LWS, args$LWS);
        }
      });
      const wrapGetOwnPropertyDescriptor$LWS = originalFunc$LWS => new ProxyCtor$LWS(originalFunc$LWS, {
        apply(_originalFunc$LWS, thisArg$LWS, args$LWS) {
          if (args$LWS.length > 1) {
            const {
              0: target$LWS,
              1: key$LWS
            } = args$LWS;
            if (typeof target$LWS === 'object' && target$LWS !== null || typeof target$LWS === 'function') {
              const state$LWS = getLazyPropertyDescriptorStateByTarget$LWS(target$LWS);
              if (state$LWS != null && state$LWS[key$LWS]) {
                // Activate the descriptor by triggering
                // its getter.
                // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                target$LWS[key$LWS];
              }
              if (shouldFixChromeBug$LWS && target$LWS === globalThisRef$LWS) {
                return getFixedDescriptor$LWS(target$LWS, key$LWS);
              }
            }
          }
          return ReflectApply$LWS(originalFunc$LWS, thisArg$LWS, args$LWS);
        }
      });
      const wrapGetOwnPropertyDescriptors$LWS = originalFunc$LWS => new ProxyCtor$LWS(originalFunc$LWS, {
        apply(_originalFunc$LWS, thisArg$LWS, args$LWS) {
          const target$LWS = args$LWS.length ? args$LWS[0] : undefined;
          if (!(typeof target$LWS === 'object' && target$LWS !== null || typeof target$LWS === 'function')) {
            // Defer to native method to throw exception.
            return ReflectApply$LWS(originalFunc$LWS, thisArg$LWS, args$LWS);
          }
          const state$LWS = getLazyPropertyDescriptorStateByTarget$LWS(target$LWS);
          const isFixingChromeBug$LWS = target$LWS === globalThisRef$LWS && shouldFixChromeBug$LWS;
          const unsafeDescs$LWS = isFixingChromeBug$LWS ?
          // Create an empty property descriptor map
          // to populate with curated descriptors.
          {} :
          // Since this is not a global object it is
          // safe to use the native method.
          ReflectApply$LWS(originalFunc$LWS, thisArg$LWS, args$LWS);
          if (!isFixingChromeBug$LWS && state$LWS === undefined) {
            // Exit early if the target is not a global
            // object and there are no lazy descriptors.
            return unsafeDescs$LWS;
          }
          const ownKeys$LWS = ReflectOwnKeys$LWS(isFixingChromeBug$LWS ? target$LWS : unsafeDescs$LWS);
          for (let i$LWS = 0, {
              length: length$LWS
            } = ownKeys$LWS; i$LWS < length$LWS; i$LWS += 1) {
            const ownKey$LWS = ownKeys$LWS[i$LWS];
            const isLazyProp$LWS = !!(state$LWS != null && state$LWS[ownKey$LWS]);
            if (isLazyProp$LWS) {
              // Activate the descriptor by triggering
              // its getter.
              // eslint-disable-next-line @typescript-eslint/no-unused-expressions
              target$LWS[ownKey$LWS];
            }
            if (isLazyProp$LWS || isFixingChromeBug$LWS) {
              const unsafeDesc$LWS = isFixingChromeBug$LWS ? getFixedDescriptor$LWS(target$LWS, ownKey$LWS) : ReflectGetOwnPropertyDescriptor$LWS(target$LWS, ownKey$LWS);
              // Update the descriptor map entry.
              if (unsafeDesc$LWS) {
                unsafeDescs$LWS[ownKey$LWS] = unsafeDesc$LWS;
              } else if (!isFixingChromeBug$LWS) {
                ReflectDeleteProperty$LWS(unsafeDescs$LWS, ownKey$LWS);
              }
            }
          }
          return unsafeDescs$LWS;
        }
      });
      try {
        ReflectRef$LWS.defineProperty = wrapDefineAccessOrProperty$LWS(ReflectDefineProperty$LWS);
        // eslint-disable-next-line no-empty
      } catch (_unused19$LWS) {}
      try {
        ReflectRef$LWS.getOwnPropertyDescriptor = wrapGetOwnPropertyDescriptor$LWS(ReflectGetOwnPropertyDescriptor$LWS);
        // eslint-disable-next-line no-empty
      } catch (_unused20$LWS) {}
      try {
        ObjectCtor$LWS.getOwnPropertyDescriptor = wrapGetOwnPropertyDescriptor$LWS(ObjectGetOwnPropertyDescriptor$LWS);
        // eslint-disable-next-line no-empty
      } catch (_unused21$LWS) {}
      try {
        ObjectCtor$LWS.getOwnPropertyDescriptors = wrapGetOwnPropertyDescriptors$LWS(ObjectGetOwnPropertyDescriptors$LWS);
        // eslint-disable-next-line no-empty
      } catch (_unused22$LWS) {}
      try {
        // eslint-disable-next-line @typescript-eslint/naming-convention, no-restricted-properties, no-underscore-dangle
        ObjectProto$LWS.__defineGetter__ = wrapDefineAccessOrProperty$LWS(ObjectProtoDefineGetter$LWS);
        // eslint-disable-next-line no-empty
      } catch (_unused23$LWS) {}
      try {
        // eslint-disable-next-line @typescript-eslint/naming-convention, no-restricted-properties, no-underscore-dangle
        ObjectProto$LWS.__defineSetter__ = wrapDefineAccessOrProperty$LWS(ObjectProtoDefineSetter$LWS);
        // eslint-disable-next-line no-empty
      } catch (_unused24$LWS) {}
      try {
        // eslint-disable-next-line @typescript-eslint/naming-convention, no-underscore-dangle
        ObjectProto$LWS.__lookupGetter__ = wrapLookupAccessor$LWS(ObjectProtoLookupGetter$LWS, lookupFixedGetter$LWS);
        // eslint-disable-next-line no-empty
      } catch (_unused25$LWS) {}
      try {
        // eslint-disable-next-line @typescript-eslint/naming-convention, no-underscore-dangle
        ObjectProto$LWS.__lookupSetter__ = wrapLookupAccessor$LWS(ObjectProtoLookupSetter$LWS, lookupFixedSetter$LWS);
        // eslint-disable-next-line no-empty
      } catch (_unused26$LWS) {}
    } : noop$LWS;
    function lookupForeignDescriptor$LWS(foreignTargetPointer$LWS, shadowTarget$LWS, key$LWS) {
      let protoPointerOrNull$LWS;
      let safeDesc$LWS;
      try {
        protoPointerOrNull$LWS = foreignCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS(foreignTargetPointer$LWS, key$LWS, (_key$LWS, configurable$LWS, enumerable$LWS, writable$LWS, valuePointerOrPrimitive$LWS, getterPointerOrPrimitive$LWS, setterPointerOrPrimitive$LWS) => {
          safeDesc$LWS = {
            __proto__: null,
            foreign: true
          };
          if (configurable$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
            safeDesc$LWS.configurable = configurable$LWS;
          }
          if (enumerable$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
            safeDesc$LWS.enumerable = enumerable$LWS;
          }
          if (writable$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
            safeDesc$LWS.writable = writable$LWS;
          }
          if (getterPointerOrPrimitive$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
            if (typeof getterPointerOrPrimitive$LWS === 'function') {
              getterPointerOrPrimitive$LWS();
              safeDesc$LWS.get = selectedTarget$LWS;
              selectedTarget$LWS = undefined;
            } else {
              safeDesc$LWS.get = undefined;
            }
          }
          if (setterPointerOrPrimitive$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
            if (typeof setterPointerOrPrimitive$LWS === 'function') {
              setterPointerOrPrimitive$LWS();
              safeDesc$LWS.set = selectedTarget$LWS;
              selectedTarget$LWS = undefined;
            } else {
              safeDesc$LWS.set = undefined;
            }
          }
          if (valuePointerOrPrimitive$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
            if (typeof valuePointerOrPrimitive$LWS === 'function') {
              valuePointerOrPrimitive$LWS();
              safeDesc$LWS.value = selectedTarget$LWS;
              selectedTarget$LWS = undefined;
            } else {
              safeDesc$LWS.value = valuePointerOrPrimitive$LWS;
            }
          }
          if (configurable$LWS === false) {
            // Update the descriptor to non-configurable on
            // the shadow target.
            ReflectDefineProperty$LWS(shadowTarget$LWS, key$LWS, safeDesc$LWS);
          }
        });
      } catch (error) {
        var _selectedTarget10$LWS;
        const errorToThrow$LWS = (_selectedTarget10$LWS = selectedTarget$LWS) != null ? _selectedTarget10$LWS : error;
        selectedTarget$LWS = undefined;
        throw errorToThrow$LWS;
      }
      if (safeDesc$LWS === undefined) {
        // Avoiding calling the has trap for any proto chain operation,
        // instead we implement the regular logic here in this trap.
        let currentObject$LWS;
        if (typeof protoPointerOrNull$LWS === 'function') {
          protoPointerOrNull$LWS();
          currentObject$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          currentObject$LWS = null;
        }
        while (currentObject$LWS) {
          safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(currentObject$LWS, key$LWS);
          if (safeDesc$LWS) {
            ReflectSetPrototypeOf$LWS(safeDesc$LWS, null);
            break;
          }
          currentObject$LWS = ReflectGetPrototypeOf$LWS(currentObject$LWS);
        }
        if (safeDesc$LWS) {
          var _ref3$LWS;
          const {
            get: getter$LWS,
            set: setter$LWS,
            value: localValue$LWS
          } = safeDesc$LWS;
          const possibleProxy$LWS = (_ref3$LWS = getter$LWS != null ? getter$LWS : setter$LWS) != null ? _ref3$LWS : localValue$LWS;
          safeDesc$LWS.foreign = (typeof possibleProxy$LWS === 'object' && possibleProxy$LWS !== null || typeof possibleProxy$LWS === 'function') && proxyPointerCache$LWS.get(possibleProxy$LWS) !== undefined;
        }
      }
      return safeDesc$LWS;
    }
    function passthruForeignTraversedSet$LWS(foreignTargetPointer$LWS, shadowTarget$LWS, key$LWS, value$LWS, receiver$LWS) {
      const safeDesc$LWS = lookupForeignDescriptor$LWS(foreignTargetPointer$LWS, shadowTarget$LWS, key$LWS);
      // Following the specification steps for
      // OrdinarySetWithOwnDescriptor ( O, P, V, Receiver, ownDesc ).
      // https://tc39.es/ecma262/#sec-ordinarysetwithowndescriptor
      if (safeDesc$LWS) {
        if ('get' in safeDesc$LWS || 'set' in safeDesc$LWS) {
          const {
            set: setter$LWS
          } = safeDesc$LWS;
          if (setter$LWS) {
            if (safeDesc$LWS.foreign) {
              foreignCallableApply$LWS(getTransferablePointer$LWS(setter$LWS),
              // Inline getTransferableValue().
              typeof receiver$LWS === 'object' && receiver$LWS !== null || typeof receiver$LWS === 'function' ? getTransferablePointer$LWS(receiver$LWS) :
              // Intentionally ignoring `document.all`.
              // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
              // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
              typeof receiver$LWS === 'undefined' ? undefined : receiver$LWS,
              // Inline getTransferableValue().
              typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function' ? getTransferablePointer$LWS(value$LWS) :
              // Intentionally ignoring `document.all`.
              // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
              // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
              typeof value$LWS === 'undefined' ? undefined : value$LWS);
            } else {
              // Even though the setter function exists, we can't
              // use `ReflectSet()` because there might be a
              // distortion for that setter function, in which
              // case we must resolve the local setter and call
              // it instead.
              ReflectApply$LWS(setter$LWS, receiver$LWS, [value$LWS]);
            }
            // If there is a setter, it either throw or we can assume
            // the value was set.
            return true;
          }
          return false;
        }
        if (safeDesc$LWS.writable === false) {
          return false;
        }
      }
      // Exit early if receiver is not object like.
      if (!(typeof receiver$LWS === 'object' && receiver$LWS !== null || typeof receiver$LWS === 'function')) {
        return false;
      }
      const safeReceiverDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(receiver$LWS, key$LWS);
      if (safeReceiverDesc$LWS) {
        ReflectSetPrototypeOf$LWS(safeReceiverDesc$LWS, null);
        // Exit early for accessor descriptors or non-writable data
        // descriptors.
        if ('get' in safeReceiverDesc$LWS || 'set' in safeReceiverDesc$LWS || safeReceiverDesc$LWS.writable === false) {
          return false;
        }
        // Setting the descriptor with only a value entry should not
        // affect existing descriptor traits.
        ReflectDefineProperty$LWS(receiver$LWS, key$LWS, {
          __proto__: null,
          value: value$LWS
        });
        return true;
      }
      // `ReflectDefineProperty()` and `ReflectSet()` both are expected
      // to return `false` when attempting to add a new property if the
      // receiver is not extensible.
      return ReflectDefineProperty$LWS(receiver$LWS, key$LWS, {
        __proto__: null,
        configurable: true,
        enumerable: true,
        value: value$LWS,
        writable: true
      });
    }
    function pushErrorAcrossBoundary$LWS(error) {
      if (LOCKER_DEBUGGABLE_FLAG$LWS) {
        checkDebugMode$LWS();
      }
      // Inline getTransferableValue().
      if (typeof error === 'object' && error !== null || typeof error === 'function') {
        const foreignErrorPointer$LWS = getTransferablePointer$LWS(error, foreignCallablePushErrorTarget$LWS);
        foreignErrorPointer$LWS();
      }
      return error;
    }
    function pushTarget$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS, foreignTargetFunctionArity$LWS, foreignTargetFunctionName$LWS, foreignTargetTypedArrayLength$LWS) {
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      const {
        proxy: proxy$LWS
      } = new BoundaryProxyHandler$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS, foreignTargetFunctionArity$LWS, foreignTargetFunctionName$LWS, foreignTargetTypedArrayLength$LWS);
      proxyPointerCache$LWS.set(proxy$LWS, foreignTargetPointer$LWS);
      return createPointer$LWS(proxy$LWS);
    }
    const setLazyPropertyDescriptorStateByTarget$LWS = IS_IN_SHADOW_REALM$LWS ? (target$LWS, state$LWS) => {
      lazyPropertyDescriptorStateCache$LWS.set(target$LWS, state$LWS);
      foreignCallableSetLazyPropertyDescriptorStateByTarget$LWS(getTransferablePointer$LWS(target$LWS), getTransferablePointer$LWS(state$LWS));
    } : noop$LWS;
    class BoundaryProxyHandler$LWS {
      constructor(foreignTargetPointer$LWS, foreignTargetTraits$LWS, foreignTargetFunctionArity$LWS, foreignTargetFunctionName$LWS, foreignTargetTypedArrayLength$LWS) {
        // Internal red/shadow realm side utilities:
        this.makeProxyLive = IS_IN_SHADOW_REALM$LWS ? function () {
          // Replace pending traps with live traps that can work with the
          // target without taking snapshots.
          this.deleteProperty = BoundaryProxyHandler$LWS.passthruDeletePropertyTrap;
          this.defineProperty = BoundaryProxyHandler$LWS.passthruDefinePropertyTrap;
          this.preventExtensions = BoundaryProxyHandler$LWS.passthruPreventExtensionsTrap;
          this.set = BoundaryProxyHandler$LWS.passthruSetTrap;
          this.setPrototypeOf = BoundaryProxyHandler$LWS.passthruSetPrototypeOfTrap;
        } : noop$LWS;
        this.makeProxyStatic = IS_IN_SHADOW_REALM$LWS ? function () {
          // Reset all traps except apply and construct for static proxies
          // since the proxy target is the shadow target and all operations
          // are going to be applied to it rather than the real target.
          this.defineProperty = BoundaryProxyHandler$LWS.staticDefinePropertyTrap;
          this.deleteProperty = BoundaryProxyHandler$LWS.staticDeletePropertyTrap;
          this.get = BoundaryProxyHandler$LWS.staticGetTrap;
          this.getOwnPropertyDescriptor = BoundaryProxyHandler$LWS.staticGetOwnPropertyDescriptorTrap;
          this.getPrototypeOf = BoundaryProxyHandler$LWS.staticGetPrototypeOfTrap;
          this.has = BoundaryProxyHandler$LWS.staticHasTrap;
          this.isExtensible = BoundaryProxyHandler$LWS.staticIsExtensibleTrap;
          this.ownKeys = BoundaryProxyHandler$LWS.staticOwnKeysTrap;
          this.preventExtensions = BoundaryProxyHandler$LWS.staticPreventExtensionsTrap;
          this.set = BoundaryProxyHandler$LWS.staticSetTrap;
          this.setPrototypeOf = BoundaryProxyHandler$LWS.staticSetPrototypeOfTrap;
          const {
            foreignTargetPointer: foreignTargetPointer$LWS,
            foreignTargetTraits: foreignTargetTraits$LWS,
            shadowTarget: shadowTarget$LWS
          } = this;
          if (useFastForeignTargetPath$LWS) {
            fastForeignTargetPointers$LWS.delete(foreignTargetPointer$LWS);
          }
          // We don't wrap `foreignCallableGetTargetIntegrityTraits()`
          // in a try-catch because it cannot throw.
          const targetIntegrityTraits$LWS = foreignCallableGetTargetIntegrityTraits$LWS(foreignTargetPointer$LWS);
          if (targetIntegrityTraits$LWS & 8 /* TargetIntegrityTraits.Revoked */) {
            // the target is a revoked proxy, in which case we revoke
            // this proxy as well.
            this.revoke();
            return;
          }
          // A proxy can revoke itself when traps are triggered and break
          // the membrane, therefore we need protection.
          try {
            copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget$LWS(foreignTargetPointer$LWS, shadowTarget$LWS);
          } catch (_unused27$LWS) {
            // We don't wrap `foreignCallableIsTargetRevoked()` in a
            // try-catch because it cannot throw.
            if (foreignCallableIsTargetRevoked$LWS(foreignTargetPointer$LWS)) {
              this.revoke();
              return;
            }
          }
          if (foreignTargetTraits$LWS & 16 /* TargetTraits.IsObject */ && !(SymbolToStringTag$LWS in shadowTarget$LWS)) {
            let toStringTag$LWS = 'Object';
            try {
              toStringTag$LWS = foreignCallableGetToStringTagOfTarget$LWS(foreignTargetPointer$LWS);
              // eslint-disable-next-line no-empty
            } catch (_unused28$LWS) {}
            this.staticToStringTag = toStringTag$LWS;
          }
          // Preserve the semantics of the target.
          if (targetIntegrityTraits$LWS & 4 /* TargetIntegrityTraits.IsFrozen */) {
            ObjectFreeze$LWS(shadowTarget$LWS);
          } else {
            if (targetIntegrityTraits$LWS & 2 /* TargetIntegrityTraits.IsSealed */) {
              ObjectSeal$LWS(shadowTarget$LWS);
            } else if (targetIntegrityTraits$LWS & 1 /* TargetIntegrityTraits.IsNotExtensible */) {
              ReflectPreventExtensions$LWS(shadowTarget$LWS);
            }
            if (LOCKER_UNMINIFIED_FLAG$LWS) {
              // We don't wrap `foreignCallableDebugInfo()` in a try-catch
              // because it cannot throw.
              foreignCallableDebugInfo$LWS('Mutations on the membrane of an object originating ' + 'outside of the sandbox will not be reflected on ' + 'the object itself:', foreignTargetPointer$LWS);
            }
          }
        } : noop$LWS;
        let shadowTarget$LWS;
        const isForeignTargetArray$LWS = foreignTargetTraits$LWS & 1 /* TargetTraits.IsArray */;
        const isForeignTargetFunction$LWS = foreignTargetTraits$LWS & 4 /* TargetTraits.IsFunction */;
        if (isForeignTargetFunction$LWS) {
          // This shadow target is never invoked. It's needed to avoid
          // proxy trap invariants. Because it's not invoked the code
          // does not need to be instrumented for code coverage.
          //
          // istanbul ignore next
          shadowTarget$LWS = foreignTargetTraits$LWS & 8 /* TargetTraits.IsArrowFunction */ ? () => {} : function () {};
        } else if (isForeignTargetArray$LWS) {
          shadowTarget$LWS = [];
        } else {
          shadowTarget$LWS = {};
        }
        const {
          proxy: proxy$LWS,
          revoke: revoke$LWS
        } = ProxyRevocable$LWS(shadowTarget$LWS, this);
        this.foreignTargetPointer = foreignTargetPointer$LWS;
        this.foreignTargetTraits = foreignTargetTraits$LWS;
        this.foreignTargetTypedArrayLength = foreignTargetTypedArrayLength$LWS;
        // Define in the BoundaryProxyHandler constructor so it is bound
        // to the BoundaryProxyHandler instance.
        this.nonConfigurableDescriptorCallback = (key$LWS, configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS) => {
          // Update the descriptor to non-configurable on the shadow
          // target.
          ReflectDefineProperty$LWS(this.shadowTarget, key$LWS, createDescriptorFromMeta$LWS(configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS));
        };
        this.proxy = proxy$LWS;
        this.revoke = revoke$LWS;
        this.serialize = noop$LWS;
        this.shadowTarget = shadowTarget$LWS;
        this.staticToStringTag = 'Object';
        // Define traps.
        if (isForeignTargetFunction$LWS) {
          var _applyTrapNameRegistr$LWS, _constructTrapNameReg$LWS;
          this.apply = this[(_applyTrapNameRegistr$LWS = applyTrapNameRegistry$LWS[foreignTargetFunctionArity$LWS]) != null ? _applyTrapNameRegistr$LWS : applyTrapNameRegistry$LWS.n];
          this.construct = this[(_constructTrapNameReg$LWS = constructTrapNameRegistry$LWS[foreignTargetFunctionArity$LWS]) != null ? _constructTrapNameReg$LWS : constructTrapNameRegistry$LWS.n];
        }
        this.defineProperty = BoundaryProxyHandler$LWS.defaultDefinePropertyTrap;
        this.deleteProperty = BoundaryProxyHandler$LWS.defaultDeletePropertyTrap;
        this.isExtensible = BoundaryProxyHandler$LWS.defaultIsExtensibleTrap;
        this.getOwnPropertyDescriptor = BoundaryProxyHandler$LWS.defaultGetOwnPropertyDescriptorTrap;
        this.getPrototypeOf = BoundaryProxyHandler$LWS.defaultGetPrototypeOfTrap;
        this.get = foreignTargetTraits$LWS & 32 /* TargetTraits.IsTypedArray */ ? BoundaryProxyHandler$LWS.hybridGetTrapForTypedArray : BoundaryProxyHandler$LWS.defaultGetTrap;
        this.has = BoundaryProxyHandler$LWS.defaultHasTrap;
        this.ownKeys = BoundaryProxyHandler$LWS.defaultOwnKeysTrap;
        this.preventExtensions = BoundaryProxyHandler$LWS.defaultPreventExtensionsTrap;
        this.setPrototypeOf = BoundaryProxyHandler$LWS.defaultSetPrototypeOfTrap;
        this.set = BoundaryProxyHandler$LWS.defaultSetTrap;
        if (foreignTargetTraits$LWS & 64 /* TargetTraits.Revoked */) {
          this.revoke();
        } else if (IS_IN_SHADOW_REALM$LWS) {
          if (isForeignTargetArray$LWS || foreignTargetTraits$LWS & 2 /* TargetTraits.IsArrayBufferView */) {
            this.makeProxyLive();
          }
        } else {
          if (foreignTargetTraits$LWS & 16 /* TargetTraits.IsObject */) {
            // Lazily define serialize method.
            let cachedSerializedValue$LWS = LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
            this.serialize = () => {
              if (cachedSerializedValue$LWS === LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
                cachedSerializedValue$LWS = foreignCallableSerializeTarget$LWS(this.foreignTargetPointer);
              }
              return cachedSerializedValue$LWS;
            };
          }
        }
      }
      // Passthru traps:
      static passthruDefinePropertyTrap(_shadowTarget$LWS, key$LWS, unsafePartialDesc$LWS) {
        lastProxyTrapCalled$LWS = 4 /* ProxyHandlerTraps.DefineProperty */;
        const {
          foreignTargetPointer: foreignTargetPointer$LWS,
          nonConfigurableDescriptorCallback: nonConfigurableDescriptorCallback$LWS
        } = this;
        const safePartialDesc$LWS = unsafePartialDesc$LWS;
        ReflectSetPrototypeOf$LWS(safePartialDesc$LWS, null);
        const {
          get: getter$LWS,
          set: setter$LWS,
          value: value$LWS
        } = safePartialDesc$LWS;
        const valuePointerOrPrimitive$LWS = 'value' in safePartialDesc$LWS ?
        // Inline getTransferableValue().
        typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function' ? getTransferablePointer$LWS(value$LWS) :
        // Intentionally ignoring `document.all`.
        // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
        // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
        typeof value$LWS === 'undefined' ? undefined : value$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        const getterPointerOrUndefinedSymbol$LWS = 'get' in safePartialDesc$LWS ?
        // Inline getTransferableValue().
        typeof getter$LWS === 'function' ? getTransferablePointer$LWS(getter$LWS) : getter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        const setterPointerOrUndefinedSymbol$LWS = 'set' in safePartialDesc$LWS ?
        // Inline getTransferableValue().
        typeof setter$LWS === 'function' ? getTransferablePointer$LWS(setter$LWS) : setter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        let result$LWS = false;
        try {
          result$LWS = foreignCallableDefineProperty$LWS(foreignTargetPointer$LWS, key$LWS, 'configurable' in safePartialDesc$LWS ? !!safePartialDesc$LWS.configurable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'enumerable' in safePartialDesc$LWS ? !!safePartialDesc$LWS.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'writable' in safePartialDesc$LWS ? !!safePartialDesc$LWS.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, valuePointerOrPrimitive$LWS, getterPointerOrUndefinedSymbol$LWS, setterPointerOrUndefinedSymbol$LWS, nonConfigurableDescriptorCallback$LWS);
        } catch (error) {
          var _selectedTarget11$LWS;
          const errorToThrow$LWS = (_selectedTarget11$LWS = selectedTarget$LWS) != null ? _selectedTarget11$LWS : error;
          selectedTarget$LWS = undefined;
          throw errorToThrow$LWS;
        }
        if (useFastForeignTargetPath$LWS && result$LWS && (typeof getterPointerOrUndefinedSymbol$LWS === 'function' || typeof setterPointerOrUndefinedSymbol$LWS === 'function')) {
          fastForeignTargetPointers$LWS.delete(foreignTargetPointer$LWS);
        }
        return result$LWS;
      }
      static passthruDeletePropertyTrap(_shadowTarget$LWS, key$LWS) {
        lastProxyTrapCalled$LWS = 8 /* ProxyHandlerTraps.DeleteProperty */;
        let result$LWS = false;
        try {
          result$LWS = foreignCallableDeleteProperty$LWS(this.foreignTargetPointer, key$LWS);
        } catch (error) {
          var _selectedTarget12$LWS;
          const errorToThrow$LWS = (_selectedTarget12$LWS = selectedTarget$LWS) != null ? _selectedTarget12$LWS : error;
          selectedTarget$LWS = undefined;
          throw errorToThrow$LWS;
        }
        return result$LWS;
      }
      static passthruGetPrototypeOfTrap(_shadowTarget$LWS) {
        lastProxyTrapCalled$LWS = 64 /* ProxyHandlerTraps.GetPrototypeOf */;
        let protoPointerOrNull$LWS;
        try {
          protoPointerOrNull$LWS = foreignCallableGetPrototypeOf$LWS(this.foreignTargetPointer);
        } catch (error) {
          var _selectedTarget13$LWS;
          const errorToThrow$LWS = (_selectedTarget13$LWS = selectedTarget$LWS) != null ? _selectedTarget13$LWS : error;
          selectedTarget$LWS = undefined;
          throw errorToThrow$LWS;
        }
        let proto$LWS;
        if (typeof protoPointerOrNull$LWS === 'function') {
          protoPointerOrNull$LWS();
          proto$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          proto$LWS = null;
        }
        return proto$LWS;
      }
      static passthruIsExtensibleTrap(_shadowTarget$LWS) {
        lastProxyTrapCalled$LWS = 256 /* ProxyHandlerTraps.IsExtensible */;
        const {
          shadowTarget: shadowTarget$LWS
        } = this;
        let result$LWS = false;
        // Check if already locked.
        if (ReflectIsExtensible$LWS(shadowTarget$LWS)) {
          const {
            foreignTargetPointer: foreignTargetPointer$LWS
          } = this;
          try {
            result$LWS = foreignCallableIsExtensible$LWS(foreignTargetPointer$LWS);
          } catch (error) {
            var _selectedTarget14$LWS;
            const errorToThrow$LWS = (_selectedTarget14$LWS = selectedTarget$LWS) != null ? _selectedTarget14$LWS : error;
            selectedTarget$LWS = undefined;
            throw errorToThrow$LWS;
          }
          if (!result$LWS) {
            copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget$LWS(foreignTargetPointer$LWS, shadowTarget$LWS);
            ReflectPreventExtensions$LWS(shadowTarget$LWS);
          }
        }
        return result$LWS;
      }
      static passthruOwnKeysTrap(_shadowTarget$LWS) {
        lastProxyTrapCalled$LWS = 512 /* ProxyHandlerTraps.OwnKeys */;
        let ownKeys$LWS;
        try {
          foreignCallableOwnKeys$LWS(this.foreignTargetPointer, (...args$LWS) => {
            ownKeys$LWS = args$LWS;
          });
        } catch (error) {
          var _selectedTarget15$LWS;
          const errorToThrow$LWS = (_selectedTarget15$LWS = selectedTarget$LWS) != null ? _selectedTarget15$LWS : error;
          selectedTarget$LWS = undefined;
          throw errorToThrow$LWS;
        }
        return ownKeys$LWS || [];
      }
      static passthruGetOwnPropertyDescriptorTrap(_shadowTarget$LWS, key$LWS) {
        lastProxyTrapCalled$LWS = 32 /* ProxyHandlerTraps.GetOwnPropertyDescriptor */;
        const {
          foreignTargetPointer: foreignTargetPointer$LWS,
          shadowTarget: shadowTarget$LWS
        } = this;
        let safeDesc$LWS;
        try {
          foreignCallableGetOwnPropertyDescriptor$LWS(foreignTargetPointer$LWS, key$LWS, (_key$LWS, configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS) => {
            safeDesc$LWS = createDescriptorFromMeta$LWS(configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS);
            if (safeDesc$LWS.configurable === false) {
              // Update the descriptor to non-configurable on
              // the shadow target.
              ReflectDefineProperty$LWS(shadowTarget$LWS, key$LWS, safeDesc$LWS);
            }
          });
        } catch (error) {
          var _selectedTarget16$LWS;
          const errorToThrow$LWS = (_selectedTarget16$LWS = selectedTarget$LWS) != null ? _selectedTarget16$LWS : error;
          selectedTarget$LWS = undefined;
          throw errorToThrow$LWS;
        }
        // Getting forged descriptors of handshake properties is not allowed.
        if (IS_NOT_IN_SHADOW_REALM$LWS && safeDesc$LWS && (key$LWS === LOCKER_NEAR_MEMBRANE_SYMBOL$LWS || key$LWS === LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS)) {
          throw new TypeErrorCtor$LWS(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
        }
        return safeDesc$LWS;
      }
      static passthruPreventExtensionsTrap(_shadowTarget$LWS) {
        lastProxyTrapCalled$LWS = 1024 /* ProxyHandlerTraps.PreventExtensions */;
        const {
          foreignTargetPointer: foreignTargetPointer$LWS,
          shadowTarget: shadowTarget$LWS
        } = this;
        let result$LWS = true;
        if (ReflectIsExtensible$LWS(shadowTarget$LWS)) {
          let resultEnum$LWS = 0 /* PreventExtensionsResult.None */;
          try {
            resultEnum$LWS = foreignCallablePreventExtensions$LWS(foreignTargetPointer$LWS);
          } catch (error) {
            var _selectedTarget17$LWS;
            const errorToThrow$LWS = (_selectedTarget17$LWS = selectedTarget$LWS) != null ? _selectedTarget17$LWS : error;
            selectedTarget$LWS = undefined;
            throw errorToThrow$LWS;
          }
          // If the target is a proxy it might reject the
          // preventExtension call, in which case we should not
          // attempt to lock down the shadow target.
          if (!(resultEnum$LWS & 1 /* PreventExtensionsResult.Extensible */)) {
            copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget$LWS(foreignTargetPointer$LWS, shadowTarget$LWS);
            ReflectPreventExtensions$LWS(shadowTarget$LWS);
          }
          result$LWS = !(resultEnum$LWS & 2 /* PreventExtensionsResult.False */);
        }
        return result$LWS;
      }
      static passthruSetPrototypeOfTrap(_shadowTarget$LWS, proto$LWS) {
        lastProxyTrapCalled$LWS = 4096 /* ProxyHandlerTraps.SetPrototypeOf */;
        const {
          foreignTargetPointer: foreignTargetPointer$LWS
        } = this;
        const transferableProto$LWS = proto$LWS ? getTransferablePointer$LWS(proto$LWS) : proto$LWS;
        let result$LWS = false;
        try {
          result$LWS = foreignCallableSetPrototypeOf$LWS(foreignTargetPointer$LWS, transferableProto$LWS);
        } catch (error) {
          var _selectedTarget18$LWS;
          const errorToThrow$LWS = (_selectedTarget18$LWS = selectedTarget$LWS) != null ? _selectedTarget18$LWS : error;
          selectedTarget$LWS = undefined;
          throw errorToThrow$LWS;
        }
        if (useFastForeignTargetPath$LWS && result$LWS) {
          fastForeignTargetPointers$LWS.delete(foreignTargetPointer$LWS);
        }
        return result$LWS;
      }
      static passthruSetTrap(_shadowTarget$LWS, key$LWS, value$LWS, receiver$LWS) {
        lastProxyTrapCalled$LWS = 2048 /* ProxyHandlerTraps.Set */;
        const {
          foreignTargetPointer: foreignTargetPointer$LWS,
          proxy: proxy$LWS,
          shadowTarget: shadowTarget$LWS
        } = this;
        // Intentionally ignoring `document.all`.
        // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
        // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
        if (typeof value$LWS === 'undefined') {
          value$LWS = undefined;
        }
        if (typeof receiver$LWS === 'undefined') {
          receiver$LWS = proxy$LWS;
        }
        // Setting forged values of handshake properties is not allowed.
        if (IS_NOT_IN_SHADOW_REALM$LWS && (key$LWS === LOCKER_NEAR_MEMBRANE_SYMBOL$LWS || key$LWS === LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS)) {
          throw new TypeErrorCtor$LWS(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
        }
        const isFastPath$LWS = proxy$LWS === receiver$LWS;
        let result$LWS = false;
        try {
          result$LWS = isFastPath$LWS ? foreignCallableSet$LWS(foreignTargetPointer$LWS, key$LWS,
          // Inline getTransferableValue().
          typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function' ? getTransferablePointer$LWS(value$LWS) : value$LWS) : passthruForeignTraversedSet$LWS(foreignTargetPointer$LWS, shadowTarget$LWS, key$LWS, value$LWS, receiver$LWS);
        } catch (error) {
          var _selectedTarget19$LWS;
          const errorToThrow$LWS = (_selectedTarget19$LWS = selectedTarget$LWS) != null ? _selectedTarget19$LWS : error;
          selectedTarget$LWS = undefined;
          throw errorToThrow$LWS;
        }
        return result$LWS;
      }
    }
    // Logic implementation of all traps.
    // Hybrid traps:
    // (traps that operate on their shadowTarget, proxy, and foreignTargetPointer):
    BoundaryProxyHandler$LWS.hybridGetTrap = IS_IN_SHADOW_REALM$LWS ? function (_shadowTarget$LWS, key$LWS, receiver$LWS) {
      const {
        foreignTargetPointer: foreignTargetPointer$LWS,
        foreignTargetTraits: foreignTargetTraits$LWS,
        proxy: proxy$LWS,
        shadowTarget: shadowTarget$LWS
      } = this;
      let safeDesc$LWS;
      let result$LWS;
      if (useFastForeignTargetPath$LWS && fastForeignTargetPointers$LWS.has(foreignTargetPointer$LWS)) {
        let pointerOrPrimitive$LWS;
        try {
          pointerOrPrimitive$LWS = foreignCallableGetPropertyValue$LWS(foreignTargetPointer$LWS, key$LWS);
        } catch (error) {
          var _selectedTarget20$LWS;
          const errorToThrow$LWS = (_selectedTarget20$LWS = selectedTarget$LWS) != null ? _selectedTarget20$LWS : error;
          selectedTarget$LWS = undefined;
          throw errorToThrow$LWS;
        }
        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          result$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          result$LWS = pointerOrPrimitive$LWS;
        }
      } else {
        safeDesc$LWS = lookupForeignDescriptor$LWS(foreignTargetPointer$LWS, shadowTarget$LWS, key$LWS);
        if (safeDesc$LWS) {
          const {
            get: getter$LWS,
            value: localValue$LWS
          } = safeDesc$LWS;
          if (getter$LWS) {
            if (safeDesc$LWS.foreign) {
              const foreignGetterPointer$LWS = getTransferablePointer$LWS(getter$LWS);
              const transferableReceiver$LWS = proxy$LWS === receiver$LWS ? foreignTargetPointer$LWS :
              // Inline getTransferableValue().
              typeof receiver$LWS === 'object' && receiver$LWS !== null || typeof receiver$LWS === 'function' ? getTransferablePointer$LWS(receiver$LWS) : receiver$LWS;
              let pointerOrPrimitive$LWS;
              try {
                pointerOrPrimitive$LWS = foreignCallableApply$LWS(foreignGetterPointer$LWS, transferableReceiver$LWS);
              } catch (error) {
                var _selectedTarget21$LWS;
                const errorToThrow$LWS = (_selectedTarget21$LWS = selectedTarget$LWS) != null ? _selectedTarget21$LWS : error;
                selectedTarget$LWS = undefined;
                throw errorToThrow$LWS;
              }
              if (typeof pointerOrPrimitive$LWS === 'function') {
                pointerOrPrimitive$LWS();
                result$LWS = selectedTarget$LWS;
                selectedTarget$LWS = undefined;
              } else {
                result$LWS = pointerOrPrimitive$LWS;
              }
            } else {
              // Even though the getter function exists,
              // we can't use `ReflectGet()` because there
              // might be a distortion for that getter function,
              // in which case we must resolve the local getter
              // and call it instead.
              result$LWS = ReflectApply$LWS(getter$LWS, receiver$LWS, []);
            }
          } else {
            result$LWS = localValue$LWS;
          }
        } else {
          const transferableReceiver$LWS = proxy$LWS === receiver$LWS ? foreignTargetPointer$LWS :
          // Inline getTransferableValue().
          typeof receiver$LWS === 'object' && receiver$LWS !== null || typeof receiver$LWS === 'function' ? getTransferablePointer$LWS(receiver$LWS) : receiver$LWS;
          let pointerOrPrimitive$LWS;
          try {
            pointerOrPrimitive$LWS = foreignCallableGet$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS, key$LWS, transferableReceiver$LWS);
          } catch (error) {
            var _selectedTarget22$LWS;
            const errorToThrow$LWS = (_selectedTarget22$LWS = selectedTarget$LWS) != null ? _selectedTarget22$LWS : error;
            selectedTarget$LWS = undefined;
            throw errorToThrow$LWS;
          }
          if (typeof pointerOrPrimitive$LWS === 'function') {
            pointerOrPrimitive$LWS();
            result$LWS = selectedTarget$LWS;
            selectedTarget$LWS = undefined;
          } else {
            result$LWS = pointerOrPrimitive$LWS;
          }
        }
      }
      if (safeDesc$LWS === undefined && result$LWS === undefined && key$LWS === SymbolToStringTag$LWS && foreignTargetTraits$LWS & 16 /* TargetTraits.IsObject */) {
        let toStringTag$LWS;
        try {
          toStringTag$LWS = foreignCallableGetToStringTagOfTarget$LWS(foreignTargetPointer$LWS);
        } catch (error) {
          var _selectedTarget23$LWS;
          const errorToThrow$LWS = (_selectedTarget23$LWS = selectedTarget$LWS) != null ? _selectedTarget23$LWS : error;
          selectedTarget$LWS = undefined;
          throw errorToThrow$LWS;
        }
        // The default language toStringTag is "Object". If we
        // receive "Object" we return `undefined` to let the
        // language resolve it naturally without projecting a
        // value.
        if (toStringTag$LWS !== 'Object') {
          result$LWS = toStringTag$LWS;
        }
      }
      return result$LWS;
    } : noop$LWS;
    BoundaryProxyHandler$LWS.hybridGetTrapForTypedArray = IS_IN_SHADOW_REALM$LWS ? function (_shadowTarget$LWS, key$LWS, receiver$LWS) {
      const {
        foreignTargetPointer: foreignTargetPointer$LWS,
        foreignTargetTypedArrayLength: foreignTargetTypedArrayLength$LWS,
        proxy: proxy$LWS,
        shadowTarget: shadowTarget$LWS
      } = this;
      let useFastPath$LWS = useFastForeignTargetPathForTypedArrays$LWS;
      if (!useFastPath$LWS && typeof key$LWS === 'string') {
        const possibleIndex$LWS = +key$LWS;
        useFastPath$LWS = possibleIndex$LWS > -1 && possibleIndex$LWS < foreignTargetTypedArrayLength$LWS && NumberIsInteger$LWS(possibleIndex$LWS);
      }
      let result$LWS;
      if (useFastPath$LWS) {
        let pointerOrPrimitive$LWS;
        try {
          pointerOrPrimitive$LWS = foreignCallableGetPropertyValue$LWS(foreignTargetPointer$LWS, key$LWS);
        } catch (error) {
          var _selectedTarget24$LWS;
          const errorToThrow$LWS = (_selectedTarget24$LWS = selectedTarget$LWS) != null ? _selectedTarget24$LWS : error;
          selectedTarget$LWS = undefined;
          throw errorToThrow$LWS;
        }
        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          result$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          result$LWS = pointerOrPrimitive$LWS;
        }
      } else {
        const safeDesc$LWS = lookupForeignDescriptor$LWS(foreignTargetPointer$LWS, shadowTarget$LWS, key$LWS);
        if (safeDesc$LWS) {
          const {
            get: getter$LWS,
            value: localValue$LWS
          } = safeDesc$LWS;
          if (getter$LWS) {
            if (safeDesc$LWS.foreign) {
              const foreignGetterPointer$LWS = getTransferablePointer$LWS(getter$LWS);
              const transferableReceiver$LWS = proxy$LWS === receiver$LWS ? foreignTargetPointer$LWS :
              // Inline getTransferableValue().
              typeof receiver$LWS === 'object' && receiver$LWS !== null || typeof receiver$LWS === 'function' ? getTransferablePointer$LWS(receiver$LWS) : receiver$LWS;
              let pointerOrPrimitive$LWS;
              try {
                pointerOrPrimitive$LWS = foreignCallableApply$LWS(foreignGetterPointer$LWS, transferableReceiver$LWS);
              } catch (error) {
                var _selectedTarget25$LWS;
                const errorToThrow$LWS = (_selectedTarget25$LWS = selectedTarget$LWS) != null ? _selectedTarget25$LWS : error;
                selectedTarget$LWS = undefined;
                throw errorToThrow$LWS;
              }
              if (typeof pointerOrPrimitive$LWS === 'function') {
                pointerOrPrimitive$LWS();
                result$LWS = selectedTarget$LWS;
                selectedTarget$LWS = undefined;
              } else {
                result$LWS = pointerOrPrimitive$LWS;
              }
            } else {
              // Even though the getter function exists,
              // we can't use `ReflectGet()` because there
              // might be a distortion for that getter function,
              // in which case we must resolve the local getter
              // and call it instead.
              result$LWS = ReflectApply$LWS(getter$LWS, receiver$LWS, []);
            }
          } else {
            result$LWS = localValue$LWS;
          }
        }
      }
      return result$LWS;
    } : noop$LWS;
    BoundaryProxyHandler$LWS.hybridHasTrap = IS_IN_SHADOW_REALM$LWS ? function (_shadowTarget$LWS, key$LWS) {
      let trueOrProtoPointerOrNull$LWS;
      try {
        trueOrProtoPointerOrNull$LWS = foreignCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS(this.foreignTargetPointer, key$LWS);
      } catch (error) {
        var _selectedTarget26$LWS;
        const errorToThrow$LWS = (_selectedTarget26$LWS = selectedTarget$LWS) != null ? _selectedTarget26$LWS : error;
        selectedTarget$LWS = undefined;
        throw errorToThrow$LWS;
      }
      let result$LWS = false;
      if (trueOrProtoPointerOrNull$LWS === true) {
        result$LWS = true;
      } else {
        // Avoiding calling the has trap for any proto chain operation,
        // instead we implement the regular logic here in this trap.
        let currentObject$LWS;
        if (typeof trueOrProtoPointerOrNull$LWS === 'function') {
          trueOrProtoPointerOrNull$LWS();
          currentObject$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          currentObject$LWS = null;
        }
        while (currentObject$LWS) {
          if (ObjectHasOwn$LWS(currentObject$LWS, key$LWS)) {
            result$LWS = true;
            break;
          }
          currentObject$LWS = ReflectGetPrototypeOf$LWS(currentObject$LWS);
        }
      }
      return result$LWS;
    } : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.passthruGetTrap = IS_NOT_IN_SHADOW_REALM$LWS ? function (_shadowTarget$LWS, key$LWS, receiver$LWS) {
      // Only allow accessing handshake property values if the
      // "has" trap has been triggered immediately BEFORE and
      // the property does NOT exist.
      handshakePropertyFlag$LWS && (handshakePropertyFlag$LWS = lastProxyTrapCalled$LWS === 128 /* ProxyHandlerTraps.Has */);
      lastProxyTrapCalled$LWS = 16 /* ProxyHandlerTraps.Get */;
      const isNearMembraneSymbol$LWS = key$LWS === LOCKER_NEAR_MEMBRANE_SYMBOL$LWS;
      const isNearMembraneSerializedValueSymbol$LWS = key$LWS === LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS;
      if (handshakePropertyFlag$LWS) {
        // Exit without performing a [[Get]] for handshake
        // properties because we know that when the
        // `handshakePropertyFlag` is ON that there are NO
        // shadowed values.
        if (isNearMembraneSymbol$LWS) {
          return true;
        }
        if (isNearMembraneSerializedValueSymbol$LWS) {
          return this.serialize();
        }
      }
      const {
        foreignTargetPointer: foreignTargetPointer$LWS,
        foreignTargetTraits: foreignTargetTraits$LWS,
        proxy: proxy$LWS
      } = this;
      if (typeof receiver$LWS === 'undefined') {
        receiver$LWS = proxy$LWS;
      }
      const transferableReceiver$LWS = proxy$LWS === receiver$LWS ? LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS :
      // Inline getTransferableValue().
      typeof receiver$LWS === 'object' && receiver$LWS !== null || typeof receiver$LWS === 'function' ? getTransferablePointer$LWS(receiver$LWS) : receiver$LWS;
      let pointerOrPrimitive$LWS;
      try {
        pointerOrPrimitive$LWS = foreignCallableGet$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS, key$LWS, transferableReceiver$LWS);
      } catch (error) {
        var _selectedTarget27$LWS;
        const errorToThrow$LWS = (_selectedTarget27$LWS = selectedTarget$LWS) != null ? _selectedTarget27$LWS : error;
        selectedTarget$LWS = undefined;
        throw errorToThrow$LWS;
      }
      let result$LWS;
      if (typeof pointerOrPrimitive$LWS === 'function') {
        pointerOrPrimitive$LWS();
        result$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
      } else {
        result$LWS = pointerOrPrimitive$LWS;
      }
      // Getting forged values of handshake properties is not allowed.
      if (result$LWS !== undefined && (isNearMembraneSymbol$LWS || isNearMembraneSerializedValueSymbol$LWS)) {
        throw new TypeErrorCtor$LWS(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
      }
      return result$LWS;
    } : noop$LWS;
    BoundaryProxyHandler$LWS.passthruHasTrap = IS_NOT_IN_SHADOW_REALM$LWS ? function (_shadowTarget$LWS, key$LWS) {
      lastProxyTrapCalled$LWS = 128 /* ProxyHandlerTraps.Has */;
      let result$LWS;
      try {
        result$LWS = foreignCallableHas$LWS(this.foreignTargetPointer, key$LWS);
      } catch (error) {
        var _selectedTarget28$LWS;
        const errorToThrow$LWS = (_selectedTarget28$LWS = selectedTarget$LWS) != null ? _selectedTarget28$LWS : error;
        selectedTarget$LWS = undefined;
        throw errorToThrow$LWS;
      }
      const isNearMembraneSymbol$LWS = key$LWS === LOCKER_NEAR_MEMBRANE_SYMBOL$LWS;
      const isNearMembraneSerializedValueSymbol$LWS = key$LWS === LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS;
      if (result$LWS) {
        handshakePropertyFlag$LWS = false;
        // Checking the existence of forged handshake properties
        // is not allowed.
        if (isNearMembraneSymbol$LWS || isNearMembraneSerializedValueSymbol$LWS) {
          throw new TypeErrorCtor$LWS(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
        }
      } else {
        // The `handshakePropertyFlag` is ON if the handshake
        // property does NOT exist on the object or its [[Prototype]].
        handshakePropertyFlag$LWS = isNearMembraneSymbol$LWS || isNearMembraneSerializedValueSymbol$LWS;
      }
      return result$LWS;
    } : alwaysFalse$LWS;
    // Pending traps:
    BoundaryProxyHandler$LWS.pendingDefinePropertyTrap = IS_IN_SHADOW_REALM$LWS ? function (shadowTarget$LWS, key$LWS, unsafePartialDesc$LWS) {
      const {
        foreignTargetPointer: foreignTargetPointer$LWS,
        foreignTargetTraits: foreignTargetTraits$LWS
      } = this;
      // We don't wrap `foreignCallableIsTargetLive()` in a
      // try-catch because it cannot throw.
      if (foreignCallableIsTargetLive$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS)) {
        this.makeProxyLive();
      } else {
        if (useFastForeignTargetPath$LWS) {
          if (isForeignPointerOfObjectProto$LWS(foreignTargetPointer$LWS)) {
            disableFastForeignTargetPointers$LWS();
          } else if (isForeignPointerOfTypedArrayProto$LWS(foreignTargetPointer$LWS)) {
            useFastForeignTargetPathForTypedArrays$LWS = false;
          }
        }
        this.makeProxyStatic();
      }
      return this.defineProperty(shadowTarget$LWS, key$LWS, unsafePartialDesc$LWS);
    } : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.pendingDeletePropertyTrap = IS_IN_SHADOW_REALM$LWS ? function (shadowTarget$LWS, key$LWS) {
      // We don't wrap `foreignCallableIsTargetLive()` in a
      // try-catch because it cannot throw.
      if (foreignCallableIsTargetLive$LWS(this.foreignTargetPointer, this.foreignTargetTraits)) {
        this.makeProxyLive();
      } else {
        this.makeProxyStatic();
      }
      return this.deleteProperty(shadowTarget$LWS, key$LWS);
    } : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.pendingPreventExtensionsTrap = IS_IN_SHADOW_REALM$LWS ? function (shadowTarget$LWS) {
      // We don't wrap `foreignCallableIsTargetLive()` in a
      // try-catch because it cannot throw.
      if (foreignCallableIsTargetLive$LWS(this.foreignTargetPointer, this.foreignTargetTraits)) {
        this.makeProxyLive();
      } else {
        this.makeProxyStatic();
      }
      return this.preventExtensions(shadowTarget$LWS);
    } : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.pendingSetPrototypeOfTrap = IS_IN_SHADOW_REALM$LWS ? function (shadowTarget$LWS, proto$LWS) {
      const {
        foreignTargetPointer: foreignTargetPointer$LWS,
        foreignTargetTraits: foreignTargetTraits$LWS
      } = this;
      // We don't wrap `foreignCallableIsTargetLive()` in a
      // try-catch because it cannot throw.
      if (foreignCallableIsTargetLive$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS)) {
        this.makeProxyLive();
      } else {
        if (useFastForeignTargetPath$LWS) {
          if (isForeignPointerOfObjectProto$LWS(foreignTargetPointer$LWS)) {
            disableFastForeignTargetPointers$LWS();
          } else if (isForeignPointerOfTypedArrayProto$LWS(foreignTargetPointer$LWS)) {
            useFastForeignTargetPathForTypedArrays$LWS = false;
          }
        }
        this.makeProxyStatic();
      }
      return this.setPrototypeOf(shadowTarget$LWS, proto$LWS);
    } : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.pendingSetTrap = IS_IN_SHADOW_REALM$LWS ? function (shadowTarget$LWS, key$LWS, value$LWS, receiver$LWS) {
      const {
        foreignTargetPointer: foreignTargetPointer$LWS,
        foreignTargetTraits: foreignTargetTraits$LWS
      } = this;
      // We don't wrap `foreignCallableIsTargetLive()` in a
      // try-catch because it cannot throw.
      if (foreignCallableIsTargetLive$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS)) {
        this.makeProxyLive();
      } else {
        if (useFastForeignTargetPath$LWS) {
          if (isForeignPointerOfObjectProto$LWS(foreignTargetPointer$LWS)) {
            disableFastForeignTargetPointers$LWS();
          } else if (isForeignPointerOfTypedArrayProto$LWS(foreignTargetPointer$LWS)) {
            useFastForeignTargetPathForTypedArrays$LWS = false;
          }
        }
        this.makeProxyStatic();
      }
      return this.set(shadowTarget$LWS, key$LWS, value$LWS, receiver$LWS);
    } : alwaysFalse$LWS;
    //  Static traps:
    BoundaryProxyHandler$LWS.staticDefinePropertyTrap = IS_IN_SHADOW_REALM$LWS ? ReflectDefineProperty$LWS : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.staticDeletePropertyTrap = IS_IN_SHADOW_REALM$LWS ? ReflectDeleteProperty$LWS : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.staticGetOwnPropertyDescriptorTrap = IS_IN_SHADOW_REALM$LWS ? ReflectGetOwnPropertyDescriptor$LWS : noop$LWS;
    BoundaryProxyHandler$LWS.staticGetPrototypeOfTrap = IS_IN_SHADOW_REALM$LWS ? ReflectGetPrototypeOf$LWS : () => null;
    BoundaryProxyHandler$LWS.staticGetTrap = IS_IN_SHADOW_REALM$LWS ? function (shadowTarget$LWS, key$LWS, receiver$LWS) {
      const {
        foreignTargetTraits: foreignTargetTraits$LWS,
        staticToStringTag: staticToStringTag$LWS
      } = this;
      const result$LWS = ReflectGet$LWS(shadowTarget$LWS, key$LWS, receiver$LWS);
      if (result$LWS === undefined && key$LWS === SymbolToStringTag$LWS && foreignTargetTraits$LWS & 16 /* TargetTraits.IsObject */ &&
      // The default language toStringTag is "Object". If we
      // receive "Object" we return `undefined` to let the
      // language resolve it naturally without projecting a
      // value.
      staticToStringTag$LWS !== 'Object' && !(key$LWS in shadowTarget$LWS)) {
        return staticToStringTag$LWS;
      }
      return result$LWS;
    } : noop$LWS;
    BoundaryProxyHandler$LWS.staticHasTrap = IS_IN_SHADOW_REALM$LWS ? ReflectHas$LWS : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.staticIsExtensibleTrap = IS_IN_SHADOW_REALM$LWS ? ReflectIsExtensible$LWS : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.staticOwnKeysTrap = IS_IN_SHADOW_REALM$LWS ? ReflectOwnKeys$LWS : () => [];
    BoundaryProxyHandler$LWS.staticPreventExtensionsTrap = IS_IN_SHADOW_REALM$LWS ? ReflectPreventExtensions$LWS : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.staticSetPrototypeOfTrap = IS_IN_SHADOW_REALM$LWS ? ReflectSetPrototypeOf$LWS : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.staticSetTrap = IS_IN_SHADOW_REALM$LWS ? ReflectSet$LWS : alwaysFalse$LWS;
    // Default traps:
    // Pending traps are needed for the shadow realm side of the membrane
    // to avoid leaking mutation operations on the primary realm side.
    BoundaryProxyHandler$LWS.defaultDefinePropertyTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.pendingDefinePropertyTrap : BoundaryProxyHandler$LWS.passthruDefinePropertyTrap;
    BoundaryProxyHandler$LWS.defaultDeletePropertyTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.pendingDeletePropertyTrap : BoundaryProxyHandler$LWS.passthruDeletePropertyTrap;
    BoundaryProxyHandler$LWS.defaultGetOwnPropertyDescriptorTrap = BoundaryProxyHandler$LWS.passthruGetOwnPropertyDescriptorTrap;
    BoundaryProxyHandler$LWS.defaultGetPrototypeOfTrap = BoundaryProxyHandler$LWS.passthruGetPrototypeOfTrap;
    BoundaryProxyHandler$LWS.defaultGetTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.hybridGetTrap : BoundaryProxyHandler$LWS.passthruGetTrap;
    BoundaryProxyHandler$LWS.defaultHasTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.hybridHasTrap : BoundaryProxyHandler$LWS.passthruHasTrap;
    BoundaryProxyHandler$LWS.defaultIsExtensibleTrap = BoundaryProxyHandler$LWS.passthruIsExtensibleTrap;
    BoundaryProxyHandler$LWS.defaultOwnKeysTrap = BoundaryProxyHandler$LWS.passthruOwnKeysTrap;
    BoundaryProxyHandler$LWS.defaultPreventExtensionsTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.pendingPreventExtensionsTrap : BoundaryProxyHandler$LWS.passthruPreventExtensionsTrap;
    BoundaryProxyHandler$LWS.defaultSetTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.pendingSetTrap : BoundaryProxyHandler$LWS.passthruSetTrap;
    BoundaryProxyHandler$LWS.defaultSetPrototypeOfTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.pendingSetPrototypeOfTrap : BoundaryProxyHandler$LWS.passthruSetPrototypeOfTrap;
    if (IS_IN_SHADOW_REALM$LWS) {
      // Initialize `fastForeignTargetPointers` weak map.
      clearFastForeignTargetPointers$LWS();
    }
    // Export callable hooks to a foreign realm.
    foreignCallableHooksCallback$LWS(
    // globalThisPointer
    // When crossing, should be mapped to the foreign globalThis
    createPointer$LWS(globalThisRef$LWS),
    // getSelectedTarget
    IS_NOT_IN_SHADOW_REALM$LWS ? () => {
      const result$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      return result$LWS;
    } : noop$LWS,
    // getTransferableValue
    value$LWS => {
      if (typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function') {
        return getTransferablePointer$LWS(value$LWS);
      }
      // Intentionally ignoring `document.all`.
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
      return typeof value$LWS === 'undefined' ? undefined : value$LWS;
    },
    // callableGetPropertyValuePointer: this callable function allows
    // the foreign realm to access a linkable pointer for a property value.
    // In order to do that, the foreign side must provide a pointer and
    // a key access the value in order to produce a pointer
    (targetPointer$LWS, key$LWS) => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      const value$LWS = target$LWS == null ? void 0 : target$LWS[key$LWS];
      // Intentionally ignoring `document.all`.
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
      return createPointer$LWS(typeof value$LWS === 'undefined' ? undefined : value$LWS);
    },
    // callableEvaluate
    IS_IN_SHADOW_REALM$LWS ? sourceText$LWS => {
      let result$LWS;
      try {
        result$LWS = localEval$LWS(sourceText$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
      // Inline getTransferableValue().
      return typeof result$LWS === 'object' && result$LWS !== null || typeof result$LWS === 'function' ? getTransferablePointer$LWS(result$LWS) : result$LWS;
    } : noop$LWS,
    // callableLinkPointers: this callable function allows the foreign
    // realm to define a linkage between two values across the membrane.
    (targetPointer$LWS, newPointer$LWS) => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      if (typeof target$LWS === 'object' && target$LWS !== null || typeof target$LWS === 'function') {
        proxyPointerCache$LWS.set(target$LWS, newPointer$LWS);
      }
    },
    // callablePushErrorTarget
    LOCKER_DEBUGGABLE_FLAG$LWS ? (foreignTargetPointer$LWS, foreignTargetTraits$LWS, foreignTargetFunctionArity$LWS, foreignTargetFunctionName$LWS, foreignTargetTypedArrayLength$LWS) => {
      const pointer$LWS = pushTarget$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS, foreignTargetFunctionArity$LWS, foreignTargetFunctionName$LWS, foreignTargetTypedArrayLength$LWS);
      const pointerWrapper$LWS = () => {
        checkDebugMode$LWS();
        return pointer$LWS();
      };
      return pointerWrapper$LWS;
    } : pushTarget$LWS,
    // callablePushTarget: This function can be used by a foreign realm
    // to install a proxy into this realm that correspond to an object
    // from the foreign realm. It returns a Pointer that can be used by
    // the foreign realm to pass back a reference to this realm when
    // passing arguments or returning from a foreign callable invocation.
    // This function is extremely important to understand the mechanics
    // of this membrane.
    pushTarget$LWS,
    // callableApply
    (targetPointer$LWS, thisArgPointerOrUndefined$LWS, ...args$LWS) => {
      targetPointer$LWS();
      const func$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let thisArg$LWS;
      if (typeof thisArgPointerOrUndefined$LWS === 'function') {
        thisArgPointerOrUndefined$LWS();
        thisArg$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
      }
      for (let i$LWS = 0, {
          length: length$LWS
        } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const pointerOrPrimitive$LWS = args$LWS[i$LWS];
        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          args$LWS[i$LWS] = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        }
      }
      let result$LWS;
      try {
        result$LWS = ReflectApply$LWS(func$LWS, thisArg$LWS, args$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
      // Inline getTransferableValue().
      return typeof result$LWS === 'object' && result$LWS !== null || typeof result$LWS === 'function' ? getTransferablePointer$LWS(result$LWS) :
      // Intentionally ignoring `document.all`.
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
      typeof result$LWS === 'undefined' ? undefined : result$LWS;
    },
    // callableConstruct
    (targetPointer$LWS, newTargetPointerOrUndefined$LWS, ...args$LWS) => {
      targetPointer$LWS();
      const constructor$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let newTarget$LWS;
      if (typeof newTargetPointerOrUndefined$LWS === 'function') {
        newTargetPointerOrUndefined$LWS();
        newTarget$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
      }
      for (let i$LWS = 0, {
          length: length$LWS
        } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const pointerOrPrimitive$LWS = args$LWS[i$LWS];
        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          args$LWS[i$LWS] = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        }
      }
      let result$LWS;
      try {
        result$LWS = ReflectConstruct$LWS(constructor$LWS, args$LWS, newTarget$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
      // Inline getTransferableValue().
      return typeof result$LWS === 'object' && result$LWS !== null || typeof result$LWS === 'function' ? getTransferablePointer$LWS(result$LWS) :
      // Intentionally ignoring `document.all`.
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
      typeof result$LWS === 'undefined' ? undefined : result$LWS;
    },
    // callableDefineProperty
    (targetPointer$LWS, key$LWS, configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS, foreignCallableNonConfigurableDescriptorCallback$LWS) => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      const safePartialDesc$LWS = createDescriptorFromMeta$LWS(configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS);
      let result$LWS = false;
      try {
        result$LWS = ReflectDefineProperty$LWS(target$LWS, key$LWS, safePartialDesc$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
      if (result$LWS && configurable$LWS === false) {
        let safeDesc$LWS;
        try {
          safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(target$LWS, key$LWS);
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
        if (safeDesc$LWS) {
          ReflectSetPrototypeOf$LWS(safeDesc$LWS, null);
          if (safeDesc$LWS.configurable === false) {
            const {
              get: getter$LWS,
              set: setter$LWS,
              value: value$LWS
            } = safeDesc$LWS;
            foreignCallableNonConfigurableDescriptorCallback$LWS(key$LWS, false,
            // configurable
            'enumerable' in safeDesc$LWS ? safeDesc$LWS.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'writable' in safeDesc$LWS ? safeDesc$LWS.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'value' in safeDesc$LWS ?
            // Inline getTransferableValue().
            typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function' ? getTransferablePointer$LWS(value$LWS) : value$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'get' in safeDesc$LWS ?
            // Inline getTransferableValue().
            typeof getter$LWS === 'function' ? getTransferablePointer$LWS(getter$LWS) : getter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'set' in safeDesc$LWS ?
            // Inline getTransferableValue().
            typeof setter$LWS === 'function' ? getTransferablePointer$LWS(setter$LWS) : setter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS);
          }
        }
      }
      return result$LWS;
    },
    // callableDeleteProperty
    (targetPointer$LWS, key$LWS) => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      try {
        return ReflectDeleteProperty$LWS(target$LWS, key$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
    },
    // callableGet
    (targetPointer$LWS, targetTraits$LWS, key$LWS, receiverPointerOrPrimitive$LWS) => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let receiver$LWS;
      if (typeof receiverPointerOrPrimitive$LWS === 'function') {
        receiverPointerOrPrimitive$LWS();
        receiver$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
      } else {
        receiver$LWS = receiverPointerOrPrimitive$LWS === LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS ? target$LWS : receiverPointerOrPrimitive$LWS;
      }
      let result$LWS;
      try {
        result$LWS = ReflectGet$LWS(target$LWS, key$LWS, receiver$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
      // Inline getTransferableValue().
      if (typeof result$LWS === 'object' && result$LWS !== null || typeof result$LWS === 'function') {
        return getTransferablePointer$LWS(result$LWS);
      }
      if (result$LWS === undefined && key$LWS === SymbolToStringTag$LWS && targetTraits$LWS & 16 /* TargetTraits.IsObject */) {
        try {
          if (!(key$LWS in target$LWS)) {
            // Section 19.1.3.6 Object.prototype.toString()
            // https://tc39.github.io/ecma262/#sec-object.prototype.tostring
            const brand$LWS = ReflectApply$LWS(ObjectProtoToString$LWS, target$LWS, []);
            // The default language toStringTag is "Object". If
            // we receive "[object Object]" we return `undefined`
            // to let the language resolve it naturally without
            // projecting a value.
            if (brand$LWS !== '[object Object]') {
              result$LWS = ReflectApply$LWS(StringProtoSlice$LWS, brand$LWS, [8, -1]);
            }
          }
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
      }
      // Intentionally ignoring `document.all`.
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
      return typeof result$LWS === 'undefined' ? undefined : result$LWS;
    },
    // callableGetOwnPropertyDescriptor
    (targetPointer$LWS, key$LWS, foreignCallableDescriptorCallback$LWS) => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let safeDesc$LWS;
      try {
        safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(target$LWS, key$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
      if (safeDesc$LWS) {
        ReflectSetPrototypeOf$LWS(safeDesc$LWS, null);
        const {
          get: getter$LWS,
          set: setter$LWS,
          value: value$LWS
        } = safeDesc$LWS;
        foreignCallableDescriptorCallback$LWS(key$LWS, 'configurable' in safeDesc$LWS ? safeDesc$LWS.configurable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'enumerable' in safeDesc$LWS ? safeDesc$LWS.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'writable' in safeDesc$LWS ? safeDesc$LWS.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'value' in safeDesc$LWS ?
        // Inline getTransferableValue().
        typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function' ? getTransferablePointer$LWS(value$LWS) :
        // Intentionally ignoring `document.all`.
        // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
        // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
        typeof value$LWS === 'undefined' ? undefined : value$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'get' in safeDesc$LWS ?
        // Inline getTransferableValue().
        typeof getter$LWS === 'function' ? getTransferablePointer$LWS(getter$LWS) : getter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'set' in safeDesc$LWS ?
        // Inline getTransferableValue().
        typeof setter$LWS === 'function' ? getTransferablePointer$LWS(setter$LWS) : setter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS);
      }
    },
    // callableGetPrototypeOf
    targetPointer$LWS => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let proto$LWS;
      try {
        proto$LWS = ReflectGetPrototypeOf$LWS(target$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
      // Intentionally ignoring `document.all`.
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
      if (typeof proto$LWS === 'undefined') {
        return null;
      }
      return proto$LWS ? getTransferablePointer$LWS(proto$LWS) : proto$LWS;
    },
    // callableHas
    (targetPointer$LWS, key$LWS) => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      try {
        return key$LWS in target$LWS;
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
    },
    // callableIsExtensible
    targetPointer$LWS => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      try {
        return ReflectIsExtensible$LWS(target$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
    },
    // callableOwnKeys
    (targetPointer$LWS, foreignCallableKeysCallback$LWS) => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let ownKeys$LWS;
      try {
        ownKeys$LWS = ReflectOwnKeys$LWS(target$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
      ReflectApply$LWS(foreignCallableKeysCallback$LWS, undefined, ownKeys$LWS);
    },
    // callablePreventExtensions
    targetPointer$LWS => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let result$LWS = 2 /* PreventExtensionsResult.False */;
      try {
        if (ReflectPreventExtensions$LWS(target$LWS)) {
          result$LWS = 4 /* PreventExtensionsResult.True */;
        } else if (ReflectIsExtensible$LWS(target$LWS)) {
          result$LWS |= 1 /* PreventExtensionsResult.Extensible */;
        }
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
      return result$LWS;
    },
    // callableSet
    (targetPointer$LWS, key$LWS, valuePointerOrPrimitive$LWS) => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let value$LWS;
      if (typeof valuePointerOrPrimitive$LWS === 'function') {
        valuePointerOrPrimitive$LWS();
        value$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
      } else {
        value$LWS = valuePointerOrPrimitive$LWS;
      }
      try {
        return ReflectSet$LWS(target$LWS, key$LWS, value$LWS, target$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
    },
    // callableSetPrototypeOf
    (targetPointer$LWS, protoPointerOrNull$LWS = null) => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let proto$LWS;
      if (typeof protoPointerOrNull$LWS === 'function') {
        // Instead of calling `protoPointerOrNull()` directly we use
        // `ReflectApply` to avoid a Maglev (https://v8.dev/blog/maglev)
        // optimizing JIT bug in Chrome >= 117:
        // https://bugs.chromium.org/p/chromium/issues/detail?id=1494060
        ReflectApply$LWS(protoPointerOrNull$LWS, undefined, []);
        proto$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
      } else {
        proto$LWS = null;
      }
      try {
        return ReflectSetPrototypeOf$LWS(target$LWS, proto$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
    },
    // callableDebugInfo
    LOCKER_DEBUGGABLE_FLAG$LWS ? (...args$LWS) => {
      if (checkDebugMode$LWS()) {
        for (let i$LWS = 0, {
            length: length$LWS
          } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
          const pointerOrPrimitive$LWS = args$LWS[i$LWS];
          if (typeof pointerOrPrimitive$LWS === 'function') {
            pointerOrPrimitive$LWS();
            args$LWS[i$LWS] = selectedTarget$LWS;
            selectedTarget$LWS = undefined;
          }
        }
        try {
          ReflectApply$LWS(consoleInfo$LWS, consoleObject$LWS, args$LWS);
          // eslint-disable-next-line no-empty
        } catch (_unused29$LWS) {}
      }
    } : noop$LWS,
    // callableDefineProperties
    IS_IN_SHADOW_REALM$LWS ? (targetPointer$LWS, ...descriptorTuples$LWS) => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      for (let i$LWS = 0, {
          length: length$LWS
        } = descriptorTuples$LWS; i$LWS < length$LWS; i$LWS += 7) {
        // We don't use `ObjectDefineProperties()` here because it
        // will throw an exception if it fails to define one of its
        // properties.
        ReflectDefineProperty$LWS(target$LWS, descriptorTuples$LWS[i$LWS], createDescriptorFromMeta$LWS(descriptorTuples$LWS[i$LWS + 1],
        // configurable
        descriptorTuples$LWS[i$LWS + 2],
        // enumerable
        descriptorTuples$LWS[i$LWS + 3],
        // writable
        descriptorTuples$LWS[i$LWS + 4],
        // valuePointer
        descriptorTuples$LWS[i$LWS + 5],
        // getterPointer
        descriptorTuples$LWS[i$LWS + 6] // setterPointer
        ));
      }
    } : noop$LWS,
    // callableGetLazyPropertyDescriptorStateByTarget
    IS_NOT_IN_SHADOW_REALM$LWS ? targetPointer$LWS => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      // We don't wrap the weak map `get()` call in a try-catch
      // because we know `target` is an object.
      const state$LWS = proxyTargetToLazyPropertyDescriptorStateMap$LWS.get(target$LWS);
      return state$LWS ? getTransferablePointer$LWS(state$LWS) : state$LWS;
    } : noop$LWS,
    // callableGetPropertyValue
    IS_NOT_IN_SHADOW_REALM$LWS ? (targetPointer$LWS, key$LWS) => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let value$LWS;
      try {
        value$LWS = target$LWS[key$LWS];
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
      return typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function' ? getTransferablePointer$LWS(value$LWS) : value$LWS;
    } : noop$LWS,
    // callableGetTargetIntegrityTraits
    IS_NOT_IN_SHADOW_REALM$LWS ? targetPointer$LWS => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      // A target may be a proxy that is revoked or throws in its
      // "isExtensible" trap.
      try {
        if (!ReflectIsExtensible$LWS(target$LWS)) {
          if (ObjectIsFrozen$LWS(target$LWS)) {
            return 4 /* TargetIntegrityTraits.IsFrozen */ & 2 /* TargetIntegrityTraits.IsSealed */ & 1 /* TargetIntegrityTraits.IsNotExtensible */;
          }
          if (ObjectIsSealed$LWS(target$LWS)) {
            return 2 /* TargetIntegrityTraits.IsSealed */ & 1 /* TargetIntegrityTraits.IsNotExtensible */;
          }
          return 1 /* TargetIntegrityTraits.IsNotExtensible */;
        }
      } catch (_unused30$LWS) {
        try {
          isArrayOrThrowForRevoked$LWS(target$LWS);
        } catch (_unused31$LWS) {
          return 8 /* TargetIntegrityTraits.Revoked */;
        }
      }
      return 0 /* TargetIntegrityTraits.None */;
    } : () => 0 /* TargetIntegrityTraits.None */,
    // callableGetToStringTagOfTarget
    targetPointer$LWS => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      try {
        // Section 19.1.3.6 Object.prototype.toString()
        // https://tc39.github.io/ecma262/#sec-object.prototype.tostring
        const brand$LWS = ReflectApply$LWS(ObjectProtoToString$LWS, target$LWS, []);
        return brand$LWS === '[object Object]' ? 'Object' : ReflectApply$LWS(StringProtoSlice$LWS, brand$LWS, [8, -1]);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
    },
    // callableInstallErrorPrepareStackTrace
    installErrorPrepareStackTrace$LWS,
    // callableInstallLazyPropertyDescriptors
    IS_IN_SHADOW_REALM$LWS ? (targetPointer$LWS, ...ownKeysAndUnforgeableGlobalThisKeys$LWS) => {
      const sliceIndex$LWS = ReflectApply$LWS(ArrayProtoIndexOf$LWS, ownKeysAndUnforgeableGlobalThisKeys$LWS, [LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS]);
      let ownKeys$LWS;
      let unforgeableGlobalThisKeys$LWS;
      if (sliceIndex$LWS === -1) {
        ownKeys$LWS = ownKeysAndUnforgeableGlobalThisKeys$LWS;
      } else {
        ownKeys$LWS = ReflectApply$LWS(ArrayProtoSlice$LWS, ownKeysAndUnforgeableGlobalThisKeys$LWS, [0, sliceIndex$LWS]);
        unforgeableGlobalThisKeys$LWS = ReflectApply$LWS(ArrayProtoSlice$LWS, ownKeysAndUnforgeableGlobalThisKeys$LWS, [sliceIndex$LWS + 1]);
      }
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let state$LWS = getLazyPropertyDescriptorStateByTarget$LWS(target$LWS);
      if (state$LWS === undefined) {
        state$LWS = {
          __proto__: null
        };
        setLazyPropertyDescriptorStateByTarget$LWS(target$LWS, state$LWS);
      }
      for (let i$LWS = 0, {
          length: length$LWS
        } = ownKeys$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const ownKey$LWS = ownKeys$LWS[i$LWS];
        state$LWS[ownKey$LWS] = true;
        ReflectDefineProperty$LWS(target$LWS, ownKey$LWS,
        // The role of this descriptor is to serve as a
        // bouncer. When either a getter or a setter is
        // invoked the descriptor will be replaced with
        // the descriptor from the foreign side and the
        // get/set operation will carry on from there.
        {
          __proto__: null,
          // We DO explicitly set configurability in the
          // off chance that the property doesn't exist.
          configurable: true,
          // We DON'T explicitly set enumerability to
          // defer to the enumerability of the existing
          // property. In the off chance the property
          // doesn't exist the property will be defined
          // as non-enumerable.
          get() {
            activateLazyOwnPropertyDefinition$LWS(target$LWS, ownKey$LWS, state$LWS);
            return target$LWS[ownKey$LWS];
          },
          set(value$LWS) {
            activateLazyOwnPropertyDefinition$LWS(target$LWS, ownKey$LWS, state$LWS);
            ReflectSet$LWS(target$LWS, ownKey$LWS, value$LWS);
          }
        });
      }
      installPropertyDescriptorMethodWrappers$LWS(unforgeableGlobalThisKeys$LWS);
    } : noop$LWS,
    // callableIsTargetLive
    IS_NOT_IN_SHADOW_REALM$LWS && liveTargetCallback$LWS ? (targetPointer$LWS, targetTraits$LWS) => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      if (target$LWS !== ObjectProto$LWS && target$LWS !== RegExpProto$LWS) {
        try {
          return liveTargetCallback$LWS(target$LWS, targetTraits$LWS);
          // eslint-disable-next-line no-empty
        } catch (_unused32$LWS) {}
      }
      return false;
    } : alwaysFalse$LWS,
    // callableIsTargetRevoked
    IS_NOT_IN_SHADOW_REALM$LWS ? targetPointer$LWS => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      try {
        isArrayOrThrowForRevoked$LWS(target$LWS);
        return false;
        //  eslint-disable-next-line no-empty
      } catch (_unused33$LWS) {}
      return true;
    } : alwaysFalse$LWS,
    // callableSerializeTarget
    IS_IN_SHADOW_REALM$LWS ? targetPointer$LWS => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      try {
        return SymbolToStringTag$LWS in target$LWS ? serializeTargetByTrialAndError$LWS(target$LWS) :
        // Fast path.
        serializeTargetByBrand$LWS(target$LWS);
        // eslint-disable-next-line no-empty
      } catch (_unused34$LWS) {}
      return undefined;
    } : noop$LWS,
    // callableSetLazyPropertyDescriptorStateByTarget
    IS_NOT_IN_SHADOW_REALM$LWS ? (targetPointer$LWS, statePointer$LWS) => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      statePointer$LWS();
      const state$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      // We don't wrap the weak map `set()` call in a try-catch
      // because we know `target` is an object.
      proxyTargetToLazyPropertyDescriptorStateMap$LWS.set(target$LWS, state$LWS);
    } : noop$LWS,
    // callableTrackAsFastTarget
    IS_IN_SHADOW_REALM$LWS ? targetPointer$LWS => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      if (useFastForeignTargetPath$LWS) {
        fastForeignTargetPointers$LWS.add(getTransferablePointer$LWS(target$LWS));
      }
    } : noop$LWS,
    // callableBatchGetPrototypeOfAndGetOwnPropertyDescriptors
    (targetPointer$LWS, foreignCallableDescriptorsCallback$LWS) => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let unsafeDescs$LWS;
      try {
        unsafeDescs$LWS = ObjectGetOwnPropertyDescriptors$LWS(target$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
      const ownKeys$LWS = ReflectOwnKeys$LWS(unsafeDescs$LWS);
      const {
        length: length$LWS
      } = ownKeys$LWS;
      const descriptorTuples$LWS = new ArrayCtor$LWS(length$LWS * 7);
      for (let i$LWS = 0, j$LWS = 0; i$LWS < length$LWS; i$LWS += 1, j$LWS += 7) {
        const ownKey$LWS = ownKeys$LWS[i$LWS];
        const safeDesc$LWS = unsafeDescs$LWS[ownKey$LWS];
        ReflectSetPrototypeOf$LWS(safeDesc$LWS, null);
        const {
          get: getter$LWS,
          set: setter$LWS,
          value: value$LWS
        } = safeDesc$LWS;
        descriptorTuples$LWS[j$LWS] = ownKey$LWS;
        descriptorTuples$LWS[j$LWS + 1] = 'configurable' in safeDesc$LWS ? safeDesc$LWS.configurable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        descriptorTuples$LWS[j$LWS + 2] = 'enumerable' in safeDesc$LWS ? safeDesc$LWS.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        descriptorTuples$LWS[j$LWS + 3] = 'writable' in safeDesc$LWS ? safeDesc$LWS.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        descriptorTuples$LWS[j$LWS + 4] = 'value' in safeDesc$LWS ?
        // Inline getTransferableValue().
        typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function' ? getTransferablePointer$LWS(value$LWS) : value$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        descriptorTuples$LWS[j$LWS + 5] = 'get' in safeDesc$LWS ?
        // Inline getTransferableValue().
        typeof getter$LWS === 'function' ? getTransferablePointer$LWS(getter$LWS) : getter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        descriptorTuples$LWS[j$LWS + 6] = 'set' in safeDesc$LWS ?
        // Inline getTransferableValue().
        typeof setter$LWS === 'function' ? getTransferablePointer$LWS(setter$LWS) : setter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
      }
      ReflectApply$LWS(foreignCallableDescriptorsCallback$LWS, undefined, descriptorTuples$LWS);
      let proto$LWS;
      try {
        proto$LWS = ReflectGetPrototypeOf$LWS(target$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
      // Intentionally ignoring `document.all`.
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
      if (typeof proto$LWS === 'undefined') {
        return null;
      }
      return proto$LWS ? getTransferablePointer$LWS(proto$LWS) : proto$LWS;
    },
    // callableBatchGetPrototypeOfWhenHasNoOwnProperty
    (targetPointer$LWS, key$LWS) => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let proto$LWS;
      try {
        if (ObjectHasOwn$LWS(target$LWS, key$LWS)) {
          return true;
        }
        proto$LWS = ReflectGetPrototypeOf$LWS(target$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
      // Intentionally ignoring `document.all`.
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
      if (typeof proto$LWS === 'undefined') {
        return null;
      }
      return proto$LWS ? getTransferablePointer$LWS(proto$LWS) : proto$LWS;
    },
    // callableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor
    (targetPointer$LWS, key$LWS, foreignCallableDescriptorCallback$LWS) => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let safeDesc$LWS;
      try {
        safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(target$LWS, key$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
      if (safeDesc$LWS) {
        ReflectSetPrototypeOf$LWS(safeDesc$LWS, null);
        const {
          get: getter$LWS,
          set: setter$LWS,
          value: value$LWS
        } = safeDesc$LWS;
        foreignCallableDescriptorCallback$LWS(key$LWS, 'configurable' in safeDesc$LWS ? safeDesc$LWS.configurable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'enumerable' in safeDesc$LWS ? safeDesc$LWS.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'writable' in safeDesc$LWS ? safeDesc$LWS.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'value' in safeDesc$LWS ?
        // Inline getTransferableValue().
        typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function' ? getTransferablePointer$LWS(value$LWS) :
        // Intentionally ignoring `document.all`.
        // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
        // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
        typeof value$LWS === 'undefined' ? undefined : value$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'get' in safeDesc$LWS ?
        // Inline getTransferableValue().
        typeof getter$LWS === 'function' ? getTransferablePointer$LWS(getter$LWS) : getter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'set' in safeDesc$LWS ?
        // Inline getTransferableValue().
        typeof setter$LWS === 'function' ? getTransferablePointer$LWS(setter$LWS) : setter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS);
        return undefined;
      }
      let proto$LWS;
      try {
        proto$LWS = ReflectGetPrototypeOf$LWS(target$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
      // Intentionally ignoring `document.all`.
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
      if (typeof proto$LWS === 'undefined') {
        return null;
      }
      return proto$LWS ? getTransferablePointer$LWS(proto$LWS) : proto$LWS;
    });
    let foreignCallablesHooked$LWS = false;
    return (...hooks$LWS) => {
      if (foreignCallablesHooked$LWS) {
        return;
      }
      foreignCallablesHooked$LWS = true;
      ({
        // 0: globalThisPointer,
        // 1: getSelectedTarget,
        // 2: getTransferableValue,
        // 3: callableGetPropertyValuePointer,
        // 4: callableEvaluate,
        // 5: callableLinkPointers,
        6: foreignCallablePushErrorTarget$LWS,
        7: foreignCallablePushTarget$LWS,
        8: foreignCallableApply$LWS,
        9: foreignCallableConstruct$LWS,
        10: foreignCallableDefineProperty$LWS,
        11: foreignCallableDeleteProperty$LWS,
        12: foreignCallableGet$LWS,
        13: foreignCallableGetOwnPropertyDescriptor$LWS,
        14: foreignCallableGetPrototypeOf$LWS,
        15: foreignCallableHas$LWS,
        16: foreignCallableIsExtensible$LWS,
        17: foreignCallableOwnKeys$LWS,
        18: foreignCallablePreventExtensions$LWS,
        19: foreignCallableSet$LWS,
        20: foreignCallableSetPrototypeOf$LWS,
        21: foreignCallableDebugInfo$LWS,
        // 22: callableDefineProperties,
        23: foreignCallableGetLazyPropertyDescriptorStateByTarget$LWS,
        24: foreignCallableGetPropertyValue$LWS,
        25: foreignCallableGetTargetIntegrityTraits$LWS,
        26: foreignCallableGetToStringTagOfTarget$LWS,
        27: foreignCallableInstallErrorPrepareStackTrace$LWS,
        // 28: callableInstallLazyPropertyDescriptors,
        29: foreignCallableIsTargetLive$LWS,
        30: foreignCallableIsTargetRevoked$LWS,
        31: foreignCallableSerializeTarget$LWS,
        32: foreignCallableSetLazyPropertyDescriptorStateByTarget$LWS,
        // 33: callableTrackAsFastTarget,
        34: foreignCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS,
        35: foreignCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS,
        36: foreignCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS
      } = hooks$LWS);
      const applyTrapForZeroOrMoreArgs$LWS = createApplyOrConstructTrapForZeroOrMoreArgs$LWS(1 /* ProxyHandlerTraps.Apply */);
      const applyTrapForOneOrMoreArgs$LWS = createApplyOrConstructTrapForOneOrMoreArgs$LWS(1 /* ProxyHandlerTraps.Apply */);
      const applyTrapForTwoOrMoreArgs$LWS = createApplyOrConstructTrapForTwoOrMoreArgs$LWS(1 /* ProxyHandlerTraps.Apply */);
      const applyTrapForThreeOrMoreArgs$LWS = createApplyOrConstructTrapForThreeOrMoreArgs$LWS(1 /* ProxyHandlerTraps.Apply */);
      const applyTrapForFourOrMoreArgs$LWS = createApplyOrConstructTrapForFourOrMoreArgs$LWS(1 /* ProxyHandlerTraps.Apply */);
      const applyTrapForFiveOrMoreArgs$LWS = createApplyOrConstructTrapForFiveOrMoreArgs$LWS(1 /* ProxyHandlerTraps.Apply */);
      const applyTrapForAnyNumberOfArgs$LWS = createApplyOrConstructTrapForAnyNumberOfArgs$LWS(1 /* ProxyHandlerTraps.Apply */);
      const constructTrapForZeroOrMoreArgs$LWS = createApplyOrConstructTrapForZeroOrMoreArgs$LWS(2 /* ProxyHandlerTraps.Construct */);
      const constructTrapForOneOrMoreArgs$LWS = createApplyOrConstructTrapForOneOrMoreArgs$LWS(2 /* ProxyHandlerTraps.Construct */);
      const constructTrapForTwoOrMoreArgs$LWS = createApplyOrConstructTrapForTwoOrMoreArgs$LWS(2 /* ProxyHandlerTraps.Construct */);
      const constructTrapForThreeOrMoreArgs$LWS = createApplyOrConstructTrapForThreeOrMoreArgs$LWS(2 /* ProxyHandlerTraps.Construct */);
      const constructTrapForFourOrMoreArgs$LWS = createApplyOrConstructTrapForFourOrMoreArgs$LWS(2 /* ProxyHandlerTraps.Construct */);
      const constructTrapForFiveOrMoreArgs$LWS = createApplyOrConstructTrapForFiveOrMoreArgs$LWS(2 /* ProxyHandlerTraps.Construct */);
      const constructTrapForAnyNumberOfArgs$LWS = createApplyOrConstructTrapForAnyNumberOfArgs$LWS(2 /* ProxyHandlerTraps.Construct */);
      if (MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS === undefined) {
        // A minification safe way to get the 'apply' and 'construct'
        // trap property names.
        MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS = ObjectKeys$LWS({
          applyTrapForZeroOrMoreArgs: applyTrapForZeroOrMoreArgs$LWS,
          applyTrapForOneOrMoreArgs: applyTrapForOneOrMoreArgs$LWS,
          applyTrapForTwoOrMoreArgs: applyTrapForTwoOrMoreArgs$LWS,
          applyTrapForThreeOrMoreArgs: applyTrapForThreeOrMoreArgs$LWS,
          applyTrapForFourOrMoreArgs: applyTrapForFourOrMoreArgs$LWS,
          applyTrapForFiveOrMoreArgs: applyTrapForFiveOrMoreArgs$LWS,
          applyTrapForAnyNumberOfArgs: applyTrapForAnyNumberOfArgs$LWS,
          constructTrapForZeroOrMoreArgs: constructTrapForZeroOrMoreArgs$LWS,
          constructTrapForOneOrMoreArgs: constructTrapForOneOrMoreArgs$LWS,
          constructTrapForTwoOrMoreArgs: constructTrapForTwoOrMoreArgs$LWS,
          constructTrapForThreeOrMoreArgs: constructTrapForThreeOrMoreArgs$LWS,
          constructTrapForFourOrMoreArgs: constructTrapForFourOrMoreArgs$LWS,
          constructTrapForFiveOrMoreArgs: constructTrapForFiveOrMoreArgs$LWS,
          constructTrapForAnyNumberOfArgs: constructTrapForAnyNumberOfArgs$LWS
        });
      }
      applyTrapNameRegistry$LWS[0] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[0];
      applyTrapNameRegistry$LWS[1] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[1];
      applyTrapNameRegistry$LWS[2] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[2];
      applyTrapNameRegistry$LWS[3] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[3];
      applyTrapNameRegistry$LWS[4] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[4];
      applyTrapNameRegistry$LWS[5] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[5];
      applyTrapNameRegistry$LWS.n = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[6];
      constructTrapNameRegistry$LWS[0] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[7];
      constructTrapNameRegistry$LWS[1] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[8];
      constructTrapNameRegistry$LWS[2] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[9];
      constructTrapNameRegistry$LWS[3] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[10];
      constructTrapNameRegistry$LWS[4] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[11];
      constructTrapNameRegistry$LWS[5] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[12];
      constructTrapNameRegistry$LWS.n = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[13];
      const {
        prototype: BoundaryProxyHandlerProto$LWS
      } = BoundaryProxyHandler$LWS;
      BoundaryProxyHandlerProto$LWS[applyTrapNameRegistry$LWS[0]] = applyTrapForZeroOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[applyTrapNameRegistry$LWS[1]] = applyTrapForOneOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[applyTrapNameRegistry$LWS[2]] = applyTrapForTwoOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[applyTrapNameRegistry$LWS[3]] = applyTrapForThreeOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[applyTrapNameRegistry$LWS[4]] = applyTrapForFourOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[applyTrapNameRegistry$LWS[5]] = applyTrapForFiveOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[applyTrapNameRegistry$LWS.n] = applyTrapForAnyNumberOfArgs$LWS;
      BoundaryProxyHandlerProto$LWS[constructTrapNameRegistry$LWS[0]] = constructTrapForZeroOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[constructTrapNameRegistry$LWS[1]] = constructTrapForOneOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[constructTrapNameRegistry$LWS[2]] = constructTrapForTwoOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[constructTrapNameRegistry$LWS[3]] = constructTrapForThreeOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[constructTrapNameRegistry$LWS[4]] = constructTrapForFourOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[constructTrapNameRegistry$LWS[5]] = constructTrapForFiveOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[constructTrapNameRegistry$LWS.n] = constructTrapForAnyNumberOfArgs$LWS;
      ReflectSetPrototypeOf$LWS(BoundaryProxyHandlerProto$LWS, null);
    };
  };
  /* eslint-enable prefer-object-spread */
}
const createMembraneMarshallSourceInStrictMode$LWS = `
'use strict';
(${createMembraneMarshall$LWS})`;
function createBlueConnector$LWS(globalObject$LWS) {
  if (typeof globalObject$LWS !== 'object' || globalObject$LWS === null) {
    throw new TypeErrorCtor$LWS('Missing globalObject.');
  }
  return createMembraneMarshall$LWS(globalObject$LWS);
}
function createRedConnector$LWS(evaluator$LWS) {
  if (typeof evaluator$LWS !== 'function') {
    throw new TypeErrorCtor$LWS('Missing evaluator function.');
  }
  return evaluator$LWS(createMembraneMarshallSourceInStrictMode$LWS)();
}
const LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS = SymbolFor$LWS('@@lockerNearMembraneUndefinedValue');
class VirtualEnvironment$LWS {
  constructor(options$LWS) {
    if (options$LWS === undefined) {
      throw new ErrorCtor$LWS('Missing required VirtualEnvironment options.');
    }
    // prettier-ignore
    const {
      blueConnector: blueConnector$LWS,
      redConnector: redConnector$LWS,
      distortionCallback: distortionCallback$LWS,
      instrumentation: instrumentation$LWS,
      liveTargetCallback: liveTargetCallback$LWS,
      revokedProxyCallback: revokedProxyCallback$LWS,
      signSourceCallback: signSourceCallback$LWS
      // eslint-disable-next-line prefer-object-spread
    } = ObjectAssign$LWS({
      __proto__: null
    }, options$LWS);
    let blueHooks$LWS;
    const blueConnect$LWS = blueConnector$LWS('blue', (...hooks$LWS) => {
      blueHooks$LWS = hooks$LWS;
    }, {
      distortionCallback: distortionCallback$LWS,
      instrumentation: instrumentation$LWS,
      liveTargetCallback: liveTargetCallback$LWS,
      revokedProxyCallback: revokedProxyCallback$LWS
    });
    const {
      0: blueGlobalThisPointer$LWS,
      1: blueGetSelectedTarget$LWS,
      2: blueGetTransferableValue$LWS,
      3: blueCallableGetPropertyValuePointer$LWS,
      // 4: blueCallableEvaluate,
      5: blueCallableLinkPointers$LWS,
      6: blueCallablePushErrorTarget$LWS,
      7: blueCallablePushTarget$LWS,
      8: blueCallableApply$LWS,
      9: blueCallableConstruct$LWS,
      10: blueCallableDefineProperty$LWS,
      11: blueCallableDeleteProperty$LWS,
      12: blueCallableGet$LWS,
      13: blueCallableGetOwnPropertyDescriptor$LWS,
      14: blueCallableGetPrototypeOf$LWS,
      15: blueCallableHas$LWS,
      16: blueCallableIsExtensible$LWS,
      17: blueCallableOwnKeys$LWS,
      18: blueCallablePreventExtensions$LWS,
      19: blueCallableSet$LWS,
      20: blueCallableSetPrototypeOf$LWS,
      // 21: blueCallableDebugInfo,
      // 22: blueCallableDefineProperties,
      23: blueCallableGetLazyPropertyDescriptorStateByTarget$LWS,
      24: blueCallableGetPropertyValue$LWS,
      25: blueCallableGetTargetIntegrityTraits$LWS,
      26: blueCallableGetToStringTagOfTarget$LWS,
      27: blueCallableInstallErrorPrepareStackTrace$LWS,
      // 28: blueCallableInstallLazyPropertyDescriptors,
      29: blueCallableIsTargetLive$LWS,
      // 30: blueCallableIsTargetRevoked,
      // 31: blueCallableSerializeTarget,
      32: blueCallableSetLazyPropertyDescriptorStateByTarget$LWS,
      // 33: blueTrackAsFastTarget,
      34: blueCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS,
      35: blueCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS,
      36: blueCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS
    } = blueHooks$LWS;
    let redHooks$LWS;
    const redConnect$LWS = redConnector$LWS('red', (...hooks$LWS) => {
      redHooks$LWS = hooks$LWS;
    });
    const {
      0: redGlobalThisPointer$LWS,
      // 1: redGetSelectedTarget,
      // 2: redGetTransferableValue,
      3: redCallableGetPropertyValuePointer$LWS,
      4: redCallableEvaluate$LWS,
      5: redCallableLinkPointers$LWS,
      6: redCallablePushErrorTarget$LWS,
      7: redCallablePushTarget$LWS,
      8: redCallableApply$LWS,
      9: redCallableConstruct$LWS,
      10: redCallableDefineProperty$LWS,
      11: redCallableDeleteProperty$LWS,
      12: redCallableGet$LWS,
      13: redCallableGetOwnPropertyDescriptor$LWS,
      14: redCallableGetPrototypeOf$LWS,
      15: redCallableHas$LWS,
      16: redCallableIsExtensible$LWS,
      17: redCallableOwnKeys$LWS,
      18: redCallablePreventExtensions$LWS,
      19: redCallableSet$LWS,
      20: redCallableSetPrototypeOf$LWS,
      21: redCallableDebugInfo$LWS,
      22: redCallableDefineProperties$LWS,
      23: redCallableGetLazyPropertyDescriptorStateByTarget$LWS,
      // 24: redCallableGetPropertyValue,
      25: redCallableGetTargetIntegrityTraits$LWS,
      26: redCallableGetToStringTagOfTarget$LWS,
      27: redCallableInstallErrorPrepareStackTrace$LWS,
      28: redCallableInstallLazyPropertyDescriptors$LWS,
      // 29: redCallableIsTargetLive,
      30: redCallableIsTargetRevoked$LWS,
      31: redCallableSerializeTarget$LWS,
      32: redCallableSetLazyPropertyDescriptorStateByTarget$LWS,
      33: redCallableTrackAsFastTarget$LWS,
      34: redCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS,
      35: redCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS,
      36: redCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS
    } = redHooks$LWS;
    blueConnect$LWS(noop$LWS,
    // redGlobalThisPointer,
    noop$LWS,
    // redGetSelectedTarget,
    noop$LWS,
    // redGetTransferableValue,
    noop$LWS,
    // redCallableGetPropertyValuePointer,
    noop$LWS,
    // redCallableEvaluate,
    noop$LWS,
    // redCallableLinkPointers,
    redCallablePushErrorTarget$LWS, redCallablePushTarget$LWS, redCallableApply$LWS, redCallableConstruct$LWS, redCallableDefineProperty$LWS, redCallableDeleteProperty$LWS, redCallableGet$LWS, redCallableGetOwnPropertyDescriptor$LWS, redCallableGetPrototypeOf$LWS, redCallableHas$LWS, redCallableIsExtensible$LWS, redCallableOwnKeys$LWS, redCallablePreventExtensions$LWS, redCallableSet$LWS, redCallableSetPrototypeOf$LWS, redCallableDebugInfo$LWS, noop$LWS,
    // redCallableDefineProperties,
    redCallableGetLazyPropertyDescriptorStateByTarget$LWS, noop$LWS,
    // redCallableGetPropertyValue,
    redCallableGetTargetIntegrityTraits$LWS, redCallableGetToStringTagOfTarget$LWS, redCallableInstallErrorPrepareStackTrace$LWS, noop$LWS,
    // redCallableInstallLazyPropertyDescriptors,
    noop$LWS,
    // redCallableIsTargetLive,
    redCallableIsTargetRevoked$LWS, redCallableSerializeTarget$LWS, redCallableSetLazyPropertyDescriptorStateByTarget$LWS, redCallableTrackAsFastTarget$LWS, redCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS, redCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS, redCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS);
    redConnect$LWS(noop$LWS,
    // blueGlobalThisPointer,
    noop$LWS,
    // blueGetSelectedTarget,
    noop$LWS,
    // blueGetTransferableValue,
    noop$LWS,
    // blueCallableGetPropertyValuePointer,
    noop$LWS,
    // blueCallableEvaluate,
    noop$LWS,
    // blueCallableLinkPointers,
    blueCallablePushErrorTarget$LWS, blueCallablePushTarget$LWS, blueCallableApply$LWS, blueCallableConstruct$LWS, blueCallableDefineProperty$LWS, blueCallableDeleteProperty$LWS, blueCallableGet$LWS, blueCallableGetOwnPropertyDescriptor$LWS, blueCallableGetPrototypeOf$LWS, blueCallableHas$LWS, blueCallableIsExtensible$LWS, blueCallableOwnKeys$LWS, blueCallablePreventExtensions$LWS, blueCallableSet$LWS, blueCallableSetPrototypeOf$LWS, noop$LWS,
    // blueCallableDebugInfo
    noop$LWS,
    // blueCallableDefineProperties,
    blueCallableGetLazyPropertyDescriptorStateByTarget$LWS, blueCallableGetPropertyValue$LWS, blueCallableGetTargetIntegrityTraits$LWS, blueCallableGetToStringTagOfTarget$LWS, blueCallableInstallErrorPrepareStackTrace$LWS, noop$LWS,
    // blueCallableInstallLazyPropertyDescriptors,
    blueCallableIsTargetLive$LWS, noop$LWS,
    // blueCallableIsTargetRevoked,
    noop$LWS,
    // blueCallableSerializeTarget,,
    blueCallableSetLazyPropertyDescriptorStateByTarget$LWS, noop$LWS,
    // blueCallableTrackAsFastTarget,
    blueCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS, blueCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS, blueCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS);
    this.blueGlobalThisPointer = blueGlobalThisPointer$LWS;
    this.blueGetSelectedTarget = blueGetSelectedTarget$LWS;
    this.blueGetTransferableValue = blueGetTransferableValue$LWS;
    this.blueCallableGetPropertyValuePointer = blueCallableGetPropertyValuePointer$LWS;
    this.blueCallableLinkPointers = blueCallableLinkPointers$LWS;
    // Ensure the `this` context of red callable functions is `undefined`.
    this.redGlobalThisPointer = () => redGlobalThisPointer$LWS();
    this.redCallableGetPropertyValuePointer = (targetPointer$LWS, key$LWS) => redCallableGetPropertyValuePointer$LWS(targetPointer$LWS, key$LWS);
    this.redCallableEvaluate = signSourceCallback$LWS ? sourceText$LWS => redCallableEvaluate$LWS(signSourceCallback$LWS(sourceText$LWS)) : sourceText$LWS => redCallableEvaluate$LWS(sourceText$LWS);
    this.redCallableLinkPointers = (targetPointer$LWS, foreignTargetPointer$LWS) => redCallableLinkPointers$LWS(targetPointer$LWS, foreignTargetPointer$LWS);
    this.redCallableSetPrototypeOf = (targetPointer$LWS, protoPointerOrNull$LWS) => redCallableSetPrototypeOf$LWS(targetPointer$LWS, protoPointerOrNull$LWS);
    this.redCallableDefineProperties = (targetPointer$LWS, ...descriptorTuples$LWS) => {
      const {
        length: length$LWS
      } = descriptorTuples$LWS;
      const args$LWS = new ArrayCtor$LWS(length$LWS + 1);
      args$LWS[0] = targetPointer$LWS;
      for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
        args$LWS[i$LWS + 1] = descriptorTuples$LWS[i$LWS];
      }
      ReflectApply$LWS(redCallableDefineProperties$LWS, undefined, args$LWS);
    };
    this.redCallableInstallLazyPropertyDescriptors = (targetPointer$LWS, ...ownKeysAndUnforgeableGlobalThisKeys$LWS) => {
      const {
        length: length$LWS
      } = ownKeysAndUnforgeableGlobalThisKeys$LWS;
      const args$LWS = new ArrayCtor$LWS(length$LWS + 1);
      args$LWS[0] = targetPointer$LWS;
      for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
        args$LWS[i$LWS + 1] = ownKeysAndUnforgeableGlobalThisKeys$LWS[i$LWS];
      }
      ReflectApply$LWS(redCallableInstallLazyPropertyDescriptors$LWS, undefined, args$LWS);
    };
    this.redCallableTrackAsFastTarget = targetPointer$LWS => redCallableTrackAsFastTarget$LWS(targetPointer$LWS);
  }
  evaluate(sourceText$LWS) {
    try {
      const bluePointerOrPrimitiveValue$LWS = this.redCallableEvaluate(sourceText$LWS);
      if (typeof bluePointerOrPrimitiveValue$LWS === 'function') {
        bluePointerOrPrimitiveValue$LWS();
        return this.blueGetSelectedTarget();
      }
      return bluePointerOrPrimitiveValue$LWS;
    } catch (error) {
      var _this$blueGetSelected$LWS;
      throw (_this$blueGetSelected$LWS = this.blueGetSelectedTarget()) != null ? _this$blueGetSelected$LWS : error;
    }
  }
  lazyRemapProperties(target$LWS, ownKeys$LWS, unforgeableGlobalThisKeys$LWS) {
    if (typeof target$LWS === 'object' && target$LWS !== null || typeof target$LWS === 'function') {
      const args$LWS = [this.blueGetTransferableValue(target$LWS)];
      ReflectApply$LWS(ArrayProtoPush$LWS, args$LWS, ownKeys$LWS);
      if (unforgeableGlobalThisKeys$LWS != null && unforgeableGlobalThisKeys$LWS.length) {
        // Use `LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL` to delimit
        // `ownKeys` and `unforgeableGlobalThisKeys`.
        args$LWS[args$LWS.length] = LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        ReflectApply$LWS(ArrayProtoPush$LWS, args$LWS, unforgeableGlobalThisKeys$LWS);
      }
      ReflectApply$LWS(this.redCallableInstallLazyPropertyDescriptors, undefined, args$LWS);
    }
  }
  link(...keys$LWS) {
    let bluePointer$LWS = this.blueGlobalThisPointer;
    let redPointer$LWS = this.redGlobalThisPointer;
    for (let i$LWS = 0, {
        length: length$LWS
      } = keys$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const key$LWS = keys$LWS[i$LWS];
      bluePointer$LWS = this.blueCallableGetPropertyValuePointer(bluePointer$LWS, key$LWS);
      redPointer$LWS = this.redCallableGetPropertyValuePointer(redPointer$LWS, key$LWS);
      this.redCallableLinkPointers(redPointer$LWS, bluePointer$LWS);
      this.blueCallableLinkPointers(bluePointer$LWS, redPointer$LWS);
    }
  }
  remapProperties(target$LWS, unsafeBlueDescs$LWS) {
    if (typeof target$LWS === 'object' && target$LWS !== null || typeof target$LWS === 'function') {
      const targetPointer$LWS = this.blueGetTransferableValue(target$LWS);
      const ownKeys$LWS = ReflectOwnKeys$LWS(unsafeBlueDescs$LWS);
      const {
        length: length$LWS
      } = ownKeys$LWS;
      const args$LWS = new ArrayCtor$LWS(1 + length$LWS * 7);
      args$LWS[0] = targetPointer$LWS;
      for (let i$LWS = 0, j$LWS = 1; i$LWS < length$LWS; i$LWS += 1, j$LWS += 7) {
        const ownKey$LWS = ownKeys$LWS[i$LWS];
        const unsafeBlueDesc$LWS = unsafeBlueDescs$LWS[ownKey$LWS];
        // Avoid poisoning by only installing own properties from unsafeBlueDescs.
        // We don't use a toSafeDescriptor() style helper since that mutates
        // the unsafeBlueDesc.
        // eslint-disable-next-line prefer-object-spread
        const safeBlueDesc$LWS = ObjectAssign$LWS({
          __proto__: null
        }, unsafeBlueDesc$LWS);
        args$LWS[j$LWS] = ownKey$LWS;
        args$LWS[j$LWS + 1] = 'configurable' in safeBlueDesc$LWS ? !!safeBlueDesc$LWS.configurable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        args$LWS[j$LWS + 2] = 'enumerable' in safeBlueDesc$LWS ? !!safeBlueDesc$LWS.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        args$LWS[j$LWS + 3] = 'writable' in safeBlueDesc$LWS ? !!safeBlueDesc$LWS.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        args$LWS[j$LWS + 4] = 'value' in safeBlueDesc$LWS ? this.blueGetTransferableValue(safeBlueDesc$LWS.value) : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        args$LWS[j$LWS + 5] = 'get' in safeBlueDesc$LWS ? this.blueGetTransferableValue(safeBlueDesc$LWS.get) : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        args$LWS[j$LWS + 6] = 'set' in safeBlueDesc$LWS ? this.blueGetTransferableValue(safeBlueDesc$LWS.set) : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
      }
      ReflectApply$LWS(this.redCallableDefineProperties, this, args$LWS);
    }
  }
  remapProto(target$LWS, proto$LWS) {
    if (typeof target$LWS === 'object' && target$LWS !== null || typeof target$LWS === 'function') {
      const foreignTargetPointer$LWS = this.blueGetTransferableValue(target$LWS);
      const transferableProto$LWS = proto$LWS ? this.blueGetTransferableValue(proto$LWS) : proto$LWS;
      this.redCallableSetPrototypeOf(foreignTargetPointer$LWS, transferableProto$LWS);
    }
  }
  trackAsFastTarget(target$LWS) {
    if (typeof target$LWS === 'object' && target$LWS !== null || typeof target$LWS === 'function') {
      this.redCallableTrackAsFastTarget(this.blueGetTransferableValue(target$LWS));
    }
  }
}

/**
 * This list must be in sync with ecma-262, anything new added to the global object
 * should be considered, to decide whether or not they need remapping. The default
 * behavior, if missing form the following list, is to be remapped, which is safer.
 *
 * Note: remapped means the functionality is provided by the blue realm, rather than
 * the red one. This helps with the identity discontinuity issue, e.g.: all Set objects
 * have the same identity because it is always derived from the outer realm's Set.
 *
 * Note 1: We have identified 3 types of intrinsics
 * A: primitives driven intrinsics
 * B: syntax driven intrinsics (they usually have a imperative form as well)
 * C: imperative only intrinsics
 *
 * While A is not remapped, it is safe, and works fast that way, and C is remapped to
 * preserve the identity of all produced objects from the same realm, B is really
 * problematic, and requires a lot more work to guarantee that objects from both sides
 * can be considered equivalents (without identity discontinuity).
 */
function getESGlobalKeys$LWS(maxPerfMode$LWS) {
  const ESGlobalKeys$LWS = [
  // *** 19.1 Value Properties of the Global Object
  'globalThis', 'Infinity', 'NaN', 'undefined',
  // *** 19.2 Function Properties of the Global Object
  // 'eval', // dangerous & Reflective
  'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent',
  // *** 19.3 Constructor Properties of the Global Object
  // 'AggregateError', // Reflective
  // 'Array', // Reflective
  'BigInt', 'Boolean',
  // 'Date', // Remapped
  // 'Error', // Reflective
  // 'EvalError', // Reflective
  'FinalizationRegistry',
  // 'Function', // dangerous & Reflective
  'Map', 'Number',
  // 'Object', // Reflective
  // Allow blue `Promise` constructor to overwrite the Red one so that promises
  // created by the `Promise` constructor or APIs like `fetch` will work.
  // 'Promise', // Remapped
  // 'Proxy', // Reflective
  // 'RangeError', // Reflective
  // 'ReferenceError', // Reflective
  'RegExp', 'Set', 'String', 'Symbol',
  // 'SyntaxError', // Reflective
  // 'TypeError', // Reflective
  // 'URIError', // Reflective
  'WeakMap', 'WeakSet', 'WeakRef',
  // *** 18.4 Other Properties of the Global Object
  // 'Atomics', // Remapped
  'JSON', 'Math', 'Reflect',
  // *** Annex B
  'escape', 'unescape'
  // *** ECMA-402
  // 'Intl',  // Remapped
  ];
  // This set is for maxPerfMode, all of these must be from the same global object
  const maxPerfModeKeys$LWS = {
    intrinsics: ['ArrayBuffer', 'Atomics', 'BigInt64Array', 'BigUint64Array', 'DataView', 'Float32Array', 'Float64Array', 'Int16Array', 'Int32Array', 'Int8Array', 'SharedArrayBuffer', 'Uint16Array', 'Uint32Array', 'Uint8Array', 'Uint8ClampedArray'],
    // Ideally these should come from browser-realm, that's a code reorg improvement for later
    browser: ['Blob', 'crypto', 'Crypto', 'File', 'FileReader', 'SubtleCrypto', 'URL']
  };
  if (maxPerfMode$LWS) {
    ESGlobalKeys$LWS.push(...maxPerfModeKeys$LWS.intrinsics, ...maxPerfModeKeys$LWS.browser);
  }
  return ESGlobalKeys$LWS;
}
// These are foundational things that should never be wrapped but are equivalent
// @TODO: Revisit this list.
const ReflectiveIntrinsicObjectNames$LWS = ['AggregateError', 'Array', 'Error', 'EvalError', 'Function', 'Object', 'Proxy', 'RangeError', 'ReferenceError', 'SyntaxError', 'TypeError', 'URIError', 'eval', 'globalThis'];
function getESGlobalsAndReflectiveIntrinsicObjectNames$LWS(maxPerfMode$LWS) {
  const ESGlobalKeys$LWS = getESGlobalKeys$LWS(maxPerfMode$LWS);
  return toSafeArray$LWS([...ESGlobalKeys$LWS, ...ReflectiveIntrinsicObjectNames$LWS]);
}
function getGlobalObjectOwnKeys$LWS(source$LWS) {
  const ownKeys$LWS = ReflectOwnKeys$LWS(source$LWS);
  // WKWebView incorrectly excludes the 'webkit' own property of the global
  // object from `Object.keys()` and `Reflect.ownKeys()` results, so add it.
  // istanbul ignore if: currently unreachable via tests
  if (ObjectHasOwn$LWS(source$LWS, 'webkit') && !ReflectApply$LWS(ArrayProtoIncludes$LWS, ownKeys$LWS, ['webkit'])) {
    ownKeys$LWS[ownKeys$LWS.length] = 'webkit';
  }
  return ownKeys$LWS;
}
function assignFilteredGlobalDescriptorsFromPropertyDescriptorMap$LWS(descs$LWS, source$LWS, maxPerfMode$LWS) {
  const ownKeys$LWS = getGlobalObjectOwnKeys$LWS(source$LWS);
  const ESGlobalsAndReflectiveIntrinsicObjectNames$LWS = getESGlobalsAndReflectiveIntrinsicObjectNames$LWS(maxPerfMode$LWS);
  for (let i$LWS = 0, {
      length: length$LWS
    } = ownKeys$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const ownKey$LWS = ownKeys$LWS[i$LWS];
    // Avoid overriding ECMAScript global names that correspond to
    // global intrinsics. This guarantee that those entries will be
    // ignored if present in the source property descriptor map.
    if (!ESGlobalsAndReflectiveIntrinsicObjectNames$LWS.includes(ownKey$LWS)) {
      const unsafeDesc$LWS = source$LWS[ownKey$LWS];
      if (unsafeDesc$LWS) {
        // Avoid poisoning by only installing own properties from
        // unsafeDesc. We don't use a toSafeDescriptor() style helper
        // since that mutates the unsafeBlueDesc.
        // eslint-disable-next-line prefer-object-spread
        descs$LWS[ownKey$LWS] = ObjectAssign$LWS({
          __proto__: null
        }, unsafeDesc$LWS);
      }
    }
  }
  return descs$LWS;
}
function getFilteredGlobalOwnKeys$LWS(source$LWS, maxPerfMode$LWS) {
  const result$LWS = [];
  let resultOffset$LWS = 0;
  const ownKeys$LWS = getGlobalObjectOwnKeys$LWS(source$LWS);
  const ESGlobalsAndReflectiveIntrinsicObjectNames$LWS = getESGlobalsAndReflectiveIntrinsicObjectNames$LWS(maxPerfMode$LWS);
  for (let i$LWS = 0, {
      length: length$LWS
    } = ownKeys$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const ownKey$LWS = ownKeys$LWS[i$LWS];
    // Avoid overriding ECMAScript global names that correspond to global
    // intrinsics. This guarantees that those entries will be ignored if
    // present in the source object.
    if (!ESGlobalsAndReflectiveIntrinsicObjectNames$LWS.includes(ownKey$LWS)) {
      result$LWS[resultOffset$LWS++] = ownKey$LWS;
    }
  }
  return result$LWS;
}
function linkIntrinsics$LWS(env$LWS, globalObject$LWS) {
  // Remap intrinsics that are realm agnostic.
  for (let i$LWS = 0, {
      length: length$LWS
    } = ReflectiveIntrinsicObjectNames$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const globalName$LWS = ReflectiveIntrinsicObjectNames$LWS[i$LWS];
    const reflectiveValue$LWS = globalObject$LWS[globalName$LWS];
    if (reflectiveValue$LWS) {
      // Proxy.prototype is undefined.
      if (reflectiveValue$LWS.prototype) {
        env$LWS.link(globalName$LWS, 'prototype');
      } else {
        env$LWS.link(globalName$LWS);
      }
    }
  }
}
const blueDocumentToRecordMap$LWS = toSafeWeakMap$LWS(new WeakMap());
// Chromium based browsers have a bug that nulls the result of `window`
// getters in detached iframes when the property descriptor of `window.window`
// is retrieved.
// https://bugs.chromium.org/p/chromium/issues/detail?id=1305302
const unforgeablePoisonedWindowKeys$LWS = IS_CHROMIUM_BROWSER$LWS ? ['window'] : undefined;
function getCachedGlobalObjectReferences$LWS(globalObject$LWS) {
  const {
    window: window$LWS
  } = globalObject$LWS;
  let record$LWS;
  let document$LWS;
  // Suppress errors thrown on cross-origin opaque windows.
  try {
    ({
      document: document$LWS
    } = globalObject$LWS);
    record$LWS = blueDocumentToRecordMap$LWS.get(document$LWS);
    // eslint-disable-next-line no-empty
  } catch (_unused$LWS) {
    return undefined;
  }
  if (record$LWS) {
    return record$LWS;
  }
  // Cache references to object values that can't be replaced
  // window -> Window -> WindowProperties -> EventTarget
  const WindowProto$LWS = ReflectGetPrototypeOf$LWS(window$LWS);
  const WindowPropertiesProto$LWS = ReflectGetPrototypeOf$LWS(WindowProto$LWS);
  const EventTargetProto$LWS = ReflectGetPrototypeOf$LWS(WindowPropertiesProto$LWS);
  record$LWS = {
    document: document$LWS,
    DocumentProto: ReflectGetPrototypeOf$LWS(document$LWS),
    window: window$LWS,
    WindowProto: ReflectGetPrototypeOf$LWS(window$LWS),
    WindowPropertiesProto: ReflectGetPrototypeOf$LWS(WindowProto$LWS),
    EventTargetProto: EventTargetProto$LWS,
    // Some simulated browser environments, e.g. those using JSDOM, may lack an EventTargetProto.
    EventTargetProtoOwnKeys: EventTargetProto$LWS ? ReflectOwnKeys$LWS(EventTargetProto$LWS) : []
  };
  blueDocumentToRecordMap$LWS.set(document$LWS, record$LWS);
  return record$LWS;
}
function filterWindowKeys$LWS(keys$LWS) {
  const excludedKeys$LWS = new SetCtor$LWS(['document', 'location', 'top', 'window']);
  const result$LWS = [];
  let resultOffset$LWS = 0;
  for (let i$LWS = 0, {
      length: length$LWS
    } = keys$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const key$LWS = keys$LWS[i$LWS];
    if (ReflectApply$LWS(SetProtoHas$LWS, excludedKeys$LWS, [key$LWS])) {
      continue;
    }
    result$LWS[resultOffset$LWS++] = key$LWS;
  }
  return result$LWS;
}
/**
 * global descriptors are a combination of 3 set of descriptors:
 * - first, the key of the red descriptors define the descriptors
 *   provided by the browser when creating a brand new window.
 * - second, once we know the base keys, we get the actual descriptors
 *   from the blueDescriptors, since those are the one we want to provide
 *   access to via the membrane.
 * - third, the user of this library can provide endowments, which define
 *   global descriptors that should be installed into the sandbox on top
 *   of the base descriptors.
 *
 * Note: The main reason for using redDescriptors as the base keys instead
 * of blueDescriptor is because there is no guarantee that this library is
 * the first one to be evaluated in the host app, which means it has no ways
 * to determine what is a real DOM API vs app specific globals.
 *
 * Quirk: The only quirk here is for the case in which this library runs
 * after some other code that patches some of the DOM APIs. This means
 * the installed proxy in the sandbox will point to the patched global
 * API in the blue realm, rather than the original, because we don't have
 * a way to access the original anymore. This should not be a deal-breaker
 * if the patched API behaves according to the spec.
 *
 * The result of this method is a descriptor map that contains everything
 * that will be installed (via the membrane) as global descriptors in
 * the red realm.
 */
function removeWindowDescriptors$LWS(unsafeDescs$LWS) {
  // Remove unforgeable descriptors that cannot be installed.
  ReflectDeleteProperty$LWS(unsafeDescs$LWS, 'document');
  ReflectDeleteProperty$LWS(unsafeDescs$LWS, 'location');
  ReflectDeleteProperty$LWS(unsafeDescs$LWS, 'top');
  ReflectDeleteProperty$LWS(unsafeDescs$LWS, 'window');
  // Remove other browser specific unforgeables.
  ReflectDeleteProperty$LWS(unsafeDescs$LWS, 'chrome');
  return unsafeDescs$LWS;
}
/**
 * Initialization operation to capture and cache all unforgeable references
 * and their respective descriptor maps before any other code runs, this
 * usually help because this library runs before anything else that can poison
 * the environment.
 */
getCachedGlobalObjectReferences$LWS(rootWindow$LWS);
const IFRAME_SANDBOX_ATTRIBUTE_VALUE$LWS = 'allow-same-origin allow-scripts';
const revoked$LWS = toSafeWeakSet$LWS(new WeakSetCtor$LWS());
const blueCreateHooksCallbackCache$LWS = toSafeWeakMap$LWS(new WeakMapCtor$LWS());
function createDetachableIframe$LWS(doc$LWS) {
  var _ReflectApply$LWS;
  const iframe$LWS = ReflectApply$LWS(DocumentProtoCreateElement$LWS, doc$LWS, ['iframe']);
  // It is impossible to test whether the NodeProtoLastChildGetter branch is
  // reached in a normal Karma test environment.
  const parent$LWS = (_ReflectApply$LWS = ReflectApply$LWS(DocumentProtoBodyGetter$LWS, doc$LWS, [])) != null ? _ReflectApply$LWS : /* istanbul ignore next */ReflectApply$LWS(NodeProtoLastChildGetter$LWS, doc$LWS, []);
  const style$LWS = ReflectApply$LWS(HTMLElementProtoStyleGetter$LWS, iframe$LWS, []);
  style$LWS.display = 'none';
  ReflectApply$LWS(ElementProtoSetAttribute$LWS, iframe$LWS, ['sandbox', IFRAME_SANDBOX_ATTRIBUTE_VALUE$LWS]);
  ReflectApply$LWS(NodeProtoAppendChild$LWS, parent$LWS, [iframe$LWS]);
  return iframe$LWS;
}
function createIframeVirtualEnvironment$LWS(globalObject$LWS, providedOptions$LWS) {
  if (typeof globalObject$LWS !== 'object' || globalObject$LWS === null) {
    throw new TypeErrorCtor$LWS('Missing global object virtualization target.');
  }
  const blueRefs$LWS = getCachedGlobalObjectReferences$LWS(globalObject$LWS);
  if (typeof blueRefs$LWS !== 'object' || blueRefs$LWS === null) {
    throw new TypeErrorCtor$LWS('Invalid virtualization target.');
  }
  const {
    distortionCallback: distortionCallback$LWS,
    defaultPolicy: defaultPolicy$LWS,
    endowments: endowments$LWS,
    globalObjectShape: globalObjectShape$LWS,
    instrumentation: instrumentation$LWS,
    keepAlive: keepAlive$LWS = true,
    liveTargetCallback: liveTargetCallback$LWS,
    maxPerfMode: maxPerfMode$LWS = false,
    signSourceCallback: signSourceCallback$LWS
    // eslint-disable-next-line prefer-object-spread
  } = ObjectAssign$LWS({
    __proto__: null
  }, providedOptions$LWS);
  const iframe$LWS = createDetachableIframe$LWS(blueRefs$LWS.document);
  const redWindow$LWS = ReflectApply$LWS(HTMLIFrameElementProtoContentWindowGetter$LWS, iframe$LWS, []);
  const shouldUseDefaultGlobalOwnKeys$LWS = typeof globalObjectShape$LWS !== 'object' || globalObjectShape$LWS === null;
  const defaultGlobalOwnKeys$LWS = filterWindowKeys$LWS(getFilteredGlobalOwnKeys$LWS(redWindow$LWS, maxPerfMode$LWS));
  let blueConnector$LWS = blueCreateHooksCallbackCache$LWS.get(blueRefs$LWS.document);
  if (blueConnector$LWS === undefined) {
    blueConnector$LWS = createBlueConnector$LWS(globalObject$LWS);
    blueCreateHooksCallbackCache$LWS.set(blueRefs$LWS.document, blueConnector$LWS);
  }
  // Install default TrustedTypes policy in the virtual environment.
  // @ts-ignore trustedTypes does not exist on GlobalObject
  if (typeof redWindow$LWS.trustedTypes !== 'undefined' && isObject$LWS(defaultPolicy$LWS)) {
    // @ts-ignore trustedTypes does not exist on GlobalObject
    redWindow$LWS.trustedTypes.createPolicy('default', defaultPolicy$LWS);
  }
  const {
    eval: redIndirectEval$LWS
  } = redWindow$LWS;
  const env$LWS = new VirtualEnvironment$LWS({
    blueConnector: blueConnector$LWS,
    redConnector: createRedConnector$LWS(signSourceCallback$LWS ? sourceText$LWS => redIndirectEval$LWS(signSourceCallback$LWS(sourceText$LWS)) : redIndirectEval$LWS),
    distortionCallback: distortionCallback$LWS,
    instrumentation: instrumentation$LWS,
    liveTargetCallback: liveTargetCallback$LWS,
    revokedProxyCallback: keepAlive$LWS ? revokedProxyCallback$LWS : undefined,
    signSourceCallback: signSourceCallback$LWS
  });
  linkIntrinsics$LWS(env$LWS, globalObject$LWS);
  // window
  // window.document
  // In browsers globalThis is === window.
  if (typeof globalThis === 'undefined') {
    // Support for globalThis was added in Chrome 71.
    // However, environments like Android emulators are running Chrome 69.
    env$LWS.link('window', 'document');
  } else {
    // document is === window.document.
    env$LWS.link('document');
  }
  // window.__proto__ (aka Window.prototype)
  // window.__proto__.__proto__ (aka WindowProperties.prototype)
  // window.__proto__.__proto__.__proto__ (aka EventTarget.prototype)
  env$LWS.link('__proto__', '__proto__', '__proto__');
  env$LWS.remapProto(blueRefs$LWS.document, blueRefs$LWS.DocumentProto);
  env$LWS.lazyRemapProperties(blueRefs$LWS.window, shouldUseDefaultGlobalOwnKeys$LWS ? defaultGlobalOwnKeys$LWS : filterWindowKeys$LWS(getFilteredGlobalOwnKeys$LWS(globalObjectShape$LWS, maxPerfMode$LWS)),
  // Chromium based browsers have a bug that nulls the result of `window`
  // getters in detached iframes when the property descriptor of `window.window`
  // is retrieved.
  // https://bugs.chromium.org/p/chromium/issues/detail?id=1305302
  keepAlive$LWS ? undefined : unforgeablePoisonedWindowKeys$LWS);
  if (endowments$LWS) {
    const filteredEndowments$LWS = {};
    assignFilteredGlobalDescriptorsFromPropertyDescriptorMap$LWS(filteredEndowments$LWS, endowments$LWS, maxPerfMode$LWS);
    removeWindowDescriptors$LWS(filteredEndowments$LWS);
    env$LWS.remapProperties(blueRefs$LWS.window, filteredEndowments$LWS);
  }
  // We intentionally skip remapping Window.prototype because there is nothing
  // in it that needs to be remapped.
  env$LWS.lazyRemapProperties(blueRefs$LWS.EventTargetProto, blueRefs$LWS.EventTargetProtoOwnKeys);
  // We don't remap `blueRefs.WindowPropertiesProto` because it is "magical"
  // in that it provides access to elements by id.
  //
  // Once we get the iframe info ready, and all mapped, we can proceed to
  // detach the iframe only if `options.keepAlive` isn't true.
  if (keepAlive$LWS) {
    // @TODO: Temporary hack to preserve the document reference in Firefox.
    // https://bugzilla.mozilla.org/show_bug.cgi?id=543435
    const {
      document: redDocument$LWS
    } = redWindow$LWS;
    // Revoke the proxies of the redDocument and redWindow to prevent access.
    revoked$LWS.add(redDocument$LWS);
    revoked$LWS.add(redWindow$LWS);
    ReflectApply$LWS(DocumentProtoOpen$LWS, redDocument$LWS, []);
    ReflectApply$LWS(DocumentProtoClose$LWS, redDocument$LWS, []);
  } else {
    if (IS_OLD_CHROMIUM_BROWSER$LWS) {
      // For Chromium < v86 browsers we evaluate the `window` object to
      // kickstart the realm so that `window` persists when the iframe is
      // removed from the document.
      redIndirectEval$LWS('window');
    }
    ReflectApply$LWS(ElementProtoRemove$LWS, iframe$LWS, []);
  }
  return env$LWS;
}
function revokedProxyCallback$LWS(value$LWS) {
  return revoked$LWS.has(value$LWS);
}

// istanbul ignore next: currently unreachable via tests, platformResourceLoader testing is exclusively done in AMD format mode
function createResourceLoadError$LWS(url$LWS) {
  return new Error(`lightning/platformResourceLoader encountered an error loading ${shared$LWS.enquote(url$LWS)}.`);
}
const EMPTY_EVAL_HELPERS$LWS = {
  forAwaitOf: shared$LWS.noop,
  genToAsync: shared$LWS.noop,
  loadScript: shared$LWS.noop,
  loadStyle: shared$LWS.noop,
  makeRedGet: shared$LWS.noop,
  makeRedSyncImports: shared$LWS.noop,
  namespace: shared$LWS.noop,
  spreadable: shared$LWS.noop,
  super: shared$LWS.noop
};
// https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md
// istanbul ignore next
const EVAL_HELPERS_SOURCE_TEXT$LWS = `'use strict';
        ${shared$LWS.SANDBOX_EVAL_CONTEXT_NAME}(${function redHelpersFactory$LWS(baseGenToAsync$LWS, forAwaitOf$LWS, loadScript$LWS, loadStyle$LWS) {
  const ArrayCtor$LWS = Array;
  // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow
  const {
    iterator: SymbolIterator$LWS
  } = Symbol;
  const {
    [SymbolIterator$LWS]: ArrayProtoIterator$LWS
  } = ArrayCtor$LWS.prototype;
  // The Generator prototype object is %GeneratorFunction.prototype.prototype%.
  // https://tc39.es/ecma262/#sec-generatorfunction.prototype.prototype
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  const GeneratorProto$LWS = function* () {}.constructor.prototype.prototype;
  const {
    next: GeneratorProtoNext$LWS,
    throw: GeneratorProtoThrow$LWS
  } = GeneratorProto$LWS;
  const {
    defineProperties: ObjectDefineProperties$LWS,
    freeze: ObjectFreeze$LWS
  } = Object;
  const {
    // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow
    apply: ReflectApply$LWS,
    get: ReflectGet$LWS,
    getPrototypeOf: ReflectGetPrototypeOf$LWS,
    setPrototypeOf: ReflectSetPrototypeOf$LWS
  } = Reflect;
  function genToAsync$LWS(func$LWS, thisArg$LWS) {
    let gen$LWS;
    const wrapGenMethod$LWS = genMethod$LWS => value$LWS => {
      if (gen$LWS === undefined) {
        gen$LWS = ReflectApply$LWS(func$LWS, thisArg$LWS, []);
      }
      return ReflectApply$LWS(genMethod$LWS, gen$LWS, [value$LWS]);
    };
    return baseGenToAsync$LWS(wrapGenMethod$LWS(GeneratorProtoNext$LWS), wrapGenMethod$LWS(GeneratorProtoThrow$LWS));
  }
  function makeRedGet$LWS(...bindings$LWS) {
    const {
      length: length$LWS
    } = bindings$LWS;
    const redGet$LWS = ArrayCtor$LWS(length$LWS);
    const descriptors$LWS = {};
    for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
      descriptors$LWS[i$LWS] = {
        __proto__: null,
        get: bindings$LWS[i$LWS]
      };
    }
    ObjectDefineProperties$LWS(redGet$LWS, descriptors$LWS);
    return redGet$LWS;
  }
  function makeRedSyncImports$LWS(bindings$LWS) {
    return function (...args$LWS) {
      for (let i$LWS = 0, {
          length: length$LWS
        } = bindings$LWS; i$LWS < length$LWS; i$LWS += 1) {
        try {
          // eslint-disable-next-line @typescript-eslint/no-unused-expressions
          bindings$LWS[i$LWS];
          // eslint-disable-next-line no-empty
        } catch (_unused35$LWS) {}
      }
      return spreadable$LWS(args$LWS);
    };
  }
  function namespace$LWS(object$LWS) {
    return ObjectFreeze$LWS(object$LWS);
  }
  function spreadable$LWS(array$LWS) {
    ReflectSetPrototypeOf$LWS(array$LWS, null);
    array$LWS[SymbolIterator$LWS] = ArrayProtoIterator$LWS;
    return array$LWS;
  }
  function superApplyOrGet$LWS(target$LWS, key$LWS, thisArgOrReceiver$LWS, args$LWS) {
    const superProto$LWS = ReflectGetPrototypeOf$LWS(target$LWS);
    if (superProto$LWS === null) {
      return undefined;
    }
    return args$LWS ? ReflectApply$LWS(superProto$LWS[key$LWS], thisArgOrReceiver$LWS, args$LWS) : ReflectGet$LWS(superProto$LWS, key$LWS, thisArgOrReceiver$LWS);
  }
  return {
    forAwaitOf: forAwaitOf$LWS,
    genToAsync: genToAsync$LWS,
    loadScript: loadScript$LWS,
    loadStyle: loadStyle$LWS,
    makeRedGet: makeRedGet$LWS,
    makeRedSyncImports: makeRedSyncImports$LWS,
    namespace: namespace$LWS,
    spreadable: spreadable$LWS,
    super: superApplyOrGet$LWS
  };
}})`;
function createEvalHelpersFactoryArgs$LWS(record$LWS) {
  const {
    document: document$LWS,
    document: {
      head: head$LWS
    },
    distortions: distortions$LWS,
    globalObject: {
      HTMLScriptElement: HTMLScriptElement$LWS,
      HTMLScriptElement: {
        prototype: HTMLScriptElementProto$LWS
      }
    },
    root: _root$LWS
  } = record$LWS;
  const isRootRecord$LWS = record$LWS === _root$LWS;
  const forOfStateCache$LWS = shared$LWS.toSafeMap(new shared$LWS.MapCtor());
  const resourcePromiseCache$LWS = shared$LWS.toSafeWeakMap(new shared$LWS.WeakMapCtor());
  const resourceStatusCache$LWS = shared$LWS.toSafeWeakMap(new shared$LWS.WeakMapCtor());
  const scriptSrcGetterDistortion$LWS = distortions$LWS.get(isRootRecord$LWS ? sharedDom$LWS.HTMLScriptElementProtoSrcGetter : shared$LWS.ObjectLookupOwnGetter(HTMLScriptElementProto$LWS, 'src'));
  const scriptSrcSetterDistortion$LWS = distortions$LWS.get(isRootRecord$LWS ? sharedDom$LWS.HTMLScriptElementProtoSrcSetter : shared$LWS.ObjectLookupOwnSetter(HTMLScriptElementProto$LWS, 'src'));
  // istanbul ignore next: deprecated code path unreachable via tests
  function genStep$LWS(resolve$LWS, reject$LWS, next$LWS, thrower$LWS, genMethodWrapper$LWS, arg$LWS) {
    let info$LWS;
    let value$LWS;
    try {
      info$LWS = genMethodWrapper$LWS(arg$LWS);
      value$LWS = info$LWS.value;
    } catch (error) {
      reject$LWS(error);
      return;
    }
    if (info$LWS.done) {
      resolve$LWS(value$LWS);
    } else {
      shared$LWS.ReflectApply(shared$LWS.PromiseProtoThen, shared$LWS.PromiseResolve(value$LWS), [next$LWS, thrower$LWS]);
    }
  }
  // istanbul ignore next: currently unreachable via tests, platformResourceLoader testing is exclusively done in AMD format mode
  function loadPromise$LWS(element$LWS, urlAsString$LWS) {
    const promise$LWS = new shared$LWS.PromiseCtor((resolve$LWS, reject$LWS) => {
      function onerror$LWS(event$LWS) {
        shared$LWS.ReflectApply(sharedDom$LWS.EventTargetProtoRemoveEventListener, element$LWS, ['error', onerror$LWS]);
        shared$LWS.ReflectApply(sharedDom$LWS.EventTargetProtoRemoveEventListener, element$LWS, ['load', onload$LWS]);
        shared$LWS.ReflectApply(sharedDom$LWS.EventProtoStopPropagation, event$LWS, []);
        resourceStatusCache$LWS.set(element$LWS, 1 /* ResourceLoaderStatus.Errored */);
        reject$LWS(createResourceLoadError$LWS(urlAsString$LWS));
      }
      function onload$LWS() {
        shared$LWS.ReflectApply(sharedDom$LWS.EventTargetProtoRemoveEventListener, element$LWS, ['error', onerror$LWS]);
        shared$LWS.ReflectApply(sharedDom$LWS.EventTargetProtoRemoveEventListener, element$LWS, ['load', onload$LWS]);
        resourceStatusCache$LWS.set(element$LWS, 3 /* ResourceLoaderStatus.Loaded */);
        // platformResourceLoader and ltng:require have to be synchronized in terms of
        // creating and loading scripts. This expando is used by ltng:require to know if a
        // script has been loaded by it or not. See W-13034908.
        if (element$LWS instanceof HTMLScriptElement$LWS) {
          // eslint-disable-next-line no-underscore-dangle
          element$LWS._ltngRequireLoaded = true;
        }
        resolve$LWS(undefined);
      }
      shared$LWS.ReflectApply(sharedDom$LWS.EventTargetProtoAddEventListener, element$LWS, ['error', onerror$LWS]);
      shared$LWS.ReflectApply(sharedDom$LWS.EventTargetProtoAddEventListener, element$LWS, ['load', onload$LWS]);
    });
    resourceStatusCache$LWS.set(element$LWS, 2 /* ResourceLoaderStatus.Loading */);
    resourcePromiseCache$LWS.set(element$LWS, promise$LWS);
    shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoAppendChild, head$LWS, [element$LWS]);
    return promise$LWS;
  }
  return [
  // This helper is used to wrap the bodies of async functions that are
  // transformed into generator functions. It's based on @babel/helpers
  // `helpers.asyncToGenerator()`:
  // https://github.com/babel/babel/blob/a967910/packages/babel-helpers/src/helpers.js#L255-L288
  // istanbul ignore next: deprecated code path unreachable via tests
  function baseGenToAsync$LWS(genNextWrapper$LWS, genThrowWrapper$LWS) {
    return new shared$LWS.PromiseCtor((resolve$LWS, reject$LWS) => {
      function next$LWS(value$LWS) {
        genStep$LWS(resolve$LWS, reject$LWS, next$LWS, thrower$LWS, genNextWrapper$LWS, value$LWS);
      }
      function thrower$LWS(error) {
        genStep$LWS(resolve$LWS, reject$LWS, next$LWS, thrower$LWS, genThrowWrapper$LWS, error);
      }
      next$LWS(undefined);
    });
  },
  // istanbul ignore next: deprecated code path unreachable via tests
  function forAwaitOf$LWS(index$LWS, stage$LWS, object$LWS) {
    if (stage$LWS === 0 /* init */) {
      let sync$LWS = false;
      let {
        [shared$LWS.SymbolAsyncIterator]: iterator$LWS
      } = object$LWS;
      if (iterator$LWS === null || iterator$LWS === undefined) {
        sync$LWS = true;
        ({
          [shared$LWS.SymbolIterator]: iterator$LWS
        } = object$LWS);
      }
      if (typeof iterator$LWS !== 'function') {
        throw new shared$LWS.TypeErrorCtor('Object is not async iterable');
      }
      forOfStateCache$LWS.set(index$LWS, {
        iterable: shared$LWS.ReflectApply(iterator$LWS, object$LWS, []),
        step: undefined,
        sync: sync$LWS
      });
      return undefined;
    }
    const state$LWS = forOfStateCache$LWS.get(index$LWS);
    if (stage$LWS === 1 /* step */) {
      const result$LWS = state$LWS.iterable.next();
      return state$LWS.sync ? new shared$LWS.PromiseCtor(resolve$LWS => {
        state$LWS.step = result$LWS;
        resolve$LWS();
      }) : shared$LWS.ReflectApply(shared$LWS.PromiseProtoThen, result$LWS, [step$LWS => {
        state$LWS.step = step$LWS;
      }]);
    }
    if (stage$LWS === 2 /* value */) {
      return state$LWS.step.value;
    }
    // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false if execution has reached this line.
    if (stage$LWS === 3 /* done */) {
      const done$LWS = !!state$LWS.step.done;
      if (done$LWS) {
        forOfStateCache$LWS.delete(index$LWS);
      }
      return done$LWS;
    }
    // istanbul ignore next: this is a safety precaution, not reachable via any normal execution
    return undefined;
  },
  // Functionality based on platformResourceLoader#loadScript (https://sfdc.co/7FuDU) but
  // adjusted for multiple sandboxes. This loadScript will create one <script> element in the
  // DOM per url per sandbox.
  // istanbul ignore next: currently unreachable via tests, platformResourceLoader testing is exclusively done in AMD format mode
  function loadScript$LWS(_thisArg$LWS, url$LWS) {
    const urlResolved$LWS = sharedUrl$LWS.resolveURL(shared$LWS.toSafeStringValue(url$LWS));
    const scripts$LWS = shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoQuerySelectorAll, head$LWS, ['script']);
    for (let i$LWS = 0, {
        length: length$LWS
      } = scripts$LWS; i$LWS < length$LWS; i$LWS += 1) {
      var _resourceStatusCache$$LWS;
      const script$LWS = scripts$LWS[i$LWS];
      // Ensure that this <script> is actually in the resource cache for this sandbox.
      // Previously this check only looked at the <script>'s src, which would give a
      // false positive if more than one sandbox had loaded this resource.
      const status$LWS = (_resourceStatusCache$$LWS = resourceStatusCache$LWS.get(script$LWS)) != null ? _resourceStatusCache$$LWS : 0 /* ResourceLoaderStatus.None */;
      // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false
      if (status$LWS && shared$LWS.ReflectApply(scriptSrcGetterDistortion$LWS, script$LWS, []) === urlResolved$LWS) {
        if (status$LWS === 3 /* ResourceLoaderStatus.Loaded */) {
          return shared$LWS.PromiseResolve(undefined);
        }
        // istanbul ignore if: this status cannot be tested without navigating the page itself during the execution of the request.
        if (status$LWS === 1 /* ResourceLoaderStatus.Errored */) {
          return shared$LWS.PromiseReject(createResourceLoadError$LWS(urlResolved$LWS));
        }
        if (status$LWS === 2 /* ResourceLoaderStatus.Loading */) {
          return resourcePromiseCache$LWS.get(script$LWS);
        }
      }
    }
    const script$LWS = shared$LWS.ReflectApply(sharedDom$LWS.DocumentProtoCreateElement, document$LWS, ['script']);
    script$LWS.type = 'text/javascript';
    // platformResourceLoader and ltng:require have to be synchronized in terms of creating
    // and loading scripts. This expando is used by ltng:require to know if a script
    // has been created by it or not. See W-13034908.
    // eslint-disable-next-line no-underscore-dangle
    script$LWS._ltngRequireCreated = true;
    shared$LWS.ReflectApply(scriptSrcSetterDistortion$LWS, script$LWS, [urlResolved$LWS]);
    return loadPromise$LWS(script$LWS, urlResolved$LWS);
  },
  // Functionality based on platformResourceLoader#loadStyle (http://sfdc.co/bIpMYB) but
  // adjusted for multiple sandboxes. This loadStyle will create one <link> element in the DOM
  // per url for all the sandboxes.
  // istanbul ignore next: currently unreachable via tests, platformResourceLoader testing is exclusively done in AMD format mode
  function loadStyle$LWS(_thisArg$LWS, url$LWS) {
    const urlResolved$LWS = sharedUrl$LWS.resolveURL(shared$LWS.toSafeStringValue(url$LWS));
    let link$LWS = shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoQuerySelector, head$LWS, [`link[href=${shared$LWS.enquote(urlResolved$LWS)}]`]);
    if (link$LWS) {
      var _resourceStatusCache$2$LWS;
      const status$LWS = (_resourceStatusCache$2$LWS = resourceStatusCache$LWS.get(link$LWS)) != null ? _resourceStatusCache$2$LWS : 0 /* ResourceLoaderStatus.None */;
      if (status$LWS === 0 /* ResourceLoaderStatus.None */ || status$LWS === 3 /* ResourceLoaderStatus.Loaded */) {
        return shared$LWS.PromiseResolve(undefined);
      }
      // istanbul ignore if: this status cannot be tested without navigating the page itself during the execution of the request.
      if (status$LWS === 1 /* ResourceLoaderStatus.Errored */) {
        return shared$LWS.PromiseReject(createResourceLoadError$LWS(urlResolved$LWS));
      }
      const promise$LWS = status$LWS === 2 /* ResourceLoaderStatus.Loading */ ? resourcePromiseCache$LWS.get(link$LWS) : undefined;
      return promise$LWS != null ? promise$LWS : shared$LWS.PromiseResolve(undefined);
    }
    link$LWS = shared$LWS.ReflectApply(sharedDom$LWS.DocumentProtoCreateElement, document$LWS, ['link']);
    link$LWS.type = 'text/css';
    link$LWS.rel = 'stylesheet';
    link$LWS.href = urlResolved$LWS;
    return loadPromise$LWS(link$LWS, urlResolved$LWS);
  }];
}
function toSourceText$LWS(value$LWS, sourceType$LWS) {
  let sourceText$LWS = typeof value$LWS === 'function' ? shared$LWS.extractFunctionBodySource(value$LWS) : shared$LWS.toSafeStringValue(value$LWS);
  // We workaround bundlers, like Rollup, aggressively stripping inline source
  // maps by compiling them with the name "sandboxMappingURL". At runtime the
  // name is changed so the inline source map is registered.
  sourceText$LWS = shared$LWS.ReflectApply(shared$LWS.StringProtoReplace, sourceText$LWS, [
  // This regexp looks involved, but it prevents browsers and developer
  // tools from mistaking the regexp or the replacement string for an
  // actual source mapping URL.
  /\/\/# sandbox(?=MappingURL=.*?\s*$)/, '//# source']);
  sourceText$LWS = `\n//# LWS Version = "0.23.6"\n${sourceText$LWS}`;
  return sourceType$LWS === 1 /* SourceType.Module */ && shared$LWS.indexOfPragma(sourceText$LWS, 'use strict') === -1 ?
  // Append "'use strict'" to the extracted function body so it is
  // evaluated in strict mode.
  `'use strict';${sourceText$LWS}` : sourceText$LWS;
}

// Flag whether the iframe should remain connected to the DOM.
const IFRAME_KEEP_ALIVE_FLAG$LWS = shared$LWS.LOCKER_UNMINIFIED_FLAG && !false;
// Fast path non-configurable document, location, and window objects in the
// virtual environment distortion callback by seeding them in the root window's
// created distortion map.
const rootDistortionMapSeedEntries$LWS = [[sharedDom$LWS.rootDocument, sharedDom$LWS.rootDocument], [sharedDom$LWS.rootWindowLocation, sharedDom$LWS.rootWindowLocation], [sharedDom$LWS.rootWindow, sharedDom$LWS.rootWindow]];
const seenGlobalObjects$LWS = shared$LWS.toSafeWeakSet(new shared$LWS.WeakSetCtor());
function createGetVirtualEnvironment$LWS(record$LWS) {
  let virtualEnvironment$LWS;
  return () => {
    // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false
    if (virtualEnvironment$LWS === undefined) {
      virtualEnvironment$LWS = createVirtualEnvironment$LWS(record$LWS);
    }
    return virtualEnvironment$LWS;
  };
}
function createVirtualEnvironmentEvaluator$LWS(record$LWS, getVirtualEnvironment$LWS) {
  let virtualEnvironment$LWS;
  return sourceText$LWS => {
    // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false
    if (virtualEnvironment$LWS === undefined) {
      virtualEnvironment$LWS = getVirtualEnvironment$LWS();
      // Stash the old eval context.
      const context$LWS = clearEvalContext$LWS();
      // Populate `record.helpers`.
      setEvalContext$LWS(redEvalHelpersFactory$LWS => {
        const helpers$LWS = shared$LWS.ReflectApply(redEvalHelpersFactory$LWS, undefined, createEvalHelpersFactoryArgs$LWS(record$LWS));
        record$LWS.helpers = helpers$LWS;
        setEvalHelpers$LWS(helpers$LWS);
      });
      virtualEnvironment$LWS.evaluate(EVAL_HELPERS_SOURCE_TEXT$LWS);
      if (typeof context$LWS === 'object' && context$LWS !== null) {
        // Track the `context` object and its properties as a fast
        // targets because it may contain things like `blueGet` and
        // `blueSet` arrays.
        virtualEnvironment$LWS.trackAsFastTarget(context$LWS);
        const ownKeys$LWS = shared$LWS.ReflectOwnKeys(context$LWS);
        for (let i$LWS = 0, {
            length: length$LWS
          } = ownKeys$LWS; i$LWS < length$LWS; i$LWS += 1) {
          const value$LWS = context$LWS[ownKeys$LWS[i$LWS]];
          if (typeof value$LWS === 'object' && value$LWS !== null) {
            virtualEnvironment$LWS.trackAsFastTarget(value$LWS);
          }
        }
      }
      // Restore the old eval context.
      setEvalContext$LWS(context$LWS);
    }
    return virtualEnvironment$LWS.evaluate(sourceText$LWS);
  };
}
function createSandboxEvaluator$LWS({
  LOCKER_VERBOSE_INSTRUMENTATION_FLAG: verboseInstrumentation$LWS,
  document: document$LWS,
  globalObject: globalObject$LWS,
  instrumentation: instrumentation$LWS,
  key: key$LWS,
  type: type$LWS
}) {
  return (sourceText$LWS, evalContext$LWS = EMPTY_OBJECT$LWS, evalGlobalObject$LWS = globalObject$LWS, evalDocument$LWS = document$LWS) => internalEvaluateInSandbox$LWS({
    context: evalContext$LWS,
    document: evalDocument$LWS,
    endowments: EMPTY_OBJECT$LWS,
    globalObject: evalGlobalObject$LWS,
    instrumentation: instrumentation$LWS,
    key: key$LWS,
    source: sourceText$LWS,
    sourceType: 0 /* SourceType.Script */,
    type: type$LWS,
    verboseInstrumentation: verboseInstrumentation$LWS
  });
}
function createVirtualEnvironment$LWS(record$LWS) {
  const {
    endowments: endowments$LWS,
    globalObject: globalObject$LWS,
    instrumentation: instrumentation$LWS,
    key: key$LWS,
    root: _root$LWS,
    root: {
      distortions: distortions$LWS
    },
    type: type$LWS
  } = record$LWS;
  const maxPerfMode$LWS = shared$LWS.isGaterEnabledFeature(shared$LWS.ENABLE_MAX_PERF_MODE_GATE) ||
  // 'devopsimpkg*' or exact 'omnistudio' will override INTO maxPerfMode
  shared$LWS.isAllowedToOverrideGaterEnabledFeature(key$LWS, shared$LWS.ENABLE_MAX_PERF_MODE_GATE);
  return createIframeVirtualEnvironment$LWS(globalObject$LWS, {
    defaultPolicy: {
      createScript:
      // istanbul ignore next: this is used to create a default in near-membrane
      dirty$LWS => dirty$LWS
    },
    distortionCallback(originalTarget$LWS) {
      const distortedTarget$LWS = distortions$LWS.get(originalTarget$LWS);
      if (distortedTarget$LWS) {
        return distortedTarget$LWS;
      }
      if (typeof originalTarget$LWS === 'function') {
        return originalTarget$LWS;
      }
      // Perform the first own property check in a try-catch to avoid
      // throwing an error on opaque, non-window, objects of a cross-origin
      // window.
      try {
        // The location property is the only common non-configurable
        // property between window and document, so it serves this check
        // very well.
        if (!shared$LWS.ObjectHasOwn(originalTarget$LWS, 'location')) {
          return originalTarget$LWS;
        }
      } catch (_unused36$LWS) {
        // Likely an opaque object of a cross-origin window.
        // istanbul ignore next: an access of property iframe.contentWindow.location.href on an opaque window, that should reach this catch clause IS tested (see packages/integration-karma/test/distortions/HTMLIFrameElement/untrusted/snippets.js, "doesNotThrowOnCreationOrAccessOfCrossOriginIframeContentWindow"), but reported as uncovered
        return originalTarget$LWS;
      }
      let originalTargetDocument$LWS;
      let originalTargetWindow$LWS;
      // Do the safe cross-origin window object check first to avoid
      // failure caused by touching non-cross-origin-safe properties.
      if (shared$LWS.ObjectHasOwn(originalTarget$LWS, 'window') && originalTarget$LWS.window === originalTarget$LWS) {
        // Slower check to detect a window object.
        try {
          // `WindowDocumentGetter` will throw if `originalTarget` is
          // not a window object, or if it is an opaque cross-origin window.
          originalTargetDocument$LWS = shared$LWS.ReflectApply(sharedDom$LWS.WindowDocumentGetter, originalTarget$LWS, []);
          originalTargetWindow$LWS = originalTarget$LWS;
        } catch (_unused37$LWS) {
          try {
            // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false
            if (shared$LWS.ReflectApply(sharedDom$LWS.WindowLocationGetter, originalTarget$LWS, [])) {
              createOpaqueSecondaryWindowSandboxRecord$LWS({
                globalObject: originalTarget$LWS,
                key: key$LWS,
                type: type$LWS
              }, _root$LWS);
              return originalTarget$LWS;
            }
            // eslint-disable-next-line no-empty
          } catch (_unused38$LWS) {}
        }
        // Check if originalTarget is a document and get its defaultView.
      } else if ('defaultView' in originalTarget$LWS) {
        // If the object doesn't appear to be a window, same or
        // cross-origin, then it may be a document for window that we
        // haven't seen yet, but can safely check non-cross-origin-safe
        // properties of, specifically `defaultView` which will give us
        // a window if one exists.
        let defaultView$LWS;
        try {
          // This will throw if `originalTarget` is not a document object.
          defaultView$LWS = shared$LWS.ReflectApply(sharedDom$LWS.DocumentProtoDefaultViewGetter, originalTarget$LWS, []);
          // eslint-disable-next-line no-empty
        } catch (_unused39$LWS) {}
        if (defaultView$LWS) {
          originalTargetDocument$LWS = originalTarget$LWS;
          originalTargetWindow$LWS = defaultView$LWS;
        }
      }
      if (originalTargetWindow$LWS) {
        createSecondaryWindowSandboxRecord$LWS({
          context: EMPTY_OBJECT$LWS,
          document: originalTargetDocument$LWS,
          globalObject: originalTargetWindow$LWS,
          key: key$LWS,
          type: type$LWS
        }, _root$LWS);
      }
      return originalTarget$LWS;
    },
    endowments: endowments$LWS && endowments$LWS !== EMPTY_OBJECT$LWS ?
    // Normalize the descriptors of the provided endowments object,
    // and the default endowments descriptors so they can be
    // accessible from inside the sandbox.
    shared$LWS.ObjectAssign({}, DEFAULT_ENDOWMENTS_DESCRIPTOR_MAP$LWS, shared$LWS.ObjectGetOwnPropertyDescriptors(endowments$LWS)) : DEFAULT_ENDOWMENTS_DESCRIPTOR_MAP$LWS,
    instrumentation: instrumentation$LWS,
    maxPerfMode: maxPerfMode$LWS,
    keepAlive:
    // istanbul ignore next: cannot test isLockerFeatureEnabled
    maxPerfMode$LWS && shared$LWS.isLockerFeatureEnabled('isLockerNextForOmnistudioEnabled') || IFRAME_KEEP_ALIVE_FLAG$LWS,
    liveTargetCallback: shared$LWS.isTargetLive,
    signSourceCallback: sourceText$LWS => trustedTypes$LWS.trusted.createScript(sourceText$LWS)
  });
}
// istanbul ignore next: currently unreachable via tests
function getDefaultType$LWS(key$LWS) {
  return key$LWS === CORE_SANDBOX_KEY$LWS ? 1 /* SandboxType.Internal */ : 0 /* SandboxType.External */;
}
function createRootWindowSandboxRecord$LWS({
  // istanbul ignore next: destructured default assignments are not correctly instrumented
  context: context$LWS = EMPTY_OBJECT$LWS,
  // istanbul ignore next: destructured default assignments are not correctly instrumented
  endowments: endowments$LWS = EMPTY_OBJECT$LWS,
  // istanbul ignore next: destructured default assignments are not correctly instrumented
  instrumentation: instrumentation$LWS = EMPTY_OBJECT$LWS,
  key: key$LWS,
  // istanbul ignore next: destructured default assignments are not correctly instrumented
  type: type$LWS = getDefaultType$LWS(key$LWS),
  // istanbul ignore next: destructured default assignments are not correctly instrumented
  verboseInstrumentation: verboseInstrumentation$LWS = false
}) {
  let record$LWS = rootSandboxRegistry$LWS[key$LWS];
  if (record$LWS) {
    return record$LWS;
  }
  // istanbul ignore next: instrumentation is not tested
  const LOCKER_INSTRUMENTATION_FLAG$LWS =
  // In the future we can preface the LOCKER_INSTRUMENTATION_FLAG
  // definition with a LOCKER_UNMINIFIED_FLAG check to have instrumentation
  // removed in minified production builds.
  instrumentation$LWS !== EMPTY_OBJECT$LWS && typeof instrumentation$LWS === 'object' && instrumentation$LWS !== null;
  const distortions$LWS = createDistortionMap$LWS(rootDistortionMapSeedEntries$LWS);
  record$LWS = {
    BASIC_INSTRUMENTATION_DATA: LOCKER_INSTRUMENTATION_FLAG$LWS ? {
      sandboxKey: key$LWS
    } : EMPTY_OBJECT$LWS,
    LOCKER_INSTRUMENTATION_FLAG: LOCKER_INSTRUMENTATION_FLAG$LWS,
    LOCKER_VERBOSE_INSTRUMENTATION_FLAG:
    // In the future we can preface the LOCKER_INSTRUMENTATION_FLAG
    // definition with a LOCKER_UNMINIFIED_FLAG check to have instrumentation
    // removed in minified production builds.
    verboseInstrumentation$LWS && LOCKER_INSTRUMENTATION_FLAG$LWS,
    UNCOMPILED_CONTEXT: ROOT_UNCOMPILED_CONTEXT$LWS,
    context: context$LWS,
    document: sharedDom$LWS.rootDocument,
    distortions: distortions$LWS,
    endowments: endowments$LWS,
    globalObject: sharedDom$LWS.rootWindow,
    helpers: EMPTY_EVAL_HELPERS$LWS,
    instrumentation: instrumentation$LWS,
    key: key$LWS,
    root: EMPTY_OBJECT$LWS,
    sandboxEvaluator: shared$LWS.noop,
    type: type$LWS,
    virtualEnvironmentEvaluator: shared$LWS.noop
  };
  const getVirtualEnvironment$LWS = createGetVirtualEnvironment$LWS(record$LWS);
  record$LWS.root = record$LWS;
  record$LWS.sandboxEvaluator = createSandboxEvaluator$LWS(record$LWS);
  record$LWS.virtualEnvironmentEvaluator = createVirtualEnvironmentEvaluator$LWS(record$LWS, getVirtualEnvironment$LWS);
  const entries$LWS = createDistortionEntries$LWS(record$LWS, getDistortionFactories$LWS(record$LWS));
  // Add distortions to the root window's distortion map.
  for (let i$LWS = 0, {
      length: length$LWS
    } = entries$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const {
      0: entryKey$LWS,
      1: entryValue$LWS
    } = entries$LWS[i$LWS];
    distortions$LWS.set(entryKey$LWS, entryValue$LWS);
  }
  rootSandboxRegistry$LWS[key$LWS] = record$LWS;
  return record$LWS;
}
function createOpaqueSecondaryWindowSandboxRecord$LWS({
  globalObject: globalObject$LWS,
  key: key$LWS,
  // istanbul ignore next: destructured default assignments are not correctly instrumented
  type: type$LWS = /* istannul ignore next: nothing works to ignore these */getDefaultType$LWS(key$LWS)
}, _root$LWS) {
  const sandboxRegistry$LWS = getOpaqueSandboxRegistry$LWS(globalObject$LWS);
  let record$LWS = sandboxRegistry$LWS[key$LWS];
  // istanbul ignore if: calls that would evaluate to true here ARE tested (see packages/integration-karma/test/distortions/HTMLIFrameElement/untrusted/snippets.js, "doesNotThrowOnCreationOrAccessOfCrossOriginIframeContentWindow"), but reported as uncovered
  if (record$LWS) {
    return record$LWS;
  }
  const {
    BASIC_INSTRUMENTATION_DATA: BASIC_INSTRUMENTATION_DATA$LWS,
    LOCKER_INSTRUMENTATION_FLAG: LOCKER_INSTRUMENTATION_FLAG$LWS,
    LOCKER_VERBOSE_INSTRUMENTATION_FLAG: LOCKER_VERBOSE_INSTRUMENTATION_FLAG$LWS,
    distortions: distortions$LWS,
    instrumentation: instrumentation$LWS
  } = _root$LWS;
  record$LWS = {
    BASIC_INSTRUMENTATION_DATA: BASIC_INSTRUMENTATION_DATA$LWS,
    LOCKER_INSTRUMENTATION_FLAG: LOCKER_INSTRUMENTATION_FLAG$LWS,
    LOCKER_VERBOSE_INSTRUMENTATION_FLAG: LOCKER_VERBOSE_INSTRUMENTATION_FLAG$LWS,
    UNCOMPILED_CONTEXT: EMPTY_OBJECT$LWS,
    context: EMPTY_OBJECT$LWS,
    document,
    distortions: EMPTY_DISTORTIONS_MAP$LWS,
    endowments: EMPTY_OBJECT$LWS,
    globalObject: globalObject$LWS,
    helpers: EMPTY_EVAL_HELPERS$LWS,
    instrumentation: instrumentation$LWS,
    key: key$LWS,
    root: _root$LWS,
    sandboxEvaluator: shared$LWS.noop,
    type: type$LWS,
    virtualEnvironmentEvaluator: shared$LWS.noop
  };
  // Fast path non-configurable location and window objects in the virtual
  // environment distortion callback by adding them to the root window's
  // distortion map.
  const {
    location: location$LWS
  } = globalObject$LWS;
  distortions$LWS.set(location$LWS, location$LWS);
  // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false
  if (!seenGlobalObjects$LWS.has(globalObject$LWS)) {
    distortions$LWS.set(globalObject$LWS, globalObject$LWS);
  }
  // Add opaque window postMessage distortion for the child window to the root
  // window's distortion map.
  const opaqueWindowPostMessageDistortionFactory$LWS = getOpaqueWindowPostMessageDistortionFactory$LWS(record$LWS);
  const opaqueWindowPostMessageDistortionEntry$LWS = opaqueWindowPostMessageDistortionFactory$LWS(record$LWS);
  const originalOpaqueWindowPostMessage$LWS = opaqueWindowPostMessageDistortionEntry$LWS[0];
  distortions$LWS.set(originalOpaqueWindowPostMessage$LWS, proxyMaskFunctionDistortion$LWS(record$LWS, opaqueWindowPostMessageDistortionFactory$LWS, opaqueWindowPostMessageDistortionEntry$LWS[1], originalOpaqueWindowPostMessage$LWS));
  sandboxRegistry$LWS[key$LWS] = record$LWS;
  return record$LWS;
}
function createSecondaryWindowSandboxRecord$LWS({
  globalObject: globalObject$LWS,
  document: document$LWS,
  // istanbul ignore next: destructured default assignments are not correctly instrumented
  context: context$LWS = /* istanbul ignore next: currently unreachable via tests */EMPTY_OBJECT$LWS,
  key: key$LWS,
  // istanbul ignore next: destructured default assignments are not correctly instrumented
  type: type$LWS = /* istanbul ignore next: currently unreachable via tests */getDefaultType$LWS(key$LWS)
}, _root$LWS) {
  const sandboxRegistry$LWS = getSandboxRegistry$LWS(document$LWS);
  let record$LWS = sandboxRegistry$LWS[key$LWS];
  if (record$LWS) {
    return record$LWS;
  }
  const {
    BASIC_INSTRUMENTATION_DATA: BASIC_INSTRUMENTATION_DATA$LWS,
    LOCKER_INSTRUMENTATION_FLAG: LOCKER_INSTRUMENTATION_FLAG$LWS,
    LOCKER_VERBOSE_INSTRUMENTATION_FLAG: LOCKER_VERBOSE_INSTRUMENTATION_FLAG$LWS,
    distortions: distortions$LWS,
    instrumentation: instrumentation$LWS
  } = _root$LWS;
  const {
    location: location$LWS,
    top: top$LWS
  } = globalObject$LWS;
  record$LWS = {
    BASIC_INSTRUMENTATION_DATA: BASIC_INSTRUMENTATION_DATA$LWS,
    LOCKER_INSTRUMENTATION_FLAG: LOCKER_INSTRUMENTATION_FLAG$LWS,
    LOCKER_VERBOSE_INSTRUMENTATION_FLAG: LOCKER_VERBOSE_INSTRUMENTATION_FLAG$LWS,
    UNCOMPILED_CONTEXT: {
      [shared$LWS.UNCOMPILED_LOCATION_NAME]: location$LWS,
      [shared$LWS.UNCOMPILED_TOP_NAME]: top$LWS,
      // The following context entries are explicitly added because the
      // UNCOMPILED_*_NAME entries will only be added to the contextNames
      // via transforms when the fully qualified member expression is detected
      // in the code, eg. window.location, or window.top.
      // See complete explanation in packages/@locker/shared-dom/src/source-transformations.ts.
      location: location$LWS,
      top: top$LWS
    },
    context: context$LWS,
    document: document$LWS,
    distortions: EMPTY_DISTORTIONS_MAP$LWS,
    endowments: EMPTY_OBJECT$LWS,
    globalObject: globalObject$LWS,
    helpers: EMPTY_EVAL_HELPERS$LWS,
    instrumentation: instrumentation$LWS,
    key: key$LWS,
    root: _root$LWS,
    sandboxEvaluator: shared$LWS.noop,
    type: type$LWS,
    virtualEnvironmentEvaluator: shared$LWS.noop
  };
  const getVirtualEnvironment$LWS = createGetVirtualEnvironment$LWS(record$LWS);
  record$LWS.sandboxEvaluator = createSandboxEvaluator$LWS(record$LWS);
  record$LWS.virtualEnvironmentEvaluator = createVirtualEnvironmentEvaluator$LWS(record$LWS, getVirtualEnvironment$LWS);
  // Fast path non-configurable document, location, and window objects in the
  // virtual environment distortion callback by adding them to the root window's
  // distortion map.
  distortions$LWS.set(document$LWS, document$LWS);
  distortions$LWS.set(location$LWS, location$LWS);
  const seenGlobalObject$LWS = seenGlobalObjects$LWS.has(globalObject$LWS);
  if (!seenGlobalObject$LWS) {
    // WindowProxy object references don't change when the window location
    // changes.
    // https://developer.mozilla.org/en-US/docs/Glossary/WindowProxy
    distortions$LWS.set(globalObject$LWS, globalObject$LWS);
  }
  const entries$LWS = createDistortionEntries$LWS(record$LWS, getDistortionFactories$LWS(record$LWS));
  for (let i$LWS = 0, {
      length: length$LWS
    } = entries$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const {
      0: entryKey$LWS,
      1: entryValue$LWS
    } = entries$LWS[i$LWS];
    // Add distortion to the root window's distortion map.
    distortions$LWS.set(entryKey$LWS, entryValue$LWS);
  }
  sandboxRegistry$LWS[key$LWS] = record$LWS;
  if (seenGlobalObject$LWS) {
    return record$LWS;
  }
  seenGlobalObjects$LWS.add(globalObject$LWS);
  const onDOMContentLoadedOrWindowLoad$LWS = () => {
    try {
      // We don't need to use `WindowDocumentGetter()` because we know
      // this is a window object and the 'document' property is
      // non-configurable.
      const {
        document: newDocument$LWS
      } = globalObject$LWS;
      // Ensure the document has changed before attempting to create a
      // sandbox record.
      if (document$LWS !== newDocument$LWS) {
        createSecondaryWindowSandboxRecord$LWS({
          context: EMPTY_OBJECT$LWS,
          document: newDocument$LWS,
          globalObject: globalObject$LWS,
          key: key$LWS,
          type: type$LWS
        }, _root$LWS);
      }
    } catch (_unused40$LWS) {
      // istanbul ignore next: this is a safety precaution that is unreachable via tests
      createOpaqueSecondaryWindowSandboxRecord$LWS({
        globalObject: globalObject$LWS,
        key: key$LWS,
        type: type$LWS
      }, _root$LWS);
    }
  };
  const frameElement$LWS = shared$LWS.ReflectApply(sharedDom$LWS.WindowFrameElementGetter, globalObject$LWS, []);
  if (frameElement$LWS) {
    // Create a new sandbox record when the iframe window location changes.
    shared$LWS.ReflectApply(sharedDom$LWS.EventTargetProtoAddEventListener, frameElement$LWS, ['load', onDOMContentLoadedOrWindowLoad$LWS,
    // useCapture
    true]);
  } else {
    // Create a new sandbox record when the opened window location changes.
    // https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event#usage_notes
    //
    // The 'unload' event handler is okay to use here under the assumption
    // that most `window.open()` calls are not done with the 'noopener'
    // option, so the back/forward cache (i.e. bfcache) is likely being
    // skipped anyways.
    // https://web.dev/bfcache/#avoid-window.opener-references
    shared$LWS.ReflectApply(sharedDom$LWS.EventTargetProtoAddEventListener, globalObject$LWS, ['unload', function onWindowUnload$LWS() {
      sharedDom$LWS.WindowQueueMicrotask(() => {
        try {
          // Ensure the document has changed before adding event
          // listeners.
          const {
            document: newDocument$LWS
          } = globalObject$LWS;
          if (document$LWS === newDocument$LWS) {
            return;
          }
          // istanbul ignore next: currently unreachable via tests
          shared$LWS.ReflectApply(sharedDom$LWS.EventTargetProtoAddEventListener, globalObject$LWS, ['DOMContentLoaded', onDOMContentLoadedOrWindowLoad$LWS, true]);
          // istanbul ignore next: currently unreachable via tests
          shared$LWS.ReflectApply(sharedDom$LWS.EventTargetProtoAddEventListener, globalObject$LWS, ['unload', onWindowUnload$LWS, true]);
        } catch (_unused41$LWS) {
          // istanbul ignore next: this is a safety precaution that is unreachable via tests
          createOpaqueSecondaryWindowSandboxRecord$LWS({
            globalObject: globalObject$LWS,
            key: key$LWS,
            type: type$LWS
          }, _root$LWS);
        }
      });
    },
    // useCapture
    true]);
  }
  return record$LWS;
}
function internalEvaluateInSandbox$LWS(evaluateOptions$LWS) {
  const {
    document: document$LWS,
    context: context$LWS,
    endowments: endowments$LWS,
    globalObject: globalObject$LWS,
    instrumentation: instrumentation$LWS,
    key: key$LWS,
    source: source$LWS,
    sourceType: sourceType$LWS,
    type: type$LWS,
    verboseInstrumentation: verboseInstrumentation$LWS
  } = evaluateOptions$LWS;
  if (typeof key$LWS !== 'string') {
    throw new shared$LWS.LockerSecurityError(shared$LWS.ERR_INVALID_SANDBOX_KEY);
  }
  const {
    LOCKER_INSTRUMENTATION_FLAG: LOCKER_INSTRUMENTATION_FLAG$LWS,
    helpers: helpers$LWS,
    virtualEnvironmentEvaluator: virtualEnvironmentEvaluator$LWS
  } = globalObject$LWS === sharedDom$LWS.rootWindow ? createRootWindowSandboxRecord$LWS({
    context: context$LWS,
    endowments: endowments$LWS,
    instrumentation: instrumentation$LWS,
    key: key$LWS,
    type: type$LWS,
    verboseInstrumentation: verboseInstrumentation$LWS
  }) : createSecondaryWindowSandboxRecord$LWS({
    context: context$LWS,
    document: document$LWS,
    globalObject: globalObject$LWS,
    key: key$LWS,
    type: type$LWS
  }, rootSandboxRegistry$LWS[key$LWS]);
  // Setting the context before evaluating the sourceText so compiled code
  // can wire up import/exports from both sides of the membrane.
  if (context$LWS !== EMPTY_OBJECT$LWS) {
    setEvalContext$LWS(context$LWS);
  }
  if (helpers$LWS !== EMPTY_EVAL_HELPERS$LWS) {
    setEvalHelpers$LWS(helpers$LWS);
  }
  let result$LWS;
  const sourceText$LWS = toSourceText$LWS(source$LWS, sourceType$LWS);
  // istanbul ignore next: instrumentation is not tested
  const activity$LWS = LOCKER_INSTRUMENTATION_FLAG$LWS ? instrumentation$LWS == null ? void 0 : instrumentation$LWS.startActivity('lws.evaluate') : undefined;
  try {
    // Protecting against errors during evaluation can guarantee the state
    // of the EvalContext to avoid leaking context values
    result$LWS = virtualEnvironmentEvaluator$LWS(sourceText$LWS);
    // istanbul ignore next: instrumentation is not tested
    instrumentation$LWS == null || instrumentation$LWS.incrementCounter == null || instrumentation$LWS.incrementCounter('lws.evaluate', 1, false);
  } catch (error) {
    // istanbul ignore next: instrumentation is not tested
    instrumentation$LWS == null || instrumentation$LWS.incrementCounter == null || instrumentation$LWS.incrementCounter('lws.evaluate', 1, true);
    // istanbul ignore next: instrumentation is not tested
    activity$LWS == null || activity$LWS.error({
      sandboxKey: key$LWS,
      error
    });
    // istanbul ignore next: instrumentation is not tested
    activity$LWS == null || activity$LWS.stop();
    throw error;
  } finally {
    clearEvalContext$LWS();
    clearEvalHelpers$LWS();
  }
  // istanbul ignore next: instrumentation is not tested
  activity$LWS == null || activity$LWS.stop();
  return result$LWS;
}

// Import `const enum SandboxType` as a value, instead of a type, so TypeScript
function evaluateInCoreSandbox$LWS(_key$LWS, source$LWS, context$LWS = EMPTY_OBJECT$LWS, endowments$LWS = EMPTY_OBJECT$LWS, instrumentation$LWS = EMPTY_OBJECT$LWS, verboseInstrumentation$LWS = false) {
  return internalEvaluateInSandbox$LWS({
    context: context$LWS,
    document: sharedDom$LWS.rootDocument,
    endowments: endowments$LWS,
    globalObject: sharedDom$LWS.rootWindow,
    instrumentation: instrumentation$LWS,
    key: CORE_SANDBOX_KEY$LWS,
    source: source$LWS,
    sourceType: 1 /* SourceType.Module */,
    type: 1 /* SandboxType.Internal */,
    verboseInstrumentation: verboseInstrumentation$LWS
  });
}
function evaluateInSandbox$LWS(key$LWS, source$LWS, context$LWS = EMPTY_OBJECT$LWS, endowments$LWS = EMPTY_OBJECT$LWS, instrumentation$LWS = EMPTY_OBJECT$LWS, verboseInstrumentation$LWS = false) {
  return internalEvaluateInSandbox$LWS({
    context: context$LWS,
    document: sharedDom$LWS.rootDocument,
    endowments: endowments$LWS,
    globalObject: sharedDom$LWS.rootWindow,
    instrumentation: instrumentation$LWS,
    key: key$LWS,
    source: source$LWS,
    sourceType: 1 /* SourceType.Module */,
    type: 0 /* SandboxType.External */,
    verboseInstrumentation: verboseInstrumentation$LWS
  });
}
// istanbul ignore next: currently unreachable via tests, exclusively used in AMD format mode
function evaluateFunction$LWS(key$LWS, fn$LWS, scope$LWS = EMPTY_OBJECT$LWS, sourceURL$LWS = '', endowments$LWS = EMPTY_OBJECT$LWS, instrumentation$LWS = EMPTY_OBJECT$LWS, verboseInstrumentation$LWS = false) {
  const argValues$LWS = shared$LWS.toSafeArray([sharedDom$LWS.rootWindow.location, sharedDom$LWS.rootWindow.top]);
  const argNames$LWS = shared$LWS.toSafeArray(['location', 'top']);
  const providedScopeNames$LWS = shared$LWS.ObjectKeys(scope$LWS);
  for (let i$LWS = 0, {
      length: length$LWS
    } = providedScopeNames$LWS; i$LWS < length$LWS; i$LWS++) {
    const name$LWS = providedScopeNames$LWS[i$LWS];
    argNames$LWS.push(name$LWS);
    argValues$LWS.push(scope$LWS[name$LWS]);
  }
  return internalEvaluateInSandbox$LWS({
    context: EMPTY_OBJECT$LWS,
    document: sharedDom$LWS.rootDocument,
    endowments: endowments$LWS,
    globalObject: sharedDom$LWS.rootWindow,
    instrumentation: instrumentation$LWS,
    key: key$LWS,
    source: `((${argNames$LWS.join(',')}) => ${fn$LWS})\n${sourceURL$LWS}`,
    sourceType: 1 /* SourceType.Module */,
    type: 0 /* SandboxType.External */,
    verboseInstrumentation: verboseInstrumentation$LWS
  })(...argValues$LWS);
}
const sandboxDependencies$LWS = shared$LWS.toSafeMap(new shared$LWS.MapCtor());
const lprDepNames$LWS = shared$LWS.toSafeSet(new shared$LWS.SetCtor(['lightning/platformResourceLoader', 'lightning:platformResourceLoader', 'lightningmobileruntime/platformResourceLoader', 'lightningmobileruntime:platformResourceLoader']));
// istanbul ignore next: currently unreachable via tests, platformResourceLoader testing is exclusively done in AMD format mode
function wrapDependency$LWS(dep$LWS, depName$LWS, key$LWS) {
  if (depName$LWS === 'lwc' || depName$LWS === '@lwc/engine-dom' || depName$LWS === '@lwc:engine-dom') {
    return wrapLWC$LWS(dep$LWS, key$LWS);
  }
  if (lprDepNames$LWS.has(depName$LWS)) {
    return wrapPlatformResourceLoader$LWS(dep$LWS, key$LWS);
  }
  return dep$LWS;
}
/**
 * Given an instance of 'lwc,' this returns a facade with a limited set
 * of exposed properties. These properties are safe to expose in the
 * sandbox. High privilege properties are not exposed.
 * @param {any} dep 'lwc' fv
 * @param {string} key sandbox key
 */
// istanbul ignore next: currently unreachable via tests, platformResourceLoader testing is exclusively done in AMD format mode
function wrapLWC$LWS(dep$LWS, key$LWS) {
  let depRegistry$LWS = sandboxDependencies$LWS.get(key$LWS);
  if (depRegistry$LWS === undefined) {
    depRegistry$LWS = shared$LWS.toSafeWeakMap(new shared$LWS.WeakMapCtor());
    sandboxDependencies$LWS.set(key$LWS, depRegistry$LWS);
  }
  let secureDep$LWS = depRegistry$LWS.get(dep$LWS);
  if (secureDep$LWS) {
    return secureDep$LWS;
  }
  secureDep$LWS = shared$LWS.ObjectAssign({}, dep$LWS);
  shared$LWS.ReflectDefineProperty(secureDep$LWS, 'sanitizeAttribute', {
    __proto__: null,
    enumerable: true,
    configurable: true,
    writable: true,
    value(tag$LWS, _namespace$LWS, attrName$LWS, attrValue$LWS) {
      if ((attrName$LWS === 'href' || attrName$LWS === 'xlink:href') && shared$LWS.ReflectApply(shared$LWS.StringProtoToLowerCase, tag$LWS, []) === 'use') {
        return htmlSanitizer$LWS.sanitizeSvgHref(attrValue$LWS);
      }
      return attrValue$LWS;
    }
  });
  shared$LWS.ReflectDefineProperty(secureDep$LWS, 'renderer', {
    __proto__: null,
    enumerable: true,
    configurable: true,
    get: function () {
      let renderer$LWS;
      return function () {
        if (renderer$LWS === undefined) {
          renderer$LWS = createRootWindowSandboxRecord$LWS({
            key: key$LWS
          }).virtualEnvironmentEvaluator(`'use strict';
                    (${shared$LWS.ReflectApply(shared$LWS.FunctionProtoToString, dep$LWS.rendererFactory, [])})`)(dep$LWS.renderer);
        }
        return renderer$LWS;
      };
    }(),
    set(_value$LWS) {}
  });
  depRegistry$LWS.set(dep$LWS, secureDep$LWS);
  return secureDep$LWS;
}
/**
 * Given an instance of 'lightning/platfromResourceLoader,' this returns
 * our secure versions of 'loadScript' and 'loadStyle' from the sandbox helpers.
 * @param {any} dep 'lightning/platfromResourceLoader'
 * @param {string} key sandbox key
 */
// istanbul ignore next: currently unreachable via tests, platformResourceLoader testing is exclusively done in AMD format mode
function wrapPlatformResourceLoader$LWS(dep$LWS, key$LWS) {
  let depRegistry$LWS = sandboxDependencies$LWS.get(key$LWS);
  if (depRegistry$LWS === undefined) {
    depRegistry$LWS = shared$LWS.toSafeWeakMap(new shared$LWS.WeakMapCtor());
    sandboxDependencies$LWS.set(key$LWS, depRegistry$LWS);
  }
  let secureDep$LWS = depRegistry$LWS.get(dep$LWS);
  if (secureDep$LWS) {
    return secureDep$LWS;
  }
  secureDep$LWS = {
    loadScript: (cmp$LWS, url$LWS, config$LWS) => {
      const urlResolved$LWS = sharedUrl$LWS.resolveURL(url$LWS);
      const sandbox$LWS = createRootWindowSandboxRecord$LWS({
        key: key$LWS
      });
      if (shared$LWS.isGaterEnabledFeature('enableTrustedMode') && config$LWS != null && config$LWS.trustedMode) {
        const trustedGlobals$LWS = config$LWS.trustedGlobals;
        if ((trustedGlobals$LWS == null ? void 0 : trustedGlobals$LWS.length) > 0) {
          return dep$LWS.loadScript(cmp$LWS, urlResolved$LWS).then(() => {
            const installGlobals$LWS = sandbox$LWS.virtualEnvironmentEvaluator(`(list) => list.forEach(([key, get, set]) => Object.defineProperty(window, key, { get, set, configurable: true, enumerable: true }));`);
            const globals$LWS = trustedGlobals$LWS.map(globalName$LWS => [globalName$LWS, function get$LWS() {
              return window[globalName$LWS];
            }, function set$LWS(value$LWS) {
              window[globalName$LWS] = value$LWS;
            }]);
            installGlobals$LWS(globals$LWS);
          });
        }
        return dep$LWS.loadScript(cmp$LWS, urlResolved$LWS);
      }
      return sandbox$LWS.helpers.loadScript(cmp$LWS, urlResolved$LWS);
    },
    loadStyle: (cmp$LWS, url$LWS) => {
      const urlResolved$LWS = sharedUrl$LWS.resolveURL(url$LWS);
      return createRootWindowSandboxRecord$LWS({
        key: key$LWS
      }).helpers.loadStyle(cmp$LWS, urlResolved$LWS);
    }
  };
  depRegistry$LWS.set(dep$LWS, secureDep$LWS);
  return secureDep$LWS;
}
Object.defineProperty(exports, 'trusted', {
  enumerable: true,
  get: function () {
    return trustedTypes$LWS.trusted;
  }
});
exports.$LWS = $LWS;
exports.CORE_SANDBOX_KEY = CORE_SANDBOX_KEY$LWS;
exports.createRootWindowSandboxRecord = createRootWindowSandboxRecord$LWS;
exports.evaluateFunction = evaluateFunction$LWS;
exports.evaluateInCoreSandbox = evaluateInCoreSandbox$LWS;
exports.evaluateInSandbox = evaluateInSandbox$LWS;
exports.wrapDependency = wrapDependency$LWS;
/*! version: 0.23.6 */
