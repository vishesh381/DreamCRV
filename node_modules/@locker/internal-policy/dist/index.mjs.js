/*!
 * Copyright (C) 2023 salesforce.com, inc.
 */
import { getSanitizerForConfig as getSanitizerForConfig$LWS } from '@locker/html-sanitizer';
import { toSafeWeakMap as toSafeWeakMap$LWS, WeakMapCtor as WeakMapCtor$LWS, ReflectApply as ReflectApply$LWS, RegExpProtoTest as RegExpProtoTest$LWS, ErrorCtor as ErrorCtor$LWS, toSafeWeakSet as toSafeWeakSet$LWS, WeakSetCtor as WeakSetCtor$LWS, LockerSecurityError as LockerSecurityError$LWS, ERR_INVALID_SANDBOX_KEY as ERR_INVALID_SANDBOX_KEY$LWS, PromiseProtoThen as PromiseProtoThen$LWS, ReflectDefineProperty as ReflectDefineProperty$LWS, FunctionProtoBind as FunctionProtoBind$LWS, ReflectDeleteProperty as ReflectDeleteProperty$LWS } from '@locker/shared';
import { AbortControllerCtor as AbortControllerCtor$LWS, HTMLAnchorElementProtoHostnameGetter as HTMLAnchorElementProtoHostnameGetter$LWS, AbortControllerProtoSignalGetter as AbortControllerProtoSignalGetter$LWS, WindowFetch as WindowFetch$LWS, ResponseProtoOkGetter as ResponseProtoOkGetter$LWS, ResponseProtoText as ResponseProtoText$LWS, AbortControllerProtoAbort as AbortControllerProtoAbort$LWS, DocumentProtoCreateElement as DocumentProtoCreateElement$LWS, ElementProtoInnerHTMLSetter as ElementProtoInnerHTMLSetter$LWS, DocumentProtoCreateElementNS as DocumentProtoCreateElementNS$LWS, NAMESPACE_SVG as NAMESPACE_SVG$LWS, NodeProtoFirstChildGetter as NodeProtoFirstChildGetter$LWS, ElementProtoInnerHTMLGetter as ElementProtoInnerHTMLGetter$LWS, HTMLTemplateElementProtoContentGetter as HTMLTemplateElementProtoContentGetter$LWS, NodeProtoIsConnectedGetter as NodeProtoIsConnectedGetter$LWS, URLCreateObjectURL as URLCreateObjectURL$LWS, BlobCtor as BlobCtor$LWS, ElementProtoGetAttribute as ElementProtoGetAttribute$LWS, ElementProtoHasAttribute as ElementProtoHasAttribute$LWS, ElementProtoNamespaceURIGetter as ElementProtoNamespaceURIGetter$LWS, ElementProtoSetAttributeNS as ElementProtoSetAttributeNS$LWS, URLRevokeObjectURL as URLRevokeObjectURL$LWS, EventTargetProtoAddEventListener as EventTargetProtoAddEventListener$LWS, HTMLScriptElementCtor as HTMLScriptElementCtor$LWS, NAMESPACE_XHTML as NAMESPACE_XHTML$LWS, NAMESPACE_XLINK as NAMESPACE_XLINK$LWS, EventTargetProtoRemoveEventListener as EventTargetProtoRemoveEventListener$LWS } from '@locker/shared-dom';
import { normalizerAnchor as normalizerAnchor$LWS, TRUSTED_DOMAINS_REG_EXP as TRUSTED_DOMAINS_REG_EXP$LWS, resolveURL as resolveURL$LWS } from '@locker/shared-url';
import { createPolicy as createPolicy$LWS, trusted as trusted$LWS } from '@locker/trusted-types';
const inflightRequests$LWS = toSafeWeakMap$LWS(new WeakMapCtor$LWS());
async function getSourceText$LWS(resourceURL$LWS, targetElement$LWS) {
  abortInFlightRequest$LWS(targetElement$LWS);
  const controller$LWS = new AbortControllerCtor$LWS();
  inflightRequests$LWS.set(targetElement$LWS, controller$LWS);
  // The error "The value of the 'Access-Control-Allow-Origin' header in the
  // response must not be the wildcard '*' when the request's credentials mode
  // is 'include'" occurs when the Access-Control-Allow-Credentials header is
  // set to true and the Access-Control-Allow-Origin header is set to an asterisk *.
  //
  // The error may be resolved in one of two ways:
  //   1) Set the Access-Control-Allow-Credentials header to 'false' and keep
  //      the Access-Control-Allow-Origin header as an asterisk * to allow all
  //      origins to access your server.
  //   2) Set the Access-Control-Allow-Origin header to a specific origin,
  //      e.g. 'http://localhost:3000' or a list of allowlisted origins that
  //      are allowed to access your server. Note that the origin must specify
  //      the protocol, domain and port.
  const hostname$LWS = ReflectApply$LWS(HTMLAnchorElementProtoHostnameGetter$LWS, normalizerAnchor$LWS, []);
  // To avoid the CORS error above without burdening users with header adjustments
  // we limit credentials mode of 'include' to "trusted" domains.
  const credentials$LWS = ReflectApply$LWS(RegExpProtoTest$LWS, TRUSTED_DOMAINS_REG_EXP$LWS, [hostname$LWS]) ? 'include' : 'same-origin';
  const signal$LWS = ReflectApply$LWS(AbortControllerProtoSignalGetter$LWS, controller$LWS, []);
  const response$LWS = await WindowFetch$LWS(resourceURL$LWS, {
    __proto__: null,
    method: 'GET',
    credentials: credentials$LWS,
    signal: signal$LWS
  });
  inflightRequests$LWS.delete(targetElement$LWS);
  if (!ReflectApply$LWS(ResponseProtoOkGetter$LWS, response$LWS, [])) {
    throw new ErrorCtor$LWS('Request failed.');
  }
  const sourceText$LWS = await ReflectApply$LWS(ResponseProtoText$LWS, response$LWS, []);
  return sourceText$LWS;
}
function abortInFlightRequest$LWS(element$LWS) {
  const abortController$LWS = inflightRequests$LWS.get(element$LWS);
  // istanbul ignore if: currently unreachable via tests (this path can be invoked, however it will cause the tests to time out)
  if (abortController$LWS) {
    ReflectApply$LWS(AbortControllerProtoAbort$LWS, abortController$LWS, []);
  }
}
const EVALUATOR_PROPERTY_KEY$LWS = '$evaluator$';
const BLOB_SCRIPT_SOURCE$LWS = `document.currentScript['${EVALUATOR_PROPERTY_KEY$LWS}']`;

// eslint-disable-next-line no-shadow
var ContentType$LWS;
(function (ContentType$LWS) {
  ContentType$LWS[ContentType$LWS["HTML"] = 0] = "HTML";
  ContentType$LWS[ContentType$LWS["SVG"] = 1] = "SVG";
  ContentType$LWS[ContentType$LWS["XML"] = 2] = "XML";
})(ContentType$LWS || (ContentType$LWS = {}));
const evaluatedScripts$LWS = toSafeWeakSet$LWS(new WeakSetCtor$LWS());
const scriptURLsCache$LWS = toSafeWeakMap$LWS(new WeakMapCtor$LWS());
const htmlTemplate$LWS = ReflectApply$LWS(DocumentProtoCreateElement$LWS, document, ['template']);
const policyOptions$LWS = {
  createHTML(dirty$LWS, lwsKey$LWS, contentType$LWS) {
    // istanbul ignore if: currently unreachable via tests, may indicate a dead code path
    if (dirty$LWS === null || dirty$LWS === undefined) {
      return '';
    }
    if (typeof lwsKey$LWS !== 'string') {
      throw new LockerSecurityError$LWS(ERR_INVALID_SANDBOX_KEY$LWS);
    }
    switch (contentType$LWS) {
      case ContentType$LWS.HTML:
        {
          ReflectApply$LWS(ElementProtoInnerHTMLSetter$LWS, htmlTemplate$LWS, [trusted$LWS.createHTML(dirty$LWS)]);
          const content$LWS = ReflectApply$LWS(HTMLTemplateElementProtoContentGetter$LWS, htmlTemplate$LWS, []);
          const sanitizer$LWS = getSanitizerForConfig$LWS(lwsKey$LWS, 'NODE_ALL_IN_PLACE');
          sanitizer$LWS.sanitize(content$LWS);
          return ReflectApply$LWS(ElementProtoInnerHTMLGetter$LWS, htmlTemplate$LWS, []);
        }
      case ContentType$LWS.SVG:
        {
          const tplElement$LWS = ReflectApply$LWS(DocumentProtoCreateElement$LWS, document, ['template']);
          ReflectApply$LWS(ElementProtoInnerHTMLSetter$LWS, tplElement$LWS, [trusted$LWS.createHTML(dirty$LWS)]);
          const wrappedDirty$LWS = ReflectApply$LWS(DocumentProtoCreateElementNS$LWS, document, [NAMESPACE_SVG$LWS, 'svg']);
          ReflectApply$LWS(ElementProtoInnerHTMLSetter$LWS, wrappedDirty$LWS, [trusted$LWS.createHTML(dirty$LWS)]);
          const sanitized$LWS = getSanitizerForConfig$LWS('SHARED_SVG_SANITIZER_KEY', 'NODE_SVG').sanitize(wrappedDirty$LWS);
          const firstChild$LWS = ReflectApply$LWS(NodeProtoFirstChildGetter$LWS, sanitized$LWS, []);
          return ReflectApply$LWS(ElementProtoInnerHTMLGetter$LWS, firstChild$LWS, []);
        }
      case ContentType$LWS.XML:
        return dirty$LWS;
      default:
        return '';
    }
  },
  createScript(_dirty$LWS, _evaluator$LWS) {
    return '';
  },
  createScriptURL(dirty$LWS, evaluator$LWS, targetElement$LWS) {
    const setURL$LWS = encloseSrcSetter$LWS(targetElement$LWS);
    dirty$LWS = `${dirty$LWS}`;
    // Passthrough for any script element evaluated by us
    // or if userland code tries to set a falsy value.
    if (evaluatedScripts$LWS.has(targetElement$LWS) || dirty$LWS === '' || dirty$LWS === 'undefined' || dirty$LWS === 'null') {
      setURL$LWS(trusted$LWS.createScriptURL(dirty$LWS));
      return dirty$LWS;
    }
    const targetElementIsConnected$LWS = ReflectApply$LWS(NodeProtoIsConnectedGetter$LWS, targetElement$LWS, []);
    const resolvedURL$LWS = resolveURL$LWS(dirty$LWS);
    if (targetElementIsConnected$LWS) {
      // When the script is connected and has a .src value it is safe to let the url passthrough
      // because it will never be evaluated again.
      if (getURL$LWS(targetElement$LWS)) {
        evaluatedScripts$LWS.add(targetElement$LWS);
        setURL$LWS(trusted$LWS.createScriptURL(dirty$LWS));
        return dirty$LWS;
      }
      // There is a small window while the source code is asynchronously fetched but the script may
      // have already been placed in the DOM without having yet our blob URL set as the .src value.
      // We block the request in this scenario and set the last URL after we evaluate.
      if (scriptURLsCache$LWS.has(targetElement$LWS)) {
        return '';
      }
    }
    const asyncRequest$LWS = getSourceText$LWS(resolvedURL$LWS, targetElement$LWS);
    scriptURLsCache$LWS.set(targetElement$LWS, resolvedURL$LWS);
    const safeURL$LWS = createSandboxURL$LWS();
    const onFulfill$LWS = sourceText$LWS => {
      ReflectDefineProperty$LWS(targetElement$LWS, EVALUATOR_PROPERTY_KEY$LWS, {
        __proto__: null,
        configurable: true,
        get: ReflectApply$LWS(FunctionProtoBind$LWS, () => {
          ReflectDeleteProperty$LWS(targetElement$LWS, EVALUATOR_PROPERTY_KEY$LWS);
          URLRevokeObjectURL$LWS(safeURL$LWS);
          const cachedURL$LWS = scriptURLsCache$LWS.get(targetElement$LWS);
          scriptURLsCache$LWS.delete(targetElement$LWS);
          evaluatedScripts$LWS.add(targetElement$LWS);
          // We sign & assign the original URL even though it will not be executed.
          // The wrappedEvaluator is guaranteed to run only one time once the script
          // is appended in the dom.
          // Re-assigning .src after it ran will not retrigger the evaluation
          // of the new URL.
          // However, TrustedTypes still requires this assignment to be signed.
          // We do this because we don't want to leave observable traces in the DOM.
          setURL$LWS(trusted$LWS.createScriptURL(cachedURL$LWS));
          evaluator$LWS(sourceText$LWS);
        }, [targetElement$LWS]),
        set: undefined
      });
      setURL$LWS(trusted$LWS.createScriptURL(safeURL$LWS));
    };
    const onReject$LWS = _error$LWS => {
      URLRevokeObjectURL$LWS(safeURL$LWS);
      const cachedURL$LWS = scriptURLsCache$LWS.get(targetElement$LWS);
      scriptURLsCache$LWS.delete(targetElement$LWS);
      // We are only able to generate 404 errors and we cannot trust any other URL.
      // This blob URL will be sufficient to trigger error event handlers.
      // We still have to sign this URL, TrustedTypes does not take into consideration
      // the state of the script elements. It's an either or operation: either we set a
      // signed value and we are ok or we don't and the browser throws an error. We
      // want our 404 URL to be set and trigger the event handlers, hence we have to sign.
      setURL$LWS(trusted$LWS.createScriptURL('blob:http://localhost/not-found'));
      // This error event handler will get triggered after we set our 404 blob URL.
      const errorEventHandler$LWS = () => {
        // Similar to our wrappedEvaluator, we leave no traces.
        setURL$LWS(trusted$LWS.createScriptURL(cachedURL$LWS));
        ReflectApply$LWS(EventTargetProtoRemoveEventListener$LWS, targetElement$LWS, ['error', errorEventHandler$LWS]);
      };
      ReflectApply$LWS(EventTargetProtoAddEventListener$LWS, targetElement$LWS, ['error', errorEventHandler$LWS]);
    };
    ReflectApply$LWS(PromiseProtoThen$LWS, asyncRequest$LWS, [onFulfill$LWS, onReject$LWS]);
    return '';
  }
};
const lwsInternalPolicy$LWS = createPolicy$LWS('lwsInternal', policyOptions$LWS);
// Even though the content is always the same we use unique URLs for each script.
function createSandboxURL$LWS() {
  return URLCreateObjectURL$LWS(new BlobCtor$LWS([BLOB_SCRIPT_SOURCE$LWS], {
    __proto__: null,
    type: 'text/javascript'
  }));
}
function getURL$LWS(targetElement$LWS) {
  const isHTMLScriptElement$LWS = targetElement$LWS instanceof HTMLScriptElementCtor$LWS;
  if (isHTMLScriptElement$LWS) {
    return ReflectApply$LWS(ElementProtoGetAttribute$LWS, targetElement$LWS, ['src']);
  }
  const hasHref$LWS = ReflectApply$LWS(ElementProtoHasAttribute$LWS, targetElement$LWS, ['href']);
  return hasHref$LWS ? ReflectApply$LWS(ElementProtoGetAttribute$LWS, targetElement$LWS, ['href']) : ReflectApply$LWS(ElementProtoGetAttribute$LWS, targetElement$LWS, ['xlink:href']);
}
function encloseSrcSetter$LWS(targetElement$LWS) {
  const namespaceURI$LWS = ReflectApply$LWS(ElementProtoNamespaceURIGetter$LWS, targetElement$LWS, []);
  const attributeNamespaceURI$LWS = namespaceURI$LWS === NAMESPACE_XHTML$LWS ? '' : NAMESPACE_XLINK$LWS;
  const attributeName$LWS = targetElement$LWS instanceof HTMLScriptElementCtor$LWS ? 'src' : 'href';
  return function (src$LWS) {
    ReflectApply$LWS(ElementProtoSetAttributeNS$LWS, targetElement$LWS, [attributeNamespaceURI$LWS, attributeName$LWS, src$LWS]);
  };
}
export { ContentType$LWS as ContentType, lwsInternalPolicy$LWS as lwsInternalPolicy };
/*! version: 0.23.6 */
