/*!
 * Copyright (C) 2023 salesforce.com, inc.
 */
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var htmlSanitizer$LWS = require('@locker/html-sanitizer');
var shared$LWS = require('@locker/shared');
var sharedDom$LWS = require('@locker/shared-dom');
var sharedUrl$LWS = require('@locker/shared-url');
var trustedTypes$LWS = require('@locker/trusted-types');
const inflightRequests$LWS = shared$LWS.toSafeWeakMap(new shared$LWS.WeakMapCtor());
async function getSourceText$LWS(resourceURL$LWS, targetElement$LWS) {
  abortInFlightRequest$LWS(targetElement$LWS);
  const controller$LWS = new sharedDom$LWS.AbortControllerCtor();
  inflightRequests$LWS.set(targetElement$LWS, controller$LWS);
  // The error "The value of the 'Access-Control-Allow-Origin' header in the
  // response must not be the wildcard '*' when the request's credentials mode
  // is 'include'" occurs when the Access-Control-Allow-Credentials header is
  // set to true and the Access-Control-Allow-Origin header is set to an asterisk *.
  //
  // The error may be resolved in one of two ways:
  //   1) Set the Access-Control-Allow-Credentials header to 'false' and keep
  //      the Access-Control-Allow-Origin header as an asterisk * to allow all
  //      origins to access your server.
  //   2) Set the Access-Control-Allow-Origin header to a specific origin,
  //      e.g. 'http://localhost:3000' or a list of allowlisted origins that
  //      are allowed to access your server. Note that the origin must specify
  //      the protocol, domain and port.
  const hostname$LWS = shared$LWS.ReflectApply(sharedDom$LWS.HTMLAnchorElementProtoHostnameGetter, sharedUrl$LWS.normalizerAnchor, []);
  // To avoid the CORS error above without burdening users with header adjustments
  // we limit credentials mode of 'include' to "trusted" domains.
  const credentials$LWS = shared$LWS.ReflectApply(shared$LWS.RegExpProtoTest, sharedUrl$LWS.TRUSTED_DOMAINS_REG_EXP, [hostname$LWS]) ? 'include' : 'same-origin';
  const signal$LWS = shared$LWS.ReflectApply(sharedDom$LWS.AbortControllerProtoSignalGetter, controller$LWS, []);
  const response$LWS = await sharedDom$LWS.WindowFetch(resourceURL$LWS, {
    __proto__: null,
    method: 'GET',
    credentials: credentials$LWS,
    signal: signal$LWS
  });
  inflightRequests$LWS.delete(targetElement$LWS);
  if (!shared$LWS.ReflectApply(sharedDom$LWS.ResponseProtoOkGetter, response$LWS, [])) {
    throw new shared$LWS.ErrorCtor('Request failed.');
  }
  const sourceText$LWS = await shared$LWS.ReflectApply(sharedDom$LWS.ResponseProtoText, response$LWS, []);
  return sourceText$LWS;
}
function abortInFlightRequest$LWS(element$LWS) {
  const abortController$LWS = inflightRequests$LWS.get(element$LWS);
  // istanbul ignore if: currently unreachable via tests (this path can be invoked, however it will cause the tests to time out)
  if (abortController$LWS) {
    shared$LWS.ReflectApply(sharedDom$LWS.AbortControllerProtoAbort, abortController$LWS, []);
  }
}
const EVALUATOR_PROPERTY_KEY$LWS = '$evaluator$';
const BLOB_SCRIPT_SOURCE$LWS = `document.currentScript['${EVALUATOR_PROPERTY_KEY$LWS}']`;

// eslint-disable-next-line no-shadow
exports.ContentType = void 0;
(function (ContentType$LWS) {
  ContentType$LWS[ContentType$LWS["HTML"] = 0] = "HTML";
  ContentType$LWS[ContentType$LWS["SVG"] = 1] = "SVG";
  ContentType$LWS[ContentType$LWS["XML"] = 2] = "XML";
})(exports.ContentType || (exports.ContentType = {}));
const evaluatedScripts$LWS = shared$LWS.toSafeWeakSet(new shared$LWS.WeakSetCtor());
const scriptURLsCache$LWS = shared$LWS.toSafeWeakMap(new shared$LWS.WeakMapCtor());
const htmlTemplate$LWS = shared$LWS.ReflectApply(sharedDom$LWS.DocumentProtoCreateElement, document, ['template']);
const policyOptions$LWS = {
  createHTML(dirty$LWS, lwsKey$LWS, contentType$LWS) {
    // istanbul ignore if: currently unreachable via tests, may indicate a dead code path
    if (dirty$LWS === null || dirty$LWS === undefined) {
      return '';
    }
    if (typeof lwsKey$LWS !== 'string') {
      throw new shared$LWS.LockerSecurityError(shared$LWS.ERR_INVALID_SANDBOX_KEY);
    }
    switch (contentType$LWS) {
      case exports.ContentType.HTML:
        {
          shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoInnerHTMLSetter, htmlTemplate$LWS, [trustedTypes$LWS.trusted.createHTML(dirty$LWS)]);
          const content$LWS = shared$LWS.ReflectApply(sharedDom$LWS.HTMLTemplateElementProtoContentGetter, htmlTemplate$LWS, []);
          const sanitizer$LWS = htmlSanitizer$LWS.getSanitizerForConfig(lwsKey$LWS, 'NODE_ALL_IN_PLACE');
          sanitizer$LWS.sanitize(content$LWS);
          return shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoInnerHTMLGetter, htmlTemplate$LWS, []);
        }
      case exports.ContentType.SVG:
        {
          const tplElement$LWS = shared$LWS.ReflectApply(sharedDom$LWS.DocumentProtoCreateElement, document, ['template']);
          shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoInnerHTMLSetter, tplElement$LWS, [trustedTypes$LWS.trusted.createHTML(dirty$LWS)]);
          const wrappedDirty$LWS = shared$LWS.ReflectApply(sharedDom$LWS.DocumentProtoCreateElementNS, document, [sharedDom$LWS.NAMESPACE_SVG, 'svg']);
          shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoInnerHTMLSetter, wrappedDirty$LWS, [trustedTypes$LWS.trusted.createHTML(dirty$LWS)]);
          const sanitized$LWS = htmlSanitizer$LWS.getSanitizerForConfig('SHARED_SVG_SANITIZER_KEY', 'NODE_SVG').sanitize(wrappedDirty$LWS);
          const firstChild$LWS = shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoFirstChildGetter, sanitized$LWS, []);
          return shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoInnerHTMLGetter, firstChild$LWS, []);
        }
      case exports.ContentType.XML:
        return dirty$LWS;
      default:
        return '';
    }
  },
  createScript(_dirty$LWS, _evaluator$LWS) {
    return '';
  },
  createScriptURL(dirty$LWS, evaluator$LWS, targetElement$LWS) {
    const setURL$LWS = encloseSrcSetter$LWS(targetElement$LWS);
    dirty$LWS = `${dirty$LWS}`;
    // Passthrough for any script element evaluated by us
    // or if userland code tries to set a falsy value.
    if (evaluatedScripts$LWS.has(targetElement$LWS) || dirty$LWS === '' || dirty$LWS === 'undefined' || dirty$LWS === 'null') {
      setURL$LWS(trustedTypes$LWS.trusted.createScriptURL(dirty$LWS));
      return dirty$LWS;
    }
    const targetElementIsConnected$LWS = shared$LWS.ReflectApply(sharedDom$LWS.NodeProtoIsConnectedGetter, targetElement$LWS, []);
    const resolvedURL$LWS = sharedUrl$LWS.resolveURL(dirty$LWS);
    if (targetElementIsConnected$LWS) {
      // When the script is connected and has a .src value it is safe to let the url passthrough
      // because it will never be evaluated again.
      if (getURL$LWS(targetElement$LWS)) {
        evaluatedScripts$LWS.add(targetElement$LWS);
        setURL$LWS(trustedTypes$LWS.trusted.createScriptURL(dirty$LWS));
        return dirty$LWS;
      }
      // There is a small window while the source code is asynchronously fetched but the script may
      // have already been placed in the DOM without having yet our blob URL set as the .src value.
      // We block the request in this scenario and set the last URL after we evaluate.
      if (scriptURLsCache$LWS.has(targetElement$LWS)) {
        return '';
      }
    }
    const asyncRequest$LWS = getSourceText$LWS(resolvedURL$LWS, targetElement$LWS);
    scriptURLsCache$LWS.set(targetElement$LWS, resolvedURL$LWS);
    const safeURL$LWS = createSandboxURL$LWS();
    const onFulfill$LWS = sourceText$LWS => {
      shared$LWS.ReflectDefineProperty(targetElement$LWS, EVALUATOR_PROPERTY_KEY$LWS, {
        __proto__: null,
        configurable: true,
        get: shared$LWS.ReflectApply(shared$LWS.FunctionProtoBind, () => {
          shared$LWS.ReflectDeleteProperty(targetElement$LWS, EVALUATOR_PROPERTY_KEY$LWS);
          sharedDom$LWS.URLRevokeObjectURL(safeURL$LWS);
          const cachedURL$LWS = scriptURLsCache$LWS.get(targetElement$LWS);
          scriptURLsCache$LWS.delete(targetElement$LWS);
          evaluatedScripts$LWS.add(targetElement$LWS);
          // We sign & assign the original URL even though it will not be executed.
          // The wrappedEvaluator is guaranteed to run only one time once the script
          // is appended in the dom.
          // Re-assigning .src after it ran will not retrigger the evaluation
          // of the new URL.
          // However, TrustedTypes still requires this assignment to be signed.
          // We do this because we don't want to leave observable traces in the DOM.
          setURL$LWS(trustedTypes$LWS.trusted.createScriptURL(cachedURL$LWS));
          evaluator$LWS(sourceText$LWS);
        }, [targetElement$LWS]),
        set: undefined
      });
      setURL$LWS(trustedTypes$LWS.trusted.createScriptURL(safeURL$LWS));
    };
    const onReject$LWS = _error$LWS => {
      sharedDom$LWS.URLRevokeObjectURL(safeURL$LWS);
      const cachedURL$LWS = scriptURLsCache$LWS.get(targetElement$LWS);
      scriptURLsCache$LWS.delete(targetElement$LWS);
      // We are only able to generate 404 errors and we cannot trust any other URL.
      // This blob URL will be sufficient to trigger error event handlers.
      // We still have to sign this URL, TrustedTypes does not take into consideration
      // the state of the script elements. It's an either or operation: either we set a
      // signed value and we are ok or we don't and the browser throws an error. We
      // want our 404 URL to be set and trigger the event handlers, hence we have to sign.
      setURL$LWS(trustedTypes$LWS.trusted.createScriptURL('blob:http://localhost/not-found'));
      // This error event handler will get triggered after we set our 404 blob URL.
      const errorEventHandler$LWS = () => {
        // Similar to our wrappedEvaluator, we leave no traces.
        setURL$LWS(trustedTypes$LWS.trusted.createScriptURL(cachedURL$LWS));
        shared$LWS.ReflectApply(sharedDom$LWS.EventTargetProtoRemoveEventListener, targetElement$LWS, ['error', errorEventHandler$LWS]);
      };
      shared$LWS.ReflectApply(sharedDom$LWS.EventTargetProtoAddEventListener, targetElement$LWS, ['error', errorEventHandler$LWS]);
    };
    shared$LWS.ReflectApply(shared$LWS.PromiseProtoThen, asyncRequest$LWS, [onFulfill$LWS, onReject$LWS]);
    return '';
  }
};
const lwsInternalPolicy$LWS = trustedTypes$LWS.createPolicy('lwsInternal', policyOptions$LWS);
// Even though the content is always the same we use unique URLs for each script.
function createSandboxURL$LWS() {
  return sharedDom$LWS.URLCreateObjectURL(new sharedDom$LWS.BlobCtor([BLOB_SCRIPT_SOURCE$LWS], {
    __proto__: null,
    type: 'text/javascript'
  }));
}
function getURL$LWS(targetElement$LWS) {
  const isHTMLScriptElement$LWS = targetElement$LWS instanceof sharedDom$LWS.HTMLScriptElementCtor;
  if (isHTMLScriptElement$LWS) {
    return shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoGetAttribute, targetElement$LWS, ['src']);
  }
  const hasHref$LWS = shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoHasAttribute, targetElement$LWS, ['href']);
  return hasHref$LWS ? shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoGetAttribute, targetElement$LWS, ['href']) : shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoGetAttribute, targetElement$LWS, ['xlink:href']);
}
function encloseSrcSetter$LWS(targetElement$LWS) {
  const namespaceURI$LWS = shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoNamespaceURIGetter, targetElement$LWS, []);
  const attributeNamespaceURI$LWS = namespaceURI$LWS === sharedDom$LWS.NAMESPACE_XHTML ? '' : sharedDom$LWS.NAMESPACE_XLINK;
  const attributeName$LWS = targetElement$LWS instanceof sharedDom$LWS.HTMLScriptElementCtor ? 'src' : 'href';
  return function (src$LWS) {
    shared$LWS.ReflectApply(sharedDom$LWS.ElementProtoSetAttributeNS, targetElement$LWS, [attributeNamespaceURI$LWS, attributeName$LWS, src$LWS]);
  };
}
exports.lwsInternalPolicy = lwsInternalPolicy$LWS;
/*! version: 0.23.6 */
