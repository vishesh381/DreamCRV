/*!
 * Copyright (C) 2019 salesforce.com, inc.
 */
import { ArrayConcat as ArrayConcat$LWS, shallowCloneArray as shallowCloneArray$LWS, ObjectAssign as ObjectAssign$LWS, ReflectApply as ReflectApply$LWS, ArrayProtoFilter as ArrayProtoFilter$LWS, toSafeArray as toSafeArray$LWS, toSafeSet as toSafeSet$LWS, SetCtor as SetCtor$LWS, LockerSecurityError as LockerSecurityError$LWS, ERR_INVALID_SANDBOX_KEY as ERR_INVALID_SANDBOX_KEY$LWS, toSafeStringValue as toSafeStringValue$LWS, StringProtoStartsWith as StringProtoStartsWith$LWS, StringProtoSplit as StringProtoSplit$LWS, StringProtoToLowerCase as StringProtoToLowerCase$LWS, StringProtoReplace as StringProtoReplace$LWS, StringProtoToUpperCase as StringProtoToUpperCase$LWS, RegExpProtoTest as RegExpProtoTest$LWS } from '@locker/shared';
import { DocumentProtoCreateElement as DocumentProtoCreateElement$LWS, DocumentProtoGetElementById as DocumentProtoGetElementById$LWS, WindowSetInterval as WindowSetInterval$LWS, WindowClearInterval as WindowClearInterval$LWS, XhrCtor as XhrCtor$LWS, EventTargetProtoAddEventListener as EventTargetProtoAddEventListener$LWS, XhrProtoStatusGetter as XhrProtoStatusGetter$LWS, XhrProtoResponseTextGetter as XhrProtoResponseTextGetter$LWS, DocumentFragmentProtoGetElementById as DocumentFragmentProtoGetElementById$LWS, ElementProtoSetAttribute as ElementProtoSetAttribute$LWS, NodeProtoAppendChild as NodeProtoAppendChild$LWS, XhrProtoOpen as XhrProtoOpen$LWS, XhrProtoSend as XhrProtoSend$LWS, HTMLAnchorElementProtoHrefSetter as HTMLAnchorElementProtoHrefSetter$LWS, HTMLAnchorElementProtoHrefGetter as HTMLAnchorElementProtoHrefGetter$LWS, HTMLAnchorElementProtoProtocolGetter as HTMLAnchorElementProtoProtocolGetter$LWS, NodeProtoNodeNameGetter as NodeProtoNodeNameGetter$LWS, DocumentProtoBodyGetter as DocumentProtoBodyGetter$LWS, ElementProtoQuerySelector as ElementProtoQuerySelector$LWS, ElementProtoHasAttribute as ElementProtoHasAttribute$LWS, CUSTOM_ELEMENT_REGISTRY_ATTRIBUTE_NAME as CUSTOM_ELEMENT_REGISTRY_ATTRIBUTE_NAME$LWS } from '@locker/shared-dom';
import { URL_SCHEMES_LIST as URL_SCHEMES_LIST$LWS, normalizerAnchor as normalizerAnchor$LWS } from '@locker/shared-url';
import createDOMPurify$LWS from 'dompurify';
import { trusted as trusted$LWS } from '@locker/trusted-types';
const additionalAttributes$LWS = ['role', 'part', 'target'];
const htmlTags$LWS = ['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blockquote', 'body', 'br', 'button', 'caption', 'canvas', 'center', 'cite', 'code', 'col', 'colgroup', 'command', 'datalist', 'dd', 'del', 'details', 'dfn', 'dir', 'div', 'dl', 'dt', 'em', 'fieldset', 'figure', 'figcaption', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'i', 'iframe', 'img', 'input', 'ins', 'keygen', 'kbd', 'label', 'legend', 'li', 'map', 'mark', 'menu', 'meter', 'nav', 'ol', 'optgroup', 'option', 'output', 'p', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'small', 'source', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr'];
const miscTags$LWS = ['#comment', '#document-fragment'];
const svgTags$LWS = ['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'audio', 'canvas', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'video', 'view', 'vkern', 'use'];
const allHTMLTags$LWS = ArrayConcat$LWS(htmlTags$LWS, svgTags$LWS, miscTags$LWS);
const allSVGTags$LWS = ArrayConcat$LWS(svgTags$LWS, miscTags$LWS);
const CUSTOM_ELEMENT_HANDLING$LWS = {
  attributeNameCheck: /.+/,
  allowCustomizedBuiltInElements: false,
  // The regexp is based on the WHATWG spec:
  // https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name
  // However, DOMPurify sanitizes unicode characters (\u0000-\uFFFF) in tag name.
  tagNameCheck: /^[a-z][-_.\w]*-[-.0-9_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u37D0\u37F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u10000-\uEFFFF]*$/
};
// A generic config in which the sanitizer attempts in place sanitization and
// returns node.
const NODE_ALL_IN_PLACE$LWS = {
  ADD_ATTR: shallowCloneArray$LWS(additionalAttributes$LWS),
  // Add '#document-fragment' to ALLOWED_TAGS to avoid a forbidden root node
  // exception.
  // https://github.com/cure53/DOMPurify/issues/664
  ALLOWED_TAGS: shallowCloneArray$LWS(allHTMLTags$LWS),
  CUSTOM_ELEMENT_HANDLING: ObjectAssign$LWS({}, CUSTOM_ELEMENT_HANDLING$LWS),
  IN_PLACE: true,
  // @ts-ignore this type is on DOMPurifyConfig
  TRUSTED_TYPES_POLICY: trusted$LWS
};
// A config to use only svg tags in which the sanitizer returns a document
// fragment.
const NODE_SVG$LWS = {
  ADD_ATTR: shallowCloneArray$LWS(additionalAttributes$LWS),
  ALLOWED_TAGS: shallowCloneArray$LWS(allSVGTags$LWS),
  CUSTOM_ELEMENT_HANDLING: ObjectAssign$LWS({}, CUSTOM_ELEMENT_HANDLING$LWS),
  RETURN_DOM_FRAGMENT: true,
  SANITIZE_DOM: false,
  // @ts-ignore this type is on DOMPurifyConfig
  TRUSTED_TYPES_POLICY: trusted$LWS
};
// A config to use only tags allowed for blob and file.
const STRING_BLOB_HTML$LWS = {
  ADD_ATTR: shallowCloneArray$LWS(additionalAttributes$LWS),
  ALLOWED_TAGS: ReflectApply$LWS(ArrayProtoFilter$LWS, allHTMLTags$LWS, [tag$LWS => tag$LWS !== 'iframe']),
  CUSTOM_ELEMENT_HANDLING: ObjectAssign$LWS({}, CUSTOM_ELEMENT_HANDLING$LWS),
  SANITIZE_DOM: false,
  // @ts-ignore this type is on DOMPurifyConfig
  TRUSTED_TYPES_POLICY: trusted$LWS
};
var CONFIG$LWS = /*#__PURE__*/Object.freeze({
  __proto__: null,
  NODE_ALL_IN_PLACE: NODE_ALL_IN_PLACE$LWS,
  NODE_SVG: NODE_SVG$LWS,
  STRING_BLOB_HTML: STRING_BLOB_HTML$LWS
});
const instancesBySandboxKeyRegistry$LWS = {
  __proto__: null
};
const SANITIZE_ATTRIBUTES_LIST$LWS = toSafeArray$LWS(['href', 'xlink:href']);
const SHARED_SVG_SANITIZER_KEY$LWS = 'SHARED_SVG_SANITIZER_KEY';
ReflectApply$LWS(DocumentProtoCreateElement$LWS, document, ['template']);
// Queue for managing pending XHR requests.
const queue$LWS = toSafeSet$LWS(new SetCtor$LWS());
// A regexp to find all non lowercase alphanumeric.
const urlReplacerRegExp$LWS = /[^a-z0-9]+/gi;
function createSantizerHooksRegistry$LWS(sandboxKey$LWS) {
  return {
    __proto__: null,
    // uponSanitizeAttribute is generic, so its definition can be a reused function
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    uponSanitizeAttribute: uponSanitizeAttribute$LWS,
    // uponSanitizeElement is sandbox-key-specific
    uponSanitizeElement(node$LWS, data$LWS, config$LWS) {
      var _config$CUSTOM_ELEMEN$LWS;
      const {
        tagName: tagName$LWS
      } = data$LWS;
      // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
      const tagNameCheck$LWS = config$LWS == null || (_config$CUSTOM_ELEMEN$LWS = config$LWS.CUSTOM_ELEMENT_HANDLING) == null ? void 0 : _config$CUSTOM_ELEMEN$LWS.tagNameCheck;
      if (tagNameCheck$LWS && ReflectApply$LWS(RegExpProtoTest$LWS, tagNameCheck$LWS, [tagName$LWS]) &&
      // This MUST be called ONLY after we've ensured the previous
      // two conditions have been met, otherwise it may result in an
      // unwanted "Illegal invocation" on a node we don't care about.
      !ReflectApply$LWS(ElementProtoHasAttribute$LWS, node$LWS, [CUSTOM_ELEMENT_REGISTRY_ATTRIBUTE_NAME$LWS])) {
        ReflectApply$LWS(ElementProtoSetAttribute$LWS, node$LWS, [CUSTOM_ELEMENT_REGISTRY_ATTRIBUTE_NAME$LWS, sandboxKey$LWS]);
      }
    }
  };
}
function createUrlContainer$LWS(url$LWS) {
  const container$LWS = ReflectApply$LWS(DocumentProtoCreateElement$LWS, document, ['div']);
  ReflectApply$LWS(ElementProtoSetAttribute$LWS, container$LWS, ['style', 'display:none']);
  ReflectApply$LWS(ElementProtoSetAttribute$LWS, container$LWS, ['id', url$LWS]);
  const body$LWS = ReflectApply$LWS(DocumentProtoBodyGetter$LWS, document, []);
  ReflectApply$LWS(NodeProtoAppendChild$LWS, body$LWS, [container$LWS]);
  return container$LWS;
}
function getSanitizerForConfig$LWS(sandboxKey$LWS, configName$LWS) {
  if (typeof sandboxKey$LWS !== 'string') {
    throw new LockerSecurityError$LWS(ERR_INVALID_SANDBOX_KEY$LWS);
  }
  if (typeof configName$LWS !== 'string') {
    throw new LockerSecurityError$LWS('Invalid config name.');
  }
  let sandboxConfiguredSanitizerInstances$LWS = instancesBySandboxKeyRegistry$LWS[sandboxKey$LWS];
  if (sandboxConfiguredSanitizerInstances$LWS === undefined) {
    sandboxConfiguredSanitizerInstances$LWS = instancesBySandboxKeyRegistry$LWS[sandboxKey$LWS] = {
      __proto__: null
    };
  }
  let configuredDOMPurifyInstance$LWS = sandboxConfiguredSanitizerInstances$LWS[configName$LWS];
  if (configuredDOMPurifyInstance$LWS === undefined) {
    const config$LWS = CONFIG$LWS[configName$LWS];
    configuredDOMPurifyInstance$LWS = createDOMPurify$LWS();
    configuredDOMPurifyInstance$LWS.setConfig(config$LWS);
    const hooksRegistry$LWS = createSantizerHooksRegistry$LWS(sandboxKey$LWS);
    for (const hookName$LWS in hooksRegistry$LWS) {
      configuredDOMPurifyInstance$LWS.addHook(hookName$LWS, hooksRegistry$LWS[hookName$LWS]);
    }
    sandboxConfiguredSanitizerInstances$LWS[configName$LWS] = configuredDOMPurifyInstance$LWS;
  }
  return configuredDOMPurifyInstance$LWS;
}
function sanitizeSvgTextReturnDOM$LWS(dirty$LWS) {
  const svgSanitizer$LWS = getSanitizerForConfig$LWS(SHARED_SVG_SANITIZER_KEY$LWS, 'NODE_SVG');
  return svgSanitizer$LWS.sanitize(dirty$LWS);
}
function sanitizeSvgHref$LWS(url$LWS) {
  const urlAsString$LWS = toSafeStringValue$LWS(url$LWS);
  if (ReflectApply$LWS(StringProtoStartsWith$LWS, urlAsString$LWS, ['#'])) {
    return url$LWS;
  }
  const normalizedHref$LWS = parseHref$LWS(urlAsString$LWS);
  // Sanitize only for supported URL_SCHEMES_LIST.
  if (URL_SCHEMES_LIST$LWS.includes(normalizedHref$LWS.protocol)) {
    const container$LWS = ReflectApply$LWS(DocumentProtoGetElementById$LWS, document, [normalizedHref$LWS.normalizedURL]);
    // Have we sanitized this URL already?
    if (container$LWS && normalizedHref$LWS.normalizedFragment) {
      checkExistingAndDequeue$LWS(container$LWS, normalizedHref$LWS);
    } else if (!container$LWS) {
      fetchAndSanitize$LWS(normalizedHref$LWS);
    }
    // If this has been in the form of http://my-url/file.svg#fragment we
    // return the normalized fragment otherwise we return the normalized URL.
    return normalizedHref$LWS.requestedFragment ? `#${normalizedHref$LWS.normalizedFragment}` : `#${normalizedHref$LWS.normalizedURL}`;
  }
  return url$LWS;
}
function updater$LWS(container$LWS, normalizedHref$LWS) {
  const {
    normalizedFragment: normalizedFragment$LWS,
    requestedFragment: requestedFragment$LWS
  } = normalizedHref$LWS;
  let el$LWS = ReflectApply$LWS(ElementProtoQuerySelector$LWS, container$LWS, [`#${normalizedFragment$LWS}`]);
  // istanbul ignore else
  if (el$LWS === null) {
    try {
      el$LWS = ReflectApply$LWS(ElementProtoQuerySelector$LWS, container$LWS, [`#${requestedFragment$LWS}`]);
      ReflectApply$LWS(ElementProtoSetAttribute$LWS, el$LWS, ['id', normalizedFragment$LWS]);
    } catch (_unused$LWS) {
      // Catch all malformed CSS3 selectors.
      // getElementById not available on Node.
      // Cannot use document.getElementById because multiple containers
      // may have the same ids for SVG elements.
    }
  }
}
function checkExistingAndDequeue$LWS(container$LWS, normalizedHref$LWS) {
  if (queue$LWS.has(normalizedHref$LWS.normalizedURL)) {
    // Wait for request to finish, then update content.
    const interval$LWS = WindowSetInterval$LWS(() => {
      // istanbul ignore else
      if (!queue$LWS.has(normalizedHref$LWS.normalizedURL)) {
        updater$LWS(container$LWS, normalizedHref$LWS);
        WindowClearInterval$LWS(interval$LWS);
      }
    }, 50);
  } else {
    updater$LWS(container$LWS, normalizedHref$LWS);
  }
}
function fetchAndSanitize$LWS(normalizedHref$LWS) {
  // This is the first time we see this href.
  const container$LWS = createUrlContainer$LWS(normalizedHref$LWS.normalizedURL);
  // Put the URL we're fetching in a queue.
  queue$LWS.add(normalizedHref$LWS.normalizedURL);
  // Initiate an XHR to fetch the resource.
  const xhr$LWS = new XhrCtor$LWS();
  ReflectApply$LWS(EventTargetProtoAddEventListener$LWS, xhr$LWS, ['load', () => {
    const status$LWS = ReflectApply$LWS(XhrProtoStatusGetter$LWS, xhr$LWS, []);
    // istanbul ignore next: the following is well tested via integration-karma
    if (status$LWS === 200) {
      // Retrieved content should be sanitized immediately.
      const responseText$LWS = ReflectApply$LWS(XhrProtoResponseTextGetter$LWS, xhr$LWS, []);
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      const fragment$LWS = sanitizeSvgTextReturnDOM$LWS(responseText$LWS);
      // Look for the container again in case other requests have finished
      // earlier for the same URL.
      if (normalizedHref$LWS.requestedFragment) {
        const el$LWS = ReflectApply$LWS(DocumentFragmentProtoGetElementById$LWS, fragment$LWS, [normalizedHref$LWS.requestedFragment]);
        if (el$LWS) {
          ReflectApply$LWS(ElementProtoSetAttribute$LWS, el$LWS, ['id', normalizedHref$LWS.normalizedFragment]);
        }
      }
      ReflectApply$LWS(NodeProtoAppendChild$LWS, container$LWS, [fragment$LWS]);
      queue$LWS.delete(normalizedHref$LWS.normalizedURL);
    }
  }]);
  ReflectApply$LWS(XhrProtoOpen$LWS, xhr$LWS, ['GET', normalizedHref$LWS.requestedURL]);
  ReflectApply$LWS(XhrProtoSend$LWS, xhr$LWS, []);
}
function parseHref$LWS(url$LWS) {
  ReflectApply$LWS(HTMLAnchorElementProtoHrefSetter$LWS, normalizerAnchor$LWS, [url$LWS]);
  const href$LWS = ReflectApply$LWS(HTMLAnchorElementProtoHrefGetter$LWS, normalizerAnchor$LWS, []);
  const protocol$LWS = ReflectApply$LWS(HTMLAnchorElementProtoProtocolGetter$LWS, normalizerAnchor$LWS, []);
  const {
    0: requestedURL$LWS,
    1: requestedFragment$LWS
  } = ReflectApply$LWS(StringProtoSplit$LWS, href$LWS, ['#']);
  const loweredUrl$LWS = ReflectApply$LWS(StringProtoToLowerCase$LWS, requestedURL$LWS, []);
  // RegExp.prototype[Symbol.replace] resets the lastIndex of global regexp to 0.
  // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
  const normalizedURL$LWS = ReflectApply$LWS(StringProtoReplace$LWS, loweredUrl$LWS, [urlReplacerRegExp$LWS, '']);
  const normalizedFragment$LWS = requestedFragment$LWS ? `${normalizedURL$LWS}_${ReflectApply$LWS(StringProtoReplace$LWS, requestedFragment$LWS, [urlReplacerRegExp$LWS, ''])}` : '';
  return {
    normalizedFragment: normalizedFragment$LWS,
    normalizedURL: normalizedURL$LWS,
    protocol: protocol$LWS,
    requestedFragment: requestedFragment$LWS,
    requestedURL: requestedURL$LWS
  };
}
// Sanitize a URL representing a SVG href attribute value.
function uponSanitizeAttribute$LWS(node$LWS, data$LWS, _config$LWS) {
  const {
    attrValue: attrValue$LWS,
    attrName: attrName$LWS
  } = data$LWS;
  if (attrValue$LWS && ReflectApply$LWS(StringProtoToUpperCase$LWS, ReflectApply$LWS(NodeProtoNodeNameGetter$LWS, node$LWS, []), []) === 'USE' && SANITIZE_ATTRIBUTES_LIST$LWS.includes(attrName$LWS)) {
    data$LWS.attrValue = sanitizeSvgHref$LWS(attrValue$LWS);
  }
  // To support Lit, we must tell DOMPurify that attributes starting with "@", ".", or "?" are allowed.
  // Ref:
  // https://lit.dev/docs/components/events/
  // https://lit.dev/docs/templates/expressions/#property-expressions
  // https://lit.dev/docs/templates/expressions/#boolean-attribute-expressions
  // istanbul ignore next: this is tested under all normal CI runs, but is not included in coverage
  if (attrName$LWS && (ReflectApply$LWS(StringProtoStartsWith$LWS, attrName$LWS, ['@']) || ReflectApply$LWS(StringProtoStartsWith$LWS, attrName$LWS, ['.']) || ReflectApply$LWS(StringProtoStartsWith$LWS, attrName$LWS, ['?']))) {
    data$LWS.forceKeepAttr = true;
  }
  return data$LWS;
}
function blobSanitizer$LWS(sandboxKey$LWS) {
  if (typeof sandboxKey$LWS !== 'string') {
    throw new LockerSecurityError$LWS(ERR_INVALID_SANDBOX_KEY$LWS);
  }
  return getSanitizerForConfig$LWS(sandboxKey$LWS, 'STRING_BLOB_HTML');
}
export { blobSanitizer$LWS as blobSanitizer, getSanitizerForConfig$LWS as getSanitizerForConfig, sanitizeSvgHref$LWS as sanitizeSvgHref, sanitizeSvgTextReturnDOM$LWS as sanitizeSvgTextReturnDOM, uponSanitizeAttribute$LWS as uponSanitizeAttribute };
/*! version: 0.23.6 */
