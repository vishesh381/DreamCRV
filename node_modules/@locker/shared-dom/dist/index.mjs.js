/*!
 * Copyright (C) 2019 salesforce.com, inc.
 */
import { ObjectLookupOwnGetter as ObjectLookupOwnGetter$LWS, ReflectGetOwnPropertyDescriptor as ReflectGetOwnPropertyDescriptor$LWS, ReflectApply as ReflectApply$LWS, StringProtoEndsWith as StringProtoEndsWith$LWS, StringProtoStartsWith as StringProtoStartsWith$LWS, SymbolFor as SymbolFor$LWS, PromiseResolve as PromiseResolve$LWS, PromiseProtoThen as PromiseProtoThen$LWS, PromiseProtoCatch as PromiseProtoCatch$LWS, ReflectDefineProperty as ReflectDefineProperty$LWS, LockerSecurityError as LockerSecurityError$LWS, ObjectHasOwn as ObjectHasOwn$LWS, shallowCloneArray as shallowCloneArray$LWS, StringProtoToLowerCase as StringProtoToLowerCase$LWS, RegExpProtoTest as RegExpProtoTest$LWS, StringProtoReplace as StringProtoReplace$LWS, getUnmaskedFunction as getUnmaskedFunction$LWS, toSafeWeakMap as toSafeWeakMap$LWS, WeakMapCtor as WeakMapCtor$LWS, StringProtoIncludes as StringProtoIncludes$LWS, ArrayIsArray as ArrayIsArray$LWS, ArrayProtoFind as ArrayProtoFind$LWS, LOCKER_SERVICE_KEY_LOWERED as LOCKER_SERVICE_KEY_LOWERED$LWS, ObjectLookupOwnSetter as ObjectLookupOwnSetter$LWS, toSafeWeakSet as toSafeWeakSet$LWS, WeakSetCtor as WeakSetCtor$LWS, FunctionProtoBind as FunctionProtoBind$LWS, UNCOMPILED_LOCATION_NAME as UNCOMPILED_LOCATION_NAME$LWS, UNCOMPILED_TOP_NAME as UNCOMPILED_TOP_NAME$LWS, ReflectDeleteProperty as ReflectDeleteProperty$LWS, StringProtoCharCodeAt as StringProtoCharCodeAt$LWS, ArrayProtoJoin as ArrayProtoJoin$LWS, RegExpCtor as RegExpCtor$LWS, RegExpProtoExec as RegExpProtoExec$LWS, StringProtoSubstring as StringProtoSubstring$LWS, StringProtoSlice as StringProtoSlice$LWS, toRegExpEscapedString as toRegExpEscapedString$LWS, SANDBOX_EVAL_CONTEXT_NAME as SANDBOX_EVAL_CONTEXT_NAME$LWS, toRegExpEscapedIdentifierName as toRegExpEscapedIdentifierName$LWS, WEBPACK_REQUIRE_NAME as WEBPACK_REQUIRE_NAME$LWS, ArrayProtoToString as ArrayProtoToString$LWS, indexOfPragma as indexOfPragma$LWS } from '@locker/shared';
const AbortControllerCtor$LWS = AbortController;
const {
  prototype: AbortControllerProto$LWS
} = AbortControllerCtor$LWS;
const {
  abort: AbortControllerProtoAbort$LWS
} = AbortControllerProto$LWS;
const AbortControllerProtoSignalGetter$LWS = ObjectLookupOwnGetter$LWS(AbortControllerProto$LWS, 'signal');
const {
  prototype: AttrProto$LWS
} = Attr;
const AttrProtoNameGetter$LWS = ObjectLookupOwnGetter$LWS(AttrProto$LWS, 'name');
const AttrProtoNamespaceURIGetter$LWS = ObjectLookupOwnGetter$LWS(AttrProto$LWS, 'namespaceURI');
const AttrProtoOwnerElementGetter$LWS = ObjectLookupOwnGetter$LWS(AttrProto$LWS, 'ownerElement');
const {
  get: AttrProtoValueGetter$LWS,
  set: AttrProtoValueSetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(AttrProto$LWS, 'value');
function normalizeNamespacedAttributeName$LWS(attrName$LWS) {
  const href$LWS = 'href';
  // Prevent arbitrary:href from being treated like a valid namespaced href value
  if (ReflectApply$LWS(StringProtoEndsWith$LWS, attrName$LWS, [href$LWS]) &&
  // ...But we don't want to match "xlink:href"
  !ReflectApply$LWS(StringProtoStartsWith$LWS, attrName$LWS, ['xlink:href'])) {
    return href$LWS;
  }
  return attrName$LWS;
}
const rootDocument$LWS = document;
const {
  prototype: DocumentProto$LWS
} = Document;
// Used by '@locker/near-membrane/dom'.
const {
  close: DocumentProtoClose$LWS,
  open: DocumentProtoOpen$LWS
} = DocumentProto$LWS;
const {
  createComment: DocumentProtoCreateComment$LWS,
  createDocumentFragment: DocumentProtoCreateDocumentFragment$LWS,
  createElement: DocumentProtoCreateElement$LWS,
  createElementNS: DocumentProtoCreateElementNS$LWS,
  getElementById: DocumentProtoGetElementById$LWS
} = DocumentProto$LWS;
const DocumentProtoBodyGetter$LWS = ObjectLookupOwnGetter$LWS(DocumentProto$LWS, 'body');
const {
  get: DocumentProtoCookieGetter$LWS,
  set: DocumentProtoCookieSetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(DocumentProto$LWS, 'cookie');
const DocumentProtoDefaultViewGetter$LWS = ObjectLookupOwnGetter$LWS(DocumentProto$LWS, 'defaultView');
const DocumentProtoDocumentElementGetter$LWS = ObjectLookupOwnGetter$LWS(DocumentProto$LWS, 'documentElement');
const DocumentProtoHeadGetter$LWS = ObjectLookupOwnGetter$LWS(DocumentProto$LWS, 'head');
const DocumentProtoImplementationGetter$LWS = ObjectLookupOwnGetter$LWS(DocumentProto$LWS, 'implementation');
const {
  append: DocumentFragmentProtoAppend$LWS,
  getElementById: DocumentFragmentProtoGetElementById$LWS
} = DocumentFragment.prototype;
const {
  prototype: ElementProto$LWS
} = Element;
const ElementAriaAttributesToPropertyName$LWS = {
  __proto__: null,
  'aria-activedescendant': 'ariaActiveDescendant',
  'aria-atomic': 'ariaAtomic',
  'aria-autocomplete': 'ariaAutoComplete',
  'aria-busy': 'ariaBusy',
  'aria-checked': 'ariaChecked',
  'aria-colcount': 'ariaColCount',
  'aria-colindex': 'ariaColIndex',
  'aria-colspan': 'ariaColSpan',
  'aria-controls': 'ariaControls',
  'aria-current': 'ariaCurrent',
  'aria-describedby': 'ariaDescribedBy',
  'aria-details': 'ariaDetails',
  'aria-disabled': 'ariaDisabled',
  'aria-errormessage': 'ariaErrorMessage',
  'aria-expanded': 'ariaExpanded',
  'aria-flowto': 'ariaFlowTo',
  'aria-haspopup': 'ariaHasPopup',
  'aria-hidden': 'ariaHidden',
  'aria-invalid': 'ariaInvalid',
  'aria-keyshortcuts': 'ariaKeyShortcuts',
  'aria-label': 'ariaLabel',
  'aria-labelledby': 'ariaLabelledBy',
  'aria-level': 'ariaLevel',
  'aria-live': 'ariaLive',
  'aria-modal': 'ariaModal',
  'aria-multiline': 'ariaMultiLine',
  'aria-multiselectable': 'ariaMultiSelectable',
  'aria-orientation': 'ariaOrientation',
  'aria-owns': 'ariaOwns',
  'aria-placeholder': 'ariaPlaceholder',
  'aria-posinset': 'ariaPosInSet',
  'aria-pressed': 'ariaPressed',
  'aria-readonly': 'ariaReadOnly',
  'aria-relevant': 'ariaRelevant',
  'aria-required': 'ariaRequired',
  'aria-roledescription': 'ariaRoleDescription',
  'aria-rowcount': 'ariaRowCount',
  'aria-rowindex': 'ariaRowIndex',
  'aria-rowspan': 'ariaRowSpan',
  'aria-selected': 'ariaSelected',
  'aria-setsize': 'ariaSetSize',
  'aria-sort': 'ariaSort',
  'aria-valuemax': 'ariaValueMax',
  'aria-valuemin': 'ariaValueMin',
  'aria-valuenow': 'ariaValueNow',
  'aria-valuetext': 'ariaValueText'
};
// Used by '@locker/near-membrane-dom'.
const {
  remove: ElementProtoRemove$LWS
} = ElementProto$LWS;
const {
  closest: ElementProtoClosest$LWS,
  getAttribute: ElementProtoGetAttribute$LWS,
  getAttributeNode: ElementProtoGetAttributeNode$LWS,
  getAttributeNodeNS: ElementProtoGetAttributeNodeNS$LWS,
  hasAttribute: ElementProtoHasAttribute$LWS,
  querySelector: ElementProtoQuerySelector$LWS,
  querySelectorAll: ElementProtoQuerySelectorAll$LWS,
  removeAttribute: ElementProtoRemoveAttribute$LWS,
  removeAttributeNode: ElementProtoRemoveAttributeNode$LWS,
  removeAttributeNS: ElementProtoRemoveAttributeNS$LWS,
  setAttribute: ElementProtoSetAttribute$LWS,
  setAttributeNS: ElementProtoSetAttributeNS$LWS,
  toggleAttribute: ElementProtoToggleAttribute$LWS
} = ElementProto$LWS;
const {
  get: ElementProtoInnerHTMLGetter$LWS,
  set: ElementProtoInnerHTMLSetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(ElementProto$LWS, 'innerHTML');
const ElementProtoNamespaceURIGetter$LWS = ObjectLookupOwnGetter$LWS(ElementProto$LWS, 'namespaceURI');
const {
  get: ElementProtoOuterHTMLGetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(ElementProto$LWS, 'outerHTML');
const ElementProtoTagNameGetter$LWS = ObjectLookupOwnGetter$LWS(ElementProto$LWS, 'tagName');

// Check for the noopener feature being enabled:
// - noopener
// - noopener=1
// - noopener=yes
const noopenerRegExp$LWS = /(^|,)(\s*noopener\s*=\s*(?:yes|1)\s*)(,|$)/g;
const rootWindow$LWS = window;
// These properties are part of the WindowOrGlobalScope mixin and not on
// Window.prototype.
// https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope
const {
  setTimeout: WindowSetTimeout$LWS
} = rootWindow$LWS;
const {
  clearInterval: WindowClearInterval$LWS,
  decodeURIComponent: WindowDecodeURIComponent$LWS,
  encodeURIComponent: WindowEncodeURIComponent$LWS,
  fetch: WindowFetch$LWS,
  location: rootWindowLocation$LWS,
  setInterval: WindowSetInterval$LWS,
  top: rootWindowTop$LWS
} = rootWindow$LWS;
const WindowQueueMicrotask$LWS = (() => {
  const {
    queueMicrotask: queueMicrotask$LWS
  } = rootWindow$LWS;
  // istanbul ignore else
  if (typeof queueMicrotask$LWS === 'function') {
    return queueMicrotask$LWS;
  }
  // Edge 15 does not support `queueMicrotask()`.
  // https://caniuse.com/mdn-api_queuemicrotask
  // https://developer.mozilla.org/en-US/docs/Web/API/queueMicrotask#when_queuemicrotask_isnt_available
  // istanbul ignore next: coverage is not measured in Edge 15, which means this whole fallback is considered "uncovered" when the tests are run in Chrome.
  // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow
  return function queueMicrotask$LWS(callback$LWS) {
    let promise$LWS = PromiseResolve$LWS();
    promise$LWS = ReflectApply$LWS(PromiseProtoThen$LWS, promise$LWS, [callback$LWS]);
    ReflectApply$LWS(PromiseProtoCatch$LWS, promise$LWS, [error => WindowSetTimeout$LWS(() => {
      throw error;
    }, 0)]);
  };
})();
const WindowDocumentGetter$LWS = ObjectLookupOwnGetter$LWS(rootWindow$LWS, 'document');
const WindowFrameElementGetter$LWS = ObjectLookupOwnGetter$LWS(rootWindow$LWS, 'frameElement');
const WindowLengthGetter$LWS = ObjectLookupOwnGetter$LWS(rootWindow$LWS, 'length');
const WindowLocationGetter$LWS = ObjectLookupOwnGetter$LWS(rootWindow$LWS, 'location');
function initWindowOpenChildWindow$LWS(win$LWS, url$LWS) {
  // Skip if `url` is an empty string or `undefined` as a blank page will be
  // opened into the targeted browsing context and not navigated away from.
  // https://developer.mozilla.org/en-US/docs/Web/API/Window/open#parameters
  if (typeof url$LWS === 'string' && url$LWS !== '') {
    // `WindowDocumentGetter` will throw if `win` is an opaque cross-origin
    // window.
    try {
      const doc$LWS = ReflectApply$LWS(WindowDocumentGetter$LWS, win$LWS, []);
      // `win.location` is a non-configurable property so can be accessed
      // directly.
      const {
        location: location$LWS
      } = win$LWS;
      // Check if the `location.href` is an intermediate value different
      // than `url`.
      // `location.href` is a non-configurable property so can be accessed
      // directly.
      // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false
      if (location$LWS.href !== url$LWS) {
        // Opening and closing `doc` prevents the default browser
        // redirect behavior.
        ReflectApply$LWS(DocumentProtoOpen$LWS, doc$LWS, []);
        ReflectApply$LWS(DocumentProtoClose$LWS, doc$LWS, []);
        // `location.replace` is a non-configurable property so can be
        // accessed directly.
        location$LWS.replace(url$LWS);
      }
      // eslint-disable-next-line no-empty
    } catch (_unused$LWS) {}
  }
  return win$LWS;
}
// This is only used by window.open() and document.open(x, y, z) distortions to
// block access to unsafe properties of the child window that's returned by those
// APIs. These properties must be otherwise available directly on the sandbox window,
// or via iframe.contentWindow created within the sandbox.
// To be effective, we mark the blocked thing with a symbol, so that can be detected by
// the distortion, otherwise the distortion will replace whatever we define here with
// whatever it provides.
const CHILD_WINDOW_BLOCKED_PROPERTY_SYMBOL$LWS = SymbolFor$LWS('@@lwsChildWindowBlockedProperty');
const CHILD_WINDOW_BLOCKED_PROPERTIES$LWS = ['eval', 'Function', 'setInterval', 'setTimeout'];
function markForUnsafePropertyBlocking$LWS(childWindow$LWS) {
  // If this function somehow receives the rootWindow, just return it.
  if (!childWindow$LWS || childWindow$LWS === rootWindow$LWS) {
    return childWindow$LWS;
  }
  for (const blocked$LWS of CHILD_WINDOW_BLOCKED_PROPERTIES$LWS) {
    const descriptor$LWS = ReflectGetOwnPropertyDescriptor$LWS(childWindow$LWS, blocked$LWS);
    const replacement$LWS = /* istanbul ignore next: this replacement function will never actually be called */() => {};
    ReflectDefineProperty$LWS(replacement$LWS, CHILD_WINDOW_BLOCKED_PROPERTY_SYMBOL$LWS, {
      __proto__: null,
      configurable: false,
      enumerable: false,
      get() {
        return true;
      }
    });
    // istanbul ignore else: currently unreachable via tests
    if (typeof childWindow$LWS[blocked$LWS] === 'function') {
      descriptor$LWS.value = replacement$LWS;
    }
    /* Eventually there will be other types of blocked properties
    else {
        descriptor.get = replacement;
    }
    */
    ReflectDefineProperty$LWS(childWindow$LWS, blocked$LWS, descriptor$LWS);
  }
  return childWindow$LWS;
}
function throwIfMarkedAsUnsafeInChildWindow$LWS(virtualEnvironmentEvaluator$LWS, name$LWS) {
  // This seemingly strange approach is necessary because this distortion will
  // otherwise replace whatever was force-assigned to the childWindow property
  // by markForUnsafePropertyBlocking with this distortion, effectively acting
  // as an UNDO of markForUnsafePropertyBlocking(). We have to dig into
  // the sandbox's global object and look at the actual property to see if it was
  // marked for unsafe property blocking, because indirect property (ie. eval) will bypass
  // any "this" property lookups.
  const getPossiblyBlockedPropertyFromSandbox$LWS = virtualEnvironmentEvaluator$LWS(`() => globalThis.${name$LWS}`);
  // istanbul ignore else: it is unnecessary to cover the else path here
  if (getPossiblyBlockedPropertyFromSandbox$LWS()[CHILD_WINDOW_BLOCKED_PROPERTY_SYMBOL$LWS]) {
    throw new LockerSecurityError$LWS(`Cannot call ${name$LWS} on this window.`);
  }
}
function isWindow$LWS(value$LWS) {
  if (typeof value$LWS === 'object' && value$LWS !== null && ObjectHasOwn$LWS(value$LWS, 'window') && value$LWS.window === value$LWS) {
    // Slower check that must certainly detect a window object.
    try {
      // window.self getter only works for a window object, otherwise it
      // throws, additionally, this works fine for a detached window as
      // well, which is important since it will guarantee that this check
      // works also for iframes that are disconnected, and could be connected
      // later on, that should not bypass this check. This check is is also
      // equivalent to window.frames, and here is the very simple spec for
      // this getter:
      // https://html.spec.whatwg.org/multipage/window-object.html#dom-self
      ReflectApply$LWS(WindowLocationGetter$LWS, value$LWS, []);
      return true;
      // eslint-disable-next-line no-empty
    } catch (_unused2$LWS) {}
  }
  return false;
}
function normalizeWindowOpenArguments$LWS(args$LWS) {
  const normalizedArgs$LWS = shallowCloneArray$LWS(args$LWS);
  const {
    length: length$LWS
  } = normalizedArgs$LWS;
  if (length$LWS) {
    const url$LWS = normalizedArgs$LWS[0];
    if (typeof url$LWS !== 'string') {
      normalizedArgs$LWS[0] = url$LWS ? `${url$LWS}` : undefined;
    }
  }
  if (length$LWS > 1) {
    const target$LWS = normalizedArgs$LWS[1];
    if (typeof target$LWS !== 'string') {
      normalizedArgs$LWS[1] = target$LWS ? `${target$LWS}` : undefined;
    }
  }
  if (length$LWS > 2) {
    let features$LWS = normalizedArgs$LWS[2];
    if (typeof features$LWS !== 'string') {
      features$LWS = features$LWS ? `${features$LWS}` : undefined;
    }
    if (features$LWS) {
      // Lowercase the features string because it is case insensitive.
      // https://html.spec.whatwg.org/multipage/window-object.html#normalizing-the-feature-name
      let loweredFeatures$LWS = ReflectApply$LWS(StringProtoToLowerCase$LWS, features$LWS, []);
      // RegExp.prototype[Symbol.replace] resets the lastIndex of global
      // regexp to 0.
      // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
      if (ReflectApply$LWS(RegExpProtoTest$LWS, noopenerRegExp$LWS, [loweredFeatures$LWS])) {
        // Replacing noopener with an enabled state that is supported
        // across all browsers. Firefox Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=1566619
        loweredFeatures$LWS = ReflectApply$LWS(StringProtoReplace$LWS, loweredFeatures$LWS, [
        // RegExp.prototype[Symbol.replace] resets the lastIndex of
        // global regexp to 0.
        // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
        noopenerRegExp$LWS, (_match$LWS, leading$LWS, _feature$LWS, ending$LWS) => `${leading$LWS}noopener${ending$LWS}`]);
      }
      features$LWS = loweredFeatures$LWS;
    }
    normalizedArgs$LWS[2] = features$LWS;
  }
  return normalizedArgs$LWS;
}
const HTMLElement$LWS = getUnmaskedFunction$LWS(rootWindow$LWS.HTMLElement);
const {
  prototype: HTMLElementProto$LWS
} = HTMLElement$LWS;
const HTMLElementProtoInnerTextGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLElementProto$LWS, 'innerText');
// Used by '@locker/near-membrane-dom'.
const HTMLElementProtoStyleGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLElementProto$LWS, 'style');
const HTMLElementGlobalAttributesToPropertyName$LWS = {
  __proto__: null,
  accesskey: 'accessKey',
  contenteditable: 'contentEditable',
  enterkeyhint: 'enterKeyHint',
  inputmode: 'inputMode',
  tabindex: 'tabIndex'
};
const HTMLTemplateElementProtoContentGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLTemplateElement.prototype, 'content');
const {
  prototype: NodeProto$LWS
} = Node;
const {
  appendChild: NodeProtoAppendChild$LWS,
  cloneNode: NodeProtoCloneNode$LWS,
  isEqualNode: NodeProtoIsEqualNode$LWS
} = NodeProto$LWS;
const NodeProtoChildNodesGetter$LWS = ObjectLookupOwnGetter$LWS(NodeProto$LWS, 'childNodes');
const NodeProtoFirstChildGetter$LWS = ObjectLookupOwnGetter$LWS(NodeProto$LWS, 'firstChild');
const NodeProtoIsConnectedGetter$LWS = ObjectLookupOwnGetter$LWS(NodeProto$LWS, 'isConnected');
// Used by '@locker/near-membrane-dom'.
const NodeProtoLastChildGetter$LWS = ObjectLookupOwnGetter$LWS(NodeProto$LWS, 'lastChild');
const NodeProtoNodeNameGetter$LWS = ObjectLookupOwnGetter$LWS(NodeProto$LWS, 'nodeName');
const NodeProtoOwnerDocumentGetter$LWS = ObjectLookupOwnGetter$LWS(NodeProto$LWS, 'ownerDocument');
const NodeProtoParentNodeGetter$LWS = ObjectLookupOwnGetter$LWS(NodeProto$LWS, 'parentNode');
const {
  get: NodeProtoTextContentGetter$LWS,
  set: NodeProtoTextContentSetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(NodeProto$LWS, 'textContent');
const rootDocumentDetachedFragment$LWS = ReflectApply$LWS(DocumentProtoCreateDocumentFragment$LWS, rootDocument$LWS, []);
const rootDocumentDetachedContainer$LWS = ReflectApply$LWS(DocumentProtoCreateElement$LWS, rootDocument$LWS, ['div']);
/* eslint-disable no-underscore-dangle */
class Validator$LWS {
  constructor(document$LWS, {
    HTMLLinkElement: HTMLLinkElement$LWS,
    HTMLScriptElement: HTMLScriptElement$LWS,
    HTMLStyleElement: HTMLStyleElement$LWS
  }) {
    this.isAllowedSharedElementChild = element$LWS => element$LWS instanceof this._constructors.HTMLLinkElement || element$LWS instanceof this._constructors.HTMLScriptElement || element$LWS instanceof this._constructors.HTMLStyleElement;
    this.isEqualDomString = (leftString$LWS, rightString$LWS) => {
      ReflectApply$LWS(ElementProtoInnerHTMLSetter$LWS, this._templates.left, [leftString$LWS]);
      ReflectApply$LWS(ElementProtoInnerHTMLSetter$LWS, this._templates.right, [rightString$LWS]);
      return deepIsEqualNode$LWS(this._templates.left, this._templates.right);
    };
    // There is no reason to ever allow any HTML or XML that contains all three of these substrings.
    // eslint-disable-next-line class-methods-use-this
    this.isInherentlyUnsecure = input$LWS => {
      const hasIframe$LWS = hasTag$LWS(input$LWS, 'iframe') && ReflectApply$LWS(StringProtoIncludes$LWS, input$LWS, ['srcdoc']);
      const hasScript$LWS = hasTag$LWS(input$LWS, 'script');
      // If neither an iframe or a script was detected, then this input is safe.
      // istanbul ignore else: returns immediately
      if (!hasIframe$LWS && !hasScript$LWS) {
        return false;
      }
      // If the string contains both the words iframe and srcdoc, it is unsafe
      // istanbul ignore else: returns immediately
      if (hasIframe$LWS) {
        return true;
      }
      // If the input contained the word "script", then we need to confirm that the string
      // that was seen is actually markup.
      //
      // IMPORTANT: We CANNOT reuse this.template.left/right for this check. Template elements
      // do not return innerText or textContent, which makes the following innerHTML/innerText
      // check useless.
      ReflectApply$LWS(DocumentFragmentProtoAppend$LWS, rootDocumentDetachedFragment$LWS, [rootDocumentDetachedContainer$LWS]);
      ReflectApply$LWS(ElementProtoInnerHTMLSetter$LWS, rootDocumentDetachedContainer$LWS, [input$LWS]);
      // This MUST BE CHECKED AFTER IT IS RENDERED. The nature of these attacks requires
      // the actual source to be set to the innerHTML to allow the browser to render
      const innerHTML$LWS = ReflectApply$LWS(ElementProtoInnerHTMLGetter$LWS, rootDocumentDetachedContainer$LWS, []);
      const innerText$LWS = ReflectApply$LWS(HTMLElementProtoInnerTextGetter$LWS, rootDocumentDetachedContainer$LWS, []);
      ReflectApply$LWS(ElementProtoRemove$LWS, rootDocumentDetachedContainer$LWS, []);
      // If innerHTML contains "script", but innerText does not, then the string
      // was hiding a script element through some kind of obfuscation, and is unsecure.
      return hasTag$LWS(innerHTML$LWS, 'script') && !hasTag$LWS(innerText$LWS, 'script');
    };
    this.isSharedElement = element$LWS => element$LWS === ReflectApply$LWS(DocumentProtoHeadGetter$LWS, this._document, []) || element$LWS === ReflectApply$LWS(DocumentProtoBodyGetter$LWS, this._document, []) || element$LWS === ReflectApply$LWS(DocumentProtoDocumentElementGetter$LWS, this._document, []);
    this._constructors = {
      HTMLLinkElement: HTMLLinkElement$LWS,
      HTMLScriptElement: HTMLScriptElement$LWS,
      HTMLStyleElement: HTMLStyleElement$LWS
    };
    this._document = document$LWS;
    this._templates = {
      left: ReflectApply$LWS(DocumentProtoCreateElement$LWS, this._document, ['template']),
      right: ReflectApply$LWS(DocumentProtoCreateElement$LWS, this._document, ['template'])
    };
  }
}
/* eslint-enable no-underscore-dangle */
function deepIsEqualNode$LWS(leftRoot$LWS, rightRoot$LWS) {
  const leftRootNode$LWS = leftRoot$LWS instanceof HTMLTemplateElement ? ReflectApply$LWS(HTMLTemplateElementProtoContentGetter$LWS, leftRoot$LWS, []) : leftRoot$LWS;
  const rightRootNode$LWS = rightRoot$LWS instanceof HTMLTemplateElement ? ReflectApply$LWS(HTMLTemplateElementProtoContentGetter$LWS, rightRoot$LWS, []) : rightRoot$LWS;
  if (ReflectApply$LWS(NodeProtoIsEqualNode$LWS, leftRootNode$LWS, [rightRootNode$LWS])) {
    const leftChildNodes$LWS = ReflectApply$LWS(NodeProtoChildNodesGetter$LWS, leftRootNode$LWS, []);
    const childCount$LWS = leftChildNodes$LWS.length;
    if (childCount$LWS > 0) {
      const rightChildNodes$LWS = ReflectApply$LWS(NodeProtoChildNodesGetter$LWS, rightRootNode$LWS, []);
      for (let i$LWS = 0; i$LWS < childCount$LWS; i$LWS += 1) {
        if (deepIsEqualNode$LWS(leftChildNodes$LWS[i$LWS], rightChildNodes$LWS[i$LWS]) === false) {
          return false;
        }
      }
    }
    return true;
  }
  return false;
}
function hasTag$LWS(input$LWS, tag$LWS) {
  return ReflectApply$LWS(StringProtoIncludes$LWS, input$LWS, [`<${tag$LWS} `]) || ReflectApply$LWS(StringProtoIncludes$LWS, input$LWS, [`:${tag$LWS} `]) || ReflectApply$LWS(StringProtoIncludes$LWS, input$LWS, [`<${tag$LWS}>`]) || ReflectApply$LWS(StringProtoIncludes$LWS, input$LWS, [`:${tag$LWS}>`]);
}
const rootValidator$LWS = new Validator$LWS(rootDocument$LWS, rootWindow$LWS);
const documentToValidatorMap$LWS = toSafeWeakMap$LWS(new WeakMapCtor$LWS([[rootDocument$LWS, rootValidator$LWS]]));
function getValidator$LWS(document$LWS, globalObject$LWS) {
  // Fast path validator lookup for top level window.
  if (globalObject$LWS === undefined || globalObject$LWS === rootWindow$LWS) {
    return rootValidator$LWS;
  }
  // Use the `document` as the key because a window object maintains its identity
  // continuity when its location changes and while the non-configurable document
  // property does not.
  let validator$LWS = documentToValidatorMap$LWS.get(document$LWS);
  if (validator$LWS === undefined) {
    validator$LWS = new Validator$LWS(document$LWS, globalObject$LWS);
    documentToValidatorMap$LWS.set(document$LWS, validator$LWS);
  }
  return validator$LWS;
}
const BlobCtor$LWS = Blob;
const {
  prototype: BlobProto$LWS
} = BlobCtor$LWS;
const {
  slice: BlobProtoSlice$LWS
} = BlobProto$LWS;
const BlobProtoSizeGetter$LWS = ObjectLookupOwnGetter$LWS(BlobProto$LWS, 'size');
const BlobProtoTypeGetter$LWS = ObjectLookupOwnGetter$LWS(BlobProto$LWS, 'type');
const {
  // We don't cherry-pick the 'userAgent' property from `navigator` here
  // to avoid triggering its getter.
  navigator: navigator$LWS,
  navigator: {
    userAgentData: userAgentData$LWS
  }
} = rootWindow$LWS;
// The user-agent client hints API is experimental and subject to change.
// https://caniuse.com/mdn-api_navigator_useragentdata
// istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
const brands$LWS = userAgentData$LWS == null ? void 0 : userAgentData$LWS.brands;
// Note: Chromium identifies itself as Chrome in its user-agent string.
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent
const chromiumUserAgentRegExp$LWS = / (?:Headless)?Chrome\/\d+/;
const webKitUserAgentRegExp$LWS = /WebKit/i;
let userAgent$LWS;
function getUserAgent$LWS() {
  if (userAgent$LWS === undefined) {
    userAgent$LWS = navigator$LWS.userAgent;
  }
  return userAgent$LWS;
}
const CUSTOM_ELEMENT_REGISTRY_ATTRIBUTE_NAME$LWS = LOCKER_SERVICE_KEY_LOWERED$LWS;
// Used by '@locker/near-membrane-dom'.
const IS_CHROMIUM_BROWSER$LWS =
// While experimental, `navigator.userAgentData.brands` may be defined as an
// empty array in headless Chromium based browsers.
ArrayIsArray$LWS(brands$LWS) && brands$LWS.length ?
// Use user-agent client hints API if available to avoid deprecation
// warnings.
// https://developer.mozilla.org/en-US/docs/Web/API/User-Agent_Client_Hints_API
// istanbul ignore next: this code is not reachable in the coverage run.
ReflectApply$LWS(ArrayProtoFind$LWS, brands$LWS, [
// prettier-ignore
// istanbul ignore next: this code is not reachable in the coverage run.
item$LWS => (item$LWS == null ? void 0 : item$LWS.brand) === 'Chromium']) !== undefined :
// Fallback to a standard user-agent string sniff.
ReflectApply$LWS(RegExpProtoTest$LWS, chromiumUserAgentRegExp$LWS, [getUserAgent$LWS()]);
// Used by '@locker/near-membrane-dom'.
const IS_OLD_CHROMIUM_BROWSER$LWS = IS_CHROMIUM_BROWSER$LWS &&
// Chromium added support for `navigator.userAgentData` in v90.
// https://caniuse.com/mdn-api_navigator_useragentdata
userAgentData$LWS === undefined;
const IS_WEBKIT_BROWSER$LWS = !IS_CHROMIUM_BROWSER$LWS && (
// istanbul ignore next: this code is not reachable in the coverage run.
ArrayIsArray$LWS(brands$LWS) && brands$LWS.length ? ReflectApply$LWS(ArrayProtoFind$LWS, brands$LWS, [
// istanbul ignore next
item$LWS => {
  const brand$LWS = item$LWS == null ? void 0 : item$LWS.brand;
  return typeof brand$LWS === 'string' && ReflectApply$LWS(RegExpProtoTest$LWS, webKitUserAgentRegExp$LWS, [brand$LWS]);
}]) !== undefined : ReflectApply$LWS(RegExpProtoTest$LWS, webKitUserAgentRegExp$LWS, [getUserAgent$LWS()]));

// Used by '@locker/near-membrane-shared-dom'.
// The DOMException constructor was exposed in Edge 12 but wasn't invocable
// until Edge 79. As long as this is used for instanceof checks it should be fine.
// https://developer.mozilla.org/en-US/docs/Web/API/DOMException#browser_compatibility
const DOMExceptionCtor$LWS = DOMException;
const {
  DATA_CLONE_ERR: DATA_CLONE_ERROR_CODE$LWS
} = DOMExceptionCtor$LWS;
const DOMExceptionProtoCodeGetter$LWS = ObjectLookupOwnGetter$LWS(DOMExceptionCtor$LWS.prototype, 'code');
const {
  createDocument: DOMImplementationProtoCreateDocument$LWS
} = DOMImplementation.prototype;
const DOMTokenListCtor$LWS = DOMTokenList;
const {
  prototype: DOMTokenListProto$LWS
} = DOMTokenListCtor$LWS;
const {
  add: DOMTokenListProtoAdd$LWS,
  contains: DOMTokenListProtoContains$LWS,
  remove: DOMTokenListProtoRemove$LWS
} = DOMTokenListProto$LWS;
const DOMTokenListProtoLengthGetter$LWS = ObjectLookupOwnGetter$LWS(DOMTokenListProto$LWS, 'length');
const DOMTokenListProtoValueGetter$LWS = ObjectLookupOwnGetter$LWS(DOMTokenListProto$LWS, 'value');
const EventCtor$LWS = Event;
const ErrorEventCtor$LWS = ErrorEvent;
const {
  prototype: EventProto$LWS
} = EventCtor$LWS;
const {
  stopPropagation: EventProtoStopPropagation$LWS
} = EventProto$LWS;
const EventProtoCurrentTargetGetter$LWS = ObjectLookupOwnGetter$LWS(EventProto$LWS, 'currentTarget');
const {
  addEventListener: EventTargetProtoAddEventListener$LWS,
  dispatchEvent: EventTargetProtoDispatchEvent$LWS,
  removeEventListener: EventTargetProtoRemoveEventListener$LWS
} = EventTarget.prototype;
const {
  prototype: HTMLAnchorElementProto$LWS
} = HTMLAnchorElement;
const HTMLAnchorElementProtoHostnameGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLAnchorElementProto$LWS, 'hostname');
const {
  get: HTMLAnchorElementProtoHrefGetter$LWS,
  set: HTMLAnchorElementProtoHrefSetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(HTMLAnchorElementProto$LWS, 'href');
const HTMLAnchorElementProtoPathnameGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLAnchorElementProto$LWS, 'pathname');
const HTMLAnchorElementProtoProtocolGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLAnchorElementProto$LWS, 'protocol');
const {
  prototype: HTMLIFrameElementProto$LWS
} = HTMLIFrameElement;
// Used by '@locker/near-membrane-dom'.
const HTMLIFrameElementProtoContentWindowGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLIFrameElementProto$LWS, 'contentWindow');
const HTMLIFrameElementProtoSandboxGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLIFrameElementProto$LWS, 'sandbox');
const HTMLIFrameElementProtoSandboxSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLIFrameElementProto$LWS, 'sandbox');
const HTMLIFrameElementProtoSrcGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLIFrameElementProto$LWS, 'src');
const HTMLIFrameElementProtoSrcSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLIFrameElementProto$LWS, 'src');
const HTMLScriptElementCtor$LWS = HTMLScriptElement;
const {
  prototype: HTMLScriptElementProto$LWS
} = HTMLScriptElementCtor$LWS;
const {
  get: HTMLScriptElementProtoSrcGetter$LWS,
  set: HTMLScriptElementProtoSrcSetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(HTMLScriptElementProto$LWS, 'src');
const NAMESPACE_DEFAULT$LWS = 'default';
const NAMESPACE_SVG$LWS = 'http://www.w3.org/2000/svg';
const NAMESPACE_XHTML$LWS = 'http://www.w3.org/1999/xhtml';
const NAMESPACE_XLINK$LWS = 'http://www.w3.org/1999/xlink';
const {
  createContextualFragment: RangeProtoCreateContextualFragment$LWS
} = Range.prototype;
const RequestProtoURLGetter$LWS = ObjectLookupOwnGetter$LWS(Request.prototype, 'url');
const ResponseCtor$LWS = Response;
const ResponseProto$LWS = ResponseCtor$LWS.prototype;
const ResponseProtoOkGetter$LWS = ObjectLookupOwnGetter$LWS(ResponseProto$LWS, 'ok');
const ResponseProtoStatus$LWS = ObjectLookupOwnGetter$LWS(ResponseProto$LWS, 'status');
const ResponseProtoStatusText$LWS = ObjectLookupOwnGetter$LWS(ResponseProto$LWS, 'statusText');
const {
  text: ResponseProtoText$LWS
} = ResponseProto$LWS;
const URLCtor$LWS = URL;
const URLProtoOriginGetter$LWS = ObjectLookupOwnGetter$LWS(URLCtor$LWS.prototype, 'origin');
const {
  createObjectURL: URLCreateObjectURL$LWS,
  revokeObjectURL: URLRevokeObjectURL$LWS
} = URLCtor$LWS;
const SCRIPT_EVALUATOR_PROPERTY_NAME$LWS = '$evaluator$';
// Lazily define SCRIPT_HOOK_BLOB_URL for jest test support.
let SCRIPT_HOOK_BLOB_URL$LWS;
const SCRIPT_HOOK_SOURCE_TEXT$LWS = `document.currentScript.${SCRIPT_EVALUATOR_PROPERTY_NAME$LWS}`;
const evaluatedScriptElements$LWS = toSafeWeakSet$LWS(new WeakSetCtor$LWS());
const originalScriptPropertyCache$LWS = toSafeWeakMap$LWS(new WeakMapCtor$LWS());
const resolvedURLRegistryCache$LWS = toSafeWeakMap$LWS(new WeakMapCtor$LWS());
function defineScriptAccessorProperty$LWS(script$LWS, propKey$LWS, getter$LWS, setter$LWS) {
  ReflectDefineProperty$LWS(script$LWS, propKey$LWS, {
    __proto__: null,
    configurable: true,
    enumerable: true,
    get: getter$LWS,
    set: setter$LWS
  });
}
function defineScriptEvaluatorProperty$LWS(script$LWS, callback$LWS) {
  // istanbul ignore if: require a test to get the evaluator in a bad state. Like code that tried to access it in between. This is mostly a "the universe is not as expected error"
  if (!ReflectDefineProperty$LWS(script$LWS, SCRIPT_EVALUATOR_PROPERTY_NAME$LWS, {
    __proto__: null,
    configurable: true,
    // Create a bound function to obscure the getter source as "[native code]".
    get: ReflectApply$LWS(FunctionProtoBind$LWS, () => {
      // Track the script element evaluation to ensure the element
      // is evaluated only once.
      evaluatedScriptElements$LWS.add(script$LWS);
      deleteScriptEvaluatorProperty$LWS(script$LWS);
      const ownerDoc$LWS = ReflectApply$LWS(NodeProtoOwnerDocumentGetter$LWS, script$LWS, []);
      const defaultView$LWS = ReflectApply$LWS(DocumentProtoDefaultViewGetter$LWS, ownerDoc$LWS, []);
      // We don't need to use something like `WindowLocationGetter()`
      // because the 'location' and 'top' property are non-configurable.
      const context$LWS = {
        [UNCOMPILED_LOCATION_NAME$LWS]: defaultView$LWS.location,
        [UNCOMPILED_TOP_NAME$LWS]: defaultView$LWS.top
      };
      callback$LWS(context$LWS, defaultView$LWS, ownerDoc$LWS);
    }, [])
  })) {
    // istanbul ignore next: require a test to get the evaluator in a bad state. Like code that tried to access it in between. This is mostly a "the universe is not as expected error"
    throw new LockerSecurityError$LWS(`Cannot evaluate ${ReflectApply$LWS(NodeProtoNodeNameGetter$LWS, script$LWS, [])}`);
  }
}
function deleteOriginalScriptProperty$LWS(script$LWS) {
  originalScriptPropertyCache$LWS.delete(script$LWS);
}
function deleteResolvedScriptURL$LWS(script$LWS) {
  resolvedURLRegistryCache$LWS.delete(script$LWS);
}
function deleteScriptEvaluatorProperty$LWS(script$LWS) {
  ReflectDeleteProperty$LWS(script$LWS, SCRIPT_EVALUATOR_PROPERTY_NAME$LWS);
}
function getOriginalScriptProperty$LWS(script$LWS) {
  return originalScriptPropertyCache$LWS.get(script$LWS);
}
function getResolvedScriptURL$LWS(script$LWS, attributeName$LWS) {
  var _resolvedURLRegistryC$LWS;
  return (_resolvedURLRegistryC$LWS = resolvedURLRegistryCache$LWS.get(script$LWS)) == null ? void 0 : _resolvedURLRegistryC$LWS[attributeName$LWS];
}
// istanbul ignore next: cannot be tested in jest environment
function getScriptSrcEvaluatorHookURL$LWS() {
  if (SCRIPT_HOOK_BLOB_URL$LWS === undefined) {
    // Create a blob URL of the evaluator hook because 'script-src blob:'
    // is allowed in our CSP whereas setting the script's textContent will
    // trigger an unsafe-eval CSP error.
    SCRIPT_HOOK_BLOB_URL$LWS = URLCreateObjectURL$LWS(new BlobCtor$LWS([SCRIPT_HOOK_SOURCE_TEXT$LWS], {
      __proto__: null,
      type: 'text/javascript'
    }));
  }
  return SCRIPT_HOOK_BLOB_URL$LWS;
}
function isScriptEvaluated$LWS(script$LWS) {
  return evaluatedScriptElements$LWS.has(script$LWS);
}
function isScriptPropertyEvaluatorHookDefined$LWS(script$LWS) {
  return originalScriptPropertyCache$LWS.has(script$LWS);
}
function isScriptURLEvaluatorHookDefined$LWS(script$LWS) {
  return resolvedURLRegistryCache$LWS.has(script$LWS);
}
function setOriginalScriptScriptProperty$LWS(script$LWS, scriptProperty$LWS) {
  return originalScriptPropertyCache$LWS.set(script$LWS, scriptProperty$LWS);
}
function setResolvedScriptURL$LWS(script$LWS, attributeName$LWS, resolvedURL$LWS) {
  let resolvedURLRegistry$LWS = resolvedURLRegistryCache$LWS.get(script$LWS);
  if (resolvedURLRegistry$LWS === undefined) {
    resolvedURLRegistry$LWS = {
      __proto__: null
    };
    resolvedURLRegistryCache$LWS.set(script$LWS, resolvedURLRegistry$LWS);
  }
  resolvedURLRegistry$LWS[attributeName$LWS] = resolvedURL$LWS;
}
function trackScriptAsEvaluated$LWS(script$LWS) {
  evaluatedScriptElements$LWS.add(script$LWS);
}

/* eslint-disable no-fallthrough */
class Token$LWS {
  constructor(tt$LWS, index$LWS, value$LWS = '') {
    this.type = tt$LWS;
    this.value = value$LWS;
    this.index = index$LWS;
  }
}
class Tokenizer$LWS {
  constructor() {
    this.currIndex = 0;
    this.source = '';
  }
  getNextToken(currIndex$LWS, source$LWS) {
    this.currIndex = currIndex$LWS;
    this.source = source$LWS;
    // Skip whitespaces and move currIndex
    while (this.isWhitespace(this.currentCharCode())) {
      this.currIndex += 1;
    }
    const ch$LWS = this.currentCharCode();
    switch (ch$LWS) {
      // dot char
      case 46:
        {
          let maybeMemberProp$LWS = '';
          while (!this.isInvalidIdentifierCode(this.nextCharCode())) {
            maybeMemberProp$LWS += this.source[this.currIndex];
          }
          if (maybeMemberProp$LWS === 'location') {
            return new Token$LWS(2 /* TokenType.LOCATION */, this.currIndex);
          }
          return new Token$LWS(4 /* TokenType.MEMBER_PROPERTY */, this.currIndex, maybeMemberProp$LWS);
        }
      // equal char
      case 61:
        {
          const nextCharCode$LWS = this.lookAhead();
          if (this.isWhitespace(nextCharCode$LWS)) {
            return new Token$LWS(0 /* TokenType.ASSIGN */, this.currIndex);
          }
          switch (nextCharCode$LWS) {
            // another equal char means equality check
            case 61:
              return new Token$LWS(5 /* TokenType.ROW */, this.currIndex);
            default:
              return new Token$LWS(0 /* TokenType.ASSIGN */, this.currIndex);
          }
        }
      // asterix sign
      case 42:
      // plus sign
      case 43:
      // minus sign
      case 45:
      // division sign
      case 47:
        {
          // any of the previous chars repeated or followed by an equal is an assignment
          const nextCharCode$LWS = this.lookAhead();
          switch (nextCharCode$LWS) {
            case 42:
            case 43:
            case 45:
            case 61:
              return new Token$LWS(0 /* TokenType.ASSIGN */, this.currIndex);
            // `window.location // 1` is not an assignment
            case 47:
              return new Token$LWS(5 /* TokenType.ROW */, this.currIndex);
            default:
              return new Token$LWS(5 /* TokenType.ROW */, this.currIndex);
          }
        }
      // question mark
      case 63:
        {
          // look for ??= operator
          if (this.nextCharCode() === 63 && this.nextCharCode() === 61) {
            return new Token$LWS(0 /* TokenType.ASSIGN */, this.currIndex);
          }
          return new Token$LWS(5 /* TokenType.ROW */, this.currIndex);
        }
      // pipe
      case 124:
        {
          // look for ||= operator
          if (this.nextCharCode() === 124 && this.nextCharCode() === 61) {
            return new Token$LWS(0 /* TokenType.ASSIGN */, this.currIndex);
          }
          return new Token$LWS(5 /* TokenType.ROW */, this.currIndex);
        }
    }
    return new Token$LWS(5 /* TokenType.ROW */, this.currIndex);
  }
  getPreviousToken(currIndex$LWS, source$LWS) {
    this.currIndex = currIndex$LWS;
    this.source = source$LWS;
    let buffer$LWS = '';
    while (this.currIndex >= 0) {
      const currCode$LWS = this.currentCharCode();
      if (this.isInvalidIdentifierCode(currCode$LWS)) {
        break;
      }
      buffer$LWS = this.source[this.currIndex] + buffer$LWS;
      this.currIndex -= 1;
    }
    if (buffer$LWS.length > 0) {
      if (buffer$LWS === 'top') {
        return new Token$LWS(6 /* TokenType.TOP */, this.currIndex);
      }
      return new Token$LWS(3 /* TokenType.MEMBER_OBJECT */, this.currIndex, buffer$LWS);
    }
    return new Token$LWS(5 /* TokenType.ROW */, this.currIndex);
  }
  currentCharCode() {
    return ReflectApply$LWS(StringProtoCharCodeAt$LWS, this.source, [this.currIndex]);
  }
  isInvalidIdentifierCode(charCode$LWS) {
    // #, $, _
    if (charCode$LWS === 35 || charCode$LWS === 36 || charCode$LWS === 95) {
      return false;
    }
    // all numbers
    if (charCode$LWS >= 48 && charCode$LWS <= 57) {
      return false;
    }
    // all uppercase
    if (charCode$LWS >= 65 && charCode$LWS <= 90) {
      return false;
    }
    // all lowercase
    if (charCode$LWS >= 97 && charCode$LWS <= 122) {
      return false;
    }
    return true;
  }
  isWhitespace(charCode$LWS) {
    switch (charCode$LWS) {
      // tab
      // istanbul ignore next: this may be dead code, as code that contains a real tab doesn't pass through this case.
      case 9:
      // new line
      case 10:
      // line tabulation
      case 11:
      // form feed
      case 12:
      // carriage return
      case 13:
      // space
      case 32:
        return true;
      default:
        return false;
    }
  }
  lookAhead() {
    return ReflectApply$LWS(StringProtoCharCodeAt$LWS, this.source, [this.currIndex + 1]);
  }
  nextCharCode() {
    return ReflectApply$LWS(StringProtoCharCodeAt$LWS, this.source, [++this.currIndex]);
  }
}
class Transpiler$LWS {
  // memberProperties must be a safe array.
  constructor(memberProperties$LWS) {
    this.memberProperties = memberProperties$LWS;
    const regexParts$LWS = this.memberProperties.map(prop$LWS => {
      const firstCharCode$LWS = ReflectApply$LWS(StringProtoCharCodeAt$LWS, prop$LWS, [0]);
      // REGEX:
      //   [\w] === [a-zA-Z0-9_]
      //   [\s] === Whitespace
      //      1. [\\w\\$\\#]+?\\[['"\`\\w\\s]+?\\]\\. Checks for code in the form of "foo[bar]."
      //      2. ([\\w\\$\\#]+?)\\(['"\`\\w\\s]{0,}\\)\\. Checks for code in the form of "foo(bar)."
      //      3. ([\\w\\$\\#]+?)\\. Check for code in the form of "foobar."
      //   {1,} Matches 1 or more of the top 1-3. All must end in a period.
      //   (?!['"\`]) Ensures that strings are not matched.
      //   Object keys can contain Symbols or other Special Characters. We only deal with [_, $, #].
      if (this.isAlphanumeric(firstCharCode$LWS)) {
        return `(?!['"\`])(([\\w\\$\\#]+?\\[['"\`\\w\\s]+?\\]\\.|([\\w\\$\\#]+?)\\(['"\`\\w\\s]{0,}\\)\\.|([\\w\\$\\#]+?)\\.){1,})${prop$LWS}(?!['"\`])\\b`;
      }
      return `(?!['"\`])(([\\w\\$\\#]+?\\[['"\`\\w\\s]+?\\]\\.|([\\w\\$\\#]+?)\\(['"\`\\w\\s]{0,}\\)\\.|([\\w\\$\\#]+?)\\.){1,})\\${prop$LWS}(?!['"\`])\\b`;
    });
    const regexString$LWS = ReflectApply$LWS(ArrayProtoJoin$LWS, regexParts$LWS, ['|']);
    this.memberExprPatt = new RegExpCtor$LWS(regexString$LWS, 'g');
    this.tokenizer = new Tokenizer$LWS();
  }
  compile(input$LWS) {
    let compiledOutput$LWS = '';
    let currentIndex$LWS = 0;
    this.memberExprPatt.lastIndex = 0;
    let match$LWS = ReflectApply$LWS(RegExpProtoExec$LWS, this.memberExprPatt, [input$LWS]);
    while (match$LWS) {
      const stringSliceToMachedIndex$LWS = ReflectApply$LWS(StringProtoSubstring$LWS, input$LWS, [currentIndex$LWS, match$LWS.index]);
      compiledOutput$LWS += stringSliceToMachedIndex$LWS;
      const expr$LWS = match$LWS[0];
      currentIndex$LWS = match$LWS.index + expr$LWS.length;
      let object$LWS = '';
      let property$LWS = '';
      // Check if the match is the full object, else skip.
      if (this.beginsWithPeriod(input$LWS, match$LWS.index)) {
        compiledOutput$LWS += expr$LWS;
        match$LWS = ReflectApply$LWS(RegExpProtoExec$LWS, this.memberExprPatt, [input$LWS]);
        continue;
      }
      // Loop through the properties and find out which Regex matched
      for (let i$LWS = 0, {
          length: length$LWS
        } = this.memberProperties; i$LWS < length$LWS; i$LWS++) {
        const memberExprObj$LWS = match$LWS[1 + i$LWS * 4];
        if (memberExprObj$LWS) {
          object$LWS = this.trimEndingChar(memberExprObj$LWS);
          property$LWS = this.memberProperties[i$LWS];
          break;
        }
      }
      const propertyIndex$LWS = match$LWS.index + object$LWS.length - 1;
      if (property$LWS === 'location' && this.tokenizer.getPreviousToken(propertyIndex$LWS, input$LWS).type === 6 /* TokenType.TOP */) {
        // rewind index from a.x.top.location to a.x.top
        const beginTopIndex$LWS = propertyIndex$LWS - 4; // `.top`;
        // determine if we're dealing with `top.location` or `x.top.location`;
        const parent$LWS = this.tokenizer.getPreviousToken(beginTopIndex$LWS, input$LWS);
        if (parent$LWS.type === 3 /* TokenType.MEMBER_OBJECT */) {
          const parentObj$LWS = ReflectApply$LWS(StringProtoSlice$LWS, input$LWS, [match$LWS.index, match$LWS.index + parent$LWS.value.length]);
          compiledOutput$LWS += `${this.replaceMemberObject(parentObj$LWS, '$$locker$$.$$top$$', object$LWS)}.location`;
        } else {
          compiledOutput$LWS += '$$locker$$.$$top$$.location';
        }
      } else {
        const nextToken$LWS = this.tokenizer.getNextToken(currentIndex$LWS, input$LWS);
        switch (nextToken$LWS.type) {
          // istanbul ignore next: there are currently no occurences of new Token(TokenType.EOF, ...)
          case 1 /* TokenType.EOF */:
          case 4 /* TokenType.MEMBER_PROPERTY */:
          case 5 /* TokenType.ROW */:
            {
              compiledOutput$LWS += this.replaceMemberObject(object$LWS, property$LWS, expr$LWS);
              break;
            }
          case 2 /* TokenType.LOCATION */:
            {
              if (property$LWS === 'top') {
                const parent$LWS = this.tokenizer.getPreviousToken(propertyIndex$LWS, input$LWS);
                if (parent$LWS.type === 3 /* TokenType.MEMBER_OBJECT */) {
                  compiledOutput$LWS += `${this.replaceMemberObject(parent$LWS.value, '$$locker$$.$$top$$', expr$LWS)}`;
                }
                break;
              }
            }
          case 0 /* TokenType.ASSIGN */:
            {
              compiledOutput$LWS += `${this.replaceMemberObject(object$LWS, '$$locker$$', object$LWS)}.${property$LWS}`;
              break;
            }
        }
      }
      match$LWS = ReflectApply$LWS(RegExpProtoExec$LWS, this.memberExprPatt, [input$LWS]);
    }
    if (currentIndex$LWS < input$LWS.length) {
      compiledOutput$LWS += ReflectApply$LWS(StringProtoSubstring$LWS, input$LWS, [currentIndex$LWS, input$LWS.length]);
    }
    return compiledOutput$LWS;
  }
  beginsWithPeriod(input$LWS, matchIndex$LWS) {
    return input$LWS[matchIndex$LWS - 1] === '.';
  }
  isAlphanumeric(code$LWS) {
    if (code$LWS > 47 && code$LWS < 58 || code$LWS > 64 && code$LWS < 91 || code$LWS > 96 && code$LWS < 123) {
      return true;
    }
    return false;
  }
  trimEndingChar(input$LWS) {
    return ReflectApply$LWS(StringProtoSlice$LWS, input$LWS, [0, -1]);
  }
  replaceMemberObject(object$LWS, replaceWith$LWS, expression$LWS) {
    return `(${object$LWS} === globalThis || ${object$LWS} === document ? ${replaceWith$LWS} : ${expression$LWS})`;
  }
}
const documentPattern$LWS = 'document';
const windowPattern$LWS = 'document\\.defaultView|frames|globalThis|self|window';
const webpackGlobalPattern$LWS = `${windowPattern$LWS}|global`;
const webpackGlobalDocumentPattern$LWS = `${documentPattern$LWS}|global.document`;
// While fully qualified member expression access can be unambiguously detected,
// ie. window.location or window.top, bare-word references to location and top
// cannot. This means that code containing the fully qualified member expressions
// can have all occurrences replaced by transforms and given special names controlled
// by LWS in Aura. This process will also result in the program knowing that it
// applied a given transform, which it can then use to populate a context names
// list to be used in the declaration assignment code injected into wrapped Aura
// component code. Because the unqualified member expressions cannot be unambiguously
// detected, there is no way for the program to know that, eg. location.search was
// used in the Aura component code and subsequently transformed, which means it
// cannot be relied upon to when populating a context names list to be used in
// the declaration assignment code. As a result, location and top must be universally
// and explicitly included in the context object, and universally and explicitly
// included in the context names list.
const UNIVERSAL_CONTEXT_NAMES$LWS = [UNCOMPILED_LOCATION_NAME$LWS, UNCOMPILED_TOP_NAME$LWS, 'location', 'top'];
const locationReferencesRegExp$LWS = createPropertyReferenceRegExp$LWS(`${documentPattern$LWS}|${windowPattern$LWS}`, 'location');
const locationReferencesWithWebpackRegExp$LWS = createPropertyReferenceRegExp$LWS(`${webpackGlobalDocumentPattern$LWS}|${webpackGlobalPattern$LWS}`, 'location');
const sandboxEvalContextNameRegExp$LWS = new RegExpCtor$LWS(`(?:^|\\W)${toRegExpEscapedString$LWS(SANDBOX_EVAL_CONTEXT_NAME$LWS)}(?:\\W|$)`);
const webpackRequireNameRegExp$LWS = new RegExpCtor$LWS(toRegExpEscapedIdentifierName$LWS(WEBPACK_REQUIRE_NAME$LWS));
const windowTopReferencesRegExp$LWS = createPropertyReferenceRegExp$LWS(windowPattern$LWS, 'top');
const windowTopReferencesWithWebpackRegExp$LWS = createPropertyReferenceRegExp$LWS(webpackGlobalPattern$LWS, 'top');
function createPropertyReferenceRegExp$LWS(objectPattern$LWS, key$LWS) {
  // An assignment operator is defined by
  // https://tc39.es/ecma262/#prod-AssignmentOperator
  // as one of the following:
  //     *= /= %= += -= <<= >>= >>>= &= ^= |= **=
  return new RegExpCtor$LWS(`\\b(?:${objectPattern$LWS})\\.${key$LWS}\\b(\\s*(?:[?*/%&^|+-]|>>>?|<<)*=(?=[^=]))?`, 'g');
}
function compileSourceText$LWS(sourceText$LWS) {
  // To avoid conflicts with anyone else using `SANDBOX_EVAL_CONTEXT_NAME`,
  // we sniff the source text to see if it is present, and in that case we
  // don't proceed with the string replacement.
  if (ReflectApply$LWS(RegExpProtoTest$LWS, sandboxEvalContextNameRegExp$LWS, [sourceText$LWS])) {
    return sourceText$LWS;
  }
  let locationRegExp$LWS;
  let topRegExp$LWS;
  if (ReflectApply$LWS(RegExpProtoTest$LWS, webpackRequireNameRegExp$LWS, [sourceText$LWS])) {
    locationRegExp$LWS = locationReferencesWithWebpackRegExp$LWS;
    topRegExp$LWS = windowTopReferencesWithWebpackRegExp$LWS;
  } else {
    locationRegExp$LWS = locationReferencesRegExp$LWS;
    topRegExp$LWS = windowTopReferencesRegExp$LWS;
  }
  // Input `sourceText` is non-compiled, so `window.location` returns `null`
  // inside the detached iframe sandbox. Our compiler solves this problem by
  // transforming the red `location` reference into a blue `location` reference.
  // The solution below emulates what our compiler does, but using a simple
  // string replacement.
  sourceText$LWS = ReflectApply$LWS(StringProtoReplace$LWS, sourceText$LWS, [locationRegExp$LWS, (_match$LWS, assignmentOperator$LWS) => assignmentOperator$LWS ? `${UNCOMPILED_LOCATION_NAME$LWS}.href${assignmentOperator$LWS}` : UNCOMPILED_LOCATION_NAME$LWS]);
  // In non-compiled source text `window.top` is null when evaluated in a
  // sandbox. We perform a naive transformation to replace references of
  // `window.top` to use our internal sandbox helpers.
  sourceText$LWS = ReflectApply$LWS(StringProtoReplace$LWS, sourceText$LWS, [topRegExp$LWS, () => UNCOMPILED_TOP_NAME$LWS]);
  return sourceText$LWS;
}
function generateContextAssignmentCodeFromContextNames$LWS(names$LWS) {
  return `const {${ReflectApply$LWS(ArrayProtoToString$LWS, names$LWS, [])}}=${SANDBOX_EVAL_CONTEXT_NAME$LWS}`;
}
function transformSourceText$LWS(sourceText$LWS) {
  if (ReflectApply$LWS(RegExpProtoTest$LWS, sandboxEvalContextNameRegExp$LWS, [sourceText$LWS])) {
    return sourceText$LWS;
  }
  const code$LWS = compileSourceText$LWS(sourceText$LWS);
  const prefix$LWS = `${generateContextAssignmentCodeFromContextNames$LWS(UNIVERSAL_CONTEXT_NAMES$LWS)};`;
  const pragmaIndex$LWS = indexOfPragma$LWS(code$LWS, 'use strict');
  if (pragmaIndex$LWS === -1) {
    return prefix$LWS + code$LWS;
  }
  // The "use strict" pragma, including quotes, is 12 characters long.
  let afterPragmaIndex$LWS = pragmaIndex$LWS + 12;
  // istanbul ignore else
  if (afterPragmaIndex$LWS < code$LWS.length && code$LWS[afterPragmaIndex$LWS] === ';') {
    // Move index after the semicolon.
    afterPragmaIndex$LWS += 1;
  }
  return ReflectApply$LWS(StringProtoSlice$LWS, code$LWS, [0, afterPragmaIndex$LWS]) + prefix$LWS + ReflectApply$LWS(StringProtoSlice$LWS, code$LWS, [afterPragmaIndex$LWS]);
}
const {
  key: StorageProtoKey$LWS,
  getItem: StorageProtoGetItem$LWS,
  removeItem: StorageProtoRemoveItem$LWS,
  setItem: StorageProtoSetItem$LWS
} = Storage.prototype;
const {
  get: SVGScriptElementProtoHrefGetter$LWS,
  set: SVGScriptElementProtoHrefSetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(SVGScriptElement.prototype, 'href');

// This has to be done 1-by-1 because putting a full file ignore in this file
// will result in dist/index.mjs.js containing the directive and subsequently being
// ignored.
// istanbul ignore next
const XhrCtor$LWS = XMLHttpRequest;
const {
  prototype: XhrProto$LWS
} = XhrCtor$LWS;
const {
  abort: XhrProtoAbort$LWS,
  open: XhrProtoOpen$LWS,
  send: XhrProtoSend$LWS
} = XhrProto$LWS;
const XhrProtoResponseTextGetter$LWS = ObjectLookupOwnGetter$LWS(XhrProto$LWS, 'responseText');
const XhrProtoStatusGetter$LWS = ObjectLookupOwnGetter$LWS(XhrProto$LWS, 'status');
const XhrProtoWithCredentialsSetter$LWS = ObjectLookupOwnSetter$LWS(XhrProto$LWS, 'withCredentials');
export { AbortControllerCtor$LWS as AbortControllerCtor, AbortControllerProto$LWS as AbortControllerProto, AbortControllerProtoAbort$LWS as AbortControllerProtoAbort, AbortControllerProtoSignalGetter$LWS as AbortControllerProtoSignalGetter, AttrProtoNameGetter$LWS as AttrProtoNameGetter, AttrProtoNamespaceURIGetter$LWS as AttrProtoNamespaceURIGetter, AttrProtoOwnerElementGetter$LWS as AttrProtoOwnerElementGetter, AttrProtoValueGetter$LWS as AttrProtoValueGetter, AttrProtoValueSetter$LWS as AttrProtoValueSetter, BlobCtor$LWS as BlobCtor, BlobProtoSizeGetter$LWS as BlobProtoSizeGetter, BlobProtoSlice$LWS as BlobProtoSlice, BlobProtoTypeGetter$LWS as BlobProtoTypeGetter, CHILD_WINDOW_BLOCKED_PROPERTY_SYMBOL$LWS as CHILD_WINDOW_BLOCKED_PROPERTY_SYMBOL, CUSTOM_ELEMENT_REGISTRY_ATTRIBUTE_NAME$LWS as CUSTOM_ELEMENT_REGISTRY_ATTRIBUTE_NAME, DATA_CLONE_ERROR_CODE$LWS as DATA_CLONE_ERROR_CODE, DOMExceptionCtor$LWS as DOMExceptionCtor, DOMExceptionProtoCodeGetter$LWS as DOMExceptionProtoCodeGetter, DOMImplementationProtoCreateDocument$LWS as DOMImplementationProtoCreateDocument, DOMTokenListProtoAdd$LWS as DOMTokenListProtoAdd, DOMTokenListProtoContains$LWS as DOMTokenListProtoContains, DOMTokenListProtoLengthGetter$LWS as DOMTokenListProtoLengthGetter, DOMTokenListProtoRemove$LWS as DOMTokenListProtoRemove, DOMTokenListProtoValueGetter$LWS as DOMTokenListProtoValueGetter, DocumentFragmentProtoAppend$LWS as DocumentFragmentProtoAppend, DocumentFragmentProtoGetElementById$LWS as DocumentFragmentProtoGetElementById, DocumentProtoBodyGetter$LWS as DocumentProtoBodyGetter, DocumentProtoClose$LWS as DocumentProtoClose, DocumentProtoCookieGetter$LWS as DocumentProtoCookieGetter, DocumentProtoCookieSetter$LWS as DocumentProtoCookieSetter, DocumentProtoCreateComment$LWS as DocumentProtoCreateComment, DocumentProtoCreateDocumentFragment$LWS as DocumentProtoCreateDocumentFragment, DocumentProtoCreateElement$LWS as DocumentProtoCreateElement, DocumentProtoCreateElementNS$LWS as DocumentProtoCreateElementNS, DocumentProtoDefaultViewGetter$LWS as DocumentProtoDefaultViewGetter, DocumentProtoDocumentElementGetter$LWS as DocumentProtoDocumentElementGetter, DocumentProtoGetElementById$LWS as DocumentProtoGetElementById, DocumentProtoHeadGetter$LWS as DocumentProtoHeadGetter, DocumentProtoImplementationGetter$LWS as DocumentProtoImplementationGetter, DocumentProtoOpen$LWS as DocumentProtoOpen, ElementAriaAttributesToPropertyName$LWS as ElementAriaAttributesToPropertyName, ElementProtoClosest$LWS as ElementProtoClosest, ElementProtoGetAttribute$LWS as ElementProtoGetAttribute, ElementProtoGetAttributeNode$LWS as ElementProtoGetAttributeNode, ElementProtoGetAttributeNodeNS$LWS as ElementProtoGetAttributeNodeNS, ElementProtoHasAttribute$LWS as ElementProtoHasAttribute, ElementProtoInnerHTMLGetter$LWS as ElementProtoInnerHTMLGetter, ElementProtoInnerHTMLSetter$LWS as ElementProtoInnerHTMLSetter, ElementProtoNamespaceURIGetter$LWS as ElementProtoNamespaceURIGetter, ElementProtoOuterHTMLGetter$LWS as ElementProtoOuterHTMLGetter, ElementProtoQuerySelector$LWS as ElementProtoQuerySelector, ElementProtoQuerySelectorAll$LWS as ElementProtoQuerySelectorAll, ElementProtoRemove$LWS as ElementProtoRemove, ElementProtoRemoveAttribute$LWS as ElementProtoRemoveAttribute, ElementProtoRemoveAttributeNS$LWS as ElementProtoRemoveAttributeNS, ElementProtoRemoveAttributeNode$LWS as ElementProtoRemoveAttributeNode, ElementProtoSetAttribute$LWS as ElementProtoSetAttribute, ElementProtoSetAttributeNS$LWS as ElementProtoSetAttributeNS, ElementProtoTagNameGetter$LWS as ElementProtoTagNameGetter, ElementProtoToggleAttribute$LWS as ElementProtoToggleAttribute, ErrorEventCtor$LWS as ErrorEventCtor, EventCtor$LWS as EventCtor, EventProtoCurrentTargetGetter$LWS as EventProtoCurrentTargetGetter, EventProtoStopPropagation$LWS as EventProtoStopPropagation, EventTargetProtoAddEventListener$LWS as EventTargetProtoAddEventListener, EventTargetProtoDispatchEvent$LWS as EventTargetProtoDispatchEvent, EventTargetProtoRemoveEventListener$LWS as EventTargetProtoRemoveEventListener, HTMLAnchorElementProtoHostnameGetter$LWS as HTMLAnchorElementProtoHostnameGetter, HTMLAnchorElementProtoHrefGetter$LWS as HTMLAnchorElementProtoHrefGetter, HTMLAnchorElementProtoHrefSetter$LWS as HTMLAnchorElementProtoHrefSetter, HTMLAnchorElementProtoPathnameGetter$LWS as HTMLAnchorElementProtoPathnameGetter, HTMLAnchorElementProtoProtocolGetter$LWS as HTMLAnchorElementProtoProtocolGetter, HTMLElementGlobalAttributesToPropertyName$LWS as HTMLElementGlobalAttributesToPropertyName, HTMLElementProto$LWS as HTMLElementProto, HTMLElementProtoInnerTextGetter$LWS as HTMLElementProtoInnerTextGetter, HTMLElementProtoStyleGetter$LWS as HTMLElementProtoStyleGetter, HTMLIFrameElementProtoContentWindowGetter$LWS as HTMLIFrameElementProtoContentWindowGetter, HTMLIFrameElementProtoSandboxGetter$LWS as HTMLIFrameElementProtoSandboxGetter, HTMLIFrameElementProtoSandboxSetter$LWS as HTMLIFrameElementProtoSandboxSetter, HTMLIFrameElementProtoSrcGetter$LWS as HTMLIFrameElementProtoSrcGetter, HTMLIFrameElementProtoSrcSetter$LWS as HTMLIFrameElementProtoSrcSetter, HTMLScriptElementCtor$LWS as HTMLScriptElementCtor, HTMLScriptElementProto$LWS as HTMLScriptElementProto, HTMLScriptElementProtoSrcGetter$LWS as HTMLScriptElementProtoSrcGetter, HTMLScriptElementProtoSrcSetter$LWS as HTMLScriptElementProtoSrcSetter, HTMLTemplateElementProtoContentGetter$LWS as HTMLTemplateElementProtoContentGetter, IS_CHROMIUM_BROWSER$LWS as IS_CHROMIUM_BROWSER, IS_OLD_CHROMIUM_BROWSER$LWS as IS_OLD_CHROMIUM_BROWSER, IS_WEBKIT_BROWSER$LWS as IS_WEBKIT_BROWSER, NAMESPACE_DEFAULT$LWS as NAMESPACE_DEFAULT, NAMESPACE_SVG$LWS as NAMESPACE_SVG, NAMESPACE_XHTML$LWS as NAMESPACE_XHTML, NAMESPACE_XLINK$LWS as NAMESPACE_XLINK, NodeProtoAppendChild$LWS as NodeProtoAppendChild, NodeProtoChildNodesGetter$LWS as NodeProtoChildNodesGetter, NodeProtoCloneNode$LWS as NodeProtoCloneNode, NodeProtoFirstChildGetter$LWS as NodeProtoFirstChildGetter, NodeProtoIsConnectedGetter$LWS as NodeProtoIsConnectedGetter, NodeProtoIsEqualNode$LWS as NodeProtoIsEqualNode, NodeProtoLastChildGetter$LWS as NodeProtoLastChildGetter, NodeProtoNodeNameGetter$LWS as NodeProtoNodeNameGetter, NodeProtoOwnerDocumentGetter$LWS as NodeProtoOwnerDocumentGetter, NodeProtoParentNodeGetter$LWS as NodeProtoParentNodeGetter, NodeProtoTextContentGetter$LWS as NodeProtoTextContentGetter, NodeProtoTextContentSetter$LWS as NodeProtoTextContentSetter, RangeProtoCreateContextualFragment$LWS as RangeProtoCreateContextualFragment, RequestProtoURLGetter$LWS as RequestProtoURLGetter, ResponseCtor$LWS as ResponseCtor, ResponseProtoOkGetter$LWS as ResponseProtoOkGetter, ResponseProtoStatus$LWS as ResponseProtoStatus, ResponseProtoStatusText$LWS as ResponseProtoStatusText, ResponseProtoText$LWS as ResponseProtoText, SCRIPT_HOOK_SOURCE_TEXT$LWS as SCRIPT_HOOK_SOURCE_TEXT, SVGScriptElementProtoHrefGetter$LWS as SVGScriptElementProtoHrefGetter, SVGScriptElementProtoHrefSetter$LWS as SVGScriptElementProtoHrefSetter, StorageProtoGetItem$LWS as StorageProtoGetItem, StorageProtoKey$LWS as StorageProtoKey, StorageProtoRemoveItem$LWS as StorageProtoRemoveItem, StorageProtoSetItem$LWS as StorageProtoSetItem, Transpiler$LWS as Transpiler, UNIVERSAL_CONTEXT_NAMES$LWS as UNIVERSAL_CONTEXT_NAMES, URLCreateObjectURL$LWS as URLCreateObjectURL, URLCtor$LWS as URLCtor, URLProtoOriginGetter$LWS as URLProtoOriginGetter, URLRevokeObjectURL$LWS as URLRevokeObjectURL, WindowClearInterval$LWS as WindowClearInterval, WindowDecodeURIComponent$LWS as WindowDecodeURIComponent, WindowDocumentGetter$LWS as WindowDocumentGetter, WindowEncodeURIComponent$LWS as WindowEncodeURIComponent, WindowFetch$LWS as WindowFetch, WindowFrameElementGetter$LWS as WindowFrameElementGetter, WindowLengthGetter$LWS as WindowLengthGetter, WindowLocationGetter$LWS as WindowLocationGetter, WindowQueueMicrotask$LWS as WindowQueueMicrotask, WindowSetInterval$LWS as WindowSetInterval, XhrCtor$LWS as XhrCtor, XhrProtoAbort$LWS as XhrProtoAbort, XhrProtoOpen$LWS as XhrProtoOpen, XhrProtoResponseTextGetter$LWS as XhrProtoResponseTextGetter, XhrProtoSend$LWS as XhrProtoSend, XhrProtoStatusGetter$LWS as XhrProtoStatusGetter, XhrProtoWithCredentialsSetter$LWS as XhrProtoWithCredentialsSetter, compileSourceText$LWS as compileSourceText, defineScriptAccessorProperty$LWS as defineScriptAccessorProperty, defineScriptEvaluatorProperty$LWS as defineScriptEvaluatorProperty, deleteOriginalScriptProperty$LWS as deleteOriginalScriptProperty, deleteResolvedScriptURL$LWS as deleteResolvedScriptURL, deleteScriptEvaluatorProperty$LWS as deleteScriptEvaluatorProperty, generateContextAssignmentCodeFromContextNames$LWS as generateContextAssignmentCodeFromContextNames, getOriginalScriptProperty$LWS as getOriginalScriptProperty, getResolvedScriptURL$LWS as getResolvedScriptURL, getScriptSrcEvaluatorHookURL$LWS as getScriptSrcEvaluatorHookURL, getValidator$LWS as getValidator, initWindowOpenChildWindow$LWS as initWindowOpenChildWindow, isScriptEvaluated$LWS as isScriptEvaluated, isScriptPropertyEvaluatorHookDefined$LWS as isScriptPropertyEvaluatorHookDefined, isScriptURLEvaluatorHookDefined$LWS as isScriptURLEvaluatorHookDefined, isWindow$LWS as isWindow, markForUnsafePropertyBlocking$LWS as markForUnsafePropertyBlocking, normalizeNamespacedAttributeName$LWS as normalizeNamespacedAttributeName, normalizeWindowOpenArguments$LWS as normalizeWindowOpenArguments, rootDocument$LWS as rootDocument, rootValidator$LWS as rootValidator, rootWindow$LWS as rootWindow, rootWindowLocation$LWS as rootWindowLocation, rootWindowTop$LWS as rootWindowTop, setOriginalScriptScriptProperty$LWS as setOriginalScriptScriptProperty, setResolvedScriptURL$LWS as setResolvedScriptURL, throwIfMarkedAsUnsafeInChildWindow$LWS as throwIfMarkedAsUnsafeInChildWindow, trackScriptAsEvaluated$LWS as trackScriptAsEvaluated, transformSourceText$LWS as transformSourceText };
/*! version: 0.23.6 */
