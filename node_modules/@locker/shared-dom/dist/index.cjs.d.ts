/// <reference types="node" />
import { Getter, Setter } from "@locker/shared";
import { SandboxRecord as SandboxRecordBase } from "@locker/shared";
declare const AbortControllerCtor: {
    new (): AbortController;
    prototype: AbortController;
};
declare const AbortControllerProto: AbortController;
declare const AbortControllerProtoAbort: {
    (reason?: any): void;
    (reason?: any): void;
};
declare const AbortControllerProtoSignalGetter: import("@locker/shared").Getter;
declare const AttrProtoNameGetter: import("@locker/shared").Getter;
declare const AttrProtoNamespaceURIGetter: import("@locker/shared").Getter;
declare const AttrProtoOwnerElementGetter: import("@locker/shared").Getter;
declare const AttrProtoValueGetter: import("@locker/shared").Getter, AttrProtoValueSetter: import("@locker/shared").Setter;
declare function normalizeNamespacedAttributeName(attrName: string): string;
// This is necessary for the non-standard `Event.prototype.path` getter
// distortion, which only exists in Chrome.
declare global {
    interface Element {
        getInnerHTML(options?: any): string;
        setHTML(value: string, options?: any): void;
        setHTMLUnsafe(value: string): void;
    }
    interface Event {
        path: EventTarget[];
    }
    interface ShadowRoot {
        setHTMLUnsafe(value: string): void;
    }
    interface Window {
        CookieStore?: CookieStore;
    }
}
interface AttributeNameToResolvedURLRegistry {
    [key: string]: string;
}
interface CookieStore extends EventTarget {
    prototype: {
        delete: Function;
        get: Function;
        getAll: Function;
        set: Function;
    };
}
type GlobalObject = Window & typeof globalThis;
type SandboxEvaluator = (sourceText: string, context?: any, globalObject?: GlobalObject, document?: Document) => any;
interface SandboxRecord extends SandboxRecordBase {
    document: Document;
    globalObject: GlobalObject;
    sandboxEvaluator: SandboxEvaluator;
}
type ScriptElement = HTMLScriptElement | SVGScriptElement;
type ScriptEvaluatorPropertyCallback = (context: any, globalObject: GlobalObject, document: Document) => void;
/* eslint-disable no-underscore-dangle */
declare class Validator {
    _document: Document;
    _constructors: any;
    _templates: {
        left: HTMLTemplateElement;
        right: HTMLTemplateElement;
    };
    isAllowedSharedElementChild: (element: Element | HTMLElement | Node | string) => boolean;
    isEqualDomString: (leftString: string, rightString: string) => boolean;
    // There is no reason to ever allow any HTML or XML that contains all three of these substrings.
    // eslint-disable-next-line class-methods-use-this
    isInherentlyUnsecure: (input: string) => boolean;
    isSharedElement: (element: Element | HTMLElement | Node) => boolean;
    constructor(document: Document, { HTMLLinkElement, HTMLScriptElement, HTMLStyleElement }: GlobalObject);
}
declare const rootValidator: Validator;
declare function getValidator(document: Document, globalObject: GlobalObject): any;
declare const BlobCtor: {
    new (blobParts?: BlobPart[] | undefined, options?: BlobPropertyBag | undefined): Blob;
    prototype: Blob;
};
declare const BlobProtoSlice: (start?: number | undefined, end?: number | undefined, contentType?: string | undefined) => Blob;
declare const BlobProtoSizeGetter: import("@locker/shared").Getter;
declare const BlobProtoTypeGetter: import("@locker/shared").Getter;
declare const CUSTOM_ELEMENT_REGISTRY_ATTRIBUTE_NAME = "lskey";
// Used by '@locker/near-membrane-dom'.
declare const IS_CHROMIUM_BROWSER: boolean;
// Used by '@locker/near-membrane-dom'.
declare const IS_OLD_CHROMIUM_BROWSER: boolean;
declare const IS_WEBKIT_BROWSER: boolean;
declare const rootDocument: Document;
// Used by '@locker/near-membrane/dom'.
declare const DocumentProtoClose: () => void, DocumentProtoOpen: {
    (unused1?: string | undefined, unused2?: string | undefined): Document;
    (url: string | URL, name: string, features: string): Window | null;
};
declare const DocumentProtoCreateComment: (data: string) => Comment, DocumentProtoCreateDocumentFragment: () => DocumentFragment, DocumentProtoCreateElement: {
    <K extends keyof HTMLElementTagNameMap>(tagName: K, options?: ElementCreationOptions | undefined): HTMLElementTagNameMap[K];
    <K_1 extends keyof HTMLElementDeprecatedTagNameMap>(tagName: K_1, options?: ElementCreationOptions | undefined): HTMLElementDeprecatedTagNameMap[K_1];
    (tagName: string, options?: ElementCreationOptions | undefined): HTMLElement;
}, DocumentProtoCreateElementNS: {
    (namespaceURI: "http://www.w3.org/1999/xhtml", qualifiedName: string): HTMLElement;
    <K extends keyof SVGElementTagNameMap>(namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: K): SVGElementTagNameMap[K];
    (namespaceURI: "http://www.w3.org/2000/svg", qualifiedName: string): SVGElement;
    <K_1 extends keyof MathMLElementTagNameMap>(namespaceURI: "http://www.w3.org/1998/Math/MathML", qualifiedName: K_1): MathMLElementTagNameMap[K_1];
    (namespaceURI: "http://www.w3.org/1998/Math/MathML", qualifiedName: string): MathMLElement;
    (namespaceURI: string | null, qualifiedName: string, options?: ElementCreationOptions | undefined): Element;
    (namespace: string | null, qualifiedName: string, options?: string | ElementCreationOptions | undefined): Element;
}, DocumentProtoGetElementById: (elementId: string) => HTMLElement | null;
declare const DocumentProtoBodyGetter: import("@locker/shared").Getter;
declare const DocumentProtoCookieGetter: import("@locker/shared").Getter, DocumentProtoCookieSetter: import("@locker/shared").Setter;
declare const DocumentProtoDefaultViewGetter: import("@locker/shared").Getter;
declare const DocumentProtoDocumentElementGetter: import("@locker/shared").Getter;
declare const DocumentProtoHeadGetter: import("@locker/shared").Getter;
declare const DocumentProtoImplementationGetter: import("@locker/shared").Getter;
declare const DocumentFragmentProtoAppend: (...nodes: (string | Node)[]) => void, DocumentFragmentProtoGetElementById: (elementId: string) => HTMLElement | null;
// Used by '@locker/near-membrane-shared-dom'.
// The DOMException constructor was exposed in Edge 12 but wasn't invocable
// until Edge 79. As long as this is used for instanceof checks it should be fine.
// https://developer.mozilla.org/en-US/docs/Web/API/DOMException#browser_compatibility
declare const DOMExceptionCtor: {
    new (message?: string | undefined, name?: string | undefined): DOMException;
    prototype: DOMException;
    readonly INDEX_SIZE_ERR: 1;
    readonly DOMSTRING_SIZE_ERR: 2;
    readonly HIERARCHY_REQUEST_ERR: 3;
    readonly WRONG_DOCUMENT_ERR: 4;
    readonly INVALID_CHARACTER_ERR: 5;
    readonly NO_DATA_ALLOWED_ERR: 6;
    readonly NO_MODIFICATION_ALLOWED_ERR: 7;
    readonly NOT_FOUND_ERR: 8;
    readonly NOT_SUPPORTED_ERR: 9;
    readonly INUSE_ATTRIBUTE_ERR: 10;
    readonly INVALID_STATE_ERR: 11;
    readonly SYNTAX_ERR: 12;
    readonly INVALID_MODIFICATION_ERR: 13;
    readonly NAMESPACE_ERR: 14;
    readonly INVALID_ACCESS_ERR: 15;
    readonly VALIDATION_ERR: 16;
    readonly TYPE_MISMATCH_ERR: 17;
    readonly SECURITY_ERR: 18;
    readonly NETWORK_ERR: 19;
    readonly ABORT_ERR: 20;
    readonly URL_MISMATCH_ERR: 21;
    readonly QUOTA_EXCEEDED_ERR: 22;
    readonly TIMEOUT_ERR: 23;
    readonly INVALID_NODE_TYPE_ERR: 24;
    readonly DATA_CLONE_ERR: 25;
};
declare const DATA_CLONE_ERROR_CODE: 25;
declare const DOMExceptionProtoCodeGetter: import("@locker/shared").Getter;
declare const DOMImplementationProtoCreateDocument: (namespace: string | null, qualifiedName: string | null, doctype?: DocumentType | null | undefined) => XMLDocument;
declare const DOMTokenListProtoAdd: (...tokens: string[]) => void, DOMTokenListProtoContains: (token: string) => boolean, DOMTokenListProtoRemove: (...tokens: string[]) => void;
declare const DOMTokenListProtoLengthGetter: import("@locker/shared").Getter;
declare const DOMTokenListProtoValueGetter: import("@locker/shared").Getter;
declare const ElementAriaAttributesToPropertyName: Record<string, string>;
// Used by '@locker/near-membrane-dom'.
declare const ElementProtoRemove: () => void;
declare const ElementProtoClosest: {
    <K extends keyof HTMLElementTagNameMap>(selector: K): HTMLElementTagNameMap[K] | null;
    <K_1 extends keyof SVGElementTagNameMap>(selector: K_1): SVGElementTagNameMap[K_1] | null;
    <K_2 extends keyof MathMLElementTagNameMap>(selector: K_2): MathMLElementTagNameMap[K_2] | null;
    <E extends Element = Element>(selectors: string): E | null;
}, ElementProtoGetAttribute: (qualifiedName: string) => string | null, ElementProtoGetAttributeNode: (qualifiedName: string) => Attr | null, ElementProtoGetAttributeNodeNS: (namespace: string | null, localName: string) => Attr | null, ElementProtoHasAttribute: (qualifiedName: string) => boolean, ElementProtoQuerySelector: {
    <K extends keyof HTMLElementTagNameMap>(selectors: K): HTMLElementTagNameMap[K] | null;
    <K_1 extends keyof SVGElementTagNameMap>(selectors: K_1): SVGElementTagNameMap[K_1] | null;
    <K_2 extends keyof MathMLElementTagNameMap>(selectors: K_2): MathMLElementTagNameMap[K_2] | null;
    <K_3 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_3): HTMLElementDeprecatedTagNameMap[K_3] | null;
    <E extends Element = Element>(selectors: string): E | null;
}, ElementProtoQuerySelectorAll: {
    <K extends keyof HTMLElementTagNameMap>(selectors: K): NodeListOf<HTMLElementTagNameMap[K]>;
    <K_1 extends keyof SVGElementTagNameMap>(selectors: K_1): NodeListOf<SVGElementTagNameMap[K_1]>;
    <K_2 extends keyof MathMLElementTagNameMap>(selectors: K_2): NodeListOf<MathMLElementTagNameMap[K_2]>;
    <K_3 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_3): NodeListOf<HTMLElementDeprecatedTagNameMap[K_3]>;
    <E extends Element = Element>(selectors: string): NodeListOf<E>;
}, ElementProtoRemoveAttribute: (qualifiedName: string) => void, ElementProtoRemoveAttributeNode: (attr: Attr) => Attr, ElementProtoRemoveAttributeNS: (namespace: string | null, localName: string) => void, ElementProtoSetAttribute: (qualifiedName: string, value: string) => void, ElementProtoSetAttributeNS: (namespace: string | null, qualifiedName: string, value: string) => void, ElementProtoToggleAttribute: (qualifiedName: string, force?: boolean | undefined) => boolean;
declare const ElementProtoInnerHTMLGetter: import("@locker/shared").Getter, ElementProtoInnerHTMLSetter: import("@locker/shared").Setter;
declare const ElementProtoNamespaceURIGetter: import("@locker/shared").Getter;
declare const ElementProtoOuterHTMLGetter: import("@locker/shared").Getter;
declare const ElementProtoTagNameGetter: import("@locker/shared").Getter;
declare const EventCtor: {
    new (type: string, eventInitDict?: EventInit | undefined): Event;
    prototype: Event;
    readonly NONE: 0;
    readonly CAPTURING_PHASE: 1;
    readonly AT_TARGET: 2;
    readonly BUBBLING_PHASE: 3;
};
declare const ErrorEventCtor: {
    new (type: string, eventInitDict?: ErrorEventInit | undefined): ErrorEvent;
    prototype: ErrorEvent;
};
declare const EventProtoStopPropagation: () => void;
declare const EventProtoCurrentTargetGetter: import("@locker/shared").Getter;
declare const EventTargetProtoAddEventListener: (type: string, callback: EventListenerOrEventListenerObject | null, options?: boolean | AddEventListenerOptions | undefined) => void, EventTargetProtoDispatchEvent: (event: Event) => boolean, EventTargetProtoRemoveEventListener: (type: string, callback: EventListenerOrEventListenerObject | null, options?: boolean | EventListenerOptions | undefined) => void;
declare const HTMLAnchorElementProtoHostnameGetter: import("@locker/shared").Getter;
declare const HTMLAnchorElementProtoHrefGetter: any, HTMLAnchorElementProtoHrefSetter: any;
declare const HTMLAnchorElementProtoPathnameGetter: import("@locker/shared").Getter;
declare const HTMLAnchorElementProtoProtocolGetter: import("@locker/shared").Getter;
declare const HTMLElementProto: HTMLElement;
declare const HTMLElementProtoInnerTextGetter: import("@locker/shared").Getter;
// Used by '@locker/near-membrane-dom'.
declare const HTMLElementProtoStyleGetter: import("@locker/shared").Getter;
declare const HTMLElementGlobalAttributesToPropertyName: Record<string, string>;
// Used by '@locker/near-membrane-dom'.
declare const HTMLIFrameElementProtoContentWindowGetter: import("@locker/shared").Getter;
declare const HTMLIFrameElementProtoSandboxGetter: import("@locker/shared").Getter;
declare const HTMLIFrameElementProtoSandboxSetter: import("@locker/shared").Setter;
declare const HTMLIFrameElementProtoSrcGetter: import("@locker/shared").Getter;
declare const HTMLIFrameElementProtoSrcSetter: import("@locker/shared").Setter;
declare const HTMLScriptElementCtor: {
    new (): HTMLScriptElement;
    prototype: HTMLScriptElement;
    supports(type: string): boolean;
};
declare const HTMLScriptElementProto: HTMLScriptElement;
declare const HTMLScriptElementProtoSrcGetter: import("@locker/shared").Getter, HTMLScriptElementProtoSrcSetter: import("@locker/shared").Setter;
declare const HTMLTemplateElementProtoContentGetter: import("@locker/shared").Getter;
declare const NAMESPACE_DEFAULT = "default";
declare const NAMESPACE_SVG = "http://www.w3.org/2000/svg";
declare const NAMESPACE_XHTML = "http://www.w3.org/1999/xhtml";
declare const NAMESPACE_XLINK = "http://www.w3.org/1999/xlink";
declare const NodeProtoAppendChild: <T extends Node>(node: T) => T, NodeProtoCloneNode: (deep?: boolean | undefined) => Node, NodeProtoIsEqualNode: (otherNode: Node | null) => boolean;
declare const NodeProtoChildNodesGetter: import("@locker/shared").Getter;
declare const NodeProtoFirstChildGetter: import("@locker/shared").Getter;
declare const NodeProtoIsConnectedGetter: import("@locker/shared").Getter;
// Used by '@locker/near-membrane-dom'.
declare const NodeProtoLastChildGetter: import("@locker/shared").Getter;
declare const NodeProtoNodeNameGetter: import("@locker/shared").Getter;
declare const NodeProtoOwnerDocumentGetter: import("@locker/shared").Getter;
declare const NodeProtoParentNodeGetter: import("@locker/shared").Getter;
declare const NodeProtoTextContentGetter: import("@locker/shared").Getter, NodeProtoTextContentSetter: import("@locker/shared").Setter;
declare const RangeProtoCreateContextualFragment: (fragment: string) => DocumentFragment;
declare const RequestProtoURLGetter: import("@locker/shared").Getter;
declare const ResponseCtor: {
    new (body?: BodyInit | null | undefined, init?: ResponseInit | undefined): Response;
    prototype: Response;
    error(): Response;
    json(data: any, init?: ResponseInit | undefined): Response;
    redirect(url: string | URL, status?: number | undefined): Response;
};
declare const ResponseProtoOkGetter: import("@locker/shared").Getter;
declare const ResponseProtoStatus: import("@locker/shared").Getter;
declare const ResponseProtoStatusText: import("@locker/shared").Getter;
declare const ResponseProtoText: () => Promise<string>;
declare const SCRIPT_HOOK_SOURCE_TEXT = "document.currentScript.$evaluator$";
declare function defineScriptAccessorProperty(script: ScriptElement, propKey: PropertyKey, getter: Getter, setter: Setter): void;
declare function defineScriptEvaluatorProperty(script: ScriptElement, callback: ScriptEvaluatorPropertyCallback): void;
declare function deleteOriginalScriptProperty(script: ScriptElement): void;
declare function deleteResolvedScriptURL(script: ScriptElement): void;
declare function deleteScriptEvaluatorProperty(script: ScriptElement): void;
declare function getOriginalScriptProperty(script: ScriptElement): string | undefined;
declare function getResolvedScriptURL(script: ScriptElement, attributeName: string): string | undefined;
// istanbul ignore next: cannot be tested in jest environment
declare function getScriptSrcEvaluatorHookURL(): string;
declare function isScriptEvaluated(script: ScriptElement): boolean;
declare function isScriptPropertyEvaluatorHookDefined(script: ScriptElement): boolean;
declare function isScriptURLEvaluatorHookDefined(script: ScriptElement): boolean;
declare function setOriginalScriptScriptProperty(script: ScriptElement, scriptProperty: string): WeakMap<ScriptElement, string>;
declare function setResolvedScriptURL(script: ScriptElement, attributeName: string, resolvedURL: string): void;
declare function trackScriptAsEvaluated(script: ScriptElement): void;
// eslint-disable-next-line no-shadow
declare const enum TokenType {
    ASSIGN = 0,
    EOF = 1,
    LOCATION = 2,
    MEMBER_OBJECT = 3,
    MEMBER_PROPERTY = 4,
    ROW = 5,
    // rest of the world
    TOP = 6
}
declare class Token {
    index: number;
    type: TokenType;
    value: string;
    constructor(tt: TokenType, index: number, value?: string);
}
declare class Tokenizer {
    private currIndex;
    private source;
    constructor();
    getNextToken(currIndex: number, source: string): Token;
    getPreviousToken(currIndex: number, source: string): Token;
    private currentCharCode;
    private isInvalidIdentifierCode;
    private isWhitespace;
    private lookAhead;
    private nextCharCode;
}
declare class Transpiler {
    memberExprPatt: RegExp;
    memberProperties: string[];
    tokenizer: Tokenizer;
    // memberProperties must be a safe array.
    constructor(memberProperties: string[]);
    compile(input: string): string;
    private beginsWithPeriod;
    private isAlphanumeric;
    private trimEndingChar;
    private replaceMemberObject;
}
// While fully qualified member expression access can be unambiguously detected,
// ie. window.location or window.top, bare-word references to location and top
// cannot. This means that code containing the fully qualified member expressions
// can have all occurrences replaced by transforms and given special names controlled
// by LWS in Aura. This process will also result in the program knowing that it
// applied a given transform, which it can then use to populate a context names
// list to be used in the declaration assignment code injected into wrapped Aura
// component code. Because the unqualified member expressions cannot be unambiguously
// detected, there is no way for the program to know that, eg. location.search was
// used in the Aura component code and subsequently transformed, which means it
// cannot be relied upon to when populating a context names list to be used in
// the declaration assignment code. As a result, location and top must be universally
// and explicitly included in the context object, and universally and explicitly
// included in the context names list.
declare const UNIVERSAL_CONTEXT_NAMES: string[];
declare function compileSourceText(sourceText: string): string;
declare function generateContextAssignmentCodeFromContextNames(names: string[]): string;
declare function transformSourceText(sourceText: string): string;
declare const StorageProtoKey: (index: number) => string | null, StorageProtoGetItem: (key: string) => string | null, StorageProtoRemoveItem: (key: string) => void, StorageProtoSetItem: (key: string, value: string) => void;
declare const SVGScriptElementProtoHrefGetter: import("@locker/shared").Getter, SVGScriptElementProtoHrefSetter: import("@locker/shared").Setter;
declare const URLCtor: {
    new (url: string | URL, base?: string | URL | undefined): URL;
    prototype: URL;
    canParse(url: string | URL, base?: string | undefined): boolean;
    createObjectURL(obj: Blob | MediaSource): string;
    revokeObjectURL(url: string): void;
};
declare const URLProtoOriginGetter: import("@locker/shared").Getter;
declare const URLCreateObjectURL: (obj: Blob | MediaSource) => string, URLRevokeObjectURL: (url: string) => void;
declare const rootWindow: Window & typeof globalThis;
declare const WindowClearInterval: ((id: number | undefined) => void) & typeof clearInterval, WindowDecodeURIComponent: typeof decodeURIComponent, WindowEncodeURIComponent: typeof encodeURIComponent, WindowFetch: ((input: URL | RequestInfo, init?: RequestInit | undefined) => Promise<Response>) & typeof fetch, rootWindowLocation: Location, WindowSetInterval: ((handler: TimerHandler, timeout?: number | undefined, ...arguments: any[]) => number) & typeof setInterval, rootWindowTop: Window | null;
declare const WindowQueueMicrotask: ((callback: VoidFunction) => void) & typeof queueMicrotask;
declare const WindowDocumentGetter: import("@locker/shared").Getter;
declare const WindowFrameElementGetter: import("@locker/shared").Getter;
declare const WindowLengthGetter: import("@locker/shared").Getter;
declare const WindowLocationGetter: import("@locker/shared").Getter;
declare function initWindowOpenChildWindow<T extends GlobalObject>(win: T, url: string | undefined): T;
type ChildWindow = Window & typeof globalThis & GlobalObject;
// This is only used by window.open() and document.open(x, y, z) distortions to
// block access to unsafe properties of the child window that's returned by those
// APIs. These properties must be otherwise available directly on the sandbox window,
// or via iframe.contentWindow created within the sandbox.
// To be effective, we mark the blocked thing with a symbol, so that can be detected by
// the distortion, otherwise the distortion will replace whatever we define here with
// whatever it provides.
declare const CHILD_WINDOW_BLOCKED_PROPERTY_SYMBOL: symbol;
declare function markForUnsafePropertyBlocking(childWindow: ChildWindow): ChildWindow;
declare function throwIfMarkedAsUnsafeInChildWindow(virtualEnvironmentEvaluator: Function, name: string): void;
declare function isWindow(value: any): boolean;
declare function normalizeWindowOpenArguments(args: Parameters<typeof window.open>): [
    url?: string | undefined,
    target?: string | undefined,
    features?: string | undefined
];
// This has to be done 1-by-1 because putting a full file ignore in this file
// will result in dist/index.mjs.js containing the directive and subsequently being
// ignored.
// istanbul ignore next
declare const XhrCtor: {
    new (): XMLHttpRequest;
    prototype: XMLHttpRequest;
    readonly UNSENT: 0;
    readonly OPENED: 1;
    readonly HEADERS_RECEIVED: 2;
    readonly LOADING: 3;
    readonly DONE: 4;
};
declare const XhrProtoAbort: () => void, XhrProtoOpen: {
    (method: string, url: string | URL): void;
    (method: string, url: string | URL, async: boolean, username?: string | null | undefined, password?: string | null | undefined): void;
}, XhrProtoSend: (body?: Document | XMLHttpRequestBodyInit | null | undefined) => void;
declare const XhrProtoResponseTextGetter: import("@locker/shared").Getter;
declare const XhrProtoStatusGetter: import("@locker/shared").Getter;
declare const XhrProtoWithCredentialsSetter: import("@locker/shared").Setter;
export { AbortControllerCtor, AbortControllerProto, AbortControllerProtoAbort, AbortControllerProtoSignalGetter, AttrProtoNameGetter, AttrProtoNamespaceURIGetter, AttrProtoOwnerElementGetter, AttrProtoValueGetter, AttrProtoValueSetter, normalizeNamespacedAttributeName, rootValidator, getValidator, BlobCtor, BlobProtoSlice, BlobProtoSizeGetter, BlobProtoTypeGetter, CUSTOM_ELEMENT_REGISTRY_ATTRIBUTE_NAME, IS_CHROMIUM_BROWSER, IS_OLD_CHROMIUM_BROWSER, IS_WEBKIT_BROWSER, rootDocument, DocumentProtoClose, DocumentProtoOpen, DocumentProtoCreateComment, DocumentProtoCreateDocumentFragment, DocumentProtoCreateElement, DocumentProtoCreateElementNS, DocumentProtoGetElementById, DocumentProtoBodyGetter, DocumentProtoCookieGetter, DocumentProtoCookieSetter, DocumentProtoDefaultViewGetter, DocumentProtoDocumentElementGetter, DocumentProtoHeadGetter, DocumentProtoImplementationGetter, DocumentFragmentProtoAppend, DocumentFragmentProtoGetElementById, DOMExceptionCtor, DATA_CLONE_ERROR_CODE, DOMExceptionProtoCodeGetter, DOMImplementationProtoCreateDocument, DOMTokenListProtoAdd, DOMTokenListProtoContains, DOMTokenListProtoRemove, DOMTokenListProtoLengthGetter, DOMTokenListProtoValueGetter, ElementAriaAttributesToPropertyName, ElementProtoRemove, ElementProtoClosest, ElementProtoGetAttribute, ElementProtoGetAttributeNode, ElementProtoGetAttributeNodeNS, ElementProtoHasAttribute, ElementProtoQuerySelector, ElementProtoQuerySelectorAll, ElementProtoRemoveAttribute, ElementProtoRemoveAttributeNode, ElementProtoRemoveAttributeNS, ElementProtoSetAttribute, ElementProtoSetAttributeNS, ElementProtoToggleAttribute, ElementProtoInnerHTMLGetter, ElementProtoInnerHTMLSetter, ElementProtoNamespaceURIGetter, ElementProtoOuterHTMLGetter, ElementProtoTagNameGetter, EventCtor, ErrorEventCtor, EventProtoStopPropagation, EventProtoCurrentTargetGetter, EventTargetProtoAddEventListener, EventTargetProtoDispatchEvent, EventTargetProtoRemoveEventListener, HTMLAnchorElementProtoHostnameGetter, HTMLAnchorElementProtoHrefGetter, HTMLAnchorElementProtoHrefSetter, HTMLAnchorElementProtoPathnameGetter, HTMLAnchorElementProtoProtocolGetter, HTMLElementProto, HTMLElementProtoInnerTextGetter, HTMLElementProtoStyleGetter, HTMLElementGlobalAttributesToPropertyName, HTMLIFrameElementProtoContentWindowGetter, HTMLIFrameElementProtoSandboxGetter, HTMLIFrameElementProtoSandboxSetter, HTMLIFrameElementProtoSrcGetter, HTMLIFrameElementProtoSrcSetter, HTMLScriptElementCtor, HTMLScriptElementProto, HTMLScriptElementProtoSrcGetter, HTMLScriptElementProtoSrcSetter, HTMLTemplateElementProtoContentGetter, NAMESPACE_DEFAULT, NAMESPACE_SVG, NAMESPACE_XHTML, NAMESPACE_XLINK, NodeProtoAppendChild, NodeProtoCloneNode, NodeProtoIsEqualNode, NodeProtoChildNodesGetter, NodeProtoFirstChildGetter, NodeProtoIsConnectedGetter, NodeProtoLastChildGetter, NodeProtoNodeNameGetter, NodeProtoOwnerDocumentGetter, NodeProtoParentNodeGetter, NodeProtoTextContentGetter, NodeProtoTextContentSetter, RangeProtoCreateContextualFragment, RequestProtoURLGetter, ResponseCtor, ResponseProtoOkGetter, ResponseProtoStatus, ResponseProtoStatusText, ResponseProtoText, SCRIPT_HOOK_SOURCE_TEXT, defineScriptAccessorProperty, defineScriptEvaluatorProperty, deleteOriginalScriptProperty, deleteResolvedScriptURL, deleteScriptEvaluatorProperty, getOriginalScriptProperty, getResolvedScriptURL, getScriptSrcEvaluatorHookURL, isScriptEvaluated, isScriptPropertyEvaluatorHookDefined, isScriptURLEvaluatorHookDefined, setOriginalScriptScriptProperty, setResolvedScriptURL, trackScriptAsEvaluated, Transpiler, UNIVERSAL_CONTEXT_NAMES, compileSourceText, generateContextAssignmentCodeFromContextNames, transformSourceText, StorageProtoKey, StorageProtoGetItem, StorageProtoRemoveItem, StorageProtoSetItem, SVGScriptElementProtoHrefGetter, SVGScriptElementProtoHrefSetter, AttributeNameToResolvedURLRegistry, CookieStore, GlobalObject, SandboxEvaluator, SandboxRecord, ScriptElement, ScriptEvaluatorPropertyCallback, URLCtor, URLProtoOriginGetter, URLCreateObjectURL, URLRevokeObjectURL, rootWindow, WindowClearInterval, WindowDecodeURIComponent, WindowEncodeURIComponent, WindowFetch, rootWindowLocation, WindowSetInterval, rootWindowTop, WindowQueueMicrotask, WindowDocumentGetter, WindowFrameElementGetter, WindowLengthGetter, WindowLocationGetter, initWindowOpenChildWindow, ChildWindow, CHILD_WINDOW_BLOCKED_PROPERTY_SYMBOL, markForUnsafePropertyBlocking, throwIfMarkedAsUnsafeInChildWindow, isWindow, normalizeWindowOpenArguments, XhrCtor, XhrProtoAbort, XhrProtoOpen, XhrProtoSend, XhrProtoResponseTextGetter, XhrProtoStatusGetter, XhrProtoWithCredentialsSetter };
//# sourceMappingURL=index.cjs.d.ts.map