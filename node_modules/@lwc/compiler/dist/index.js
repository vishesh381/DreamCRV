/**
 * Copyright (c) 2025 Salesforce, Inc.
 */
import * as path from 'path';
import { isUndefined, getAPIVersionFromNumber, DEFAULT_SSR_MODE, isBoolean, isAPIFeatureEnabled, isString } from '@lwc/shared';
import { invariant, CompilerValidationErrors, normalizeToCompilerError, TransformerErrors, DiagnosticLevel, CompilerError, generateCompilerError } from '@lwc/errors';
import { compileComponentForSSR, compileTemplateForSSR } from '@lwc/ssr-compiler';
import * as styleCompiler from '@lwc/style-compiler';
import { compile } from '@lwc/template-compiler';
import * as babel from '@babel/core';
import babelAsyncGeneratorFunctionsPlugin from '@babel/plugin-transform-async-generator-functions';
import babelAsyncToGenPlugin from '@babel/plugin-transform-async-to-generator';
import babelClassPropertiesPlugin from '@babel/plugin-transform-class-properties';
import babelObjectRestSpreadPlugin from '@babel/plugin-transform-object-rest-spread';
import lockerBabelPluginTransformUnforgeables from '@locker/babel-plugin-transform-unforgeables';
import lwcClassTransformPlugin from '@lwc/babel-plugin-component';

/*
 * Copyright (c) 2024, Salesforce, Inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/**
 * Flag indicating that a warning about still using the deprecated `enableLwcSpread`
 * compiler option has already been logged to the `console`.
 */
let alreadyWarnedAboutLwcSpread = false;
/**
 * Flag indicating that a warning about still using the deprecated `stylesheetConfig`
 * compiler option has already been logged to the `console`.
 */
let alreadyWarnedOnStylesheetConfig = false;
const DEFAULT_OPTIONS = {
    isExplicitImport: false,
    preserveHtmlComments: false,
    enableStaticContentOptimization: true,
    // TODO [#3370]: remove experimental template expression flag
    experimentalComplexExpressions: false,
    disableSyntheticShadowSupport: false,
    enableLightningWebSecurityTransforms: false,
    targetSSR: false,
    ssrMode: DEFAULT_SSR_MODE,
};
const DEFAULT_DYNAMIC_IMPORT_CONFIG = {
    loader: '',
    strictSpecifier: true,
};
const DEFAULT_STYLESHEET_CONFIG = {
    customProperties: {
        resolution: { type: 'native' },
    },
};
const DEFAULT_OUTPUT_CONFIG = {
    minify: false,
    sourcemap: false,
};
/**
 * Validates that the options conform to the expected shape and normalizes them to a standard format
 * @param options Input options
 * @returns Normalized options
 * @example
 * const normalizedOptions = validateTransformOptions({
 *   namespace: 'c',
 *   name: 'app',
 * })
 */
function validateTransformOptions(options) {
    validateOptions(options);
    return normalizeOptions(options);
}
function validateOptions(options) {
    invariant(!isUndefined(options), CompilerValidationErrors.MISSING_OPTIONS_OBJECT, [options]);
    if (!isUndefined(options.enableLwcSpread) && !alreadyWarnedAboutLwcSpread) {
        alreadyWarnedAboutLwcSpread = true;
        // eslint-disable-next-line no-console
        console.warn(`"enableLwcSpread" property is deprecated. The value doesn't impact the compilation and can safely be removed.`);
    }
    if (!isUndefined(options.stylesheetConfig) && !alreadyWarnedOnStylesheetConfig) {
        alreadyWarnedOnStylesheetConfig = true;
        // eslint-disable-next-line no-console
        console.warn(`"stylesheetConfig" property is deprecated. The value doesn't impact the compilation and can safely be removed.`);
    }
    if (!isUndefined(options.outputConfig)) {
        validateOutputConfig(options.outputConfig);
    }
}
function isUndefinedOrBoolean(property) {
    return isUndefined(property) || isBoolean(property);
}
function validateOutputConfig(config) {
    invariant(isUndefinedOrBoolean(config.sourcemap) || config.sourcemap === 'inline', CompilerValidationErrors.INVALID_SOURCEMAP_PROPERTY, [config.sourcemap]);
    if (!isUndefined(config.minify)) {
        // eslint-disable-next-line no-console
        console.warn(`"OutputConfig.minify" property is deprecated. The value doesn't impact the compilation and can safely be removed.`);
    }
}
function normalizeOptions(options) {
    const outputConfig = {
        ...DEFAULT_OUTPUT_CONFIG,
        ...options.outputConfig,
    };
    const stylesheetConfig = {
        customProperties: {
            ...DEFAULT_STYLESHEET_CONFIG.customProperties,
            ...(options.stylesheetConfig && options.stylesheetConfig.customProperties),
        },
    };
    const experimentalDynamicComponent = {
        ...DEFAULT_DYNAMIC_IMPORT_CONFIG,
        ...options.experimentalDynamicComponent,
    };
    const apiVersion = getAPIVersionFromNumber(options.apiVersion);
    return {
        ...DEFAULT_OPTIONS,
        ...options,
        stylesheetConfig,
        outputConfig,
        experimentalDynamicComponent,
        apiVersion,
    };
}

/*
 * Copyright (c) 2024, Salesforce, Inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/**
 * Transform the passed source code
 * @param src The source to be transformed. Can be the content of a JavaScript, HTML, or CSS file.
 * @param filename The source filename, with extension.
 * @param config The transformation options. The `name` and the `namespace` of the component is the
 * minimum required for transformation.
 * @returns An object with the generated code, source map and gathered metadata.
 * @throws Compilation errors
 */
function styleTransform(src, filename, config) {
    const { customProperties } = config.stylesheetConfig;
    const styleCompilerConfig = {
        customProperties: {
            resolverModule: customProperties.resolution.type === 'module'
                ? customProperties.resolution.name
                : undefined,
        },
        scoped: config.scopedStyles,
        disableSyntheticShadowSupport: config.disableSyntheticShadowSupport,
        apiVersion: config.apiVersion,
    };
    let res;
    try {
        res = styleCompiler.transform(src, filename, styleCompilerConfig);
    }
    catch (e) {
        throw normalizeToCompilerError(TransformerErrors.CSS_TRANSFORMER_ERROR, e, { filename });
    }
    // Rollup only cares about the mappings property on the map. Since producing a source map for
    // the styles doesn't make sense, the transform returns an empty mappings.
    return {
        code: res.code,
        map: { mappings: '' },
    };
}

/*
 * Copyright (c) 2024, Salesforce, Inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/**
 * Transforms a HTML template into module exporting a template function.
 * The transform also add a style import for the default stylesheet associated with
 * the template regardless if there is an actual style or not.
 * @param src HTML source
 * @param filename Source filename, with extension.
 * @param options Transformation options
 * @returns Transformed code, source map, and metadata
 * @throws Compiler errors, when compilation fails.
 * @example
 */
function templateTransform(src, filename, options) {
    const { experimentalDynamicComponent, 
    // TODO [#3370]: remove experimental template expression flag
    experimentalComplexExpressions, preserveHtmlComments, enableStaticContentOptimization, customRendererConfig, enableDynamicComponents, experimentalDynamicDirective: deprecatedDynamicDirective, instrumentation, namespace, name, apiVersion, disableSyntheticShadowSupport, } = options;
    const experimentalDynamicDirective = deprecatedDynamicDirective ?? Boolean(experimentalDynamicComponent);
    let result;
    try {
        result = compile(src, filename, {
            name,
            namespace,
            experimentalDynamicDirective,
            // TODO [#3370]: remove experimental template expression flag
            experimentalComplexExpressions,
            preserveHtmlComments,
            enableStaticContentOptimization,
            customRendererConfig,
            enableDynamicComponents,
            instrumentation,
            apiVersion,
            disableSyntheticShadowSupport,
        });
    }
    catch (e) {
        throw normalizeToCompilerError(TransformerErrors.HTML_TRANSFORMER_ERROR, e, { filename });
    }
    const fatalError = result.warnings.find((warning) => warning.level === DiagnosticLevel.Error);
    if (fatalError) {
        throw CompilerError.from(fatalError, { filename });
    }
    // The "Error" diagnostic level makes no sense to include here, because it would already have been
    // thrown above. As for "Log" and "Fatal", they are currently unused.
    const warnings = result.warnings.filter((_) => _.level === DiagnosticLevel.Warning);
    // Rollup only cares about the mappings property on the map. Since producing a source map for
    // the template doesn't make sense, the transform returns an empty mappings.
    return {
        code: result.code,
        map: { mappings: '' },
        warnings,
        cssScopeTokens: result.cssScopeTokens,
    };
}

/*
 * Copyright (c) 2024, Salesforce, Inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/**
 * Transforms a JavaScript file.
 * @param code The source code to transform
 * @param filename The source filename, with extension.
 * @param options Transformation options.
 * @returns Compiled code
 * @throws Compilation errors
 * @example
 */
function scriptTransform(code, filename, options) {
    const { isExplicitImport, 
    // TODO [#5031]: Unify dynamicImports and experimentalDynamicComponent options
    experimentalDynamicComponent: dynamicImports, outputConfig: { sourcemap }, enableLightningWebSecurityTransforms, namespace, name, instrumentation, apiVersion, } = options;
    const lwcBabelPluginOptions = {
        isExplicitImport,
        dynamicImports,
        namespace,
        name,
        instrumentation,
        apiVersion,
    };
    const plugins = [
        [lwcClassTransformPlugin, lwcBabelPluginOptions],
        [babelClassPropertiesPlugin, { loose: true }],
    ];
    if (!isAPIFeatureEnabled(3 /* APIFeature.DISABLE_OBJECT_REST_SPREAD_TRANSFORMATION */, apiVersion)) {
        plugins.push(babelObjectRestSpreadPlugin);
    }
    if (enableLightningWebSecurityTransforms) {
        plugins.push(lockerBabelPluginTransformUnforgeables, babelAsyncToGenPlugin, babelAsyncGeneratorFunctionsPlugin);
    }
    let result;
    try {
        result = babel.transformSync(code, {
            filename,
            sourceMaps: sourcemap,
            // Prevent Babel from loading local configuration.
            babelrc: false,
            configFile: false,
            // Force Babel to generate new line and white spaces. This prevent Babel from generating
            // an error when the generated code is over 500KB.
            compact: false,
            plugins,
        });
    }
    catch (e) {
        let transformerError = TransformerErrors.JS_TRANSFORMER_ERROR;
        // Sniff for a Babel decorator error, so we can provide a more helpful error message.
        if (e.code === 'BABEL_TRANSFORM_ERROR' &&
            e.message?.includes('Decorators are not enabled.') &&
            /\b(track|api|wire)\b/.test(e.message) // sniff for @track/@api/@wire
        ) {
            transformerError = TransformerErrors.JS_TRANSFORMER_DECORATOR_ERROR;
        }
        throw normalizeToCompilerError(transformerError, e, { filename });
    }
    return {
        code: result.code,
        map: result.map,
    };
}

/*
 * Copyright (c) 2024, Salesforce, Inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/**
 * Transform the passed source code.
 * @param src The source to be transformed. Can be the content of a JavaScript, HTML, or CSS file.
 * @param filename The source filename, with extension.
 * @param options The transformation options. The `name` and the `namespace` of the component is the
 * minimum required for transformation.
 * @returns A promise resolving to an object with the generated code, source map and gathered metadata.
 * @example
 * const source = `
 *     import { LightningElement } from 'lwc';
 *     export default class App extends LightningElement {}
 * `;
 * const filename = 'app.js';
 * const options = {
 *     namespace: 'c',
 *     name: 'app',
 * };
 * const { code } = await transform(source, filename, options);
 * @deprecated Use {@linkcode transformSync} instead
 */
function transform(src, filename, options) {
    validateArguments(src, filename);
    return new Promise((resolve, reject) => {
        try {
            const res = transformSync(src, filename, options);
            resolve(res);
        }
        catch (error) {
            reject(error);
        }
    });
}
/**
 * Transform the passed source code
 * @param src The source to be transformed. Can be the content of a JavaScript, HTML, or CSS file.
 * @param filename The source filename, with extension.
 * @param options The transformation options. The `name` and the `namespace` of the component is the
 * minimum required for transformation.
 * @returns An object with the generated code, source map and gathered metadata.
 * @example
 *
 * const source = `
 *     import { LightningElement } from 'lwc';
 *     export default class App extends LightningElement {}
 * `;
 * const filename = 'app.js';
 * const options = {
 *     namespace: 'c',
 *     name: 'app',
 * };
 * const { code } = transformSync(source, filename, options);
 */
function transformSync(src, filename, options) {
    validateArguments(src, filename);
    const normalizedOptions = validateTransformOptions(options);
    return transformFile(src, filename, normalizedOptions);
}
function validateArguments(src, filename) {
    invariant(isString(src), TransformerErrors.INVALID_SOURCE, [src]);
    invariant(isString(filename), TransformerErrors.INVALID_ID, [filename]);
}
function transformFile(src, filename, options) {
    switch (path.extname(filename)) {
        case '.html':
            if (options.targetSSR) {
                return compileTemplateForSSR(src, filename, options, options.ssrMode);
            }
            return templateTransform(src, filename, options);
        case '.css':
            return styleTransform(src, filename, options);
        case '.tsx':
        case '.jsx':
        case '.ts':
        case '.js':
        case '.mts':
        case '.mjs':
            if (options.targetSSR) {
                return compileComponentForSSR(src, filename, options, options.ssrMode);
            }
            return scriptTransform(src, filename, options);
        default:
            throw generateCompilerError(TransformerErrors.NO_AVAILABLE_TRANSFORMER, {
                messageArgs: [filename],
                origin: { filename },
            });
    }
}

/*
 * Copyright (c) 2024, Salesforce, Inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/** The version of LWC being used. */
const version = "8.13.1";

export { transform, transformSync, version };
/** version: 8.13.1 */
//# sourceMappingURL=index.js.map
