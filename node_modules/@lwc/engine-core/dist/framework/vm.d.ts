import type { VNodes, VCustomElement, VNode, VBaseElement, VStaticPartElement } from './vnodes';
import type { ReactiveObserver } from './mutation-tracker';
import type { LightningElement, LightningElementConstructor, LightningElementShadowRoot } from './base-lightning-element';
import type { ComponentDef } from './def';
import type { Template } from './template';
import type { HostNode, HostElement, RendererAPI } from './renderer';
import type { Stylesheets, APIVersion } from '@lwc/shared';
type ShadowRootMode = 'open' | 'closed';
export interface TemplateCache {
    [key: string]: any;
}
export interface SlotSet {
    slotAssignments: {
        [key: string]: VNodes;
    };
    owner?: VM;
}
export declare const enum VMState {
    created = 0,
    connected = 1,
    disconnected = 2
}
export declare const enum RenderMode {
    Light = 0,
    Shadow = 1
}
export declare const enum ShadowMode {
    Native = 0,
    Synthetic = 1
}
export type ShadowSupportMode = 'any' | 'reset' | 'native';
export interface Context {
    /** The string used for synthetic shadow DOM and light DOM style scoping. */
    stylesheetToken: string | undefined;
    /** True if a stylesheetToken was added to the host class */
    hasTokenInClass: boolean | undefined;
    /** True if a stylesheetToken was added to the host attributes */
    hasTokenInAttribute: boolean | undefined;
    /** The legacy string used for synthetic shadow DOM and light DOM style scoping. */
    legacyStylesheetToken: string | undefined;
    /** True if a legacyStylesheetToken was added to the host class */
    hasLegacyTokenInClass: boolean | undefined;
    /** True if a legacyStylesheetToken was added to the host attributes */
    hasLegacyTokenInAttribute: boolean | undefined;
    /** Whether or not light DOM scoped styles are present in the stylesheets. */
    hasScopedStyles: boolean | undefined;
    /** The VNodes injected in all the shadow trees to apply the associated component stylesheets. */
    styleVNodes: VNode[] | null;
    /**
     * Object used by the template function to store information that can be reused between
     * different render cycle of the same template.
     */
    tplCache: TemplateCache;
    /** List of wire hooks that are invoked when the component gets connected. */
    wiredConnecting: Array<() => void>;
    /** List of wire hooks that are invoked when the component gets disconnected. */
    wiredDisconnecting: Array<() => void>;
}
export type RefVNodes = {
    [name: string]: VBaseElement | VStaticPartElement;
};
export interface VM<N = HostNode, E = HostElement> {
    /** The host element */
    readonly elm: HostElement;
    /** The host element tag name */
    readonly tagName: string;
    /** The component definition */
    readonly def: ComponentDef;
    /** The component context object. */
    readonly context: Context;
    /** The owner VM or null for root elements. */
    readonly owner: VM<N, E> | null;
    /** References to elements rendered using lwc:ref (template refs) */
    refVNodes: RefVNodes | null;
    /** Whether or not the VM was hydrated */
    readonly hydrated: boolean;
    /** Rendering operations associated with the VM */
    renderMode: RenderMode;
    shadowMode: ShadowMode;
    /** True if shadow migrate mode is in effect, i.e. this is native with synthetic-like modifications */
    shadowMigrateMode: boolean;
    /** The component creation index. */
    idx: number;
    /** Component state, analogous to Element.isConnected */
    /** The component connection state. */
    state: VMState;
    /** The list of VNodes associated with the shadow tree. */
    children: VNodes;
    /** The list of adopted children VNodes. */
    aChildren: VNodes;
    /**
     * The list of custom elements VNodes currently rendered in the shadow tree. We keep track of
     * those elements to efficiently unmount them when the parent component is disconnected without
     * having to traverse the VNode tree.
     */
    velements: VCustomElement[];
    /** The component public properties. */
    cmpProps: {
        [name: string]: any;
    };
    /**
     * Contains information about the mapping between the slot names and the slotted VNodes, and
     * the owner of the slot content.
     */
    cmpSlots: SlotSet;
    /** The component internal reactive properties. */
    cmpFields: {
        [name: string]: any;
    };
    /** Flag indicating if the component has been scheduled for rerendering. */
    isScheduled: boolean;
    /** Flag indicating if the component internal should be scheduled for re-rendering. */
    isDirty: boolean;
    /** The shadow DOM mode. */
    mode: ShadowRootMode;
    /** The template method returning the VDOM tree. */
    cmpTemplate: Template | null;
    /** The component instance. */
    component: LightningElement;
    /** The custom element shadow root. */
    shadowRoot: LightningElementShadowRoot | null;
    /**
     * The component render root. If the component is a shadow DOM component, it is its shadow
     * root. If the component is a light DOM component it the element itself.
     */
    renderRoot: LightningElementShadowRoot | HostElement;
    /** The template reactive observer. */
    tro: ReactiveObserver;
    /**
     * Hook invoked whenever a property is accessed on the host element. This hook is used by
     * Locker only.
     */
    setHook: (cmp: LightningElement, prop: PropertyKey, newValue: any) => void;
    /**
     * Hook invoked whenever a property is set on the host element. This hook is used by Locker
     * only.
     */
    getHook: (cmp: LightningElement, prop: PropertyKey) => any;
    /**
     * Hook invoked whenever a method is called on the component (life-cycle hooks, public
     * properties and event handlers). This hook is used by Locker.
     */
    callHook: (cmp: LightningElement | undefined, fn: (...args: any[]) => any, args?: any[]) => any;
    /**
     * Renderer API
     */
    renderer: RendererAPI;
    /**
     * Debug info bag. Stores useful debug information about the component.
     */
    debugInfo?: Record<string, any>;
    /**
     * Any stylesheets associated with the component
     */
    stylesheets: Stylesheets | null;
    /**
     * API version associated with this VM
     */
    apiVersion: APIVersion;
}
type VMAssociable = HostNode | LightningElement;
export declare function rerenderVM(vm: VM): void;
export declare function connectRootElement(elm: any): void;
export declare function disconnectRootElement(elm: any): void;
export declare function appendVM(vm: VM): void;
export declare function removeVM(vm: VM): void;
export declare function createVM<HostNode, HostElement>(elm: HostElement, ctor: LightningElementConstructor, renderer: RendererAPI, options: {
    mode: ShadowRootMode;
    owner: VM<HostNode, HostElement> | null;
    tagName: string;
    hydrated?: boolean;
}): VM;
export declare function computeShadowAndRenderMode(Ctor: LightningElementConstructor, renderer: RendererAPI): {
    renderMode: RenderMode;
    shadowMode: ShadowMode;
};
export declare function associateVM(obj: VMAssociable, vm: VM): void;
export declare function getAssociatedVM(obj: VMAssociable): VM;
export declare function getAssociatedVMIfPresent(obj: VMAssociable): VM | undefined;
export declare function runRenderedCallback(vm: VM): void;
export declare function runConnectedCallback(vm: VM): void;
export declare function resetComponentRoot(vm: VM): void;
export declare function scheduleRehydration(vm: VM): void;
export declare function runWithBoundaryProtection(vm: VM, owner: VM | null, pre: () => void, job: () => void, post: () => void): void;
export declare function forceRehydration(vm: VM): void;
export declare function runFormAssociatedCustomElementCallback(vm: VM, faceCb: () => void, args?: any[]): void;
export declare function runFormAssociatedCallback(elm: HTMLElement, form: HTMLFormElement | null): void;
export declare function runFormDisabledCallback(elm: HTMLElement, disabled: boolean): void;
export declare function runFormResetCallback(elm: HTMLElement): void;
export type FormRestoreState = File | string | Array<[string, FormDataEntryValue]>;
export type FormRestoreReason = 'restore' | 'autocomplete';
export declare function runFormStateRestoreCallback(elm: HTMLElement, state: FormRestoreState | null, reason: FormRestoreReason): void;
export declare function resetRefVNodes(vm: VM): void;
export {};
//# sourceMappingURL=vm.d.ts.map