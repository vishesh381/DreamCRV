import type { LightningElement } from '../base-lightning-element';
import type { ConfigValue, ContextValue, ReplaceReactiveValues, WireAdapterConstructor } from '../wiring';
/**
 * The decorator returned by `@wire()`; not the `wire` function.
 *
 * For TypeScript users:
 * - If you are seeing an unclear error message, ensure that both the type of the decorated prop and
 * the config used match the types expected by the wire adapter.
 * - String literal types in the config are resolved to the corresponding prop on the component.
 * For example, a component with `id = 555` and `@wire(getBook, {id: "$id"} as const) book` will
 * have `"$id"` resolve to type `number`.
 */
interface WireDecorator<Value, Class> {
    (target: unknown, context: ClassFieldDecoratorContext<Class, Value | undefined> | ClassMethodDecoratorContext<Class, Value extends (value: any) => any ? Value : (this: Class, value: Value) => void> | ClassGetterDecoratorContext<Class, Value | undefined> | ClassSetterDecoratorContext<Class, Value>): void;
}
/**
 * Decorator factory to wire a property or method to a wire adapter data source.
 * @param adapter the adapter used to provision data
 * @param config configuration object for the adapter
 * @returns A decorator function
 * @example
 * export default class WireExample extends LightningElement {
 *   \@api bookId;
 *   \@wire(getBook, { id: '$bookId'}) book;
 * }
 */
export default function wire<ReactiveConfig extends ConfigValue = ConfigValue, Value = any, Context extends ContextValue = ContextValue, Class = LightningElement>(adapter: WireAdapterConstructor<ReplaceReactiveValues<ReactiveConfig, Class>, Value, Context> | {
    adapter: WireAdapterConstructor<ReplaceReactiveValues<ReactiveConfig, Class>, Value, Context>;
}, config?: ReactiveConfig): WireDecorator<Value, Class>;
export declare function internalWireFieldDecorator(key: string): PropertyDescriptor;
export {};
//# sourceMappingURL=wire.d.ts.map