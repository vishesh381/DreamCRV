import type { WireAdapterConstructor, ConfigCallback } from '../wiring';
import type { LightningElementConstructor } from '../base-lightning-element';
type WireCompilerMeta = Record<string, WireCompilerDef>;
type TrackCompilerMeta = Record<string, 1>;
type MethodCompilerMeta = string[];
type PropCompilerMeta = Record<string, PropCompilerDef>;
export declare const enum PropType {
    Field = 0,
    Set = 1,
    Get = 2,
    GetSet = 3
}
interface PropCompilerDef {
    config: PropType;
    type: string;
}
interface WireCompilerDef {
    method?: number;
    adapter: WireAdapterConstructor;
    config: ConfigCallback;
    dynamic?: string[];
}
interface RegisterDecoratorMeta {
    readonly publicMethods?: MethodCompilerMeta;
    readonly publicProps?: PropCompilerMeta;
    readonly track?: TrackCompilerMeta;
    readonly wire?: WireCompilerMeta;
    readonly fields?: string[];
}
/**
 * INTERNAL: This function can only be invoked by compiled code. The compiler
 * will prevent this function from being imported by user-land code.
 * @param Ctor
 * @param meta
 */
export declare function registerDecorators(Ctor: LightningElementConstructor, meta: RegisterDecoratorMeta): LightningElementConstructor;
interface DecoratorMeta {
    readonly apiMethods: PropertyDescriptorMap;
    readonly apiFields: PropertyDescriptorMap;
    readonly apiFieldsConfig: Record<string, PropType>;
    readonly wiredMethods: PropertyDescriptorMap;
    readonly wiredFields: PropertyDescriptorMap;
    readonly observedFields: PropertyDescriptorMap;
}
export declare function getDecoratorsMeta(Ctor: LightningElementConstructor): DecoratorMeta;
export {};
//# sourceMappingURL=register.d.ts.map