import type { VNodes } from './vnodes';
import type { SlotSet, TemplateCache, VM } from './vm';
import type { RenderAPI } from './api';
import type { Stylesheets } from '@lwc/shared';
export interface Template {
    (api: RenderAPI, cmp: object, slotSet: SlotSet, cache: TemplateCache): VNodes;
    /** The list of slot names used in the template. */
    slots?: string[];
    /** The stylesheet associated with the template. */
    stylesheets?: Stylesheets;
    /** The string used for synthetic shadow style scoping and light DOM style scoping. */
    stylesheetToken?: string;
    /** Same as the above, but for legacy use cases (pre-LWC v3.0.0) */
    legacyStylesheetToken?: string;
    /** Render mode for the template. Could be light or undefined (which means it's shadow) */
    renderMode?: 'light';
    /** True if this template contains template refs, undefined or false otherwise */
    hasRefs?: boolean;
}
export declare let isUpdatingTemplate: boolean;
export declare function getVMBeingRendered(): VM | null;
export declare function setVMBeingRendered(vm: VM | null): void;
export declare const parseFragment: (strings: string[], ...keys: (string | number)[]) => () => Element;
export declare const parseSVGFragment: (strings: string[], ...keys: (string | number)[]) => () => Element;
export declare function evaluateTemplate(vm: VM, html: Template): VNodes;
export declare function computeHasScopedStyles(template: Template, vm: VM | undefined): boolean;
export declare function hasStyles(stylesheets: Stylesheets | undefined | null): stylesheets is Stylesheets;
//# sourceMappingURL=template.d.ts.map