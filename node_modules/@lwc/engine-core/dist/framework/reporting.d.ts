import type { RenderMode, ShadowMode, ShadowSupportMode } from './vm';
export declare const enum ReportingEventId {
    CrossRootAriaInSyntheticShadow = "CrossRootAriaInSyntheticShadow",
    CompilerRuntimeVersionMismatch = "CompilerRuntimeVersionMismatch",
    NonStandardAriaReflection = "NonStandardAriaReflection",
    TemplateMutation = "TemplateMutation",
    StylesheetMutation = "StylesheetMutation",
    ConnectedCallbackWhileDisconnected = "ConnectedCallbackWhileDisconnected",
    ShadowModeUsage = "ShadowModeUsage",
    ShadowSupportModeUsage = "ShadowSupportModeUsage",
    RenderModeMismatch = "RenderModeMismatch"
}
export interface BasePayload {
    tagName?: string;
}
export interface CrossRootAriaInSyntheticShadowPayload extends BasePayload {
    attributeName: string;
}
export interface CompilerRuntimeVersionMismatchPayload extends BasePayload {
    compilerVersion: string;
    runtimeVersion: string;
}
export interface NonStandardAriaReflectionPayload extends BasePayload {
    propertyName: string;
    isSetter: boolean;
    setValueType: string | undefined;
}
export interface TemplateMutationPayload extends BasePayload {
    propertyName: string;
}
export interface StylesheetMutationPayload extends BasePayload {
    propertyName: string;
}
export interface ConnectedCallbackWhileDisconnectedPayload extends BasePayload {
}
export interface RenderModeMismatchPayload extends BasePayload {
    mode: RenderMode;
}
export interface ShadowModeUsagePayload extends BasePayload {
    mode: ShadowMode;
}
export interface ShadowSupportModeUsagePayload extends BasePayload {
    mode: ShadowSupportMode;
}
export type ReportingPayloadMapping = {
    [ReportingEventId.CrossRootAriaInSyntheticShadow]: CrossRootAriaInSyntheticShadowPayload;
    [ReportingEventId.CompilerRuntimeVersionMismatch]: CompilerRuntimeVersionMismatchPayload;
    [ReportingEventId.NonStandardAriaReflection]: NonStandardAriaReflectionPayload;
    [ReportingEventId.TemplateMutation]: TemplateMutationPayload;
    [ReportingEventId.StylesheetMutation]: StylesheetMutationPayload;
    [ReportingEventId.ConnectedCallbackWhileDisconnected]: ConnectedCallbackWhileDisconnectedPayload;
    [ReportingEventId.ShadowModeUsage]: ShadowModeUsagePayload;
    [ReportingEventId.ShadowSupportModeUsage]: ShadowSupportModeUsagePayload;
    [ReportingEventId.RenderModeMismatch]: RenderModeMismatchPayload;
};
export type ReportingDispatcher<T extends ReportingEventId = ReportingEventId> = (reportingEventId: T, payload: ReportingPayloadMapping[T]) => void;
/** Callbacks to invoke when reporting is enabled */
type OnReportingEnabledCallback = () => void;
export declare const reportingControl: {
    /**
     * Attach a new reporting control (aka dispatcher).
     * @param dispatcher reporting control
     */
    attachDispatcher(dispatcher: ReportingDispatcher): void;
    /**
     * Detach the current reporting control (aka dispatcher).
     */
    detachDispatcher(): void;
};
/**
 * Call a callback when reporting is enabled, or immediately if reporting is already enabled.
 * Will only ever be called once.
 * @param callback
 */
export declare function onReportingEnabled(callback: OnReportingEnabledCallback): void;
/**
 * Report to the current dispatcher, if there is one.
 * @param reportingEventId
 * @param payload data to report
 */
export declare function report<T extends ReportingEventId>(reportingEventId: T, payload: ReportingPayloadMapping[T]): void;
/**
 * Return true if reporting is enabled
 */
export declare function isReportingEnabled(): boolean;
export {};
//# sourceMappingURL=reporting.d.ts.map