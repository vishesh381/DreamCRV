import type { LightningElement } from '../base-lightning-element';
import type { HostElement } from '../renderer';
export type DataCallback<T = any> = (value: T) => void;
export type ConfigValue = Record<string, any>;
export type WireAdapterSchemaValue = 'optional' | 'required';
export type ContextValue = Record<string, any>;
export interface WireAdapter<Config extends ConfigValue = ConfigValue, Context extends ContextValue = ContextValue> {
    update(config: Config, context?: Context): void;
    connect(): void;
    disconnect(): void;
}
export interface WireAdapterConstructor<Config extends ConfigValue = ConfigValue, Value = any, Context extends ContextValue = ContextValue> {
    new (callback: DataCallback<Value>, sourceContext?: {
        tagName: string;
    }): WireAdapter<Config, Context>;
    configSchema?: Record<keyof Config, WireAdapterSchemaValue>;
    contextSchema?: Record<keyof Context, WireAdapterSchemaValue>;
}
export interface WireDef {
    method?: (data: any) => void;
    adapter: WireAdapterConstructor;
    dynamic: string[];
    configCallback: ConfigCallback;
}
export interface WireMethodDef extends WireDef {
    method: (data: any) => void;
}
export interface WireFieldDef extends WireDef {
    method?: undefined;
}
export type ConfigCallback = (component: LightningElement) => ConfigValue;
export interface WireDebugInfo {
    data?: any;
    config?: ConfigValue;
    context?: ContextValue;
    wasDataProvisionedForConfig: boolean;
}
export type WireContextSubscriptionCallback = (subscriptionPayload: WireContextSubscriptionPayload) => void;
export interface WireContextSubscriptionPayload {
    setNewContext(newContext: ContextValue): void;
    setDisconnectedCallback(disconnectCallback: () => void): void;
}
export interface ContextConsumer {
    provide(newContext: ContextValue): void;
}
export interface ContextProviderOptions {
    consumerConnectedCallback: (consumer: ContextConsumer) => void;
    consumerDisconnectedCallback?: (consumer: ContextConsumer) => void;
}
export type ContextProvider = (elmOrComponent: EventTarget, options: ContextProviderOptions) => void;
export type RegisterContextProviderFn = (element: HostElement, adapterContextToken: string, onContextSubscription: WireContextSubscriptionCallback) => void;
/** Resolves a property chain to the corresponding value on the target type. */
type ResolveReactiveValue<
/** The object to search for properties; initially the component. */
Target, 
/** A string representing a chain of of property keys, e.g. "data.user.name". */
Keys extends string> = Keys extends `${infer FirstKey}.${infer Rest}` ? FirstKey extends keyof Target ? ResolveReactiveValue<Target[FirstKey], Rest> : undefined : Keys extends keyof Target ? Target[Keys] : undefined;
/**
 * Detects if the `Value` type is a property chain starting with "$". If so, it resolves the
 * properties to the corresponding value on the target type.
 */
type ResolveValueIfReactive<Value, Target> = Value extends string ? string extends Value ? any : Value extends `$${infer Keys}` ? ResolveReactiveValue<Target, Keys> : Value : Value;
export type ReplaceReactiveValues<Config extends ConfigValue, Component> = {
    [K in keyof Config]: ResolveValueIfReactive<Config[K], Component>;
};
export {};
//# sourceMappingURL=types.d.ts.map