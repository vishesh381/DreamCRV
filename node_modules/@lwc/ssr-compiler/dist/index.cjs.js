/**
 * Copyright (c) 2025 Salesforce, Inc.
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var shared = require('@lwc/shared');
var astring = require('astring');
var estreeToolkit = require('estree-toolkit');
var meriyah = require('meriyah');
var errors = require('@lwc/errors');
var immer = require('immer');
var node_path = require('node:path');
var acorn = require('acorn');
var templateCompiler = require('@lwc/template-compiler');
var builders = require('estree-toolkit/dist/builders');
var types = require('@babel/types');
var util = require('util');

/*
 * Copyright (c) 2024, Salesforce, Inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const EMIT_IDENT = estreeToolkit.builders.identifier('$$emit');
// Rollup may rename variables to prevent shadowing. When it does, it uses the format `foo$0`, `foo$1`, etc.
const TMPL_FN_PATTERN = /tmpl($\d+)?/;
const GEN_MARKUP_OR_GEN_SLOTTED_CONTENT_PATTERN = /(?:generateMarkup|generateSlottedContent)($\d+)?/;
const isWithinFn = (pattern, nodePath) => {
    const { node } = nodePath;
    if (!node) {
        return false;
    }
    if ((node.type === 'FunctionDeclaration' || node.type === 'FunctionExpression') &&
        node.id &&
        pattern.test(node.id.name)) {
        return true;
    }
    if (nodePath.parentPath) {
        return isWithinFn(pattern, nodePath.parentPath);
    }
    return false;
};
const visitors$2 = {
    // @ts-expect-error types for `traverse` do not support sharing a visitor between node types:
    // https://github.com/sarsamurmu/estree-toolkit/issues/20
    'FunctionDeclaration|FunctionExpression'(path, state) {
        const { node } = path;
        if (!node?.async || !node?.generator) {
            return;
        }
        // Component authors might conceivably use async generator functions in their own code. Therefore,
        // when traversing & transforming written+generated code, we need to disambiguate generated async
        // generator functions from those that were written by the component author.
        if (!isWithinFn(GEN_MARKUP_OR_GEN_SLOTTED_CONTENT_PATTERN, path) &&
            !isWithinFn(TMPL_FN_PATTERN, path)) {
            return;
        }
        node.generator = false;
        node.async = state.mode === 'async';
        node.params.unshift(EMIT_IDENT);
    },
    YieldExpression(path, state) {
        const { node } = path;
        if (!node) {
            return;
        }
        // Component authors might conceivably use generator functions within their own code. Therefore,
        // when traversing & transforming written+generated code, we need to disambiguate generated yield
        // expressions from those that were written by the component author.
        if (!isWithinFn(TMPL_FN_PATTERN, path) &&
            !isWithinFn(GEN_MARKUP_OR_GEN_SLOTTED_CONTENT_PATTERN, path)) {
            return;
        }
        if (node.delegate) {
            // transform `yield* foo(arg)` into `foo($$emit, arg)` or `await foo($$emit, arg)`
            if (node.argument?.type !== 'CallExpression') {
                throw new Error('Implementation error: cannot transmogrify complex yield-from expressions');
            }
            const callExpr = node.argument;
            callExpr.arguments.unshift(EMIT_IDENT);
            path.replaceWith(state.mode === 'sync' ? callExpr : estreeToolkit.builders.awaitExpression(callExpr));
        }
        else {
            // transform `yield foo` into `$$emit(foo)`
            const emittedExpression = node.argument;
            if (!emittedExpression) {
                throw new Error('Implementation error: cannot transform a yield expression that yields nothing');
            }
            path.replaceWith(estreeToolkit.builders.callExpression(EMIT_IDENT, [emittedExpression]));
        }
    },
    ImportSpecifier(path, _state) {
        // @lwc/ssr-runtime has a couple of helper functions that need to conform to either the generator or
        // no-generator compilation mode/paradigm. Since these are simple helper functions, we can maintain
        // two implementations of each helper method:
        //
        // - renderAttrs vs renderAttrsNoYield
        // - fallbackTmpl vs fallbackTmplNoYield
        //
        // If this becomes too burdensome to maintain, we can officially deprecate the generator-based approach
        // and switch the @lwc/ssr-runtime implementation wholesale over to the no-generator paradigm.
        const { node } = path;
        if (!node || node.imported.type !== 'Identifier') {
            throw new Error('Implementation error: unexpected missing identifier in import specifier');
        }
        if (path.parent?.type !== 'ImportDeclaration' ||
            path.parent.source.value !== '@lwc/ssr-runtime') {
            return;
        }
        if (node.imported.name === 'fallbackTmpl') {
            node.imported.name = 'fallbackTmplNoYield';
        }
        else if (node.imported.name === 'renderAttrs') {
            node.imported.name = 'renderAttrsNoYield';
        }
    },
};
/**
 * Transforms async-generator code into either the async or synchronous alternatives that are
 * ~semantically equivalent. For example, this template:
 *
 *   <template>
 *       <div>foobar</div>
 *       <x-child></x-child>
 *   </template>
 *
 * Is compiled into the following JavaScript, intended for execution during SSR & stripped down
 * for the purposes of this example:
 *
 *   async function* tmpl(props, attrs, slottedContent, Cmp, instance) {
 *       yield '<div>foobar</div>';
 *       const childProps = {};
 *       const childAttrs = {};
 *       yield* generateChildMarkup("x-child", childProps, childAttrs, childSlottedContentGenerator);
 *   }
 *
 * When transmogrified in async-mode, the above generated template function becomes the following:
 *
 *   async function tmpl($$emit, props, attrs, slottedContent, Cmp, instance) {
 *       $$emit('<div>foobar</div>');
 *       const childProps = {};
 *       const childAttrs = {};
 *       await generateChildMarkup($$emit, "x-child", childProps, childAttrs, childSlottedContentGenerator);
 *   }
 *
 * When transmogrified in sync-mode, the template function becomes the following:
 *
 *   function tmpl($$emit, props, attrs, slottedContent, Cmp, instance) {
 *       $$emit('<div>foobar</div>');
 *       const childProps = {};
 *       const childAttrs = {};
 *       generateChildMarkup($$emit, "x-child", childProps, childAttrs, childSlottedContentGenerator);
 *   }
 *
 * There are tradeoffs for each of these modes. Notably, the async-yield variety is the easiest to transform
 * into either of the other varieties and, for that reason, is the variety that is "authored" by the SSR compiler.
 */
function transmogrify(compiledComponentAst, mode = 'sync') {
    const state = {
        mode,
    };
    return immer.produce(compiledComponentAst, (astDraft) => estreeToolkit.traverse(astDraft, visitors$2, state));
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */


function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/**
 * Creates an import statement, e.g. `import { foo, bar as $bar$ } from "pkg"`
 * @param imports names to be imported; values can be a string (plain import) or object (aliased)
 * @param source source location to import from; defaults to @lwc/ssr-runtime
 */
const bImportDeclaration = (imports, source = '@lwc/ssr-runtime') => {
    let parsed;
    if (typeof imports === 'string') {
        parsed = [[imports, undefined]];
    }
    else if (Array.isArray(imports)) {
        parsed = imports.map((imp) => [imp, undefined]);
    }
    else {
        parsed = Object.entries(imports);
    }
    const specifiers = parsed.map(([imported, local]) => {
        if (imported === 'default') {
            return estreeToolkit.builders.importDefaultSpecifier(estreeToolkit.builders.identifier(local));
        }
        else if (imported === '*') {
            return estreeToolkit.builders.importNamespaceSpecifier(estreeToolkit.builders.identifier(local));
        }
        else if (local) {
            return estreeToolkit.builders.importSpecifier(estreeToolkit.builders.identifier(imported), estreeToolkit.builders.identifier(local));
        }
        else {
            return estreeToolkit.builders.importSpecifier(estreeToolkit.builders.identifier(imported));
        }
    });
    return estreeToolkit.builders.importDeclaration(specifiers, estreeToolkit.builders.literal(source));
};

/*
 * Copyright (c) 2024, Salesforce, Inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
var _ImportManager_map;
class ImportManager {
    constructor() {
        _ImportManager_map.set(this, new Map());
    }
    /** Add an import to a collection of imports, probably for adding to the AST later. */
    add(imports, source = '@lwc/ssr-runtime') {
        let specifiers;
        if (typeof imports === 'string') {
            specifiers = [[imports, undefined]];
        }
        else if (Array.isArray(imports)) {
            specifiers = imports.map((name) => [name, undefined]);
        }
        else {
            specifiers = Object.entries(imports);
        }
        let specifierMap = __classPrivateFieldGet(this, _ImportManager_map, "f").get(source);
        if (specifierMap) {
            for (const [imported, local] of specifiers) {
                specifierMap.set(imported, local);
            }
        }
        else {
            specifierMap = new Map(specifiers);
            __classPrivateFieldGet(this, _ImportManager_map, "f").set(source, specifierMap);
        }
    }
    /** Get the collection of imports for adding to the AST, probably soon! */
    getImportDeclarations() {
        return Array.from(__classPrivateFieldGet(this, _ImportManager_map, "f"), ([source, specifierMap]) => {
            return bImportDeclaration(Object.fromEntries(specifierMap), source);
        });
    }
}
_ImportManager_map = new WeakMap();

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/**
 * This accomplishes two things:
 *
 *  1. it replaces "lwc" with "@lwc/ssr-runtime" in an import specifier
 *  2. it makes note of the local var name associated with the `LightningElement` import
 */
function replaceLwcImport(path, state) {
    if (!path.node || !isLwcSource(path)) {
        return;
    }
    for (const specifier of path.node.specifiers) {
        if (specifier.type === 'ImportSpecifier' &&
            specifier.imported.type === 'Identifier' &&
            specifier.imported.name === 'LightningElement') {
            state.lightningElementIdentifier = specifier.local.name;
            break;
        }
    }
    path.replaceWith(estreeToolkit.builders.importDeclaration(structuredClone(path.node.specifiers), estreeToolkit.builders.literal('@lwc/ssr-runtime')));
}
/**
 * This handles lwc barrel exports by replacing "lwc" with "@lwc/ssr-runtime"
 */
function replaceNamedLwcExport(path) {
    if (!path.node || !isLwcSource(path)) {
        return;
    }
    path.replaceWith(estreeToolkit.builders.exportNamedDeclaration(structuredClone(path.node.declaration), structuredClone(path.node.specifiers), estreeToolkit.builders.literal('@lwc/ssr-runtime')));
}
/**
 * This handles all lwc barrel exports by replacing "lwc" with "@lwc/ssr-runtime"
 */
function replaceAllLwcExport(path) {
    if (!path.node || !isLwcSource(path)) {
        return;
    }
    path.replaceWith(estreeToolkit.builders.exportAllDeclaration(estreeToolkit.builders.literal('@lwc/ssr-runtime'), structuredClone(path.node.exported)));
}
/**
 * Utility to determine if a node source is 'lwc'
 */
function isLwcSource(path) {
    return path.node?.source?.value === 'lwc';
}

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/**
 * While traversing the component JS, this takes note of any .html files that are
 * explicitly imported.
 */
function catalogTmplImport(path, state) {
    if (!path.node) {
        return;
    }
    const { specifiers, source } = path.node;
    const specifier = specifiers[0];
    if (typeof source.value !== 'string' ||
        !source.value.endsWith('.html') ||
        specifiers.length !== 1 ||
        specifier.type !== 'ImportDefaultSpecifier') {
        return;
    }
    state.tmplExplicitImports = state.tmplExplicitImports ?? new Map();
    state.tmplExplicitImports.set(specifier.local.name, source.value);
}

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function catalogAndReplaceStyleImports(path, state) {
    const specifier = path.node.specifiers[0];
    if (typeof path.node.source.value !== 'string' ||
        !path.node.source.value.endsWith('.css') ||
        path.node.specifiers.length !== 1 ||
        specifier.type !== 'ImportDefaultSpecifier') {
        return;
    }
    // Any file ending in `*.scoped.css` which is directly imported into a Component `*.js` file (and assumed
    // to be used for `static stylesheets`) is assumed to be scoped, so needs to be marked as such with a query param.
    // Outside of SSR, this is done by `@lwc/babel-plugin-component`, so we need to emulate its behavior. The goal here
    // is for `@lwc/template-compiler` to know to add `stylesheet.$scoped$ = true` to its compiled output, which it
    // detects using the query param.
    if (path.node?.source.value.endsWith('.scoped.css')) {
        path.replaceWith(estreeToolkit.builders.importDeclaration(path.node.specifiers, estreeToolkit.builders.literal(path.node.source.value + '?scoped=true')));
    }
    state.cssExplicitImports = state.cssExplicitImports ?? new Map();
    state.cssExplicitImports.set(specifier.local.name, path.node.source.value);
}
/**
 * This adds implicit style imports to the compiled component artifact.
 */
function getStylesheetImports(filepath) {
    const moduleName = /(?<moduleName>[^/]+)\.html$/.exec(filepath)?.groups?.moduleName;
    if (!moduleName) {
        throw new Error(`Could not determine module name from file path: ${filepath}`);
    }
    return [
        [{ default: 'defaultStylesheets' }, `./${moduleName}.css`],
        [{ default: 'defaultScopedStylesheets' }, `./${moduleName}.scoped.css?scoped=true`],
    ];
}
function catalogStaticStylesheets(ids, state) {
    state.staticStylesheetIds = state.staticStylesheetIds ?? new Set();
    for (const id of ids) {
        state.staticStylesheetIds.add(id);
    }
}

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/** Placeholder value to use to opt out of validation. */
const NO_VALIDATION = false;
const PLACEHOLDER_PREFIX = `__ESTEMPLATE_${Math.random().toString().slice(2)}_PLACEHOLDER__`;
const getReplacementNode = (state, placeholderId) => {
    const key = Number(placeholderId.slice(PLACEHOLDER_PREFIX.length));
    const nodeCount = state.replacementNodes.length;
    if (key >= nodeCount) {
        throw new Error(`Cannot use index ${key} when only ${nodeCount} values have been provided.`);
    }
    const validateReplacement = state.placeholderToValidator.get(key);
    const replacementNode = state.replacementNodes[key];
    if (validateReplacement &&
        !(Array.isArray(replacementNode)
            ? replacementNode.every(validateReplacement)
            : validateReplacement(replacementNode))) {
        const expectedType = validateReplacement.__debugName ||
            validateReplacement.name ||
            '(could not determine)';
        const actualType = Array.isArray(replacementNode)
            ? `[${replacementNode.map((n) => n && n.type).join(', ')}]`
            : replacementNode?.type;
        throw new Error(`Validation failed for templated node. Expected type ${expectedType}, but received ${actualType}.`);
    }
    return replacementNode;
};
const visitors$1 = {
    Identifier(path, state) {
        if (path.node?.name.startsWith(PLACEHOLDER_PREFIX)) {
            const replacementNode = getReplacementNode(state, path.node.name);
            if (replacementNode === null) {
                path.remove();
            }
            else if (Array.isArray(replacementNode)) {
                if (replacementNode.length === 0) {
                    path.remove();
                }
                else {
                    if (path.parentPath?.node?.type === 'ExpressionStatement') {
                        path.parentPath.replaceWithMultiple(replacementNode);
                    }
                    else {
                        path.replaceWithMultiple(replacementNode);
                    }
                }
            }
            else {
                path.replaceWith(replacementNode);
            }
        }
    },
    Literal(path, state) {
        if (typeof path.node?.value === 'string' &&
            path.node.value.startsWith(PLACEHOLDER_PREFIX)) {
            // A literal can only be replaced with a single node
            const replacementNode = getReplacementNode(state, path.node.value);
            path.replaceWith(replacementNode);
        }
    },
};
function esTemplateImpl(javascriptSegments, validators, wrap, unwrap) {
    let placeholderCount = 0;
    let parsableCode = javascriptSegments[0];
    const placeholderToValidator = new Map();
    for (let i = 1; i < javascriptSegments.length; i += 1) {
        const segment = javascriptSegments[i];
        const validator = validators[i - 1]; // always one less value than strings in template literals
        if (typeof validator === 'function' || validator === NO_VALIDATION) {
            // Template slot will be filled by a *new* argument passed to the generated function
            if (validator !== NO_VALIDATION) {
                placeholderToValidator.set(placeholderCount, validator);
            }
            parsableCode += `${PLACEHOLDER_PREFIX}${placeholderCount}`;
            placeholderCount += 1;
        }
        else {
            // Template slot uses a *previously defined* argument passed to the generated function
            if (validator >= placeholderCount) {
                throw new Error(`Reference to argument ${validator} at index ${i} cannot be used. Only ${placeholderCount - 1} arguments have been defined.`);
            }
            parsableCode += `${PLACEHOLDER_PREFIX}${validator}`;
        }
        parsableCode += segment;
    }
    if (wrap) {
        parsableCode = wrap(parsableCode);
    }
    const originalAstProgram = acorn.parse(parsableCode, {
        ecmaVersion: 2022,
        allowAwaitOutsideFunction: true,
        allowReturnOutsideFunction: true,
        allowSuperOutsideMethod: true,
        allowImportExportEverywhere: true,
        locations: false,
    });
    let originalAst;
    const finalCharacter = javascriptSegments.at(-1)?.trimEnd()?.at(-1);
    if (originalAstProgram.body.length === 1) {
        originalAst =
            finalCharacter === ';' && originalAstProgram.body[0].type === 'ExpressionStatement'
                ? (originalAst = originalAstProgram.body[0].expression)
                : (originalAst = originalAstProgram.body[0]);
    }
    else {
        originalAst = originalAstProgram.body;
    }
    // Turns Acorn AST objects into POJOs, for use with Immer.
    originalAst = JSON.parse(JSON.stringify(originalAst));
    return function templatedAst(...replacementNodes) {
        const result = immer.produce(originalAst, (astDraft) => estreeToolkit.traverse(astDraft, visitors$1, {
            placeholderToValidator,
            replacementNodes,
        }));
        return (unwrap ? unwrap(result) : result);
    };
}
/**
 * Template literal tag that generates a builder function. Like estree's `builders`, but for more
 * complex structures. The template values should be estree `is` validators or a back reference to
 * a previous slot (to re-use the referenced value).
 *
 * To have the generated function return a particular node type, the generic comes _after_ the
 * template literal. Kinda weird, but it's necessary to infer the types of the template values.
 * (If it were at the start, we'd need to explicitly provide _all_ type params. Tedious!)
 * @example
 * const bSum = esTemplate`(${is.identifier}, ${is.identifier}) => ${0} + ${1}`<EsArrowFunctionExpression>
 * const sumFuncNode = bSum(b.identifier('a'), b.identifier('b'))
 * // `sumFuncNode` is an AST node representing `(a, b) => a + b`
 */
function esTemplate(javascriptSegments, ...Validators) {
    return esTemplateImpl(javascriptSegments, Validators);
}
/** Similar to {@linkcode esTemplate}, but supports `yield` expressions. */
function esTemplateWithYield(javascriptSegments, ...validators) {
    const wrap = (code) => `function* placeholder() {${code}}`;
    const unwrap = (node) => node.body.body.length === 1 ? node.body.body[0] : node.body.body;
    return esTemplateImpl(javascriptSegments, validators, wrap, unwrap);
}

/*
 * Copyright (c) 2024, Salesforce, Inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function generateError(node, error, ...messageArgs) {
    return errors.generateCompilerError(error, {
        messageArgs,
        origin: node.loc
            ? {
                filename: node.loc.source || undefined,
                location: {
                    line: node.loc.start.line,
                    column: node.loc.start.column,
                    ...(node.range
                        ? { start: node.range[0], length: node.range[1] - node.range[0] }
                        : {}),
                },
            }
            : undefined,
    });
}

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function bMemberExpressionChain(props) {
    // Technically an incorrect assertion, but it works fine...
    let expr = estreeToolkit.builders.identifier('instance');
    for (const prop of props) {
        expr = estreeToolkit.builders.memberExpression(expr, estreeToolkit.builders.literal(prop), true);
    }
    return expr;
}
function getWireParams(node) {
    const { decorators } = node;
    if (decorators.length > 1) {
        throw generateError(node, errors.DecoratorErrors.ONE_WIRE_DECORATOR_ALLOWED);
    }
    // validate the parameters
    const wireDecorator = decorators[0].expression;
    if (!estreeToolkit.is.callExpression(wireDecorator)) {
        // TODO [#5032]: Harmonize errors thrown in `@lwc/ssr-compiler`
        throw new Error('todo - invalid usage');
    }
    const args = wireDecorator.arguments;
    if (args.length === 0 || args.length > 2) {
        // TODO [#5032]: Harmonize errors thrown in `@lwc/ssr-compiler`
        throw new Error('todo - wrong number of args');
    }
    const [id, config] = args;
    if (estreeToolkit.is.spreadElement(id) || estreeToolkit.is.spreadElement(config)) {
        // TODO [#5032]: Harmonize errors thrown in `@lwc/ssr-compiler`
        throw new Error('todo - spread in params');
    }
    return [id, config];
}
function validateWireId(id, path) {
    // name of identifier or object used in member expression (e.g. "foo" for `foo.bar`)
    let wireAdapterVar;
    if (estreeToolkit.is.memberExpression(id)) {
        if (id.computed) {
            // TODO [#5032]: Harmonize errors thrown in `@lwc/ssr-compiler`
            throw new Error('todo - FUNCTION_IDENTIFIER_CANNOT_HAVE_COMPUTED_PROPS');
        }
        if (!estreeToolkit.is.identifier(id.object)) {
            // TODO [#5032]: Harmonize errors thrown in `@lwc/ssr-compiler`
            throw new Error('todo - FUNCTION_IDENTIFIER_CANNOT_HAVE_NESTED_MEMBER_EXRESSIONS');
        }
        wireAdapterVar = id.object.name;
    }
    else if (!estreeToolkit.is.identifier(id)) {
        // TODO [#5032]: Harmonize errors thrown in `@lwc/ssr-compiler`
        throw new Error('todo - invalid adapter name');
    }
    else {
        wireAdapterVar = id.name;
    }
    // This is not the exact same validation done in @lwc/babel-plugin-component but it accomplishes the same thing
    if (path.scope?.getBinding(wireAdapterVar)?.kind !== 'module') {
        throw generateError(path.node, errors.DecoratorErrors.COMPUTED_PROPERTY_MUST_BE_CONSTANT_OR_LITERAL);
    }
}
function validateWireConfig(config, path) {
    if (!estreeToolkit.is.objectExpression(config)) {
        // TODO [#5032]: Harmonize errors thrown in `@lwc/ssr-compiler`
        throw new Error('todo - CONFIG_OBJECT_SHOULD_BE_SECOND_PARAMETER');
    }
    for (const property of config.properties) {
        // Only validate computed object properties because static props are all valid
        // and we ignore {...spreads} and {methods(){}}
        if (!estreeToolkit.is.property(property) || !property.computed)
            continue;
        const key = property.key;
        if (estreeToolkit.is.identifier(key)) {
            const binding = path.scope?.getBinding(key.name);
            // TODO [#3956]: Investigate allowing imported constants
            if (binding?.kind === 'const')
                continue;
            // By default, the identifier `undefined` has no binding (when it's actually undefined),
            // but has a binding if it's used as a variable (e.g. `let undefined = "don't do this"`)
            if (key.name === 'undefined' && !binding)
                continue;
        }
        else if (estreeToolkit.is.literal(key)) {
            if (estreeToolkit.is.templateLiteral(key)) {
                // A template literal is not guaranteed to always result in the same value
                // (e.g. `${Math.random()}`), so we disallow them entirely.
                // TODO [#5032]: Harmonize errors thrown in `@lwc/ssr-compiler`
                throw new Error('todo - COMPUTED_PROPERTY_CANNOT_BE_TEMPLATE_LITERAL');
            }
            else if (!('regex' in key)) {
                // A literal can be a regexp, template literal, or primitive; only allow primitives
                continue;
            }
        }
        else if (estreeToolkit.is.templateLiteral(key)) {
            throw generateError(path.node, errors.DecoratorErrors.COMPUTED_PROPERTY_CANNOT_BE_TEMPLATE_LITERAL);
        }
        throw generateError(path.node, errors.DecoratorErrors.COMPUTED_PROPERTY_MUST_BE_CONSTANT_OR_LITERAL);
    }
}
function catalogWireAdapters(path, state) {
    const node = path.node;
    const [id, config] = getWireParams(node);
    validateWireId(id, path);
    let reactiveConfig;
    if (config) {
        validateWireConfig(config, path);
        reactiveConfig = immer.produce(config, (draft) => {
            // replace '$foo' values with `instance.foo`; preserve everything else
            for (const prop of draft.properties) {
                const { value } = prop;
                if (estreeToolkit.is.literal(value) &&
                    typeof value.value === 'string' &&
                    value.value.startsWith('$')) {
                    prop.value = bMemberExpressionChain(value.value.slice(1).split('.'));
                }
            }
        });
    }
    else {
        // FIXME: for `@wire(Adapter), does engine-server use `undefined` or `{}` for config?
        reactiveConfig = estreeToolkit.builders.objectExpression([]); // empty object
    }
    state.wireAdapters = [
        ...state.wireAdapters,
        { adapterId: id, config: reactiveConfig, field: node },
    ];
}
const bSetWiredProp = (esTemplate `
    instance.${ /*wire-decorated property*/estreeToolkit.is.identifier} = newValue
`);
const bCallWiredMethod = (esTemplate `
    instance.${ /*wire-decorated method*/estreeToolkit.is.identifier}(newValue)
`);
const bWireAdapterPlumbing = (esTemplate `{
    const wireInstance = new ${ /*wire adapter constructor*/estreeToolkit.is.expression}((newValue) => {
        ${ /*update the decorated property or call the decorated method*/estreeToolkit.is.expressionStatement};
    });
    wireInstance.connect?.();
    if (wireInstance.update) {
        const getLiveConfig = () => {
            return ${ /* reactive wire config */estreeToolkit.is.objectExpression};
        };
        // This may look a bit weird, in that the 'update' function is called twice: once with
        // an 'undefined' value and possibly again with a context-provided value. While weird,
        // this preserves the behavior of the browser-side wire implementation as well as the
        // original SSR implementation.
        wireInstance.update(getLiveConfig(), undefined);
        __connectContext(${ /*wire adapter constructor*/0}, instance, (newContextValue) => {
            wireInstance.update(getLiveConfig(), newContextValue);
        });
    }
}`);
function bWireAdaptersPlumbing(adapters) {
    return adapters.map(({ adapterId, config, field }) => {
        const actionUponNewValue = estreeToolkit.is.methodDefinition(field) && field.kind === 'method'
            ? // Validation in compile-js/index.ts `visitors` ensures `key` is an identifier
                bCallWiredMethod(field.key)
            : bSetWiredProp(field.key);
        return bWireAdapterPlumbing(adapterId, actionUponNewValue, config);
    });
}

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const bGenerateMarkup = (esTemplate `
    // These variables may mix with component-authored variables, so should be reasonably unique
    const __lwcSuperPublicProperties__ = Array.from(Object.getPrototypeOf(${ /* Component class */estreeToolkit.is.identifier})?.__lwcPublicProperties__?.values?.() ?? []);
    const __lwcPublicProperties__ = new Set(${ /*public properties*/estreeToolkit.is.arrayExpression}.concat(__lwcSuperPublicProperties__));
    const __lwcPrivateProperties__ = new Set(${ /*private properties*/estreeToolkit.is.arrayExpression});

    ${ /* component class */0}[__SYMBOL__GENERATE_MARKUP] = async function* generateMarkup(
            tagName, 
            props, 
            attrs, 
            shadowSlottedContent,
            lightSlottedContent, 
            scopedSlottedContent,
            parent, 
            scopeToken,
            contextfulParent
    ) {
        tagName = tagName ?? ${ /*component tag name*/estreeToolkit.is.literal};
        attrs = attrs ?? Object.create(null);
        props = props ?? Object.create(null);
        const instance = new ${ /* Component class */0}({
            tagName: tagName.toUpperCase(),
        });

        __establishContextfulRelationship(contextfulParent, instance);
        ${ /*connect wire*/estreeToolkit.is.statement}

        instance[__SYMBOL__SET_INTERNALS](
            props,
            attrs,
            __lwcPublicProperties__,
            __lwcPrivateProperties__,
        );
        instance.isConnected = true;
        if (instance.connectedCallback) {
            __mutationTracker.enable(instance);
            instance.connectedCallback();
            __mutationTracker.disable(instance);
        }
        // If a render() function is defined on the class or any of its superclasses, then that takes priority.
        // Next, if the class or any of its superclasses has an implicitly-associated template, then that takes
        // second priority (e.g. a foo.html file alongside a foo.js file). Finally, there is a fallback empty template.
        const tmplFn = instance.render?.() ?? ${ /*component class*/0}[__SYMBOL__DEFAULT_TEMPLATE] ?? __fallbackTmpl;
        yield \`<\${tagName}\`;

        const hostHasScopedStylesheets =
            tmplFn.hasScopedStylesheets ||
            hasScopedStaticStylesheets(${ /*component class*/0});
        const hostScopeToken = hostHasScopedStylesheets ? tmplFn.stylesheetScopeToken + "-host" : undefined;

        yield* __renderAttrs(instance, attrs, hostScopeToken, scopeToken);
        yield '>';
        yield* tmplFn(
            shadowSlottedContent,
            lightSlottedContent,
            scopedSlottedContent,
            ${ /*component class*/0},
            instance
        );
        yield \`</\${tagName}>\`;
    }
    ${ /* component class */0}.__lwcPublicProperties__ = __lwcPublicProperties__;
`);
const bExposeTemplate = (esTemplate `
    if (${ /*template*/estreeToolkit.is.identifier}) {
        ${ /* component class */estreeToolkit.is.identifier}[__SYMBOL__DEFAULT_TEMPLATE] = ${ /*template*/0}
    }
`);
/**
 * This builds a generator function `generateMarkup` and adds it to the component JS's
 * compilation output. `generateMarkup` acts as the glue between component JS and its
 * template(s), including:
 *
 *  - managing reflection of attrs & props
 *  - instantiating the component instance
 *  - setting the internal state of that component instance
 *  - invoking component lifecycle methods
 *  - yielding the tag name & attributes
 *  - deferring to the template function for yielding child content
 */
function addGenerateMarkupFunction(program, state, tagName, filename) {
    const { privateProperties, publicProperties, tmplExplicitImports } = state;
    // The default tag name represents the component name that's passed to the transformer.
    // This is needed to generate markup for dynamic components which are invoked through
    // the generateMarkup function on the constructor.
    // At the time of generation, the invoker does not have reference to its tag name to pass as an argument.
    const defaultTagName = estreeToolkit.builders.literal(tagName);
    const classIdentifier = estreeToolkit.builders.identifier(state.lwcClassName);
    let exposeTemplateBlock = null;
    if (!tmplExplicitImports) {
        const defaultTmplPath = `./${node_path.parse(filename).name}.html`;
        const tmplVar = estreeToolkit.builders.identifier('tmpl');
        program.body.unshift(bImportDeclaration({ default: tmplVar.name }, defaultTmplPath));
        program.body.unshift(bImportDeclaration({ SYMBOL__DEFAULT_TEMPLATE: '__SYMBOL__DEFAULT_TEMPLATE' }));
        exposeTemplateBlock = bExposeTemplate(tmplVar, classIdentifier);
    }
    // If no wire adapters are detected on the component, we don't bother injecting the wire-related code.
    let connectWireAdapterCode = [];
    if (state.wireAdapters.length) {
        connectWireAdapterCode = bWireAdaptersPlumbing(state.wireAdapters);
        program.body.unshift(bImportDeclaration({ connectContext: '__connectContext' }));
    }
    program.body.unshift(bImportDeclaration({
        fallbackTmpl: '__fallbackTmpl',
        hasScopedStaticStylesheets: undefined,
        mutationTracker: '__mutationTracker',
        renderAttrs: '__renderAttrs',
        SYMBOL__GENERATE_MARKUP: '__SYMBOL__GENERATE_MARKUP',
        SYMBOL__SET_INTERNALS: '__SYMBOL__SET_INTERNALS',
        establishContextfulRelationship: '__establishContextfulRelationship',
    }));
    program.body.push(...bGenerateMarkup(classIdentifier, estreeToolkit.builders.arrayExpression(publicProperties.map(estreeToolkit.builders.literal)), estreeToolkit.builders.arrayExpression(privateProperties.map(estreeToolkit.builders.literal)), defaultTagName, connectWireAdapterCode));
    if (exposeTemplateBlock) {
        program.body.push(exposeTemplateBlock);
    }
}

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const decorators = new Set(['api', 'wire', 'track']);
function removeDecoratorImport(path) {
    if (!path.node || path.node.source.value !== '@lwc/ssr-runtime') {
        return;
    }
    const filteredSpecifiers = path.node.specifiers.filter((specifier) => !(specifier.type === 'ImportSpecifier' &&
        specifier.imported.type === 'Identifier' &&
        decorators.has(specifier.imported.name)));
    if (filteredSpecifiers.length !== path.node.specifiers.length) {
        path.replaceWith(estreeToolkit.builders.importDeclaration(filteredSpecifiers, estreeToolkit.builders.literal('@lwc/ssr-runtime')));
    }
}

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const visitors = {
    $: { scope: true },
    ExportNamedDeclaration(path) {
        replaceNamedLwcExport(path);
    },
    ExportAllDeclaration(path) {
        replaceAllLwcExport(path);
    },
    ImportDeclaration(path, state) {
        if (!path.node || !path.node.source.value || typeof path.node.source.value !== 'string') {
            return;
        }
        replaceLwcImport(path, state);
        catalogTmplImport(path, state);
        catalogAndReplaceStyleImports(path, state);
        removeDecoratorImport(path);
    },
    ImportExpression(path, state) {
        const { experimentalDynamicComponent, importManager } = state;
        if (!experimentalDynamicComponent) {
            // if no `experimentalDynamicComponent` config, then leave dynamic `import()`s as-is
            return;
        }
        if (experimentalDynamicComponent.strictSpecifier) {
            if (!estreeToolkit.is.literal(path.node?.source) || typeof path.node.source.value !== 'string') {
                // TODO [#5032]: Harmonize errors thrown in `@lwc/ssr-compiler`
                throw new Error('todo - LWCClassErrors.INVALID_DYNAMIC_IMPORT_SOURCE_STRICT');
            }
        }
        const loader = experimentalDynamicComponent.loader;
        if (!loader) {
            // if no `loader` defined, then leave dynamic `import()`s as-is
            return;
        }
        const source = path.node.source;
        // 1. insert `import { load as __load } from '${loader}'` at top of program
        importManager.add({ load: '__load' }, loader);
        // 2. replace this import with `__load(${source})`
        path.replaceWith(estreeToolkit.builders.callExpression(estreeToolkit.builders.identifier('__load'), [structuredClone(source)]));
    },
    ClassDeclaration(path, state) {
        const { node } = path;
        if (node?.superClass &&
            // export default class extends LightningElement {}
            (estreeToolkit.is.exportDefaultDeclaration(path.parentPath) ||
                // class Cmp extends LightningElement {}; export default Cmp
                path.scope
                    ?.getBinding(node.id.name)
                    ?.references.some((ref) => estreeToolkit.is.exportDefaultDeclaration(ref.parent)))) {
            // If it's a default-exported class with a superclass, then it's an LWC component!
            state.isLWC = true;
            if (node.id) {
                state.lwcClassName = node.id.name;
            }
            else {
                node.id = estreeToolkit.builders.identifier('DefaultComponentName');
                state.lwcClassName = 'DefaultComponentName';
            }
            // There's no builder for comment nodes :\
            const lwcVersionComment = {
                type: 'Block',
                value: shared.LWC_VERSION_COMMENT,
            };
            // Add LWC version comment to end of class body
            const { body } = node;
            if (body.trailingComments) {
                body.trailingComments.push(lwcVersionComment);
            }
            else {
                body.trailingComments = [lwcVersionComment];
            }
        }
    },
    PropertyDefinition(path, state) {
        const node = path.node;
        if (!node?.key) {
            // Seems to occur for `@wire() [symbol];` -- not sure why
            throw new Error('Unknown state: property definition has no key');
        }
        if (!estreeToolkit.is.identifier(node.key)) {
            return;
        }
        const { decorators } = node;
        validateUniqueDecorator(decorators);
        const decoratedExpression = decorators?.[0]?.expression;
        if (estreeToolkit.is.identifier(decoratedExpression) && decoratedExpression.name === 'api') {
            state.publicProperties.push(node.key.name);
        }
        else if (estreeToolkit.is.callExpression(decoratedExpression) &&
            estreeToolkit.is.identifier(decoratedExpression.callee) &&
            decoratedExpression.callee.name === 'wire') {
            if (node.computed) {
                // TODO [#5032]: Harmonize errors thrown in `@lwc/ssr-compiler`
                throw new Error('@wire cannot be used on computed properties in SSR context.');
            }
            catalogWireAdapters(path, state);
            state.privateProperties.push(node.key.name);
        }
        else {
            state.privateProperties.push(node.key.name);
        }
        if (node.static &&
            node.key.name === 'stylesheets' &&
            estreeToolkit.is.arrayExpression(node.value) &&
            node.value.elements.every((el) => estreeToolkit.is.identifier(el))) {
            catalogStaticStylesheets(node.value.elements.map((el) => el.name), state);
        }
    },
    MethodDefinition(path, state) {
        const node = path.node;
        if (!estreeToolkit.is.identifier(node?.key)) {
            return;
        }
        // If we mutate any class-methods that are piped through this compiler, then we'll be
        // inadvertently mutating things like Wire adapters.
        if (!state.isLWC) {
            return;
        }
        const { decorators } = node;
        validateUniqueDecorator(decorators);
        // The real type is a subset of `Expression`, which doesn't work with the `is` validators
        const decoratedExpression = decorators?.[0]?.expression;
        if (estreeToolkit.is.callExpression(decoratedExpression) &&
            estreeToolkit.is.identifier(decoratedExpression.callee) &&
            decoratedExpression.callee.name === 'wire') {
            // not a getter/setter
            const isRealMethod = node.kind === 'method';
            if (node.computed) {
                // TODO [#5032]: Harmonize errors thrown in `@lwc/ssr-compiler`
                throw new Error(`@wire cannot be used on computed ${isRealMethod ? 'method' : 'properties'} in SSR context.`);
            }
            // Getters and setters are methods in the AST, but treated as properties by @wire
            // Note that this means that their implementations are ignored!
            if (!isRealMethod) {
                const methodAsProp = estreeToolkit.builders.propertyDefinition(structuredClone(node.key), null, node.computed, node.static);
                methodAsProp.decorators = structuredClone(decorators);
                path.replaceWith(methodAsProp);
                // We do not need to call `catalogWireAdapters()` because, by replacing the current
                // node, `traverse()` will visit it again automatically, so we will just call
                // `catalogWireAdapters()` later anyway.
                return;
            }
            else {
                catalogWireAdapters(path, state);
            }
        }
        else if (estreeToolkit.is.identifier(decoratedExpression) && decoratedExpression.name === 'api') {
            if (state.publicProperties.includes(node.key.name)) {
                // TODO [#5032]: Harmonize errors thrown in `@lwc/ssr-compiler`
                throw new Error(`LWC1112: @api get ${node.key.name} and @api set ${node.key.name} detected in class declaration. Only one of the two needs to be decorated with @api.`);
            }
            state.publicProperties.push(node.key.name);
        }
        switch (node.key.name) {
            case 'constructor':
                // add our own custom arg after any pre-existing constructor args
                node.value.params = [
                    ...structuredClone(node.value.params),
                    estreeToolkit.builders.identifier('propsAvailableAtConstruction'),
                ];
                break;
            case 'connectedCallback':
                state.hasConnectedCallback = true;
                break;
            case 'renderedCallback':
                state.hadRenderedCallback = true;
                path.remove();
                break;
            case 'disconnectedCallback':
                state.hadDisconnectedCallback = true;
                path.remove();
                break;
            case 'errorCallback':
                state.hadErrorCallback = true;
                path.remove();
                break;
        }
    },
    Super(path, state) {
        // If we mutate any super calls that are piped through this compiler, then we'll be
        // inadvertently mutating things like Wire adapters.
        if (!state.isLWC) {
            return;
        }
        const parentFn = path.getFunctionParent();
        if (parentFn &&
            parentFn.parentPath?.node?.type === 'MethodDefinition' &&
            parentFn.parentPath?.node?.kind === 'constructor' &&
            path.parentPath &&
            path.parentPath.node?.type === 'CallExpression') {
            // add our own custom arg after any pre-existing super() args
            path.parentPath.node.arguments = [
                ...structuredClone(path.parentPath.node.arguments),
                estreeToolkit.builders.identifier('propsAvailableAtConstruction'),
            ];
        }
    },
    Program: {
        leave(path, state) {
            // After parsing the whole tree, insert needed imports
            const importDeclarations = state.importManager.getImportDeclarations();
            if (importDeclarations.length > 0) {
                path.node?.body.unshift(...importDeclarations);
            }
        },
    },
    Identifier(path, _state) {
        const { node } = path;
        if (node?.name.startsWith('__lwc') && node.name.endsWith('__')) {
            // TODO [#5032]: Harmonize errors thrown in `@lwc/ssr-compiler`
            throw new Error(`LWCTODO: identifier name '${node.name}' cannot start with '__lwc'`);
        }
    },
};
function validateUniqueDecorator(decorators) {
    if (decorators.length < 2) {
        return;
    }
    const expressions = decorators.map(({ expression }) => expression);
    const wire = expressions.find((expr) => estreeToolkit.is.callExpression(expr) && estreeToolkit.is.identifier(expr.callee, { name: 'wire' }));
    const api = expressions.find((expr) => estreeToolkit.is.identifier(expr, { name: 'api' }));
    if (wire && api) {
        throw generateError(wire, errors.DecoratorErrors.CONFLICT_WITH_ANOTHER_DECORATOR, 'api');
    }
    const track = expressions.find((expr) => estreeToolkit.is.identifier(expr, { name: 'track' }));
    if (wire && track) {
        throw generateError(wire, errors.DecoratorErrors.CONFLICT_WITH_ANOTHER_DECORATOR, 'track');
    }
}
function compileJS(src, filename, tagName, options, compilationMode) {
    let ast = meriyah.parseModule(src, {
        module: true,
        next: true,
        loc: true,
        source: filename,
        ranges: true,
    });
    const state = {
        isLWC: false,
        hasConstructor: false,
        hasConnectedCallback: false,
        hadRenderedCallback: false,
        hadDisconnectedCallback: false,
        hadErrorCallback: false,
        lightningElementIdentifier: null,
        lwcClassName: null,
        tmplExplicitImports: null,
        cssExplicitImports: null,
        staticStylesheetIds: null,
        publicProperties: [],
        privateProperties: [],
        wireAdapters: [],
        experimentalDynamicComponent: options.experimentalDynamicComponent,
        importManager: new ImportManager(),
    };
    estreeToolkit.traverse(ast, visitors, state);
    if (!state.isLWC) {
        // If an `extends LightningElement` is not detected in the JS, the
        // file in question is likely not an LWC. With this v1 implementation,
        // we'll just return the original source.
        return {
            code: astring.generate(ast, {}),
        };
    }
    addGenerateMarkupFunction(ast, state, tagName, filename);
    if (compilationMode === 'async' || compilationMode === 'sync') {
        ast = transmogrify(ast, compilationMode);
    }
    return {
        code: astring.generate(ast, {
            // The AST generated by meriyah doesn't seem to include comments,
            // so this just preserves the LWC version comment we added
            comments: true,
        }),
    };
}

/*
 * Copyright (c) 2024, Salesforce, Inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const bStylesheetTokenDeclaration = (esTemplate `
    const stylesheetScopeToken = '${estreeToolkit.is.literal}';
`);
const bHasScopedStylesheetsDeclaration = (esTemplate `
    const hasScopedStylesheets = defaultScopedStylesheets !== undefined && defaultScopedStylesheets.length > 0;
`);
// Scope tokens are associated with a given template. This is assigned here so that it can be used in `generateMarkup`.
// We also need to keep track of whether the template has any scoped styles or not so that we can render (or not) the
// scope token.
const tmplAssignmentBlock = (esTemplate `
${ /* template */estreeToolkit.is.identifier}.hasScopedStylesheets = hasScopedStylesheets;
${ /* template */0}.stylesheetScopeToken = stylesheetScopeToken;
`);
function addScopeTokenDeclarations(program, filename, namespace, componentName) {
    const { scopeToken } = templateCompiler.generateScopeTokens(filename, namespace, componentName);
    program.body.unshift(bStylesheetTokenDeclaration(builders.builders.literal(scopeToken)), bHasScopedStylesheetsDeclaration());
    program.body.push(...tmplAssignmentBlock(builders.builders.identifier('tmpl')));
}

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function getRootMemberExpression$2(node) {
    return node.object.type === 'MemberExpression' ? getRootMemberExpression$2(node.object) : node;
}
function expressionIrToEs(node, cxt) {
    if (node.type === 'Identifier') {
        const isLocalVar = cxt.isLocalVar(node.name);
        return isLocalVar
            ? node
            : estreeToolkit.builders.memberExpression(estreeToolkit.builders.identifier('instance'), node);
    }
    else if (node.type === 'MemberExpression') {
        const nodeClone = structuredClone(node);
        const rootMemberExpr = getRootMemberExpression$2(nodeClone);
        if (!cxt.isLocalVar(rootMemberExpr.object.name)) {
            rootMemberExpr.object = estreeToolkit.builders.memberExpression(estreeToolkit.builders.identifier('instance'), rootMemberExpr.object);
        }
        return nodeClone;
    }
    throw new Error(`Unimplemented expression: ${node.type}`);
}

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function optimizeAdjacentYieldStmts(statements) {
    let prevStmt = null;
    return statements
        .map((stmt) => {
        if (
        // Check if the current statement and previous statement are
        // both yield expression statements that yield a string literal.
        prevStmt &&
            estreeToolkit.is.expressionStatement(prevStmt) &&
            estreeToolkit.is.yieldExpression(prevStmt.expression) &&
            !prevStmt.expression.delegate &&
            prevStmt.expression.argument &&
            estreeToolkit.is.literal(prevStmt.expression.argument) &&
            typeof prevStmt.expression.argument.value === 'string' &&
            estreeToolkit.is.expressionStatement(stmt) &&
            estreeToolkit.is.yieldExpression(stmt.expression) &&
            !stmt.expression.delegate &&
            stmt.expression.argument &&
            estreeToolkit.is.literal(stmt.expression.argument) &&
            typeof stmt.expression.argument.value === 'string') {
            prevStmt.expression.argument.value += stmt.expression.argument.value;
            return null;
        }
        prevStmt = stmt;
        return stmt;
    })
        .filter((el) => el !== null);
}
function bAttributeValue(node, attrName) {
    if (!('attributes' in node)) {
        throw new TypeError(`Cannot get attribute value from ${node.type}`);
    }
    const nameAttrValue = node.attributes.find((attr) => attr.name === attrName)?.value;
    if (!nameAttrValue) {
        return estreeToolkit.builders.literal(null);
    }
    else if (nameAttrValue.type === 'Literal') {
        const name = typeof nameAttrValue.value === 'string' ? nameAttrValue.value : '';
        return estreeToolkit.builders.literal(name);
    }
    else {
        return estreeToolkit.builders.memberExpression(estreeToolkit.builders.literal('instance'), nameAttrValue);
    }
}
function getRootMemberExpression$1(node) {
    return node.object.type === 'MemberExpression' ? getRootMemberExpression$1(node.object) : node;
}
function getRootIdentifier$1(node, cxt) {
    const rootMemberExpression = getRootMemberExpression$1(node);
    if (estreeToolkit.is.identifier(rootMemberExpression.object)) {
        return rootMemberExpression.object;
    }
    if (cxt.templateOptions.experimentalComplexExpressions) {
        // TODO [#3370]: Implement complex template expressions
        return null;
    }
    // Should be impossible to hit, at least until we implement complex template expressions
    /* v8 ignore next */
    throw new Error(`Invalid expression, must be an Identifier, found type="${rootMemberExpression.type}": \`${JSON.stringify(rootMemberExpression)}\``);
}
/**
 * Given an expression in a context, return an expression that may be scoped to that context.
 * For example, for the expression `foo`, it will typically be `instance.foo`, but if we're
 * inside a `for:each` block then the `foo` variable may refer to the scoped `foo`,
 * e.g. `<template for:each={foos} for:item="foo">`
 * @param expression
 * @param cxt
 */
function getScopedExpression(expression, cxt) {
    let scopeReferencedId = null;
    if (estreeToolkit.is.memberExpression(expression)) {
        // e.g. `foo.bar` -> scopeReferencedId is `foo`
        scopeReferencedId = getRootIdentifier$1(expression, cxt);
    }
    else if (estreeToolkit.is.identifier(expression)) {
        // e.g. `foo` -> scopeReferencedId is `foo`
        scopeReferencedId = expression;
    }
    if (scopeReferencedId === null) {
        if (cxt.templateOptions.experimentalComplexExpressions) {
            // TODO [#3370]: Implement complex template expressions
            return expression;
        }
        // Should be impossible to hit, at least until we implement complex template expressions
        /* v8 ignore next */
        throw new Error(`Invalid expression, must be a MemberExpression or Identifier, found type="${expression.type}": \`${JSON.stringify(expression)}\``);
    }
    return cxt.isLocalVar(scopeReferencedId.name)
        ? expression
        : estreeToolkit.builders.memberExpression(estreeToolkit.builders.identifier('instance'), expression);
}
function normalizeClassAttributeValue(value) {
    // @ts-expect-error weird indirection results in wrong overload being picked up
    return shared.StringReplace.call(shared.StringTrim.call(value), /\s+/g, ' ');
}
function getChildAttrsOrProps(attrs, cxt) {
    const objectAttrsOrProps = attrs
        .map(({ name, value, type }) => {
        // Babel function required to align identifier validation with babel-plugin-component: https://github.com/salesforce/lwc/issues/4826
        const key = types.isValidES3Identifier(name) ? estreeToolkit.builders.identifier(name) : estreeToolkit.builders.literal(name);
        if (value.type === 'Literal' && typeof value.value === 'string') {
            let literalValue = value.value;
            if (name === 'style') {
                literalValue = shared.normalizeStyleAttributeValue(literalValue);
            }
            else if (name === 'class') {
                literalValue = normalizeClassAttributeValue(literalValue);
                if (literalValue === '') {
                    return; // do not render empty `class=""`
                }
            }
            else if (name === 'spellcheck') {
                // `spellcheck` string values are specially handled to massage them into booleans:
                // https://github.com/salesforce/lwc/blob/574ffbd/packages/%40lwc/template-compiler/src/codegen/index.ts#L445-L448
                literalValue = literalValue.toLowerCase() !== 'false';
            }
            return estreeToolkit.builders.property('init', key, estreeToolkit.builders.literal(literalValue));
        }
        else if (value.type === 'Literal' && typeof value.value === 'boolean') {
            if (name === 'class') {
                return; // do not render empty `class=""`
            }
            return estreeToolkit.builders.property('init', key, estreeToolkit.builders.literal(type === 'Attribute' ? '' : value.value));
        }
        else if (value.type === 'Identifier' || value.type === 'MemberExpression') {
            let propValue = expressionIrToEs(value, cxt);
            if (name === 'class') {
                cxt.import('normalizeClass');
                propValue = estreeToolkit.builders.callExpression(estreeToolkit.builders.identifier('normalizeClass'), [propValue]);
            }
            return estreeToolkit.builders.property('init', key, propValue);
        }
        throw new Error(`Unimplemented child attr IR node type: ${value.type}`);
    })
        .filter(Boolean);
    return estreeToolkit.builders.objectExpression(objectAttrsOrProps);
}
/**
 * Determine if the provided node is of type Literal
 * @param node
 */
function isLiteral(node) {
    return node.type === 'Literal';
}

/*
 * Copyright (c) 2024, Salesforce, Inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const bNormalizeTextContent = (esTemplate `
    normalizeTextContent(${ /* string value */estreeToolkit.is.expression});
`);
const bYieldTextContent = (esTemplateWithYield `
    yield renderTextContent(${ /* text concatenation, possibly as binary expression */estreeToolkit.is.expression});
`);
/**
 * True if this is one of a series of text content nodes and/or comment node that are adjacent to one another as
 * siblings. (Comment nodes are ignored when preserve-comments is turned off.) This allows for adjacent text
 * node concatenation.
 */
const isConcatenatedNode = (node, cxt) => {
    switch (node.type) {
        case 'Text':
            return true;
        case 'Comment':
            return !cxt.templateOptions.preserveComments;
        default:
            return false;
    }
};
const isLastConcatenatedNode = (cxt) => {
    const siblings = cxt.siblings;
    const currentNodeIndex = cxt.currentNodeIndex;
    const nextSibling = siblings[currentNodeIndex + 1];
    if (!nextSibling) {
        // we are the last sibling
        return true;
    }
    return !isConcatenatedNode(nextSibling, cxt);
};
function generateExpressionFromTextNode(node, cxt) {
    return isLiteral(node.value) ? builders.builders.literal(node.value.value) : expressionIrToEs(node.value, cxt);
}
function generateConcatenatedTextNodesExpressions(cxt) {
    const siblings = cxt.siblings;
    const currentNodeIndex = cxt.currentNodeIndex;
    const textNodes = [];
    for (let i = currentNodeIndex; i >= 0; i--) {
        const sibling = siblings[i];
        if (isConcatenatedNode(sibling, cxt)) {
            if (sibling.type === 'Text') {
                textNodes.unshift(sibling);
            }
        }
        else {
            // If we reach a non-Text/Comment node, we are done. These should not be concatenated
            // with sibling Text nodes separated by e.g. an Element:
            //     {a}{b}<div></div>{c}{d}
            // In the above, {a} and {b} are concatenated, and {c} and {d} are concatenated,
            // but the `<div>` separates the two groups.
            break;
        }
    }
    if (!textNodes.length) {
        // Render nothing. This can occur if we hit a comment in non-preserveComments mode with no adjacent text nodes
        return [];
    }
    cxt.import(['normalizeTextContent', 'renderTextContent']);
    // Generate a binary expression to concatenate the text together. E.g.:
    //     renderTextContent(
    //         normalizeTextContent(a) +
    //         normalizeTextContent(b) +
    //         normalizeTextContent(c)
    //     )
    const concatenatedExpression = textNodes
        .map((node) => bNormalizeTextContent(generateExpressionFromTextNode(node, cxt)))
        .reduce((accumulator, expression) => builders.builders.binaryExpression('+', accumulator, expression));
    return [bYieldTextContent(concatenatedExpression)];
}

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const Comment = function Comment(node, cxt) {
    if (cxt.templateOptions.preserveComments) {
        return [estreeToolkit.builders.expressionStatement(estreeToolkit.builders.yieldExpression(estreeToolkit.builders.literal(`<!--${node.value}-->`)))];
    }
    else {
        const isLastInSeries = isLastConcatenatedNode(cxt);
        // If preserve comments is off, we check if we should flush text content
        // for adjacent text nodes. (If preserve comments is on, then the previous
        // text node already flushed.)
        if (isLastInSeries) {
            return generateConcatenatedTextNodesExpressions(cxt);
        }
        return [];
    }
};

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
/** Extends a validator to return `true` if the node is `null`. */
function isNullableOf(validator) {
    const nullableValidator = (node) => {
        return node === null || validator(node);
    };
    if (process.env.NODE_ENV !== 'production') {
        nullableValidator.__debugName = `nullable(${validator.__debugName || validator.name || 'unknown validator'})`;
    }
    return nullableValidator;
}
isNullableOf.__debugName = 'isNullableOf';
if (process.env.NODE_ENV !== 'production') {
    // Modifying another package's exports is a code smell!
    for (const [key, val] of shared.entries(estreeToolkit.is)) {
        val.__debugName = key;
    }
}

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const bGenerateSlottedContent = (esTemplateWithYield `
        const shadowSlottedContent = ${ /* hasShadowSlottedContent */estreeToolkit.is.literal}
            ? async function* generateSlottedContent(contextfulParent) {
                // The 'contextfulParent' variable is shadowed here so that a contextful relationship
                // is established between components rendered in slotted content & the "parent"
                // component that contains the <slot>.

                ${ /* shadow slot content */estreeToolkit.is.statement}
            } 
            // Avoid creating the object unnecessarily
            : null;

        const lightSlottedContentMap = ${ /* hasLightSlottedContent */estreeToolkit.is.literal} 
            ? Object.create(null)
            // Avoid creating the object unnecessarily
            : null;
        
        // The containing slot treats scoped slotted content differently.
        const scopedSlottedContentMap = ${ /* hasScopedSlottedContent */estreeToolkit.is.literal} 
            ? Object.create(null)
            // Avoid creating the object unnecessarily
            : null;

        function addSlottedContent(name, fn, contentMap) {
            let contentList = contentMap[name];
            if (contentList) {
                contentList.push(fn);
            } else {
                contentMap[name] = [fn];
            }
        }

        ${ /* light DOM addLightContent statements */estreeToolkit.is.expressionStatement}
        ${ /* scoped slot addLightContent statements */estreeToolkit.is.expressionStatement}
`);
// Note that this function name (`generateSlottedContent`) does not need to be scoped even though
// it may be repeated multiple times in the same scope, because it's a function _expression_ rather
// than a function _declaration_, so it isn't available to be referenced anywhere.
const bAddSlottedContent = (esTemplate `
    addSlottedContent(${ /* slot name */estreeToolkit.is.expression} ?? "", async function* generateSlottedContent(contextfulParent, ${
/* scoped slot data variable */ isNullableOf(estreeToolkit.is.identifier)}, slotAttributeValue) {
        // FIXME: make validation work again  
        ${ /* slot content */false}
    }, ${ /* content map */estreeToolkit.is.identifier});
`);
function getShadowSlottedContent(slottableChildren, cxt) {
    return optimizeAdjacentYieldStmts(irChildrenToEs(slottableChildren, cxt, (child) => {
        const { isSlotted } = cxt;
        if (child.type === 'ExternalComponent' || child.type === 'Element') {
            cxt.isSlotted = false;
        }
        // cleanup function
        return () => {
            cxt.isSlotted = isSlotted;
        };
    }));
}
// Light DOM slots are a bit complex because of needing to handle slots _not_ at the top level
// At the non-top level, it matters what the ancestors are. These are relevant to slots:
// - If (`if:true`, `if:false`)
// - IfBlock/ElseBlock/ElseifBlock (`lwc:if`, `lwc:elseif`, `lwc:else`)
// Whereas anything else breaks the relationship between the slotted content and the containing
// Component (e.g. another Component/ExternalComponent) or is disallowed (e.g. ForEach/ForOf).
// Then there are the leaf nodes, which _may_ have a `slot` attribute on them:
// - Element/Text/Component/ExternalComponent (e.g. `<div>`, `<x-foo>`)
// Once you reach a leaf, you know what content should be rendered for a given slot name. But you
// also need to consider all of its ancestors, which may cause the slot content to be conditionally
// rendered (e.g. IfBlock/ElseBlock).
// For example:
//     <x-foo>
//         <template lwc:if={darkTheme}>
//             <div slot="footer"></div>
//         </template>
//         <template lwc:else>
//             yolo
//         </template>
//     </x-foo>
// In this example, we render the `<div>` into the `footer` slot, if `darkTheme` is true.
// Otherwise, we will render the text node `yolo` into the default slot.
// The goal here is to traverse through the tree and identify all unique `slot` attribute names
// and group those into AST trees on a per-`slot` name basis, only for leafs/ancestors that are
// relevant to slots (as mentioned above).
function getLightSlottedContent(rootNodes, cxt) {
    const results = [];
    // For the given slot name, get the EsExpressions we should use to render it
    // The ancestorIndices is an array of integers referring to the chain of ancestors
    // and their positions in the child arrays of their own parents
    const addLightDomSlotContent = (slotName, ancestorIndices) => {
        const clone = immer.produce(rootNodes[ancestorIndices[0]], (draft) => {
            // Create a clone of the AST with only the ancestors and no other siblings
            let current = draft;
            for (let i = 1; i < ancestorIndices.length; i++) {
                const nextIndex = ancestorIndices[i];
                // If i >= 1 then the current must necessarily be a SlottableAncestorIrType
                const next = current.children[nextIndex];
                current.children = [next];
                current = next;
            }
            // The leaf must necessarily be a SlottableLeafIrType
            const leaf = current;
            // Light DOM slots do not actually render the `slot` attribute.
            if (leaf.type !== 'Text') {
                leaf.attributes = leaf.attributes.filter((attr) => attr.name !== 'slot');
            }
        });
        const { isSlotted: originalIsSlotted } = cxt;
        cxt.isSlotted = ancestorIndices.length > 1 || clone.type === 'Slot';
        const slotContent = irToEs(clone, cxt);
        cxt.isSlotted = originalIsSlotted;
        results.push(estreeToolkit.builders.expressionStatement(bAddSlottedContent(slotName, null, slotContent, estreeToolkit.builders.identifier('lightSlottedContentMap'))));
    };
    const traverse = (nodes, ancestorIndices) => {
        for (let i = 0; i < nodes.length; i++) {
            // must set the siblings inside the for loop due to nested children
            cxt.siblings = nodes;
            cxt.currentNodeIndex = i;
            const node = nodes[i];
            switch (node.type) {
                // SlottableAncestorIrType
                case 'If':
                case 'IfBlock':
                case 'ElseifBlock':
                case 'ElseBlock': {
                    traverse(node.children, [...ancestorIndices, i]);
                    break;
                }
                // SlottableLeafIrType
                case 'Slot':
                case 'Element':
                case 'Text':
                case 'Component':
                case 'ExternalComponent': {
                    // '' is the default slot name. Text nodes are always slotted into the default slot
                    const slotName = node.type === 'Text' ? estreeToolkit.builders.literal('') : bAttributeValue(node, 'slot');
                    // For concatenated adjacent text nodes, for any but the final text node, we
                    // should skip them and let the final text node take care of rendering its siblings
                    if (node.type === 'Text' && !isLastConcatenatedNode(cxt)) {
                        continue;
                    }
                    addLightDomSlotContent(slotName, [...ancestorIndices, i]);
                    break;
                }
            }
        }
        // reset the context
        cxt.siblings = undefined;
        cxt.currentNodeIndex = undefined;
    };
    traverse(rootNodes, []);
    return results;
}
function getSlottedContent(node, cxt) {
    const { isSlotted } = cxt;
    cxt.isSlotted = true;
    // Anything inside the slotted content is a normal slotted content except for `<template lwc:slot-data>` which is a scoped slot.
    const slottableChildren = node.children.filter((child) => child.type !== 'ScopedSlotFragment');
    const scopedSlottableChildren = node.children.filter((child) => child.type === 'ScopedSlotFragment');
    const shadowSlotContent = getShadowSlottedContent(slottableChildren, cxt);
    const lightSlotContent = getLightSlottedContent(slottableChildren, cxt);
    const scopedSlotContent = scopedSlottableChildren.map((child) => {
        const boundVariableName = child.slotData.value.name;
        const boundVariable = estreeToolkit.builders.identifier(boundVariableName);
        cxt.pushLocalVars([boundVariableName]);
        const slotName = isLiteral(child.slotName)
            ? estreeToolkit.builders.literal(child.slotName.value)
            : expressionIrToEs(child.slotName, cxt);
        // TODO [#4768]: what if the bound variable is `generateMarkup` or some framework-specific identifier?
        const addLightContentExpr = estreeToolkit.builders.expressionStatement(bAddSlottedContent(slotName, boundVariable, irChildrenToEs(child.children, cxt), estreeToolkit.builders.identifier('scopedSlottedContentMap')));
        cxt.popLocalVars();
        return addLightContentExpr;
    });
    const hasShadowSlottedContent = estreeToolkit.builders.literal(shadowSlotContent.length > 0);
    const hasLightSlottedContent = estreeToolkit.builders.literal(lightSlotContent.length > 0);
    const hasScopedSlottedContent = estreeToolkit.builders.literal(scopedSlotContent.length > 0);
    cxt.isSlotted = isSlotted;
    return bGenerateSlottedContent(hasShadowSlottedContent, shadowSlotContent, hasLightSlottedContent, hasScopedSlottedContent, lightSlotContent, scopedSlotContent);
}

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const bYieldFromChildGenerator = (esTemplateWithYield `
    {
        const childProps = ${ /* child props */estreeToolkit.is.objectExpression};
        const childAttrs = ${ /* child attrs */estreeToolkit.is.objectExpression};
        /* 
            If 'slotAttributeValue' is set, it references a slot that does not exist, and the 'slot' attribute should be set in the DOM. This behavior aligns with engine-server and engine-dom.
            See: engine-server/src/__tests__/fixtures/slot-forwarding/slots/dangling/ for example case.
        */
        if (slotAttributeValue) {
            childAttrs.slot = slotAttributeValue;
        }
        ${
/*
    Slotted content is inserted here.
    Note that the slotted content will be stored in variables named
    `shadowSlottedContent`/`lightSlottedContentMap / scopedSlottedContentMap` which are used below
when the child's generateMarkup function is invoked.
*/
estreeToolkit.is.statement}

        const scopeToken = hasScopedStylesheets ? stylesheetScopeToken : undefined;
        const generateMarkup = ${ /* Component */estreeToolkit.is.identifier}[__SYMBOL__GENERATE_MARKUP];
        const tagName = ${ /* tag name */estreeToolkit.is.literal};

        if (generateMarkup) {
            yield* generateMarkup(
                tagName, 
                childProps, 
                childAttrs, 
                shadowSlottedContent,
                lightSlottedContentMap,
                scopedSlottedContentMap,
                instance,
                scopeToken,
                contextfulParent
            );
        } else {
            yield \`<\${tagName}>\`;
            yield* __fallbackTmpl(shadowSlottedContent, lightSlottedContentMap, scopedSlottedContentMap, ${ /* Component */3}, instance)
            yield \`</\${tagName}>\`;
        }
    }
`);
const Component = function Component(node, cxt) {
    // Import the custom component's generateMarkup export.
    const childComponentLocalName = `ChildComponentCtor_${templateCompiler.toPropertyName(node.name)}`;
    const importPath = templateCompiler.kebabcaseToCamelcase(node.name);
    cxt.import({ default: childComponentLocalName }, importPath);
    cxt.import({
        SYMBOL__GENERATE_MARKUP: '__SYMBOL__GENERATE_MARKUP',
        fallbackTmpl: '__fallbackTmpl',
    });
    const childTagName = node.name;
    return [
        bYieldFromChildGenerator(getChildAttrsOrProps(node.properties, cxt), getChildAttrsOrProps(node.attributes, cxt), getSlottedContent(node, cxt), estreeToolkit.builders.identifier(childComponentLocalName), estreeToolkit.builders.literal(childTagName)),
    ];
};

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const bYieldFromDynamicComponentConstructorGenerator = (esTemplateWithYield `
    const Ctor = '${ /* lwcIs attribute value */estreeToolkit.is.expression}';
    if (Ctor) {
        if (typeof Ctor !== 'function' || !(Ctor.prototype instanceof LightningElement)) {
            throw new Error(\`Invalid constructor: "\${String(Ctor)}" is not a LightningElement constructor.\`)
        }
        const childProps = ${ /* child props */estreeToolkit.is.objectExpression};
        const childAttrs = ${ /* child attrs */estreeToolkit.is.objectExpression};
        /* 
            If 'slotAttributeValue' is set, it references a slot that does not exist, and the 'slot' attribute should be set in the DOM. This behavior aligns with engine-server and engine-dom.
            See: engine-server/src/__tests__/fixtures/slot-forwarding/slots/dangling/ for example case.
        */
        if (slotAttributeValue) {
            childAttrs.slot = slotAttributeValue;
        }
        ${
/*
    Slotted content is inserted here.
    Note that the slotted content will be stored in variables named
    `shadowSlottedContent`/`lightSlottedContentMap / scopedSlottedContentMap` which are used below
    when the child's generateMarkup function is invoked.
*/
estreeToolkit.is.statement}

        const scopeToken = hasScopedStylesheets ? stylesheetScopeToken : undefined;
        
        yield* Ctor[__SYMBOL__GENERATE_MARKUP](
            null, 
            childProps,
            childAttrs,
            shadowSlottedContent,
            lightSlottedContentMap,
            scopedSlottedContentMap,
            instance,
            scopeToken,
            contextfulParent
        );
    }
`);
const LwcComponent = function LwcComponent(node, cxt) {
    const { directives } = node;
    const lwcIs = directives.find((directive) => directive.name === 'Is');
    if (!shared.isUndefined(lwcIs)) {
        cxt.import({
            LightningElement: undefined,
            SYMBOL__GENERATE_MARKUP: '__SYMBOL__GENERATE_MARKUP',
        });
        return bYieldFromDynamicComponentConstructorGenerator(
        // The template compiler has validation to prevent lwcIs.value from being a literal
        expressionIrToEs(lwcIs.value, cxt), getChildAttrsOrProps(node.properties, cxt), getChildAttrsOrProps(node.attributes, cxt), getSlottedContent(node, cxt));
    }
    else {
        return [];
    }
};

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const bYield = (expr) => estreeToolkit.builders.expressionStatement(estreeToolkit.builders.yieldExpression(expr));
// TODO [#4714]: scope token renders as a suffix for literals, but prefix for expressions
const bYieldDynamicValue = (esTemplateWithYield `
    {
        const attrName = ${ /* attribute name */estreeToolkit.is.literal};
        let attrValue = ${ /* attribute value expression */estreeToolkit.is.expression};
        const isHtmlBooleanAttr = ${ /* isHtmlBooleanAttr */estreeToolkit.is.literal};

        // Global HTML boolean attributes are specially coerced into booleans
        // https://github.com/salesforce/lwc/blob/f34a347/packages/%40lwc/template-compiler/src/codegen/index.ts#L450-L454
        if (isHtmlBooleanAttr) {
            attrValue = attrValue ? '' : undefined;
        }

        // Global HTML "tabindex" attribute is specially massaged into a stringified number
        // This follows the historical behavior in api.ts:
        // https://github.com/salesforce/lwc/blob/f34a347/packages/%40lwc/engine-core/src/framework/api.ts#L193-L211
        if (attrName === 'tabindex') {
            const shouldNormalize = attrValue > 0 && typeof attrValue !== 'boolean';
            attrValue = shouldNormalize ? 0 : attrValue;
        }

        // Backwards compatibility with historical patchStyleAttribute() behavior:
        // https://github.com/salesforce/lwc/blob/59e2c6c/packages/%40lwc/engine-core/src/framework/modules/computed-style-attr.ts#L40
        if (attrName === 'style' && (typeof attrValue !== 'string' || attrValue === '')) {
            attrValue = undefined;
        }

        if (attrValue !== undefined && attrValue !== null) {
            yield ' ' + attrName;

            if (attrValue !== '') {
                yield \`="\${htmlEscape(String(attrValue), true)}"\`;
            }
        }
    }
`);
const bYieldClassDynamicValue = (esTemplateWithYield `
    {
        const attrValue = normalizeClass(${ /* attribute value expression */estreeToolkit.is.expression});
        const shouldRenderScopeToken = hasScopedStylesheets || hasScopedStaticStylesheets(Cmp);

        // Concatenate the scope token with the class attribute value as necessary.
        // If either is missing, render the other alone.
        let combinedValue = shouldRenderScopeToken ? stylesheetScopeToken : '';
        if (attrValue) {
            if (combinedValue) {
                combinedValue += ' ';
            }
            combinedValue += htmlEscape(String(attrValue), true);
        }
        if (combinedValue) {
            yield \` class="\${combinedValue}"\`;
        }
    }
`);
// TODO [#4714]: scope token renders as a suffix for literals, but prefix for expressions
const bStringLiteralYield = (esTemplateWithYield `
    {
        const attrName = ${ /* attribute name */estreeToolkit.is.literal}
        const attrValue = ${ /* attribute value */estreeToolkit.is.literal};

        const shouldRenderScopeToken = attrName === 'class' &&
            (hasScopedStylesheets || hasScopedStaticStylesheets(Cmp));
        const suffix = shouldRenderScopeToken ? ' ' + stylesheetScopeToken : '';

        yield ' ' + attrName;
        if (attrValue !== '' || shouldRenderScopeToken) {
            yield '="' + attrValue + suffix + '"';
        }
        
    }
`);
const bConditionallyYieldScopeTokenClass = (esTemplateWithYield `
    if (hasScopedStylesheets || hasScopedStaticStylesheets(Cmp)) {
        yield \` class="\${stylesheetScopeToken}"\`;
    }
`);
/*
    If `slotAttributeValue` is set, it references a slot that does not exist, and the `slot` attribute should be set in the DOM. This behavior aligns with engine-server and engine-dom.
    See: engine-server/src/__tests__/fixtures/slot-forwarding/slots/dangling/ for example case.
*/
const bConditionallyYieldDanglingSlotName = (esTemplateWithYield `
    if (slotAttributeValue) {
        yield \` slot="\${slotAttributeValue}"\`; 
    }   
`);
const bYieldSanitizedHtml = esTemplateWithYield `
    yield sanitizeHtmlContent(${ /* lwc:inner-html content */estreeToolkit.is.expression})
`;
function yieldAttrOrPropLiteralValue(name, valueNode) {
    const { value, type } = valueNode;
    if (typeof value === 'string') {
        let yieldedValue;
        if (name === 'style') {
            yieldedValue = shared.normalizeStyleAttributeValue(value);
        }
        else if (name === 'class') {
            yieldedValue = normalizeClassAttributeValue(value);
            if (yieldedValue === '') {
                return [];
            }
        }
        else if (name === 'spellcheck') {
            // `spellcheck` string values are specially handled to massage them into booleans.
            // https://github.com/salesforce/lwc/blob/fe4e95f/packages/%40lwc/template-compiler/src/codegen/index.ts#L445-L448
            yieldedValue = String(value.toLowerCase() !== 'false');
        }
        else {
            yieldedValue = value;
        }
        return [bStringLiteralYield(estreeToolkit.builders.literal(name), estreeToolkit.builders.literal(yieldedValue))];
    }
    else if (typeof value === 'boolean') {
        if (name === 'class') {
            return [];
        }
        return [bYield(estreeToolkit.builders.literal(` ${name}`))];
    }
    throw new Error(`Unknown attr/prop literal: ${type}`);
}
function yieldAttrOrPropDynamicValue(elementName, name, value, cxt) {
    cxt.import('htmlEscape');
    const scopedExpression = getScopedExpression(value, cxt);
    switch (name) {
        case 'class':
            cxt.import('normalizeClass');
            return [bYieldClassDynamicValue(scopedExpression)];
        default:
            return [
                bYieldDynamicValue(estreeToolkit.builders.literal(name), scopedExpression, estreeToolkit.builders.literal(shared.isBooleanAttribute(name, elementName))),
            ];
    }
}
function reorderAttributes(attrs, props) {
    let classAttr = null;
    let styleAttr = null;
    let slotAttr = null;
    const boringAttrs = attrs.filter((attr) => {
        if (attr.name === 'class') {
            classAttr = attr;
            return false;
        }
        else if (attr.name === 'style') {
            styleAttr = attr;
            return false;
        }
        else if (attr.name === 'slot') {
            slotAttr = attr;
            return false;
        }
        return true;
    });
    return [classAttr, styleAttr, ...boringAttrs, ...props, slotAttr].filter((el) => el !== null);
}
const Element = function Element(node, cxt) {
    const innerHtmlDirective = node.type === 'Element' && node.directives.find((dir) => dir.name === 'InnerHTML');
    const attrsAndProps = reorderAttributes(node.attributes, node.properties);
    let hasClassAttribute = false;
    const yieldAttrsAndProps = attrsAndProps
        .filter(({ name }) => {
        // `<input checked>`/`<input value>` is treated as a property, not an attribute,
        // so should never be SSR'd. See https://github.com/salesforce/lwc/issues/4763
        return !(node.name === 'input' && (name === 'value' || name === 'checked'));
    })
        .flatMap(({ name, value, type }) => {
        if (type === 'Attribute' && (name === 'inner-h-t-m-l' || name === 'outer-h-t-m-l')) {
            throw new Error(`Cannot set attribute "${name}" on <${node.name}>.`);
        }
        let result;
        if (value.type === 'Literal') {
            result = yieldAttrOrPropLiteralValue(name, value);
        }
        else {
            result = yieldAttrOrPropDynamicValue(node.name, name, value, cxt);
        }
        if (result.length > 0 && name === 'class') {
            // actually yielded a class attribute value
            hasClassAttribute = true;
        }
        return result;
    });
    let childContent;
    // An element can have children or lwc:inner-html, but not both
    // If it has both, the template compiler will throw an error before reaching here
    if (node.children.length) {
        childContent = irChildrenToEs(node.children, cxt);
    }
    else if (innerHtmlDirective) {
        const value = innerHtmlDirective.value;
        const unsanitizedHtmlExpression = value.type === 'Literal' ? estreeToolkit.builders.literal(value.value) : expressionIrToEs(value, cxt);
        childContent = [bYieldSanitizedHtml(unsanitizedHtmlExpression)];
        cxt.import('sanitizeHtmlContent');
    }
    else {
        childContent = [];
    }
    const isForeignSelfClosingElement = node.namespace !== shared.HTML_NAMESPACE && childContent.length === 0;
    const isSelfClosingElement = shared.isVoidElement(node.name, shared.HTML_NAMESPACE) || isForeignSelfClosingElement;
    return [
        bYield(estreeToolkit.builders.literal(`<${node.name}`)),
        bConditionallyYieldDanglingSlotName(),
        // If we haven't already prefixed the scope token to an existing class, add an explicit class here
        ...(hasClassAttribute ? [] : [bConditionallyYieldScopeTokenClass()]),
        ...yieldAttrsAndProps,
        bYield(estreeToolkit.builders.literal(isForeignSelfClosingElement ? `/>` : `>`)),
        ...(isSelfClosingElement ? [] : [...childContent, bYield(estreeToolkit.builders.literal(`</${node.name}>`))]),
    ].filter(Boolean);
};

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const bForOfYieldFrom$1 = (esTemplate `
    for (let [${estreeToolkit.is.identifier}, ${estreeToolkit.is.identifier}] of Object.entries(${estreeToolkit.is.expression} ?? {})) {
        ${estreeToolkit.is.statement};
    }
`);
const ForEach = function ForEach(node, cxt) {
    const forItemId = node.item.name;
    const forIndexId = node.index?.name ?? '__unused__';
    cxt.pushLocalVars([forItemId, forIndexId]);
    const forEachStatements = irChildrenToEs(node.children, cxt);
    cxt.popLocalVars();
    const expression = node.expression;
    const iterable = getScopedExpression(expression, cxt);
    return [
        bForOfYieldFrom$1(estreeToolkit.builders.identifier(forIndexId), estreeToolkit.builders.identifier(forItemId), iterable, optimizeAdjacentYieldStmts(forEachStatements)),
    ];
};

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function getRootMemberExpression(node) {
    return node.object.type === 'MemberExpression' ? getRootMemberExpression(node.object) : node;
}
function getRootIdentifier(node) {
    const rootMemberExpression = getRootMemberExpression(node);
    return estreeToolkit.is.identifier(rootMemberExpression?.object) ? rootMemberExpression.object : null;
}
const bForOfYieldFrom = (esTemplate `
    for (let ${estreeToolkit.is.identifier} of toIteratorDirective(${estreeToolkit.is.expression} ?? [])) {
        ${estreeToolkit.is.statement};
    }
`);
const ForOf = function ForEach(node, cxt) {
    const id = node.iterator.name;
    cxt.pushLocalVars([id]);
    const forEachStatements = irChildrenToEs(node.children, cxt);
    cxt.popLocalVars();
    const expression = node.expression;
    const scopeReferencedId = estreeToolkit.is.memberExpression(expression)
        ? getRootIdentifier(expression)
        : null;
    const iterable = cxt.isLocalVar(scopeReferencedId?.name)
        ? node.expression
        : estreeToolkit.builders.memberExpression(estreeToolkit.builders.identifier('instance'), node.expression);
    cxt.import('toIteratorDirective');
    return [
        bForOfYieldFrom(estreeToolkit.builders.identifier(id), iterable, optimizeAdjacentYieldStmts(forEachStatements)),
    ];
};

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const LegacyIf = function If(node, cxt) {
    const { modifier: trueOrFalseAsStr, condition, children } = node;
    const trueOrFalse = trueOrFalseAsStr === 'true';
    const test = trueOrFalse
        ? expressionIrToEs(condition, cxt)
        : estreeToolkit.builders.unaryExpression('!', expressionIrToEs(condition, cxt));
    const childStatements = irChildrenToEs(children, cxt);
    const block = estreeToolkit.builders.blockStatement(optimizeAdjacentYieldStmts(childStatements));
    return [estreeToolkit.builders.ifStatement(test, block)];
};

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const bConditionalSlot = (esTemplateWithYield `
    if (isLightDom) {
        const isScopedSlot = ${ /* isScopedSlot */estreeToolkit.is.literal};
        const isSlotted = ${ /* isSlotted */estreeToolkit.is.literal};
        const slotName = ${ /* slotName */estreeToolkit.is.expression};
        const lightGenerators = lightSlottedContent?.[slotName ?? ""];
        const scopedGenerators = scopedSlottedContent?.[slotName ?? ""];
        const mismatchedSlots = isScopedSlot ? lightGenerators : scopedGenerators;
        const generators = isScopedSlot ? scopedGenerators : lightGenerators;
        /* 
            If a slotAttributeValue is present, it should be provided for assignment to any slotted content. This behavior aligns with v1 and engine-dom.
            See: engine-server/src/__tests__/fixtures/slot-forwarding/slots/dangling/ for example.
            Note the slot mapping does not work for scoped slots, so the slot name is not rendered in this case.
            See: engine-server/src/__tests__/fixtures/slot-forwarding/scoped-slots for example.
        */
        const danglingSlotName = !isScopedSlot ? ${ /* slotAttributeValue */estreeToolkit.is.expression} || slotAttributeValue : null;
        // start bookend HTML comment for light DOM slot vfragment
        if (!isSlotted) {
            yield '<!---->';

            // If there is slot data, scoped slot factory has its own vfragment hence its own bookend
            if (isScopedSlot && generators) {
                yield '<!---->';
            }
        }

        if (generators) {
            for (let i = 0; i < generators.length; i++) {
                yield* generators[i](contextfulParent, ${ /* scoped slot data */isNullableOf(estreeToolkit.is.expression)}, danglingSlotName);
                // Scoped slotted data is separated by bookends. Final bookends are added outside of the loop below.
                if (isScopedSlot && i < generators.length - 1) {
                    yield '<!---->';
                    yield '<!---->';
                }
            }
        /* 
            If there were mismatched slots, do not fallback to the default. This is required for parity with
            engine-core which resets children to an empty array when there are children (mismatched or not). 
            Because the child nodes are reset, the default slotted content is not rendered in the mismatched slot case. 
            See https://github.com/salesforce/lwc/blob/master/packages/%40lwc/engine-core/src/framework/api.ts#L238
        */
        } else if (!mismatchedSlots) {
            // If we're in this else block, then the generator _must_ have yielded
            // something. It's impossible for a slottedContent["foo"] to exist
            // without the generator yielding at least a text node / element.
            // FIXME: how does this work with comments and lwc:preserve-comments?
            // TODO: default/fallback slot content
            ${ /* slot fallback content */estreeToolkit.is.statement}
        }

        // end bookend HTML comment for light DOM slot vfragment
        if (!isSlotted) {
            yield '<!---->';

            // If there is slot data, scoped slot factory has its own vfragment hence its own bookend
            if (isScopedSlot && generators) {
                yield '<!---->';
            }
        }
    } else {
        ${ /* slot element AST */estreeToolkit.is.statement}
    }
`);
const Slot = function Slot(node, ctx) {
    const slotBindDirective = node.directives.find((dir) => dir.name === 'SlotBind');
    const slotBound = slotBindDirective?.value
        ? getScopedExpression(slotBindDirective.value, ctx)
        : null;
    const slotName = bAttributeValue(node, 'name');
    // FIXME: avoid serializing the slot's children twice
    const slotAst = Element(node, ctx);
    const slotChildren = irChildrenToEs(node.children, ctx);
    const isScopedSlot = estreeToolkit.builders.literal(Boolean(slotBound));
    const isSlotted = estreeToolkit.builders.literal(Boolean(ctx.isSlotted));
    const slotAttributeValue = bAttributeValue(node, 'slot');
    return [
        bConditionalSlot(isScopedSlot, isSlotted, slotName, slotAttributeValue, slotBound, slotChildren, slotAst),
    ];
};

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const Text = function Text(node, cxt) {
    if (isLastConcatenatedNode(cxt)) {
        // render all concatenated content up to us
        return generateConcatenatedTextNodesExpressions(cxt);
    }
    // our last sibling is responsible for rendering our content, not us
    return [];
};

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function createNewContext(templateOptions) {
    const importManager = new ImportManager();
    const localVarStack = [];
    const pushLocalVars = (vars) => {
        localVarStack.push(new Set(vars));
    };
    const popLocalVars = () => {
        localVarStack.pop();
    };
    const isLocalVar = (varName) => {
        if (!varName) {
            return false;
        }
        for (const stackFrame of localVarStack) {
            if (stackFrame.has(varName)) {
                return true;
            }
        }
        return false;
    };
    return {
        getImports: () => importManager.getImportDeclarations(),
        cxt: {
            pushLocalVars,
            popLocalVars,
            isLocalVar,
            templateOptions,
            import: importManager.add.bind(importManager),
            siblings: undefined,
            currentNodeIndex: undefined,
        },
    };
}

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
// lwc:if/lwc:elseif/lwc:else use bookend comments due to VFragment vdom node using them
// The bookends should surround the entire if/elseif/else series
// Note: these should only be rendered if _something_ is rendered by a series of if/elseif/else's
function bYieldBookendComment() {
    return estreeToolkit.builders.expressionStatement(estreeToolkit.builders.yieldExpression(estreeToolkit.builders.literal(`<!---->`)));
}
function bBlockStatement(childNodes, cxt) {
    const childStatements = irChildrenToEs(childNodes, cxt);
    // Due to `flattenFragmentsInChildren`, we have to remove bookends for all _top-level_ slotted
    // content. This applies to both light DOM and shadow DOM slots, although light DOM slots have
    // the additional wrinkle that they themselves are VFragments with their own bookends.
    // https://github.com/salesforce/lwc/blob/a33b390/packages/%40lwc/engine-core/src/framework/rendering.ts#L718-L753
    const statements = cxt.isSlotted
        ? childStatements
        : [bYieldBookendComment(), ...childStatements, bYieldBookendComment()];
    return estreeToolkit.builders.blockStatement(optimizeAdjacentYieldStmts(statements));
}
function bIfStatement(ifElseIfNode, cxt) {
    const { children, condition, else: elseNode } = ifElseIfNode;
    let elseBlock = null;
    if (elseNode) {
        if (elseNode.type === 'ElseBlock') {
            elseBlock = bBlockStatement(elseNode.children, cxt);
        }
        else {
            elseBlock = bIfStatement(elseNode, cxt);
        }
    }
    return estreeToolkit.builders.ifStatement(expressionIrToEs(condition, cxt), bBlockStatement(children, cxt), elseBlock);
}
const IfBlock = function IfBlock(node, cxt) {
    return [bIfStatement(node, cxt)];
};

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const bThrowError = (esTemplate `
  throw new Error(${estreeToolkit.is.literal});
`);
const Root = function Root(node, cxt) {
    return irChildrenToEs(node.children, cxt);
};
const defaultTransformer = (node) => {
    throw new Error(`Unimplemented IR node: ${util.inspect(node)}`);
};
const transformers = {
    Comment,
    Component,
    Element,
    ExternalComponent: Element,
    ForEach,
    ForOf,
    If: LegacyIf,
    IfBlock,
    Root,
    Text,
    // lwc:elseif cannot exist without an lwc:if (IfBlock); this gets handled by that transformer
    ElseifBlock: defaultTransformer,
    // lwc:elseif cannot exist without an lwc:elseif (IfBlock); this gets handled by that transformer
    ElseBlock: defaultTransformer,
    ScopedSlotFragment: defaultTransformer,
    Slot,
    Lwc: LwcComponent,
};
function irChildrenToEs(children, cxt, cb) {
    const result = [];
    for (let i = 0; i < children.length; i++) {
        // must set the siblings inside the for loop due to nested children
        cxt.siblings = children;
        cxt.currentNodeIndex = i;
        const cleanUp = cb?.(children[i]);
        result.push(...irToEs(children[i], cxt));
        cleanUp?.();
    }
    // reset the context
    cxt.siblings = undefined;
    cxt.currentNodeIndex = undefined;
    return result;
}
function irToEs(node, cxt) {
    if ('directives' in node && node.directives.some((d) => d.name === 'Dynamic')) {
        return [
            bThrowError(estreeToolkit.builders.literal('The lwc:dynamic directive is not supported for SSR. Use <lwc:component> instead.')),
        ];
    }
    const transformer = transformers[node.type];
    return transformer(node, cxt);
}
function templateIrToEsTree(node, contextOpts) {
    const { getImports, cxt } = createNewContext(contextOpts);
    const statements = irToEs(node, cxt);
    return {
        addImport: cxt.import,
        getImports,
        statements,
    };
}

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
// TODO [#4663]: Render mode mismatch between template and compiler should throw.
const bExportTemplate = (esTemplate `
    export default async function* tmpl(
            shadowSlottedContent,
            lightSlottedContent,
            scopedSlottedContent,
            Cmp,
            instance
    ) {
        // Deliberately using let so we can mutate as many times as we want in the same scope.
        // These should be scoped to the "tmpl" function however, to avoid conflicts with other templates.
        let textContentBuffer = '';
        let didBufferTextContent = false;

        // This will get overridden but requires initialization.
        const slotAttributeValue = null;

        // Establishes a contextual relationship between two components for ContextProviders.
        // This variable will typically get overridden (shadowed) within slotted content.
        const contextfulParent = instance;

        const isLightDom = Cmp.renderMode === 'light';
        if (!isLightDom) {
            yield \`<template shadowrootmode="open"\${Cmp.delegatesFocus ? ' shadowrootdelegatesfocus' : ''}>\`
        }
        
        const { stylesheets: staticStylesheets } = Cmp;
        if (defaultStylesheets || defaultScopedStylesheets || staticStylesheets) {
            yield renderStylesheets(
                defaultStylesheets, 
                defaultScopedStylesheets, 
                staticStylesheets,
                stylesheetScopeToken, 
                Cmp, 
                hasScopedStylesheets,
            );
        }

        ${estreeToolkit.is.statement};

        if (!isLightDom) {
            yield '</template>';
            if (shadowSlottedContent) {
                // instance must be passed in; this is used to establish the contextful relationship
                // between context provider (aka parent component) and context consumer (aka slotted content)
                yield* shadowSlottedContent(contextfulParent);
            }
        }
    }
`);
function compileTemplate(src, filename, options, compilationMode) {
    const { root, warnings } = templateCompiler.parse(src, {
        // `options` is from @lwc/compiler, and may have flags that @lwc/template-compiler doesn't
        // know about, so we must explicitly extract the relevant props.
        name: options.name,
        namespace: options.namespace,
        customRendererConfig: options.customRendererConfig,
        experimentalComputedMemberExpression: options.experimentalComputedMemberExpression,
        experimentalComplexExpressions: options.experimentalComplexExpressions,
        enableDynamicComponents: options.enableDynamicComponents,
        preserveHtmlComments: options.preserveHtmlComments,
        enableStaticContentOptimization: options.enableStaticContentOptimization,
        instrumentation: options.instrumentation,
        apiVersion: options.apiVersion,
        disableSyntheticShadowSupport: options.disableSyntheticShadowSupport,
        // TODO [#3331]: remove usage of lwc:dynamic in 246
        experimentalDynamicDirective: options.experimentalDynamicDirective,
    });
    if (!root || warnings.length) {
        for (const warning of warnings) {
            // eslint-disable-next-line no-console
            console.error('Cannot compile:', warning.message);
        }
        // The legacy SSR implementation would not bail from compilation even if a
        // DiagnosticLevel.Fatal error was encountered. It would only fail if the
        // template parser failed to return a root node. That behavior is duplicated
        // here.
        if (!root) {
            throw new Error('Template compilation failure; see warnings in the console.');
        }
    }
    const preserveComments = !!root.directives.find((directive) => directive.name === 'PreserveComments')?.value?.value;
    const experimentalComplexExpressions = Boolean(options.experimentalComplexExpressions);
    const { addImport, getImports, statements } = templateIrToEsTree(root, {
        preserveComments,
        experimentalComplexExpressions,
    });
    addImport(['renderStylesheets', 'hasScopedStaticStylesheets']);
    for (const [imports, source] of getStylesheetImports(filename)) {
        addImport(imports, source);
    }
    const moduleBody = [...getImports(), bExportTemplate(optimizeAdjacentYieldStmts(statements))];
    let program = estreeToolkit.builders.program(moduleBody, 'module');
    addScopeTokenDeclarations(program, filename, options.namespace, options.name);
    if (compilationMode === 'async' || compilationMode === 'sync') {
        program = transmogrify(program, compilationMode);
    }
    return {
        code: astring.generate(program, {}),
    };
}

/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function compileComponentForSSR(src, filename, options, mode = shared.DEFAULT_SSR_MODE) {
    const tagName = shared.generateCustomElementTagName(options.namespace, options.name);
    const { code } = compileJS(src, filename, tagName, options, mode);
    return { code, map: undefined };
}
function compileTemplateForSSR(src, filename, options, mode = shared.DEFAULT_SSR_MODE) {
    const { code } = compileTemplate(src, filename, options, mode);
    return { code, map: undefined };
}

exports.compileComponentForSSR = compileComponentForSSR;
exports.compileTemplateForSSR = compileTemplateForSSR;
/** version: 8.13.1 */
//# sourceMappingURL=index.cjs.js.map
