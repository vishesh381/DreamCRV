import type { Node as EsNode } from 'estree';
import type { Checker } from 'estree-toolkit/dist/generated/is-type';
/** Placeholder value to use to opt out of validation. */
declare const NO_VALIDATION = false;
/** A function that accepts a node and checks that it is a particular type of node. */
type Validator<T extends EsNode | null = EsNode | null> = (node: EsNode | null | undefined) => node is T;
/**
 * A pointer to a previous value in the template literal, indicating that the value should be re-used.
 * @see {@linkcode esTemplate}
 */
type ValidatorReference = number;
/** A validator, validation opt-out, or reference to previously-used validator. */
type ValidatorPlaceholder<T extends EsNode | null> = Validator<T> | ValidatorReference | typeof NO_VALIDATION;
/** Extracts the type being validated from the validator function. */
type ValidatedType<T> = T extends Validator<infer V> ? T extends Checker<infer C> ? // estree validator
C | C[] : // custom validator
V | Array<NonNullable<V>> : T extends typeof NO_VALIDATION ? // no validation = broadest type possible
EsNode | EsNode[] | null : never;
/**
 * Converts the validators and refs used in the template to the list of parameters required by the
 * created template function. Removes back references to previous slots from the list.
 */
type ToReplacementParameters<Arr extends unknown[]> = Arr extends [infer Head, ...infer Rest] ? Head extends number ? ToReplacementParameters<Rest> : [
    ValidatedType<Head>,
    ...ToReplacementParameters<Rest>
] : [];
/**
 * Template literal tag that generates a builder function. Like estree's `builders`, but for more
 * complex structures. The template values should be estree `is` validators or a back reference to
 * a previous slot (to re-use the referenced value).
 *
 * To have the generated function return a particular node type, the generic comes _after_ the
 * template literal. Kinda weird, but it's necessary to infer the types of the template values.
 * (If it were at the start, we'd need to explicitly provide _all_ type params. Tedious!)
 * @example
 * const bSum = esTemplate`(${is.identifier}, ${is.identifier}) => ${0} + ${1}`<EsArrowFunctionExpression>
 * const sumFuncNode = bSum(b.identifier('a'), b.identifier('b'))
 * // `sumFuncNode` is an AST node representing `(a, b) => a + b`
 */
export declare function esTemplate<Validators extends ValidatorPlaceholder<EsNode | null>[]>(javascriptSegments: TemplateStringsArray, ...Validators: Validators): <RetType>(...replacementNodes: ToReplacementParameters<Validators>) => RetType;
/** Similar to {@linkcode esTemplate}, but supports `yield` expressions. */
export declare function esTemplateWithYield<Validators extends ValidatorPlaceholder<EsNode | null>[]>(javascriptSegments: TemplateStringsArray, ...validators: Validators): <RetType>(...replacementNodes: ToReplacementParameters<Validators>) => RetType;
export {};
//# sourceMappingURL=estemplate.d.ts.map