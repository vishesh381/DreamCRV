import type { TransformerContext } from './types';
import type { Attribute as IrAttribute, Node as IrNode, Property as IrProperty } from '@lwc/template-compiler';
import type { Expression as EsExpression, ObjectExpression as EsObjectExpression, Statement as EsStatement } from 'estree';
import type { ComplexExpression as IrComplexExpression, Expression as IrExpression, Literal as IrLiteral } from '@lwc/template-compiler';
export declare function optimizeAdjacentYieldStmts(statements: EsStatement[]): EsStatement[];
export declare function bAttributeValue(node: IrNode, attrName: string): EsExpression;
/**
 * Given an expression in a context, return an expression that may be scoped to that context.
 * For example, for the expression `foo`, it will typically be `instance.foo`, but if we're
 * inside a `for:each` block then the `foo` variable may refer to the scoped `foo`,
 * e.g. `<template for:each={foos} for:item="foo">`
 * @param expression
 * @param cxt
 */
export declare function getScopedExpression(expression: EsExpression, cxt: TransformerContext): EsExpression;
export declare function normalizeClassAttributeValue(value: string): string;
export declare function getChildAttrsOrProps(attrs: (IrAttribute | IrProperty)[], cxt: TransformerContext): EsObjectExpression;
/**
 * Determine if the provided node is of type Literal
 * @param node
 */
export declare function isLiteral(node: IrLiteral | IrExpression | IrComplexExpression): node is IrLiteral;
//# sourceMappingURL=shared.d.ts.map