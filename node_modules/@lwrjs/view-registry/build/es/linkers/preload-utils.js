import { LwrUnresolvableError, createSingleDiagnosticError, descriptions, logger } from '@lwrjs/diagnostics';
import { explodeSpecifier, getGroupName, getVersionedModuleId, normalizeVersionToUri, VERSION_NOT_PROVIDED, getSpecifier, isGroupie, } from '@lwrjs/shared-utils';
/**
 * keeps track of preloadModules metadata
 */
export function setPreloadModulesMeta(specifier, uri, integrity, groups, preloads) {
    // Throw a very specific error if we get this back and the uri property is not set
    if (!uri) {
        throw createSingleDiagnosticError({
            description: descriptions.UNRESOLVABLE.PRELOAD_MODULE(specifier),
        }, LwrUnresolvableError);
    }
    // We need to support version-less preloadModules, including version-less rootComponents.
    // Removing the "/v/version_not_provided" hack from the preloadModules specifier
    // because otherwise the loader will wait for that module that will never get defined.
    // TODO: remove pending W-12702948
    const [removedVersion, version] = specifier.split('/v/');
    const normalizedSpecifier = version === VERSION_NOT_PROVIDED ? removedVersion : specifier;
    specifier = normalizedSpecifier;
    const preloadModulesSpecifiers = preloads.specifiers;
    const preloadBundleGroupsMap = preloads.groups;
    const preloadModulesURIs = preloads.uris;
    const preloadModuleIntegrities = preloads.integrities;
    preloadModulesSpecifiers.push(specifier);
    const { specifier: unversionedSpecifier } = explodeSpecifier(specifier);
    const groupName = getGroupName(unversionedSpecifier, groups);
    if (groupName && preloadBundleGroupsMap.has(groupName)) {
        return;
    }
    // With bundling groups, we only want to include one URI
    preloadModulesURIs.push(uri);
    groupName && preloadBundleGroupsMap.set(groupName, true);
    preloadModuleIntegrities.set(uri, integrity);
}
/**
 * Recursively gets preloadModules metadata starting with a specifier
 * Note: don't call me unless you got bundles
 */
export async function getPreloadModulesMeta(specifier, // un-versioned specifier
viewPreloads, bundleConfig, moduleRegistry, defRegistry, runtimeEnvironment, runtimeParams, pending) {
    const { exclude = [], external = {}, groups = {} } = bundleConfig;
    const isExternal = function (rawSpecifier) {
        const { specifier } = explodeSpecifier(rawSpecifier);
        return Object.keys(external).includes(specifier);
    };
    const isExclude = function (specifier) {
        return exclude.includes(specifier);
    };
    if (isExternal(specifier)) {
        logger.warn({
            label: `view-registry`,
            message: `"${specifier}" is configured in both bundleConfig.externals and bootstrap.preloadModules. We are treating it as external.`,
        });
    }
    else {
        // eslint-disable-next-line no-await-in-loop
        const versionedModuleId = await getVersionedModuleId(specifier, moduleRegistry, runtimeParams); // TODO replace moduleRegistry with defRegistry
        const versionedModuleSpecifier = getSpecifier({
            specifier,
            version: normalizeVersionToUri(versionedModuleId.version),
        });
        const uri = 
        // eslint-disable-next-line no-await-in-loop
        await defRegistry.resolveModuleUri(versionedModuleId, runtimeEnvironment, runtimeParams);
        // fallback to un-versioned specifier if needed
        const normalizedSpecifier = versionedModuleId.version === VERSION_NOT_PROVIDED ? specifier : versionedModuleSpecifier;
        // Will set the integrity after loading the record below
        const preloadModuleRecord = await defRegistry.getModuleBundle(versionedModuleId, runtimeEnvironment, runtimeParams);
        const { integrity } = preloadModuleRecord;
        setPreloadModulesMeta(normalizedSpecifier, uri, integrity, groups, viewPreloads);
        if (exclude.length || Object.keys(groups).length) {
            const { imports } = preloadModuleRecord.bundleRecord;
            if (imports) {
                if (!pending) {
                    pending = new Map();
                }
                for (let i = 0; i < imports.length; i++) {
                    const imp = imports[i];
                    if (!pending.has(imp.specifier) &&
                        (isExclude(imp.specifier) || isGroupie(imp.specifier, groups))) {
                        pending.set(imp.specifier, true); // prevent dupe calls
                        // eslint-disable-next-line no-await-in-loop
                        await getPreloadModulesMeta(imp.specifier, viewPreloads, bundleConfig, moduleRegistry, defRegistry, runtimeEnvironment, runtimeParams, pending);
                    }
                }
            }
        }
    }
}
//# sourceMappingURL=preload-utils.js.map