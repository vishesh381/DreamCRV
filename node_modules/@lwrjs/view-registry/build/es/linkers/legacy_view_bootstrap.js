import { logger } from '@lwrjs/diagnostics';
import { kebabCaseToModuleSpecifier, getModuleGraphs, GraphDepth, getModuleUriPrefix, explodeSpecifier, isBundler, getHydrateDirective, isGroupie, isExternalSpecifier, isLocalDev, isLambdaEnv, } from '@lwrjs/shared-utils';
import { AppResourceEnum, getAppSpecifier } from '@lwrjs/app-service/identity';
import { addExternalScriptNonce, generateHtmlTag, getModuleResource, getModuleResourceByUri, getViewNonce, getModuleGraphCacheKey, } from '../utils.js';
import { flattenCustomElements, getBundleIntegrity, getViewBootstrapConfigurationResource, getViewHmrConfigurationResource, } from './utils.js';
import { setPreloadModulesMeta, getPreloadModulesMeta } from './preload-utils.js';
import { LRUCache } from 'lru-cache';
function includeIdFactory(bundleConfig) {
    return (moduleRef) => {
        // Do not bundle externals, including the loader module, which is auto bundled
        // with the shim + loader combo
        if (isExternalSpecifier(moduleRef.specifier, bundleConfig)) {
            // Do not include externals in the required imports but also return false to indicate it should not be in the bundle
            return false;
        }
        return true;
    };
}
// `getModuleGraphs` is very expensive and does not need to be recomputed every time.
// Note: we use the same cache key passed in from the top level view-registry for consistency
const moduleGraphsCache = new LRUCache({
    max: 500,
    dispose: (_value, key) => {
        if (isLambdaEnv()) {
            logger.warn(`Module graph evicted from cache ${key}`);
        }
        else {
            logger.verbose(`Module graph evicted from cache ${key}`);
        }
    },
});
const isRunningLocalDev = isLocalDev();
export async function getHtmlResources(view, viewParams, resourceContext) {
    const { runtimeEnvironment, runtimeParams, moduleRegistry, moduleBundler, resourceRegistry, viewMetadata, } = resourceContext;
    const { format, hmrEnabled, bundle, debug, minify } = runtimeEnvironment;
    const { customElements, serverData, serverDebug } = viewMetadata;
    const isAMD = format === 'amd';
    const { bundleConfig, unsafeEnableViewLinkCaching } = resourceContext;
    const { external = {}, exclude = [] } = bundleConfig;
    // Bundling groups is only supported in AMD for now
    const groups = isAMD ? bundleConfig.groups || {} : {};
    const enableModuleGraphsCache = unsafeEnableViewLinkCaching && !isRunningLocalDev && !process.env.NOCACHE;
    const getPreloadUri = function (rawSpecifier, uriMap) {
        const { specifier } = explodeSpecifier(rawSpecifier);
        // do not preload externals; this is the app's responsibility
        if (Object.keys(external).some((e) => specifier === e))
            return;
        const uri = uriMap[rawSpecifier];
        // if there is no uri for an exclude or groupie, they've been handled via another specifier
        // eg: if a bundle group has already been added to the URI map, its groups will not also be added
        if (!uri && (exclude.includes(specifier) || isGroupie(specifier, groups))) {
            // warn instead of throwing from setPreloadModulesMeta()
            logger.warn({
                label: 'view-registry',
                message: `Skipping preload of unknown static import: ${rawSpecifier}`,
            });
            return;
        }
        return uri;
    };
    const { id: appName, bootstrap: { services, module: bootstrapModule, preloadModules = [] } = {
        services: [],
        preloadModules: [],
    }, } = view;
    const defRegistry = bundle ? moduleBundler : moduleRegistry;
    const depth = isAMD
        ? { static: GraphDepth.ALL, dynamic: 1 }
        : { static: GraphDepth.NONE, dynamic: 0 };
    if (isAMD) {
        depth.includeId = includeIdFactory(bundleConfig);
    }
    // The Application Bootstrap (ABS) module resource is EITHER
    //      - configured as routes[x].bootstrap.module OR
    //      - defaulted as "@lwrjs/app-service/{appName}/module/{format}"
    const appIdentity = {
        appName,
        format: runtimeEnvironment.format,
        resourceType: AppResourceEnum.MODULE,
    };
    const bootstrapSpecifier = bootstrapModule || getAppSpecifier(appIdentity);
    /*
        Internal module and module dependency related resources used by the view to render view related components.
     */
    const moduleResources = [];
    /*
        External resources that the view depends. These resources include ones that an ViewDefinition client are required to load
        in order to view to begin initialization.
     */
    const requiredResources = [];
    /*
        Bootstrap configuration resources -- these resources are specifically exposed as bootstrap.resources in the RenderedViewRecord
     */
    const configResources = [];
    // Cache of visited module flattened graphs
    const visitedCache = new Map();
    // Collection of import URL metadata
    const imports = {};
    // Collection of root view component specifiers
    const rootComponents = [];
    // Collection of modules specifiers that MUST be loaded in the view
    const requiredAmdModules = [];
    // Collect preload modules metadata
    const viewPreloads = {
        uris: [],
        specifiers: [],
        groups: new Map(),
        integrities: new Map(),
    };
    // Determine if server side rendering view modules
    const isSSR = view.bootstrap?.ssr;
    // Determine the LWR client version
    const version = view.bootstrap?.lwrVersion;
    // Page level nonce for script tags
    const nonce = getViewNonce(viewParams);
    // ABS module and custom element references
    let bootstrapModuleRef, versionedSpecifier = bootstrapSpecifier;
    const customElementsRecords = [];
    const flattenedElements = flattenCustomElements(customElements, isSSR);
    const viewContainsLiveElements = !isSSR || flattenedElements.some(({ props }) => getHydrateDirective(props));
    if (viewContainsLiveElements) {
        // ------ AMD Required module resources
        if (isAMD) {
            // Keep shim format in sync with view_bootstrap.ts
            const shimBundle = debug || minify === false
                ? 'lwr-loader-shim-legacy.bundle.js'
                : 'lwr-loader-shim-legacy.bundle.min.js';
            let def = (await resourceRegistry.getResource({ specifier: shimBundle, version }, runtimeEnvironment, runtimeParams));
            if (!def) {
                // HACK: fallback to looking for the other shim.
                // TODO: remove this once KJ fixes W-15953000
                let fallbackShimBundle;
                if (shimBundle === 'lwr-loader-shim-legacy.bundle.js') {
                    fallbackShimBundle = 'lwr-loader-shim-legacy.bundle.min.js';
                    def = (await resourceRegistry.getResource({ specifier: fallbackShimBundle, version }, runtimeEnvironment, runtimeParams));
                }
                else {
                    fallbackShimBundle = 'lwr-loader-shim-legacy.bundle.js';
                    def = (await resourceRegistry.getResource({ specifier: fallbackShimBundle, version }, runtimeEnvironment, runtimeParams));
                }
                // throw if we still can't find it
                if (!def) {
                    throw Error('Failed to find definition of resource: ' + shimBundle);
                }
            }
            // Throw a very specific error if we get this back and the src or inline properties are not set
            if (!def.inline && !def.src) {
                throw Error(`Invalid Shim ${shimBundle}: ${JSON.stringify(def)}`);
            }
            addExternalScriptNonce(def, nonce);
            requiredResources.push(def);
            // Always inline the error shim script after the shim
            const errorShimDef = (await resourceRegistry.getResource({ specifier: 'lwr-error-shim.js', version }, runtimeEnvironment, 
            // Hack there is only a prod version of the error shim  so forcing ignore debug
            // So we never check the debug metadata
            { ...runtimeParams, ignoreDebug: true }));
            if (!errorShimDef) {
                throw Error('Failed to find definition of resource: lwr-error-shim.js');
            }
            // Throw a very specific error if we get this back and the src or inline properties are not set
            if (!errorShimDef.inline && !errorShimDef.src) {
                throw Error(`Invalid Shim lwr-error-shim.js: ${JSON.stringify(errorShimDef)}`);
            }
            addExternalScriptNonce(errorShimDef, nonce);
            requiredResources.push(errorShimDef);
        }
        // ------- Application Bootstrap module
        // Traversal of the Bootstrap Module Graph is done to get all the URLS for discoverable static dependencies.
        // Reasoning: This is to avoid unnecessary HTTP 302's during initial application module fetching.
        // Scope: ESM currently only exposes immutable URI references, optimize for AMD formats
        let bootstrapModuleGraph;
        // Just determine the cache key based on the inputs to the getModuleGraphs
        const bootstrapModuleGraphCacheKey = getModuleGraphCacheKey(bootstrapSpecifier, runtimeEnvironment, runtimeParams);
        if (enableModuleGraphsCache && moduleGraphsCache.has(bootstrapModuleGraphCacheKey)) {
            bootstrapModuleGraph = moduleGraphsCache.get(bootstrapModuleGraphCacheKey);
        }
        else {
            bootstrapModuleGraph = await getModuleGraphs(bootstrapSpecifier, { includeUris: true, includeLinkedDefinitions: true, depth }, moduleRegistry, defRegistry, runtimeEnvironment, runtimeParams, visitedCache);
            enableModuleGraphsCache &&
                moduleGraphsCache.set(bootstrapModuleGraphCacheKey, bootstrapModuleGraph);
        }
        bootstrapModuleRef = {
            specifier: bootstrapModuleGraph.graphs[0].specifier,
            flatGraph: bootstrapModuleGraph,
            resources: configResources,
        };
        // ADD bootstrap module uri as a script resource
        versionedSpecifier = bootstrapModuleGraph.graphs[0].specifier;
        const uri = bootstrapModuleGraph.uriMap[versionedSpecifier];
        // Throw a very specific error if we get this back and the uri property is not set
        if (!uri) {
            throw Error(`Invalid Module Resource ${versionedSpecifier}`);
        }
        const integrity = getBundleIntegrity(bootstrapModuleGraph, versionedSpecifier);
        moduleResources.push(getModuleResourceByUri(uri, runtimeEnvironment, { integrity, isPreload: false, isSSR, nonce }));
        // PRELOAD the bootstrap module static dependencies as preloaded script resources
        for (const depSpecifier of bootstrapModuleGraph.graphs[0].static) {
            const uri = getPreloadUri(depSpecifier, bootstrapModuleGraph.uriMap);
            if (uri) {
                const integrity = getBundleIntegrity(bootstrapModuleGraph, depSpecifier);
                setPreloadModulesMeta(depSpecifier, uri, integrity, groups, viewPreloads);
            }
        }
        // PRELOAD configured preloadModules as preloaded script resources
        if (isBundler(defRegistry)) {
            for (const specifier of preloadModules) {
                // eslint-disable-next-line no-await-in-loop
                await getPreloadModulesMeta(specifier, viewPreloads, bundleConfig, moduleRegistry, defRegistry, runtimeEnvironment, runtimeParams);
            }
        }
        if (isAMD) {
            // ADD bootstrap module as required
            requiredAmdModules.push(versionedSpecifier);
            // AMD ADD bootstrap module uri addressability
            imports[versionedSpecifier] = uri;
            // PRELOAD bootstrap module static deps as link resource
            for (const staticDep of bootstrapModuleGraph.graphs[0].static) {
                const uri = bootstrapModuleGraph.uriMap[staticDep];
                // AMD ADD static module dep uri addressability
                imports[staticDep] = uri;
                // ADD bootstrap module static deps to requiredAmdModules if services, otherwise preloadModules
                if (services?.length) {
                    requiredAmdModules.push(staticDep);
                }
            }
            // AMD Add import mappings for known dynamic imports
            for (const dynamicDep of bootstrapModuleGraph.graphs[0].dynamicRefs) {
                const uri = bootstrapModuleGraph.uriMap[dynamicDep];
                if (uri) {
                    imports[dynamicDep] = uri;
                }
                else {
                    logger.warn({
                        label: `view-registry`,
                        message: `Skipping unknown dynamic import: ${dynamicDep}`,
                    });
                }
            }
        }
    }
    // ------- View related custom element moduleResources
    await Promise.all(flattenedElements.map(async ({ tagName: element, props }) => {
        const hydrateDirective = getHydrateDirective(props);
        const isSsrOnly = isSSR && !hydrateDirective;
        const elementSpecifier = kebabCaseToModuleSpecifier(element);
        const moduleGraphCacheKey = getModuleGraphCacheKey(elementSpecifier, runtimeEnvironment, {
            ...runtimeParams,
            ssr: isSsrOnly,
        });
        let graph;
        if (enableModuleGraphsCache && moduleGraphsCache.has(moduleGraphCacheKey)) {
            graph = moduleGraphsCache.get(moduleGraphCacheKey);
        }
        else {
            graph = await getModuleGraphs(elementSpecifier, { includeUris: true, includeLinkedDefinitions: true, depth }, moduleRegistry, defRegistry, runtimeEnvironment, { ...runtimeParams, ssr: isSsrOnly }, visitedCache);
            enableModuleGraphsCache && moduleGraphsCache.set(moduleGraphCacheKey, graph);
        }
        // add to the viewRecord
        customElementsRecords.push({ elementName: element, flatGraph: graph });
        // Only process custom elements that are to be hydrated or are CSR-only islands
        if (!isSSR || getHydrateDirective(props)) {
            // PRELOAD the custom element module as a link resource
            const specifier = graph.graphs[0].specifier;
            const uri = graph.uriMap[specifier];
            const integrity = getBundleIntegrity(graph, specifier);
            setPreloadModulesMeta(specifier, uri, integrity, groups, viewPreloads);
            // PRELOAD custom element static deps as link resources when bundling is ON
            if (bundle) {
                for (const depSpecifier of graph.graphs[0].static) {
                    const depUri = getPreloadUri(depSpecifier, graph.uriMap);
                    if (depUri) {
                        const integrity = getBundleIntegrity(graph, depSpecifier);
                        setPreloadModulesMeta(depSpecifier, depUri, integrity, groups, viewPreloads);
                    }
                }
            }
            // ADD register custom elements as a uri addressable rootComponents
            rootComponents.push(specifier);
            imports[specifier] = uri;
            if (isAMD) {
                for (const staticDep of graph.graphs[0].static) {
                    const uri = graph.uriMap[staticDep];
                    // AMD ADD static module dep uri addressability
                    imports[staticDep] = uri;
                }
                // AMD ADD dynamic imports module dep uri addressability
                for (const dynamicDep of graph.graphs[0].dynamicRefs) {
                    const uri = graph.uriMap[dynamicDep];
                    imports[dynamicDep] = uri;
                }
            }
        }
    }));
    if (viewContainsLiveElements || serverDebug?.message) {
        if (isLocalDev()) {
            // ADD the client-side bootstrap module and mapping for local-dev
            const localDevSpecifier = 'lwr_local_dev/bootstrap';
            rootComponents.push(localDevSpecifier);
            const localDevMod = await getModuleResource({ specifier: localDevSpecifier, version: '' }, runtimeEnvironment, {}, moduleRegistry, runtimeParams);
            if (localDevMod.src)
                imports[localDevSpecifier] = localDevMod.src;
        }
        // ADD configuration of the bootstrapModule
        configResources.unshift(getViewBootstrapConfigurationResource({
            id: view.id,
            url: viewParams?.page?.url,
            configAsSrc: view.bootstrap?.configAsSrc || false,
            mixedMode: view.bootstrap?.mixedMode || false,
            nonce: viewParams?.page?.nonce,
            ssr: view.bootstrap?.ssr || false,
        }, {
            appId: appIdentity.appName,
            bootstrapModule: versionedSpecifier,
            autoBoot: view.bootstrap?.autoBoot === false ? false : true,
            importMappings: {
                imports,
                default: getModuleUriPrefix(runtimeEnvironment, runtimeParams),
            },
            rootComponents,
            serverData,
            ...(isAMD && { requiredModules: requiredAmdModules }),
            // in AMD we need to tell the loader what modules we are preloading
            ...(isAMD && { preloadModules: viewPreloads.specifiers }),
        }, runtimeEnvironment, runtimeParams, serverDebug?.message));
    }
    if (!isAMD && hmrEnabled) {
        configResources.unshift(getViewHmrConfigurationResource(view, viewMetadata));
    }
    const dedupedUris = [...new Set(viewPreloads.uris)];
    // PRELOAD script resources for preload module URIs after the bootstrap module
    for (const preloadUri of dedupedUris) {
        const integrity = viewPreloads.integrities.get(preloadUri);
        moduleResources.push(getModuleResourceByUri(preloadUri, runtimeEnvironment, {
            integrity,
            isPreload: true,
            isSSR,
            nonce,
        }));
    }
    // generate html partial
    const htmlResources = await Promise.all([...configResources, ...requiredResources, ...moduleResources].map(generateHtmlTag));
    return {
        partial: htmlResources.join('\n'),
        viewRecord: {
            resources: requiredResources,
            customElements: customElementsRecords,
            moduleResources,
            bootstrapModule: bootstrapModuleRef,
        },
    };
}
//# sourceMappingURL=legacy_view_bootstrap.js.map