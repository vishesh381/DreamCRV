import { logger } from '@lwrjs/diagnostics';
import { kebabCaseToModuleSpecifier, toImportMetadata, getModuleGraphs, getMappingUriPrefix, GraphDepth, explodeSpecifier, isBundler, getHydrateDirective, isGroupie, isLocalDev, isLambdaEnv, } from '@lwrjs/shared-utils';
import { LRUCache } from 'lru-cache';
import { AppResourceEnum, getAppSpecifier } from '@lwrjs/app-service/identity';
import { addExternalScriptNonce, generateHtmlTag, getModuleResourceByUri, getViewNonce } from '../utils.js';
import { flattenCustomElements, getBundleIntegrity, getViewBootstrapConfigurationResource, getViewHmrConfigurationResource, } from './utils.js';
import { getModuleGraphCacheKey } from '../utils.js';
import { setPreloadModulesMeta, getPreloadModulesMeta } from './preload-utils.js';
// `getModuleGraphs` is very expensive and does not need to be recomputed every time.
// Note: we use the same cache key passed in from the top level view-registry for consistency
const moduleGraphsCache = new LRUCache({
    max: 500,
    dispose: (_value, key) => {
        if (isLambdaEnv()) {
            logger.warn(`Module graph evicted from cache ${key}`);
        }
        else {
            logger.verbose(`Module graph evicted from cache ${key}`);
        }
    },
});
const isRunningLocalDev = isLocalDev();
export async function getHtmlResources(view, viewParams, resourceContext) {
    const { runtimeEnvironment, runtimeParams, moduleRegistry, moduleBundler, resourceRegistry, viewMetadata, } = resourceContext;
    const { format, hmrEnabled, bundle, debug, minify } = runtimeEnvironment;
    const { customElements, serverData, serverDebug } = viewMetadata;
    const defRegistry = bundle ? moduleBundler : moduleRegistry;
    const isAMD = format === 'amd';
    const depth = isAMD
        ? { static: GraphDepth.ALL, dynamic: 1 }
        : { static: GraphDepth.NONE, dynamic: 1 };
    const { bundleConfig, unsafeEnableViewLinkCaching } = resourceContext;
    const { external = {}, exclude = [] } = bundleConfig;
    // Bundling groups is only supported in AMD for now
    const groups = isAMD ? bundleConfig.groups || {} : {};
    const enableModuleGraphsCache = unsafeEnableViewLinkCaching && !isRunningLocalDev && !process.env.NOCACHE;
    const getPreloadUri = function (rawSpecifier, uriMap) {
        const { specifier } = explodeSpecifier(rawSpecifier);
        if (Object.keys(external).some((e) => specifier === e))
            return;
        const uri = uriMap[rawSpecifier];
        if (!uri && (exclude.includes(specifier) || isGroupie(specifier, groups))) {
            // warn instead of throwing from setPreloadModulesMeta()
            logger.warn({
                label: 'view-registry',
                message: `Skipping preload of unknown static import: ${rawSpecifier}`,
            });
            return;
        }
        return uri;
    };
    const { id: appName, bootstrap: { services, module: bootstrapModule, preloadModules = [] } = {
        services: [],
        preloadModules: [],
    }, } = view;
    // The Application Bootstrap (ABS) module resource is EITHER
    //      - configured as routes[x].bootstrap.module OR
    //      - defaulted as "@lwrjs/app-service/{appName}/module/{format}"
    const appIdentity = {
        appName,
        format: runtimeEnvironment.format,
        resourceType: AppResourceEnum.MODULE,
    };
    const bootstrapSpecifier = bootstrapModule || getAppSpecifier(appIdentity);
    /*
        Internal module and module dependency related resources used by the view to render view related components.
     */
    const moduleResources = [];
    /*
        External resources that the view depends. These resources include ones that an ViewDefinition client are required to load
        in order to view to begin initialization.
     */
    const requiredResources = [];
    /*
        Bootstrap configuration resources -- these resources are specifically exposed as bootstrap.resources in the RenderedViewRecord
     */
    const configResources = [];
    // Cache of visited module flattened graphs
    const visitedCache = new Map();
    // Collection of import URL metadata
    const imports = {};
    // Collection of root view component specifiers
    const rootComponents = [];
    // Collection of modules specifiers that MUST be loaded in the view
    const requiredAmdModules = [];
    // Collect preload modules metadata
    const viewPreloads = {
        uris: [],
        specifiers: [],
        groups: new Map(),
        integrities: new Map(),
    };
    // Determine if server side rendering view modules
    const isSSR = view.bootstrap?.ssr;
    // Determine the LWR client version
    const version = view.bootstrap?.lwrVersion;
    // Page level nonce for script tags
    const nonce = getViewNonce(viewParams);
    // ABS module and custom element references
    let bootstrapModuleRef, versionedSpecifier = bootstrapSpecifier;
    let importMetadata = { imports: {} };
    const customElementsRecords = [];
    const flattenedElements = flattenCustomElements(customElements, isSSR);
    const viewContainsLiveElements = !isSSR || flattenedElements.some(({ props }) => getHydrateDirective(props));
    if (viewContainsLiveElements) {
        // ------ AMD Required module resources
        if (isAMD) {
            // Keep shim format in sync with legacy_view_bootstrap.ts
            const shimBundle = debug || minify === false ? 'lwr-loader-shim.bundle.js' : 'lwr-loader-shim.bundle.min.js';
            const def = (await resourceRegistry.getResource({ specifier: shimBundle, version }, runtimeEnvironment, runtimeParams));
            if (!def) {
                throw Error('Failed to find definition of resource: ' + shimBundle);
            }
            // Throw a very specific error if we get this back and the src or inline properties are not set
            if (!def.inline && !def.src) {
                throw Error(`Invalid Shim ${shimBundle}: ${JSON.stringify(def)}`);
            }
            addExternalScriptNonce(def, nonce);
            requiredResources.push(def);
            // Always inline the error shim script after the shim
            const errorShimDef = (await resourceRegistry.getResource({ specifier: 'lwr-error-shim.js', version }, runtimeEnvironment, 
            // Hack there is only a prod version of the error shim  so forcing ignore debug
            // So we never check the debug metadata
            { ...runtimeParams, ignoreDebug: true }));
            if (!errorShimDef) {
                throw Error('Failed to find definition of resource: lwr-error-shim.js');
            }
            // Throw a very specific error if we get this back and the src or inline properties are not set
            if (!errorShimDef.inline && !errorShimDef.src) {
                throw Error(`Invalid Shim lwr-error-shim.js: ${JSON.stringify(errorShimDef)}`);
            }
            addExternalScriptNonce(errorShimDef, nonce);
            requiredResources.push(errorShimDef);
        }
        // ------- Application Bootstrap module
        // Traversal of the Bootstrap Module Graph is done to get all the URLS for discoverable static dependencies.
        // Reasoning: This is to avoid unnecessary HTTP 302's during initial application module fetching.
        let bootstrapModuleGraph;
        // Just determine the cache key based on the inputs to the getModuleGraphs
        const bootstrapModuleGraphCacheKey = getModuleGraphCacheKey(bootstrapSpecifier, runtimeEnvironment, runtimeParams);
        if (enableModuleGraphsCache && moduleGraphsCache.has(bootstrapModuleGraphCacheKey)) {
            bootstrapModuleGraph = moduleGraphsCache.get(bootstrapModuleGraphCacheKey);
        }
        else {
            bootstrapModuleGraph = await getModuleGraphs(bootstrapSpecifier, { includeUris: true, includeLinkedDefinitions: true, depth }, moduleRegistry, defRegistry, runtimeEnvironment, runtimeParams, visitedCache);
            enableModuleGraphsCache &&
                moduleGraphsCache.set(bootstrapModuleGraphCacheKey, bootstrapModuleGraph);
        }
        bootstrapModuleRef = {
            specifier: bootstrapModuleGraph.graphs[0].specifier,
            flatGraph: bootstrapModuleGraph,
            resources: configResources,
        };
        // ADD bootstrap module uri as a script resource
        versionedSpecifier = bootstrapModuleGraph.graphs[0].specifier;
        const uri = bootstrapModuleGraph.uriMap[versionedSpecifier];
        // Throw a very specific error if we get this back and the uri property is not set
        if (!uri) {
            throw Error(`Invalid Module Resource ${versionedSpecifier}`);
        }
        const integrity = getBundleIntegrity(bootstrapModuleGraph, versionedSpecifier);
        moduleResources.push(getModuleResourceByUri(uri, runtimeEnvironment, { integrity, isPreload: false, isSSR, nonce }));
        // PRELOAD the bootstrap module static dependencies as preloaded script resources
        for (const depSpecifier of bootstrapModuleGraph.graphs[0].static) {
            const uri = getPreloadUri(depSpecifier, bootstrapModuleGraph.uriMap);
            if (uri) {
                const integrity = getBundleIntegrity(bootstrapModuleGraph, depSpecifier);
                setPreloadModulesMeta(depSpecifier, uri, integrity, groups, viewPreloads);
            }
        }
        // PRELOAD configured preloadModules as preloaded script resources
        if (isBundler(defRegistry)) {
            for (const specifier of preloadModules) {
                // eslint-disable-next-line no-await-in-loop
                await getPreloadModulesMeta(specifier, viewPreloads, bundleConfig, moduleRegistry, defRegistry, runtimeEnvironment, runtimeParams);
            }
        }
        if (isAMD) {
            // ADD bootstrap module as required
            requiredAmdModules.push(versionedSpecifier);
            // ADD bootstrap module uri addressability
            imports[versionedSpecifier] = uri;
            // PRELOAD bootstrap module static deps as link resource
            for (const staticDep of bootstrapModuleGraph.graphs[0].static) {
                const uri = bootstrapModuleGraph.uriMap[staticDep];
                // ADD static module dep uri addressability
                imports[staticDep] = uri;
                // ADD bootstrap module static deps to requiredAmdModules if services, otherwise preloadModules
                if (services?.length) {
                    requiredAmdModules.push(staticDep);
                }
            }
            // Add import mappings for known dynamic imports
            for (const dynamicDep of bootstrapModuleGraph.graphs[0].dynamicRefs) {
                const uri = bootstrapModuleGraph.uriMap[dynamicDep];
                if (uri) {
                    imports[dynamicDep] = uri;
                }
                else {
                    logger.warn({
                        label: `view-registry`,
                        message: `Skipping unknown dynamic import: ${dynamicDep}`,
                    });
                }
            }
        }
        importMetadata = await toImportMetadata(bootstrapModuleGraph, { imports: {}, index: {} }, moduleRegistry, runtimeEnvironment, runtimeParams);
    }
    // ------- View related custom element moduleResources
    for (const { tagName: element, props } of flattenedElements) {
        const hydrateDirective = getHydrateDirective(props);
        const isSsrOnly = isSSR && !hydrateDirective;
        const elementSpecifier = kebabCaseToModuleSpecifier(element);
        const moduleGraphCacheKey = getModuleGraphCacheKey(elementSpecifier, runtimeEnvironment, {
            ...runtimeParams,
            ssr: isSsrOnly,
        });
        let graph;
        if (enableModuleGraphsCache && moduleGraphsCache.has(moduleGraphCacheKey)) {
            graph = moduleGraphsCache.get(moduleGraphCacheKey);
        }
        else {
            // eslint-disable-next-line no-await-in-loop
            graph = await getModuleGraphs(elementSpecifier, { includeUris: true, includeLinkedDefinitions: true, depth }, moduleRegistry, defRegistry, runtimeEnvironment, { ...runtimeParams, ssr: isSsrOnly }, visitedCache);
            enableModuleGraphsCache && moduleGraphsCache.set(moduleGraphCacheKey, graph);
        }
        // add to the viewRecord
        customElementsRecords.push({ elementName: element, flatGraph: graph });
        // Only process custom elements that are to be hydrated or are CSR-only islands
        if (!isSSR || getHydrateDirective(props)) {
            // PRELOAD the custom element module as a link resource
            const specifier = graph.graphs[0].specifier;
            const uri = graph.uriMap[specifier];
            const integrity = getBundleIntegrity(graph, specifier);
            setPreloadModulesMeta(specifier, uri, integrity, groups, viewPreloads);
            // PRELOAD custom element static deps as link resources when bundling is ON
            if (bundle) {
                for (const depSpecifier of graph.graphs[0].static) {
                    const depUri = getPreloadUri(depSpecifier, graph.uriMap);
                    if (depUri) {
                        const integrity = getBundleIntegrity(graph, depSpecifier);
                        setPreloadModulesMeta(depSpecifier, depUri, integrity, groups, viewPreloads);
                    }
                }
            }
            // ADD register custom elements as a uri addressable rootComponents
            rootComponents.push(specifier);
            imports[specifier] = uri;
            if (isAMD) {
                for (const staticDep of graph.graphs[0].static) {
                    const uri = graph.uriMap[staticDep];
                    // AMD ADD static module dep uri addressability
                    imports[staticDep] = uri;
                }
                // AMD ADD dynamic imports module dep uri addressability
                for (const dynamicDep of graph.graphs[0].dynamicRefs) {
                    const uri = graph.uriMap[dynamicDep];
                    imports[dynamicDep] = uri;
                }
            }
            // eslint-disable-next-line no-await-in-loop
            importMetadata = await toImportMetadata(graph, importMetadata, moduleRegistry, runtimeEnvironment, runtimeParams);
        }
    }
    if (viewContainsLiveElements || serverDebug?.message) {
        // ADD configuration of the bootstrapModule
        configResources.unshift(getViewBootstrapConfigurationResource({
            id: view.id,
            url: viewParams?.page?.url,
            configAsSrc: view.bootstrap?.configAsSrc || false,
            mixedMode: view.bootstrap?.mixedMode || false,
            nonce: viewParams?.page?.nonce,
            ssr: view.bootstrap?.ssr || false,
        }, {
            appId: appIdentity.appName,
            bootstrapModule: versionedSpecifier,
            autoBoot: view.bootstrap?.autoBoot === false ? false : true,
            imports: importMetadata?.imports,
            index: importMetadata?.index,
            rootComponents,
            serverData,
            ...(isAMD && { requiredModules: requiredAmdModules }),
            // in AMD we need to tell the loader what modules we are preloading
            ...(isAMD && { preloadModules: viewPreloads.specifiers }),
        }, runtimeEnvironment, runtimeParams, serverDebug?.message));
    }
    if (!isAMD && hmrEnabled) {
        configResources.unshift(getViewHmrConfigurationResource(view, viewMetadata));
    }
    // PRELOAD script resources for preload module URIs after the bootstrap module
    const dedupedUris = [...new Set(viewPreloads.uris)];
    for (const preloadUri of dedupedUris) {
        const integrity = viewPreloads.integrities.get(preloadUri);
        moduleResources.push(getModuleResourceByUri(preloadUri, runtimeEnvironment, {
            integrity,
            isPreload: true,
            isSSR,
            nonce,
        }));
    }
    // generate html partial
    const htmlResources = await Promise.all([...configResources, ...requiredResources, ...moduleResources].map(generateHtmlTag));
    const mapping = getMappingUriPrefix(runtimeEnvironment, runtimeParams);
    const endpoints = {
        uris: {
            mapping,
        },
    };
    return {
        partial: htmlResources.join('\n'),
        viewRecord: {
            resources: requiredResources,
            customElements: customElementsRecords,
            endpoints,
            importMetadata,
            moduleResources,
            bootstrapModule: bootstrapModuleRef,
        },
    };
}
//# sourceMappingURL=view_bootstrap.js.map