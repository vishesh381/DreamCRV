import { buildEnvironmentContext, getMappingUriPrefix, getModuleUriPrefix, getClientBootstrapConfigurationUri, hashContent, } from '@lwrjs/shared-utils';
const CONTENT_TYPE = 'application/javascript';
export function getViewBootstrapConfigurationResource(viewInfo, config, runtimeEnvironment, runtimeParams, debugMessage) {
    const { compat, debug, hmrEnabled, apiVersion, format } = runtimeEnvironment;
    const isESM = format === 'esm';
    const defaultUrl = getModuleUriPrefix(runtimeEnvironment, runtimeParams);
    const mapping = getMappingUriPrefix(runtimeEnvironment, runtimeParams);
    const endpoints = {
        uris: {
            mapping,
            // TODO: DBL Should the ESM rely directly on the module endpoint?  why not use the mapping endpoint as well?
            ...(isESM && { module: defaultUrl }),
            ...(isESM &&
                hmrEnabled && {
                hmr: `/${apiVersion}/hmr/${format}/${compat}?${debug ? 'debug=true' : ''}`,
            }),
        },
        ...(debug && { modifiers: { debug: 'true' } }),
    };
    const nodeEnv = {
        // TODO: W-12639529 change NODE_ENV after addressing downstream customers
        NODE_ENV: runtimeEnvironment.serverMode,
    };
    const lwrEnv = {
        // Note: SSR is always false because this script is executed on the client
        SSR: false,
        // Used by `lwr/environment`
        ...buildEnvironmentContext(runtimeParams),
    };
    const configString = [
        '/* This script is generated */',
        '/* Client Bootstrap configuration */',
        `globalThis.LWR = globalThis.LWR || {};`,
        `Object.assign(globalThis.LWR, ${JSON.stringify({
            ...config,
            endpoints,
        })});`,
        `globalThis.LWR = {...globalThis.LWR, env: ${JSON.stringify(lwrEnv)}};`,
        `globalThis.process={...globalThis.process,env:{...globalThis.process?.env,...${JSON.stringify(nodeEnv)}}};`,
        // TODO: evaluate moving these to app layer
        `globalThis.lwcRuntimeFlags = { ENABLE_MIXED_SHADOW_MODE: ${viewInfo.mixedMode}, ENABLE_WIRE_SYNC_EMIT: ${viewInfo.ssr} };`,
        debug && debugMessage && `console.error(${JSON.stringify(debugMessage)});`,
    ]
        .filter(Boolean)
        .join('\n');
    if (viewInfo.configAsSrc) {
        const viewUrl = viewInfo.url || '/';
        const url = getClientBootstrapConfigurationUri({ id: viewInfo.id, url: viewUrl, query: runtimeParams.query }, runtimeEnvironment, runtimeParams, hashContent(configString));
        return {
            type: CONTENT_TYPE,
            content: configString,
            inline: false,
            // TODO do not create an integrity for config as src.  We modify this script
            // for HMR and fingerprints
            // integrity: createIntegrityHash(configString),
            nonce: viewInfo.nonce,
            src: url,
        };
    }
    else {
        return {
            type: CONTENT_TYPE,
            content: configString,
            inline: true,
        };
    }
}
export function getViewHmrConfigurationResource(view, viewMetadata) {
    const { assetReferences } = viewMetadata;
    const { contentTemplate, layoutTemplate } = view;
    const refs = assetReferences.map((assetReference) => {
        if (assetReference.override) {
            return assetReference.override?.entry;
        }
    });
    const configString = [
        `
        /* generated View/HMR debug script */
        globalThis._lwrRuntimeDebug = {
            viewMetadata: {
                assetReferences: ${JSON.stringify(refs)},
                templates: ${JSON.stringify([contentTemplate, layoutTemplate].filter(Boolean))}
            }
        }
        `,
    ]
        .filter(Boolean)
        .join('\n');
    // Return an inline resource
    return {
        type: CONTENT_TYPE,
        inline: true,
        content: configString,
    };
}
export function flattenCustomElements(arr, isSSR = false) {
    const ret = [];
    const visitedTags = new Set();
    function flatten(arr) {
        for (const val of arr) {
            const { tagName, children, props } = val;
            if (!visitedTags.has(tagName)) {
                if (isSSR) {
                    ret.push({ tagName, props });
                }
                else {
                    ret.push({ tagName });
                }
                visitedTags.add(tagName);
            }
            if (children) {
                flatten(children);
            }
        }
    }
    flatten(arr);
    return ret;
}
export function getBundleIntegrity(bootstrapModuleGraph, versionedSpecifier) {
    const def = bootstrapModuleGraph.linkedDefinitions[versionedSpecifier];
    const integrity = def?.integrity;
    return integrity;
}
//# sourceMappingURL=utils.js.map