import { basename, extname } from 'path';
import { explodeSpecifier, getMappingUriPrefix, getSpecifier, getClientBootstrapConfigurationUri, mimeLookup, DEFAULT_TITLE, streamToString, getFeatureFlags, getCacheKeyFromJson, } from '@lwrjs/shared-utils';
import { AppResourceEnum, getAppSpecifier, ResourceIdentityTypes, } from '@lwrjs/app-service/identity';
import crypto from 'crypto';
function generateExternalStyle(src) {
    return `<link rel="stylesheet" href="${src}">`;
}
function generateExternalScript(type = 'application/javascript', src, async, defer, nonce, integrity) {
    // add script loader order attribute
    let scriptLoadOrder = '';
    if (defer) {
        scriptLoadOrder = ' defer';
    }
    else if (async) {
        scriptLoadOrder = ' async';
    }
    // add the right CSP header attribute
    let cspHashAttr = '';
    // For now use the ENABLE_NONCE to gate adding nonce or integrity
    // W-15868505 is open to create a better config
    if (getFeatureFlags().ENABLE_NONCE) {
        if (integrity) {
            cspHashAttr = ` integrity="${integrity}"`;
        }
        else if (nonce) {
            cspHashAttr = ` nonce="${nonce}"`;
        }
    }
    return `<script type="${type}"${scriptLoadOrder}${cspHashAttr} src="${src}"></script>`;
}
function generateLinkPreloadTag({ href, type }) {
    if (type === 'module') {
        return `<link rel="modulepreload" href="${href}" />`;
    }
    else {
        return `<link rel="preload" href="${href}" type="${type}" />`;
    }
}
function generateExternalTag({ type, src = '', async, defer, isPreload, nonce, integrity, }) {
    if (isPreload) {
        return generateLinkPreloadTag({ href: src, type: type });
    }
    else if (type === 'text/css') {
        return generateExternalStyle(src);
    }
    else {
        return generateExternalScript(type, src, async, defer, nonce, integrity);
    }
}
async function generateInlineTag({ specifier, type, content, stream, nonce }) {
    const typeStr = type === 'text/css' ? '' : ` type="${type}"`;
    const tag = type === 'text/css' ? 'style' : 'script';
    const nonceStr = getFeatureFlags().ENABLE_NONCE && nonce && nonce ? ` nonce="${nonce}"` : '';
    if (!content && !stream) {
        throw new Error(`Invalid inline Resource Definition: must have either "content" or "stream": "${specifier}"`);
    }
    const code = stream ? await streamToString(stream()) : content;
    return `<${tag}${typeStr}${nonceStr}>${code}</${tag}>`;
}
export async function generateHtmlTag(definition) {
    if (definition.inline) {
        return await generateInlineTag(definition);
    }
    else if (definition.src) {
        return generateExternalTag(definition);
    }
    throw new Error(`Invalid external Resource Definition: missing a "src": "${definition.specifier}"`);
}
export function normalizeRenderedResult({ renderedView, metadata, options, cache, status, }) {
    return {
        renderedView,
        metadata: {
            customElements: metadata ? metadata.customElements : [],
            assetReferences: metadata ? metadata.assetReferences : [],
            serverBundles: metadata ? metadata.serverBundles : new Set(),
            serverData: metadata ? metadata.serverData : {},
            serverDebug: metadata ? metadata.serverDebug : {},
        },
        options: {
            skipMetadataCollection: options ? options.skipMetadataCollection : false,
        },
        cache: cache || {},
        status,
    };
}
export function reduceSourceAssetReferences(assets) {
    return assets.map(({ url, tagName, override }) => {
        return {
            url,
            tagName,
            override,
        };
    });
}
export function normalizeRenderOptions(runtimeEnvironment, overrideRenderOptions, baseRenderOptions) {
    return {
        // Default render options
        skipMetadataCollection: false,
        freezeAssets: runtimeEnvironment.immutableAssets,
        viewParamCacheKey: null,
        ...baseRenderOptions,
        ...overrideRenderOptions,
    };
}
function getTitleFromFilePath(filePath) {
    return filePath && typeof filePath === 'string' ? basename(filePath, extname(filePath)) : DEFAULT_TITLE;
}
export function generatePageContext({ requestPath: url }, { id, contentTemplate, properties }, runtimeParams) {
    // title is set to the first defined value of the following:
    //      - properties.title from the route (or viewParams.title from the route handler)
    //      - filename from route.contentTemplate
    //      - DEFAULT_TITLE
    const title = properties?.title || getTitleFromFilePath(contentTemplate);
    const locale = runtimeParams.locale;
    const basePath = runtimeParams.basePath;
    const assetBasePath = runtimeParams.assetBasePath;
    const uiBasePath = runtimeParams.uiBasePath;
    return { assetBasePath, basePath, id, locale, title, url, uiBasePath };
}
// type guard for ViewDef responses
export function isViewResponse(response) {
    return response.body !== undefined;
}
export function isViewDefinitionResponse(response) {
    return response.view !== undefined;
}
export async function toJsonFormat(viewRequest, viewDefinition, route, runtimeEnvironment, runtimeParams, moduleRegistry) {
    const { viewRecord } = viewDefinition;
    const { bootstrap, id: appName } = route;
    const workerSpecifiers = bootstrap?.workers || {};
    // coalesce workers from route configuration
    const workers = {};
    for (const id of Object.keys(workerSpecifiers)) {
        const appIdentity = {
            appName,
            format: runtimeEnvironment.format,
            resourceType: AppResourceEnum.MODULE,
            subResource: {
                type: ResourceIdentityTypes.WORKER,
                workerId: `${id}`,
            },
        };
        const workerBootstrapSpecifier = getAppSpecifier(appIdentity);
        // eslint-disable-next-line no-await-in-loop
        workers[id] = await createJsonModule(workerBootstrapSpecifier, moduleRegistry, runtimeEnvironment, runtimeParams);
    }
    // ADD bootstrap module and dependencies to modules property
    const modules = [];
    const resources = [];
    const bootstrapGraph = viewRecord.bootstrapModule;
    if (bootstrapGraph) {
        [bootstrapGraph.flatGraph.graphs[0].specifier, ...bootstrapGraph.flatGraph.graphs[0].static].map((module) => {
            modules.push({
                // versioned specifier
                specifier: module,
                links: {
                    self: bootstrapGraph.flatGraph.uriMap[module],
                },
            });
        });
        // If bootstrapGraph exists exposes its resources via configuration URL
        resources.push({
            type: 'application/javascript',
            src: getClientBootstrapConfigurationUri({ url: viewRequest.url, id: route.id, query: viewRequest.query }, runtimeEnvironment, runtimeParams),
        });
    }
    const mappingUrl = getMappingUriPrefix(runtimeEnvironment, runtimeParams);
    const endpoints = {
        uris: {
            mapping: mappingUrl,
        },
        ...(runtimeEnvironment.debug && { modifiers: { debug: 'true' } }),
    };
    // ADD customElements as pre-loadable module entry points
    const preloadModules = viewRecord.customElements?.map((ce) => {
        return {
            // versioned specifier
            specifier: ce.flatGraph.graphs[0].specifier,
            links: {
                self: ce.flatGraph.uriMap[ce.flatGraph.graphs[0].specifier],
            },
        };
    });
    // ADD assetReferences to the JSON resources
    viewRecord.assetReferences?.forEach((asset) => {
        if (asset.override?.uri) {
            const type = mimeLookup(asset.override?.uri);
            resources.push({ type, src: asset.override?.uri });
        }
    });
    // Import Metadata
    const importMetadata = !runtimeEnvironment.featureFlags?.LEGACY_LOADER && viewRecord.importMetadata;
    viewRecord.resources?.forEach((resource) => {
        resources.push({ type: resource.type, src: resource.src });
    });
    const body = {
        ...importMetadata,
        modules,
        preloadModules,
        endpoints,
        resources,
        workers,
    };
    return {
        body,
        headers: {
            'Content-Type': 'application/json',
        },
    };
}
export async function getModuleResource(moduleId, runtimeEnvironment, moduleResourceMeta, defRegistry, runtimeParams) {
    const { format } = runtimeEnvironment;
    const { isSSR = false, isPreload = false } = moduleResourceMeta;
    const moduleUri = await defRegistry.resolveModuleUri(moduleId, runtimeEnvironment, runtimeParams);
    return {
        src: moduleUri,
        type: format === 'amd' ? 'application/javascript' : 'module',
        async: !isSSR && isPreload,
        defer: isSSR,
        // only use link preload for ESM for compat reasons.
        // AMD should use regular script tags for preloading
        isPreload: format !== 'amd' && isPreload,
    };
}
export function getModuleResourceByUri(uri, runtimeEnvironment, moduleResourceMeta) {
    const { integrity, isSSR = false, isPreload = false, nonce } = moduleResourceMeta;
    const { format } = runtimeEnvironment;
    return {
        src: uri,
        type: format === 'amd' ? 'application/javascript' : 'module',
        async: !isSSR && isPreload,
        defer: isSSR,
        // only use link preload for ESM for compat reasons.
        // AMD should use regular script tags for preloading
        isPreload: format !== 'amd' && isPreload,
        integrity,
        nonce,
    };
}
// Given a specifier and resource type, return the JSON serialized Module data
export async function createJsonModule(specifier, moduleRegistry, environment, params) {
    const { version } = await moduleRegistry.getModuleEntry({ specifier }, params);
    const { namespace, name } = explodeSpecifier(specifier);
    const moduleIdentifier = {
        specifier,
        namespace,
        name,
        version,
    };
    const { ownHash } = await moduleRegistry.getModule(moduleIdentifier, params);
    return {
        // versioned specifier
        specifier: getSpecifier(moduleIdentifier),
        version,
        ownHash,
        links: {
            self: await moduleRegistry.resolveModuleUri(moduleIdentifier, environment, params, ownHash),
        },
    };
}
/**
 * Get the nonce set on the page context of the view params
 */
export function getViewNonce(viewParams) {
    return getFeatureFlags().ENABLE_NONCE
        ? viewParams?.page?.nonce
        : undefined;
}
/**
 * Generate a nonce in the page context of the view params
 */
export function generateViewNonce(viewParams) {
    if (getFeatureFlags().ENABLE_NONCE) {
        const nonce = crypto.randomBytes(16).toString('base64');
        if (!viewParams.page) {
            viewParams.page = { nonce };
        }
        else {
            viewParams.page.nonce = nonce;
        }
    }
}
/**
 * Add a nonce to a script definition in view if it is external (not inline)
 */
export function addExternalScriptNonce(def, nonce) {
    if (nonce && getFeatureFlags().ENABLE_NONCE && !def.inline) {
        def.nonce = nonce;
    }
}
export function generateLinkHeaders(assets, patterns) {
    // store each Path's config in this config
    const assetConfig = {};
    for (const assetRef of assets) {
        const path = assetRef.override?.uri || assetRef.url;
        let matched = null;
        for (const pattern of patterns) {
            const { match } = pattern;
            const matchPatterns = Array.isArray(match) ? match : [match];
            for (const filePattern of matchPatterns) {
                const regex = new RegExp(filePattern);
                if (regex.test(path)) {
                    matched = pattern.attributes;
                    break;
                }
            }
            if (matched)
                break;
        }
        if (matched) {
            assetConfig[path] = matched;
        }
    }
    // Use the assetConfig to construct the Link Header
    return Object.keys(assetConfig).reduce((linkHeader, path) => {
        linkHeader = `${linkHeader ? linkHeader + ', ' : ''}<${path}>`;
        const properties = assetConfig[path];
        // Add the properties mentioned on the preloadResource patterns except match prop
        for (const prop in properties) {
            // Check if the prop has empty string, if so add the prop name alone
            // eg: if crossorigin: '' => </global.css>; as=style; crossorigin
            linkHeader += properties[prop] !== '' ? `; ${prop}=${properties[prop]}` : `; ${prop}`;
        }
        return linkHeader;
    }, '');
}
export function getViewDefCacheKey(view, runtimeEnvironment, freezeAssets, runtimeParams) {
    const { id, bootstrap, rootComponent, contentTemplate, layoutTemplate } = view;
    return getCacheKeyFromJson({
        id,
        bootstrap,
        rootComponent,
        contentTemplate,
        layoutTemplate,
        freezeAssets,
        locale: runtimeParams?.locale,
        basePath: runtimeParams?.basePath,
        debug: runtimeEnvironment.debug,
        // Add a variable on if the nonce is enabled
        nonceEnabled: getFeatureFlags().ENABLE_NONCE,
    });
}
export function getModuleGraphCacheKey(specifier, runtimeEnvironment, runtimeParams) {
    const updatedParams = {
        ...runtimeParams,
    };
    // Remove the URL and query from the runtimeParams
    delete updatedParams.url;
    delete updatedParams.query;
    return getCacheKeyFromJson({
        specifier,
        updatedParams,
        runtimeEnvironment,
    });
}
//# sourceMappingURL=utils.js.map