import { InflightTasks, createStringBuilder, extractMetadataFromHtml, getCacheKeyFromJson, getFeatureFlags, getSpecifier, isLocalDev, normalizeResourcePath, shortestTtl, isRelative, } from '@lwrjs/shared-utils';
import { getTracer, ViewSpan } from '@lwrjs/instrumentation';
import { generateViewNonce, getViewNonce, normalizeRenderOptions, normalizeRenderedResult, reduceSourceAssetReferences, getViewDefCacheKey, } from './utils.js';
import { linkLwrResources } from './linkers/link-lwr-resources.js';
// TODO: investigate perf impact W-16056356
import { LRUCache } from 'lru-cache';
import { DiagnosticsError, LwrServerError, createSingleDiagnosticError, descriptions, logger, } from '@lwrjs/diagnostics';
export { LwrViewHandler } from './view-handler.js';
export class LwrViewRegistry {
    constructor(context, globalConfig) {
        this.viewProviders = [];
        // Cache of compiled views retrieved from the viewProviders
        //  Cache key: ViewIdentity
        this.compiledViews = new Map();
        this.immutableAssets = new Map();
        // Cache of unresolved view definitions
        //  Cache key: View + View Params
        //
        // Pending view definitions are tracked to prevent concurrent resolution of the same view.
        // Subsequent requests for the same view will await the original promise.
        this.pendingViewDefinitions = new InflightTasks();
        this.name = 'lwr-view-registry';
        this.resourceRegistry = context.resourceRegistry;
        this.runtimeEnvironment = context.runtimeEnvironment;
        this.moduleRegistry = context.moduleRegistry;
        this.moduleBundler = context.moduleBundler;
        this.assetRegistry = context.assetRegistry;
        this.viewTransformers = context.viewTransformers || [];
        this.globalConfig = globalConfig;
        this.globalData = context.globalData;
        this.appEmitter = context.appEmitter;
        const observer = context.appObserver;
        this.viewDefinitions = new LRUCache({
            max: parseInt(process.env.VIEW_CACHE_SIZE ?? '500', 10),
            dispose: (_value, key) => {
                // We expect the view to get evicted quite often in LWR@MRT so we are not warning of eviction here.
                logger.verbose(`View evicted from cache ${key}`);
            },
        });
        // Observers for cached entries external dependencies -- view templates, modules, and assets
        observer.onViewSourceChange(({ payload }) => this.onViewSourceChange(payload));
        observer.onModuleDefinitionChange(({ payload }) => this.onModuleDefinitionChange(payload));
        observer.onAssetSourceChange(({ payload }) => this.onAssetSourceChange(payload));
    }
    async onModuleDefinitionChange(moduleDefinition) {
        // TODO we will make this more robust in the future w/ full MRT HMR
        if (isLocalDev()) {
            this.viewDefinitions.clear();
            return;
        }
        const versionedSpecifier = getSpecifier(moduleDefinition);
        // invalidate viewDefinition cache entries with references to the LinkedModuleDefinition
        for (const [id, viewDefEntry] of this.viewDefinitions.entries()) {
            const { viewDefinition: { viewRecord }, } = viewDefEntry;
            const uriMap = viewRecord.bootstrapModule?.flatGraph.uriMap;
            if (uriMap) {
                Object.keys(uriMap);
            }
            const someBootstrapDeps = viewRecord.bootstrapModule?.specifier === versionedSpecifier ||
                Object.keys(viewRecord.bootstrapModule?.flatGraph.uriMap || []).includes(versionedSpecifier);
            const someCustomElementsDeps = viewRecord.customElements?.some((element) => {
                return (element.flatGraph.graphs[0].specifier === versionedSpecifier ||
                    Object.keys(element.flatGraph.uriMap || []).includes(versionedSpecifier));
            });
            // Delete the viewDefinition if it contains a reference to the updated module definition
            if (someBootstrapDeps || someCustomElementsDeps) {
                this.viewDefinitions.delete(id);
            }
        }
    }
    async onViewSourceChange(compiledView) {
        // TODO we will make this more robust in the future w/ full MRT HMR
        if (isLocalDev()) {
            this.viewDefinitions.clear();
            return;
        }
        // invalidate compiledViews and viewDefinition cache entries with references to the CompiledView template id.
        const { contentTemplate, rootComponent } = compiledView.viewId;
        const compiledViewCacheKey = getCacheKeyFromJson({ contentTemplate, rootComponent });
        this.compiledViews.set(compiledViewCacheKey, compiledView);
        // invalidate viewDefinitions cache
        for (const [id, viewDefEntry] of this.viewDefinitions.entries()) {
            const { contentTemplate: eContentTempl, layoutTemplate: eLayoutTemplate, rootComponent: eRootComponent, } = viewDefEntry.view;
            if (eContentTempl === contentTemplate ||
                eLayoutTemplate === contentTemplate ||
                eRootComponent === rootComponent) {
                // invalidate matched entry.
                this.viewDefinitions.delete(id);
            }
        }
    }
    onAssetSourceChange(asset) {
        // invalidate viewDefinition cache entries with references to the AssetSource entry.
        const assetId = asset.entry;
        for (const [id, viewDefEntry] of this.viewDefinitions.entries()) {
            const { viewDefinition: { viewRecord }, } = viewDefEntry;
            const someAssets = viewRecord.assetReferences?.some((ref) => {
                return ref.override?.entry === assetId;
            });
            if (someAssets) {
                this.viewDefinitions.delete(id);
            }
        }
    }
    getPublicApi() {
        return {
            getViewDefinition: this.getViewDefinition.bind(this),
            getView: this.getView.bind(this),
        };
    }
    // -- Public API --------------------------------------------------------------------
    // Add new view providers
    addViewProviders(providers) {
        this.viewProviders.push(...providers);
    }
    addViewTransformers(transformers) {
        this.viewTransformers.push(...transformers);
    }
    initializeViewProviders() {
        return Promise.all(this.viewProviders.map((vp) => vp.initialize()));
    }
    async delegateGetView(viewId) {
        for (const vp of this.viewProviders) {
            // eslint-disable-next-line no-await-in-loop
            const result = await vp.getView(viewId);
            if (result) {
                return result;
            }
        }
        throw new Error(`No View provider was able to resolve a view for template: ${viewId.contentTemplate}`);
    }
    async getView(viewId) {
        const { contentTemplate, rootComponent } = viewId;
        const compiledViewCacheKey = getCacheKeyFromJson({ contentTemplate, rootComponent });
        logger.debug(`[view-registry][getView] compiledViewCacheKey=${compiledViewCacheKey}`);
        // For now we are only supporting ttl 0 == skipCaching.
        const route = this.globalConfig.routes.find((r) => r.id === viewId.id);
        const skipCaching = route?.cache?.ttl === 0;
        // use cached compiledView if available
        if (!skipCaching && this.compiledViews.has(compiledViewCacheKey)) {
            return this.compiledViews.get(compiledViewCacheKey);
        }
        const compiledView = await this.delegateGetView(viewId);
        // cache the compiled view
        if (!skipCaching) {
            this.compiledViews.set(compiledViewCacheKey, compiledView);
        }
        return compiledView;
    }
    hasViewDefinition(view, viewParams, runtimeEnvironment, runtimeParams, renderOptions) {
        const { freezeAssets, viewParamCacheKey } = normalizeRenderOptions(this.runtimeEnvironment, renderOptions);
        const viewDefId = getViewDefCacheKey(view, runtimeEnvironment, freezeAssets, runtimeParams);
        logger.debug(`[view-registry][hasViewDefinition] viewDefId=${viewDefId}`);
        // viewParams is an unbounded object and can be very large (17MB/view for developer.salesforce.com). Allowing consumers
        // to provide a simple override avoids the excess memory / performance overhead of serializing & storing the viewParams
        // on every request, while still reusing our caching logic.
        const viewParamKey = viewParamCacheKey
            ? getCacheKeyFromJson(viewParamCacheKey)
            : getCacheKeyFromJson(viewParams);
        logger.debug(`[view-registry][hasViewDefinition] viewParamKey=${viewParamKey}`);
        // important: cache key does not include the unbounded viewParams
        if (this.viewDefinitions.has(viewDefId)) {
            const viewDef = this.viewDefinitions.get(viewDefId);
            if (viewDef && viewDef.paramKey === viewParamKey) {
                return true;
            }
        }
        return false;
    }
    async getViewDefinition(view, viewParams, runtimeEnvironment, runtimeParams = { requestCache: {} }, renderOptions) {
        runtimeParams.requestCache = runtimeParams.requestCache ?? {};
        try {
            const { freezeAssets, viewParamCacheKey } = normalizeRenderOptions(this.runtimeEnvironment, renderOptions);
            const viewDefCacheKey = getViewDefCacheKey(view, runtimeEnvironment, freezeAssets, runtimeParams);
            logger.debug(`[view-registry][getViewDefinition] viewDefCacheKey=${viewDefCacheKey}`);
            // viewParams is an unbounded object and can be very large (17MB/view for developer.salesforce.com). Allowing consumers
            // to provide a simple override avoids the excess memory / performance overhead of serializing & storing the viewParams
            // on every request, while still reusing our caching logic.
            const viewParamKey = viewParamCacheKey
                ? getCacheKeyFromJson(viewParamCacheKey)
                : getCacheKeyFromJson(viewParams);
            logger.debug(`[view-registry][getViewDefinition] viewParamKey=${viewParamKey}`);
            // important: cache key does not include the unbounded viewParams
            // check the cross-request cache, then the request cache (which is cleaned up after each base doc request)
            if (this.viewDefinitions.has(viewDefCacheKey) || runtimeParams.requestCache[viewDefCacheKey]) {
                const viewDefinition = this.viewDefinitions.get(viewDefCacheKey) || runtimeParams.requestCache[viewDefCacheKey];
                if (viewDefinition &&
                    viewDefinition.paramKey === viewParamKey &&
                    viewDefinition.viewDefinition.immutable) {
                    return viewDefinition.viewDefinition;
                }
            }
            // If we missed cache generate a nonce in the page context (we do not want it part of the cache key)
            const updatableViewParams = { ...viewParams };
            generateViewNonce(updatableViewParams);
            const pendingViewDefCacheKey = viewDefCacheKey + viewParamKey;
            const viewDefinition = await this.pendingViewDefinitions.execute(pendingViewDefCacheKey, () => getTracer().trace({
                name: ViewSpan.RenderView,
                attributes: {
                    view: view.id,
                    ssr: view.bootstrap?.ssr === true,
                },
            }, () => this.renderView(view, updatableViewParams, runtimeEnvironment, runtimeParams, pendingViewDefCacheKey, renderOptions)));
            // Once the view is generated add the nonce to the response so it can be cached and then added to the headers
            viewDefinition.nonce = getViewNonce(updatableViewParams);
            const route = this.globalConfig.routes.find((r) => r.id === view.id);
            const maxViewCacheTtl = getFeatureFlags().MAX_VIEW_CACHE_TTL;
            // optionally set a max TTL on the view registry cache
            // use a very low TTL if the shortest is 0, to allow the view to be fetched > once during a single request
            const maxTtl = maxViewCacheTtl && parseInt(maxViewCacheTtl, 10);
            const leastTtl = shortestTtl(viewDefinition.cache?.ttl, route?.cache?.ttl, maxTtl);
            const ttl = leastTtl !== undefined ? (leastTtl === 0 ? 10 : leastTtl * 1000) : undefined;
            // cache view definition for the shortest ttl or until it is the least recently used when ttl is undefined
            const viewDefCacheEntry = { view, viewDefinition, paramKey: viewParamKey };
            if (view.bootstrap?.includeCookiesForSSR) {
                // important: DO NOT cache authenticated view definitions beyond a single request.
                // Keep the cache entry only during the request in case viewRegistry.getViewDefinition is called > once.
                // This can happen when a route handler calls viewApi.getViewResponse then returns a ViewDefinitionResponse.
                runtimeParams.requestCache[viewDefCacheKey] = viewDefCacheEntry;
            }
            else {
                // Standard cross-request caching
                this.viewDefinitions.set(viewDefCacheKey, viewDefCacheEntry, { ttl });
            }
            return viewDefinition;
        }
        catch (err) {
            if (err instanceof DiagnosticsError) {
                throw err;
            }
            logger.error(`Failed to get view definition "${view.id}"`);
            logger.error(err);
            const message = err instanceof Error ? err.message : String(err);
            throw createSingleDiagnosticError({ description: descriptions.SERVER.UNEXPECTED_ERROR(message) }, LwrServerError);
        }
    }
    async renderView(view, viewParams, runtimeEnvironment, runtimeParams, viewCacheKey, renderOptions) {
        const { id, contentTemplate, rootComponent, layoutTemplate } = view;
        const lwrResourcesId = `__LWR_RESOURCES__${Date.now()}`;
        const renderedContent = await this.render({ id, contentTemplate, rootComponent }, { ...viewParams, lwr_resources: lwrResourcesId }, runtimeParams, runtimeEnvironment);
        // normalize the renderOptions provided by the CompiledView content with the request options.
        let normalizedRenderOptions = normalizeRenderOptions(this.runtimeEnvironment, renderedContent.options, renderOptions);
        const layout = layoutTemplate || renderedContent.compiledView.layoutTemplate;
        if (!layout) {
            // Content only view
            const renderedViewDef = await this.link(renderedContent, {
                view,
                viewParams,
                runtimeEnvironment,
                runtimeParams,
                // using any options provided by the content, overridden with invocation provided rendering options
                renderOptions: normalizedRenderOptions,
                contentIds: { lwrResourcesId },
                viewCacheKey,
            });
            return renderedViewDef;
        }
        // Layout wrapped content: pass in the view provider properties and body from the rendered content
        const layoutTemplatePath = normalizeResourcePath(layout, this.globalConfig);
        const renderedLayout = await this.render({ id, contentTemplate: layoutTemplatePath }, {
            ...renderedContent.compiledView.properties,
            ...viewParams,
            body: renderedContent.renderedView,
            lwr_resources: lwrResourcesId,
        }, runtimeParams, runtimeEnvironment);
        normalizedRenderOptions = normalizeRenderOptions(this.runtimeEnvironment, renderedLayout.options, normalizedRenderOptions);
        const renderedViewDef = await this.link({
            ...renderedLayout,
            // Rendered Layout view's immutability is a composite of the layouts mutability and the body's mutability
            compiledView: {
                ...renderedLayout.compiledView,
                immutable: renderedContent.compiledView.immutable && renderedLayout.compiledView.immutable,
            },
            // Rendered layouts known metadata is a composition of the layouts and body content's known metadata.
            metadata: {
                customElements: [
                    ...renderedContent.metadata.customElements,
                    ...renderedLayout.metadata.customElements,
                ],
                assetReferences: [
                    ...renderedContent.metadata.assetReferences,
                    ...renderedLayout.metadata.assetReferences,
                ],
                serverData: {
                    ...renderedContent.metadata.serverData,
                    ...renderedLayout.metadata.serverData,
                },
                serverDebug: {
                    ...renderedContent.metadata.serverDebug,
                    ...renderedLayout.metadata.serverDebug,
                },
                serverBundles: renderedContent.metadata.serverBundles, // 1st pass of SSR
            },
            cache: renderedContent.cache,
            status: renderedContent.status,
        }, 
        // Render Content now contains a layout
        {
            view: { ...view, layoutTemplate: layoutTemplatePath },
            viewParams,
            runtimeEnvironment,
            runtimeParams,
            renderOptions: normalizedRenderOptions,
            contentIds: { lwrResourcesId },
            // TODO: We override the importer with the original view, however
            // Layouts relative paths won't work
            importer: renderedContent.compiledView.filePath,
            viewCacheKey,
        });
        return renderedViewDef;
    }
    async render(viewId, viewParams, runtimeParams, runtimeEnvironment) {
        const globalContext = this.globalData;
        const { id, rootComponent, contentTemplate } = viewId;
        const compiledView = await this.getView({ id, contentTemplate, rootComponent });
        // Get content/body of the view
        /*
            When rendering the compiled view, a collection variable properties can be passed to the render() to be rendered in
            the view's content.  The following are the sources of those properties:
            * GlobalContext is global data provided by the project in the ${globalDataDir}
            * A View Provider MAY expose a set of properties that should be applied to all rendered content generated by the CompiledView renderer()
            * A caller can also pass a set of property parameters derived from the request or out-of-band sources.

            These are merged together in to a combined context used by render()
        */
        const result = await compiledView.render({
            ...runtimeParams,
            ...globalContext,
            ...compiledView.properties,
            ...viewParams,
        }, runtimeEnvironment);
        const normalizedResult = normalizeRenderedResult(result);
        return {
            compiledView,
            ...normalizedResult,
        };
    }
    async link(renderedView, viewContext) {
        const { view, viewParams, runtimeEnvironment: runtimeEnv, runtimeParams, renderOptions, contentIds, importer, viewCacheKey, } = viewContext;
        const { skipMetadataCollection, freezeAssets } = renderOptions;
        const { lwrResourcesId } = contentIds;
        const { moduleRegistry, resourceRegistry, moduleBundler } = this;
        const runtimeEnvironment = { ...runtimeEnv, immutableAssets: freezeAssets };
        // normalize/extract metadata
        const { renderedView: renderedViewContent, metadata: renderedViewMetadata, compiledView: { immutable = true }, } = renderedView;
        const { linkedMetadata, stringBuilder } = getTracer().trace({
            name: ViewSpan.ParseView,
            attributes: {
                view: view.id,
                ssr: view.bootstrap?.ssr === true,
            },
        }, () => {
            const linkedMetadata = skipMetadataCollection
                ? renderedViewMetadata
                : extractMetadataFromHtml(renderedViewContent, renderedViewMetadata, this.globalConfig);
            const stringBuilder = createStringBuilder(renderedViewContent);
            return { linkedMetadata, stringBuilder };
        });
        const mergedViewContext = {
            ...viewContext,
            config: this.globalConfig,
            runtimeEnvironment,
            importer: importer || renderedView.compiledView.filePath,
        };
        // Note: this is the TTL for the page NOT for the view registry cache
        let pageTtl = renderedView.cache.ttl;
        let pageStatus = renderedView.status;
        for (const viewTransformer of this.viewTransformers) {
            // eslint-disable-next-line no-await-in-loop
            const linkResults = await getTracer().trace({
                name: ViewSpan.Transform,
                attributes: {
                    name: viewTransformer.name,
                },
            }, () => viewTransformer.link?.(stringBuilder, mergedViewContext, linkedMetadata));
            // Keep track of the shortest TTL from each view transformer (e.g. lwcSsrViewTransformer)
            const ttl = linkResults && linkResults.cache?.ttl;
            pageTtl = shortestTtl(ttl || undefined, pageTtl);
            // Set the status info, if it doesn't already exist
            if (!pageStatus && linkResults) {
                pageStatus = linkResults.status;
            }
        }
        const linkedAssetContent = stringBuilder.toString();
        // Link LWR related resources
        if (linkedAssetContent.includes(lwrResourcesId)) {
            // This calculation is expensive, only do it if lwr_resources is needed
            // Link LWR View resources if necessary
            const { renderedView: linkedView, viewRecord } = await linkLwrResources(linkedAssetContent, view, viewParams, {
                lwrResourcesId,
                viewMetadata: linkedMetadata,
                moduleRegistry,
                moduleBundler,
                resourceRegistry,
                runtimeEnvironment,
                runtimeParams,
                bundleConfig: this.globalConfig.bundleConfig,
                unsafeEnableViewLinkCaching: this.globalConfig.unsafeEnableViewLinkCaching,
                // Use the same cache key for the link stage
                viewLinkCacheKey: viewCacheKey,
            });
            if (viewRecord.resources?.length) {
                linkedMetadata.assetReferences.push(...viewRecord.resources.reduce((res, asset) => {
                    if (!asset.src)
                        return res;
                    res.push({
                        url: asset.src,
                        relative: isRelative(asset.src),
                    });
                    return res;
                }, []));
            }
            return {
                // ...viewDefinition,
                renderedView: linkedView,
                immutable,
                viewRecord: {
                    assetReferences: reduceSourceAssetReferences(linkedMetadata.assetReferences),
                    ...viewRecord,
                    serverBundles: linkedMetadata.serverBundles,
                },
                cache: { ttl: pageTtl },
                status: pageStatus,
            };
        }
        return {
            renderedView: linkedAssetContent,
            immutable,
            viewRecord: {
                assetReferences: reduceSourceAssetReferences(linkedMetadata.assetReferences),
                moduleResources: [],
                serverBundles: linkedMetadata.serverBundles,
            },
            cache: { ttl: pageTtl },
            status: pageStatus,
        };
    }
}
//# sourceMappingURL=index.js.map