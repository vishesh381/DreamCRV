import { resolve } from 'path';
import { normalizeResourcePath, shortestTtl } from '@lwrjs/shared-utils';
import { getTracer, ViewSpan } from '@lwrjs/instrumentation';
import { generateHtmlTag, generateLinkHeaders, generatePageContext, isViewResponse, isViewDefinitionResponse, toJsonFormat, } from './utils.js';
import { DiagnosticsError, LwrApplicationError, createSingleDiagnosticError, descriptions, } from '@lwrjs/diagnostics';
export class LwrViewHandler {
    constructor(context, globalConfig) {
        this.globalConfig = globalConfig;
        this.routeHandlers = context.routeHandlers;
        this.viewRegistry = context.viewRegistry;
        this.moduleRegistry = context.moduleRegistry;
    }
    // Get the View's HTML Response
    async getViewContent(
    // request
    viewRequest, 
    // config
    route, 
    // context
    runtimeEnvironment, runtimeParams) {
        if (route.routeHandler) {
            const response = await this.getRouteHandlerResponse(viewRequest, route, runtimeEnvironment, runtimeParams);
            if (isViewResponse(response)) {
                // Return custom view response payload as-is
                return response;
            }
            // Process ViewDefinitionResponse
            const { view, viewParams, renderOptions } = normalizeViewProperties(viewRequest, response, route, this.globalConfig, runtimeParams);
            const viewDefinition = await this.viewRegistry.getViewDefinition(view, viewParams, runtimeEnvironment, runtimeParams, renderOptions);
            const link = !!route?.bootstrap?.preloadResources?.patterns?.length &&
                generateLinkHeaders(viewDefinition.viewRecord.assetReferences || [], route?.bootstrap?.preloadResources?.patterns || []);
            return {
                ...response,
                body: viewDefinition.renderedView,
                ...(!!link && { headers: { link } }),
                metadata: {
                    viewDefinition,
                },
                cache: { ttl: shortestTtl(response.cache?.ttl, viewDefinition.cache?.ttl) },
            };
        }
        // default static view
        const viewDefinition = await this.getDefaultRouteViewDefinition(viewRequest, route, runtimeEnvironment, runtimeParams);
        const link = !!route?.bootstrap?.preloadResources?.patterns?.length &&
            generateLinkHeaders(viewDefinition.viewRecord.assetReferences || [], route.bootstrap?.preloadResources?.patterns || []);
        return {
            body: viewDefinition.renderedView,
            metadata: {
                viewDefinition,
            },
            cache: viewDefinition.cache,
            ...(!!link && { headers: { link } }),
        };
    }
    // Get the View's JSON Manifest Response
    async getViewJson(
    // request
    viewRequest, 
    // config
    route, 
    // context
    runtimeEnvironment, runtimeParams = {}) {
        if (route.routeHandler) {
            const response = await this.getRouteHandlerResponse(viewRequest, route, runtimeEnvironment, runtimeParams);
            if (isViewResponse(response)) {
                // Return custom view response payload as-is
                return response;
            }
            const { view, viewParams, renderOptions } = normalizeViewProperties(viewRequest, response, route, this.globalConfig, runtimeParams);
            const viewDefinition = await this.viewRegistry.getViewDefinition(view, viewParams, runtimeEnvironment, runtimeParams, renderOptions);
            return {
                ...response,
                ...(await toJsonFormat(viewRequest, viewDefinition, route, runtimeEnvironment, runtimeParams, this.moduleRegistry)),
            };
        }
        // default static view
        const viewDefinition = await this.getDefaultRouteViewDefinition(viewRequest, route, runtimeEnvironment, runtimeParams);
        // return the JSON form of the LinkedViewDefinition
        return await toJsonFormat(viewRequest, viewDefinition, route, runtimeEnvironment, runtimeParams, this.moduleRegistry);
    }
    // Get the View's Configuration Script Response
    // This is a standalone script containing globalThis.LWR
    // It is linked from the JSON response of an app (globalThis.LWR is inlined for HTML responses)
    async getViewConfiguration(
    // request
    viewRequest, 
    // config
    route, 
    // context
    runtimeEnvironment, runtimeParams = {}) {
        let viewDefinition;
        if (route.routeHandler) {
            const response = await this.getRouteHandlerResponse(viewRequest, route, runtimeEnvironment, runtimeParams);
            if (isViewResponse(response)) {
                // Return custom view response payload as-is
                return response;
            }
            const { view, viewParams, renderOptions } = normalizeViewProperties(viewRequest, response, route, this.globalConfig, runtimeParams);
            viewDefinition = await this.viewRegistry.getViewDefinition(view, viewParams, runtimeEnvironment, runtimeParams, renderOptions);
        }
        else {
            // default static view
            viewDefinition = await this.getDefaultRouteViewDefinition(viewRequest, route, runtimeEnvironment, runtimeParams);
        }
        // Serialize the ViewDefinitions bootstrap resources as the exposed configuration
        const bootstrapResources = viewDefinition.viewRecord.bootstrapModule?.resources;
        if (!bootstrapResources) {
            return;
        }
        // If configuration as source do not wrap the content in a script tag
        const htmlResources = route.bootstrap?.configAsSrc
            ? bootstrapResources.map((resource) => resource.content).join('\n')
            : await generateHtmlTag({
                type: 'application/javascript',
                inline: true,
                content: bootstrapResources.map((resource) => resource.content).join('\n'),
            });
        return {
            body: htmlResources,
        };
    }
    async getDefaultRouteViewDefinition(
    // request
    viewRequest, route, 
    // context
    runtimeEnvironment, runtimeParams = {}) {
        const { id, bootstrap, rootComponent, contentTemplate, layoutTemplate, properties } = route;
        const page = generatePageContext(viewRequest, route, runtimeParams);
        const viewDefinition = await this.viewRegistry.getViewDefinition({
            id,
            bootstrap,
            rootComponent,
            contentTemplate,
            layoutTemplate,
        }, { page, ...properties }, runtimeEnvironment, runtimeParams);
        return viewDefinition;
    }
    async getRouteHandlerResponse(
    // request
    viewRequest, route, 
    // context
    runtimeEnvironment, runtimeParams = {}) {
        if (!route.routeHandler) {
            throw new Error('Route handler is required for a CustomView');
        }
        const routeHandlerOptions = route.routeHandler[1];
        const routeHandlerFn = this.routeHandlers[route.routeHandler[0]];
        if (!routeHandlerFn) {
            throw new Error(`Route handler does not exist for id: ${route.routeHandler}`);
        }
        const { rootDir, assets, contentDir, layoutsDir } = this.globalConfig;
        const paths = { rootDir, assets, contentDir, layoutsDir };
        const locale = runtimeParams.locale;
        const basePath = runtimeParams.basePath;
        const assetBasePath = runtimeParams.assetBasePath;
        const uiBasePath = runtimeParams.assetBasePath;
        const viewApi = this.getBoundApi(viewRequest, route, runtimeEnvironment, runtimeParams);
        const response = await getTracer().trace({
            name: ViewSpan.ExecuteRouteHandler,
            attributes: {
                view: route.id,
                route: viewRequest.requestPath,
            },
        }, async () => {
            try {
                return await routeHandlerFn({ ...viewRequest, locale, basePath, assetBasePath, uiBasePath }, { route: route, viewApi, ...paths }, routeHandlerOptions);
            }
            catch (err) {
                if (err instanceof DiagnosticsError) {
                    throw err;
                }
                const message = err instanceof Error ? err.message : String(err);
                throw createSingleDiagnosticError({ description: descriptions.APPLICATION.ROUTE_HANDLER_ERROR(route.id, message) }, LwrApplicationError);
            }
        });
        // if the locale was returned by the route handler update the runtime time params
        if (response?.locale) {
            runtimeParams.locale = response.locale;
        }
        const preloadResources = route?.bootstrap?.preloadResources?.patterns;
        if (preloadResources && preloadResources.length) {
            // Add link headers if this is a viewDefinition response
            let viewDefintionMeta = response.metadata?.viewDefinition;
            if (!viewDefintionMeta && isViewDefinitionResponse(response)) {
                viewDefintionMeta = (await viewApi.getViewResponse(response.view, response.viewParams, response.renderOptions)).metadata?.viewDefinition;
            }
            if (viewDefintionMeta) {
                const link = generateLinkHeaders(
                // idk when metadata?.viewDefinition would be undefined but
                // it's optional....probably Darrell's fault
                viewDefintionMeta?.viewRecord.assetReferences || [], preloadResources);
                if (link) {
                    response.headers = {
                        ...response.headers,
                        link,
                    };
                }
            }
        }
        return response;
    }
    /*
        The Custom Route Handler accessible APIS are bound to runtime request when provided to a
        Route Handler.
    */
    getBoundApi(viewRequest, route, runtimeEnvironment, runtimeParams) {
        return {
            // Create a version of renderView() to pass to the route handler, it will:
            //  - handle and protect the runtime environment
            getViewResponse: this.getViewResponse.bind(this, viewRequest, route, runtimeEnvironment, runtimeParams),
            hasViewResponse: this.hasViewResponse.bind(this, route, runtimeEnvironment, runtimeParams),
        };
    }
    hasViewResponse(route, runtimeEnvironment, runtimeParams = {}, 
    // custom route handler managed properties
    view, viewParams, renderOptions) {
        const { id, bootstrap } = route;
        const managedView = { ...view, id, bootstrap };
        return this.viewRegistry.hasViewDefinition(managedView, viewParams, runtimeEnvironment, runtimeParams, renderOptions);
    }
    async getViewResponse(viewRequest, route, runtimeEnvironment, runtimeParams = {}, 
    // custom route handler managed properties
    view, viewParams, renderOptions) {
        const { id, bootstrap } = route;
        const managedView = { ...view, id, bootstrap };
        // If this is a localized view request (could have come from a route handler)
        // Update the runtime params
        if (view.locale) {
            runtimeParams.locale = view.locale;
        }
        const viewResponse = {
            view: managedView,
            viewParams,
            renderOptions,
        };
        const { view: normalizedView, viewParams: normalizedViewParams, renderOptions: normalizedRenderOptions, } = normalizeViewProperties(viewRequest, viewResponse, route, this.globalConfig, runtimeParams);
        const viewDefinition = await this.viewRegistry.getViewDefinition(normalizedView, normalizedViewParams, runtimeEnvironment, runtimeParams, normalizedRenderOptions);
        return {
            body: viewDefinition.renderedView,
            metadata: {
                viewDefinition,
            },
            cache: viewDefinition.cache,
        };
    }
}
function normalizeViewProperties(viewRequest, response, route, config, runtimeParams) {
    const { view: { rootComponent, contentTemplate: cTemplate, layoutTemplate: lTemplate }, viewParams, renderOptions, } = response;
    const { rootDir, assets, contentDir, layoutsDir } = config;
    const paths = { rootDir, assets, contentDir, layoutsDir };
    // grab the page.title from the viewParams (analogous to route.properties)
    const page = generatePageContext(viewRequest, {
        ...route,
        contentTemplate: cTemplate,
        properties: viewParams,
    }, runtimeParams);
    const { id, bootstrap } = route;
    return {
        view: {
            id,
            bootstrap,
            ...(rootComponent && { rootComponent }),
            ...(cTemplate && {
                contentTemplate: typeof cTemplate === 'string'
                    ? resolve(normalizeResourcePath(cTemplate, paths))
                    : cTemplate,
            }),
            ...(lTemplate && { layoutTemplate: resolve(normalizeResourcePath(lTemplate, paths)) }),
        },
        viewParams: { page, ...viewParams },
        renderOptions,
    };
}
//# sourceMappingURL=view-handler.js.map