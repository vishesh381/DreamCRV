var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/view-registry/src/linkers/view_bootstrap.ts
__markAsModule(exports);
__export(exports, {
  getHtmlResources: () => getHtmlResources
});
var import_diagnostics = __toModule(require("@lwrjs/diagnostics"));
var import_shared_utils = __toModule(require("@lwrjs/shared-utils"));
var import_lru_cache = __toModule(require("lru-cache"));
var import_identity = __toModule(require("@lwrjs/app-service/identity"));
var import_utils = __toModule(require("../utils.cjs"));
var import_utils2 = __toModule(require("./utils.cjs"));
var import_utils3 = __toModule(require("../utils.cjs"));
var import_preload_utils = __toModule(require("./preload-utils.cjs"));
var moduleGraphsCache = new import_lru_cache.LRUCache({
  max: 500,
  dispose: (_value, key) => {
    if ((0, import_shared_utils.isLambdaEnv)()) {
      import_diagnostics.logger.warn(`Module graph evicted from cache ${key}`);
    } else {
      import_diagnostics.logger.verbose(`Module graph evicted from cache ${key}`);
    }
  }
});
var isRunningLocalDev = (0, import_shared_utils.isLocalDev)();
async function getHtmlResources(view, viewParams, resourceContext) {
  const {
    runtimeEnvironment,
    runtimeParams,
    moduleRegistry,
    moduleBundler,
    resourceRegistry,
    viewMetadata
  } = resourceContext;
  const {format, hmrEnabled, bundle, debug, minify} = runtimeEnvironment;
  const {customElements, serverData, serverDebug} = viewMetadata;
  const defRegistry = bundle ? moduleBundler : moduleRegistry;
  const isAMD = format === "amd";
  const depth = isAMD ? {static: import_shared_utils.GraphDepth.ALL, dynamic: 1} : {static: import_shared_utils.GraphDepth.NONE, dynamic: 1};
  const {bundleConfig, unsafeEnableViewLinkCaching} = resourceContext;
  const {external = {}, exclude = []} = bundleConfig;
  const groups = isAMD ? bundleConfig.groups || {} : {};
  const enableModuleGraphsCache = unsafeEnableViewLinkCaching && !isRunningLocalDev && !process.env.NOCACHE;
  const getPreloadUri = function(rawSpecifier, uriMap) {
    const {specifier} = (0, import_shared_utils.explodeSpecifier)(rawSpecifier);
    if (Object.keys(external).some((e) => specifier === e))
      return;
    const uri = uriMap[rawSpecifier];
    if (!uri && (exclude.includes(specifier) || (0, import_shared_utils.isGroupie)(specifier, groups))) {
      import_diagnostics.logger.warn({
        label: "view-registry",
        message: `Skipping preload of unknown static import: ${rawSpecifier}`
      });
      return;
    }
    return uri;
  };
  const {
    id: appName,
    bootstrap: {services, module: bootstrapModule, preloadModules = []} = {
      services: [],
      preloadModules: []
    }
  } = view;
  const appIdentity = {
    appName,
    format: runtimeEnvironment.format,
    resourceType: import_identity.AppResourceEnum.MODULE
  };
  const bootstrapSpecifier = bootstrapModule || (0, import_identity.getAppSpecifier)(appIdentity);
  const moduleResources = [];
  const requiredResources = [];
  const configResources = [];
  const visitedCache = new Map();
  const imports = {};
  const rootComponents = [];
  const requiredAmdModules = [];
  const viewPreloads = {
    uris: [],
    specifiers: [],
    groups: new Map(),
    integrities: new Map()
  };
  const isSSR = view.bootstrap?.ssr;
  const version = view.bootstrap?.lwrVersion;
  const nonce = (0, import_utils.getViewNonce)(viewParams);
  let bootstrapModuleRef, versionedSpecifier = bootstrapSpecifier;
  let importMetadata = {imports: {}};
  const customElementsRecords = [];
  const flattenedElements = (0, import_utils2.flattenCustomElements)(customElements, isSSR);
  const viewContainsLiveElements = !isSSR || flattenedElements.some(({props}) => (0, import_shared_utils.getHydrateDirective)(props));
  if (viewContainsLiveElements) {
    if (isAMD) {
      const shimBundle = debug || minify === false ? "lwr-loader-shim.bundle.js" : "lwr-loader-shim.bundle.min.js";
      const def = await resourceRegistry.getResource({specifier: shimBundle, version}, runtimeEnvironment, runtimeParams);
      if (!def) {
        throw Error("Failed to find definition of resource: " + shimBundle);
      }
      if (!def.inline && !def.src) {
        throw Error(`Invalid Shim ${shimBundle}: ${JSON.stringify(def)}`);
      }
      (0, import_utils.addExternalScriptNonce)(def, nonce);
      requiredResources.push(def);
      const errorShimDef = await resourceRegistry.getResource({specifier: "lwr-error-shim.js", version}, runtimeEnvironment, {...runtimeParams, ignoreDebug: true});
      if (!errorShimDef) {
        throw Error("Failed to find definition of resource: lwr-error-shim.js");
      }
      if (!errorShimDef.inline && !errorShimDef.src) {
        throw Error(`Invalid Shim lwr-error-shim.js: ${JSON.stringify(errorShimDef)}`);
      }
      (0, import_utils.addExternalScriptNonce)(errorShimDef, nonce);
      requiredResources.push(errorShimDef);
    }
    let bootstrapModuleGraph;
    const bootstrapModuleGraphCacheKey = (0, import_utils3.getModuleGraphCacheKey)(bootstrapSpecifier, runtimeEnvironment, runtimeParams);
    if (enableModuleGraphsCache && moduleGraphsCache.has(bootstrapModuleGraphCacheKey)) {
      bootstrapModuleGraph = moduleGraphsCache.get(bootstrapModuleGraphCacheKey);
    } else {
      bootstrapModuleGraph = await (0, import_shared_utils.getModuleGraphs)(bootstrapSpecifier, {includeUris: true, includeLinkedDefinitions: true, depth}, moduleRegistry, defRegistry, runtimeEnvironment, runtimeParams, visitedCache);
      enableModuleGraphsCache && moduleGraphsCache.set(bootstrapModuleGraphCacheKey, bootstrapModuleGraph);
    }
    bootstrapModuleRef = {
      specifier: bootstrapModuleGraph.graphs[0].specifier,
      flatGraph: bootstrapModuleGraph,
      resources: configResources
    };
    versionedSpecifier = bootstrapModuleGraph.graphs[0].specifier;
    const uri = bootstrapModuleGraph.uriMap[versionedSpecifier];
    if (!uri) {
      throw Error(`Invalid Module Resource ${versionedSpecifier}`);
    }
    const integrity = (0, import_utils2.getBundleIntegrity)(bootstrapModuleGraph, versionedSpecifier);
    moduleResources.push((0, import_utils.getModuleResourceByUri)(uri, runtimeEnvironment, {integrity, isPreload: false, isSSR, nonce}));
    for (const depSpecifier of bootstrapModuleGraph.graphs[0].static) {
      const uri2 = getPreloadUri(depSpecifier, bootstrapModuleGraph.uriMap);
      if (uri2) {
        const integrity2 = (0, import_utils2.getBundleIntegrity)(bootstrapModuleGraph, depSpecifier);
        (0, import_preload_utils.setPreloadModulesMeta)(depSpecifier, uri2, integrity2, groups, viewPreloads);
      }
    }
    if ((0, import_shared_utils.isBundler)(defRegistry)) {
      for (const specifier of preloadModules) {
        await (0, import_preload_utils.getPreloadModulesMeta)(specifier, viewPreloads, bundleConfig, moduleRegistry, defRegistry, runtimeEnvironment, runtimeParams);
      }
    }
    if (isAMD) {
      requiredAmdModules.push(versionedSpecifier);
      imports[versionedSpecifier] = uri;
      for (const staticDep of bootstrapModuleGraph.graphs[0].static) {
        const uri2 = bootstrapModuleGraph.uriMap[staticDep];
        imports[staticDep] = uri2;
        if (services?.length) {
          requiredAmdModules.push(staticDep);
        }
      }
      for (const dynamicDep of bootstrapModuleGraph.graphs[0].dynamicRefs) {
        const uri2 = bootstrapModuleGraph.uriMap[dynamicDep];
        if (uri2) {
          imports[dynamicDep] = uri2;
        } else {
          import_diagnostics.logger.warn({
            label: `view-registry`,
            message: `Skipping unknown dynamic import: ${dynamicDep}`
          });
        }
      }
    }
    importMetadata = await (0, import_shared_utils.toImportMetadata)(bootstrapModuleGraph, {imports: {}, index: {}}, moduleRegistry, runtimeEnvironment, runtimeParams);
  }
  for (const {tagName: element, props} of flattenedElements) {
    const hydrateDirective = (0, import_shared_utils.getHydrateDirective)(props);
    const isSsrOnly = isSSR && !hydrateDirective;
    const elementSpecifier = (0, import_shared_utils.kebabCaseToModuleSpecifier)(element);
    const moduleGraphCacheKey = (0, import_utils3.getModuleGraphCacheKey)(elementSpecifier, runtimeEnvironment, {
      ...runtimeParams,
      ssr: isSsrOnly
    });
    let graph;
    if (enableModuleGraphsCache && moduleGraphsCache.has(moduleGraphCacheKey)) {
      graph = moduleGraphsCache.get(moduleGraphCacheKey);
    } else {
      graph = await (0, import_shared_utils.getModuleGraphs)(elementSpecifier, {includeUris: true, includeLinkedDefinitions: true, depth}, moduleRegistry, defRegistry, runtimeEnvironment, {...runtimeParams, ssr: isSsrOnly}, visitedCache);
      enableModuleGraphsCache && moduleGraphsCache.set(moduleGraphCacheKey, graph);
    }
    customElementsRecords.push({elementName: element, flatGraph: graph});
    if (!isSSR || (0, import_shared_utils.getHydrateDirective)(props)) {
      const specifier = graph.graphs[0].specifier;
      const uri = graph.uriMap[specifier];
      const integrity = (0, import_utils2.getBundleIntegrity)(graph, specifier);
      (0, import_preload_utils.setPreloadModulesMeta)(specifier, uri, integrity, groups, viewPreloads);
      if (bundle) {
        for (const depSpecifier of graph.graphs[0].static) {
          const depUri = getPreloadUri(depSpecifier, graph.uriMap);
          if (depUri) {
            const integrity2 = (0, import_utils2.getBundleIntegrity)(graph, depSpecifier);
            (0, import_preload_utils.setPreloadModulesMeta)(depSpecifier, depUri, integrity2, groups, viewPreloads);
          }
        }
      }
      rootComponents.push(specifier);
      imports[specifier] = uri;
      if (isAMD) {
        for (const staticDep of graph.graphs[0].static) {
          const uri2 = graph.uriMap[staticDep];
          imports[staticDep] = uri2;
        }
        for (const dynamicDep of graph.graphs[0].dynamicRefs) {
          const uri2 = graph.uriMap[dynamicDep];
          imports[dynamicDep] = uri2;
        }
      }
      importMetadata = await (0, import_shared_utils.toImportMetadata)(graph, importMetadata, moduleRegistry, runtimeEnvironment, runtimeParams);
    }
  }
  if (viewContainsLiveElements || serverDebug?.message) {
    configResources.unshift((0, import_utils2.getViewBootstrapConfigurationResource)({
      id: view.id,
      url: viewParams?.page?.url,
      configAsSrc: view.bootstrap?.configAsSrc || false,
      mixedMode: view.bootstrap?.mixedMode || false,
      nonce: viewParams?.page?.nonce,
      ssr: view.bootstrap?.ssr || false
    }, {
      appId: appIdentity.appName,
      bootstrapModule: versionedSpecifier,
      autoBoot: view.bootstrap?.autoBoot === false ? false : true,
      imports: importMetadata?.imports,
      index: importMetadata?.index,
      rootComponents,
      serverData,
      ...isAMD && {requiredModules: requiredAmdModules},
      ...isAMD && {preloadModules: viewPreloads.specifiers}
    }, runtimeEnvironment, runtimeParams, serverDebug?.message));
  }
  if (!isAMD && hmrEnabled) {
    configResources.unshift((0, import_utils2.getViewHmrConfigurationResource)(view, viewMetadata));
  }
  const dedupedUris = [...new Set(viewPreloads.uris)];
  for (const preloadUri of dedupedUris) {
    const integrity = viewPreloads.integrities.get(preloadUri);
    moduleResources.push((0, import_utils.getModuleResourceByUri)(preloadUri, runtimeEnvironment, {
      integrity,
      isPreload: true,
      isSSR,
      nonce
    }));
  }
  const htmlResources = await Promise.all([...configResources, ...requiredResources, ...moduleResources].map(import_utils.generateHtmlTag));
  const mapping = (0, import_shared_utils.getMappingUriPrefix)(runtimeEnvironment, runtimeParams);
  const endpoints = {
    uris: {
      mapping
    }
  };
  return {
    partial: htmlResources.join("\n"),
    viewRecord: {
      resources: requiredResources,
      customElements: customElementsRecords,
      endpoints,
      importMetadata,
      moduleResources,
      bootstrapModule: bootstrapModuleRef
    }
  };
}
