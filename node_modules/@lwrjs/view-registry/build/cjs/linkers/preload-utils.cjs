var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/view-registry/src/linkers/preload-utils.ts
__markAsModule(exports);
__export(exports, {
  getPreloadModulesMeta: () => getPreloadModulesMeta,
  setPreloadModulesMeta: () => setPreloadModulesMeta
});
var import_diagnostics = __toModule(require("@lwrjs/diagnostics"));
var import_shared_utils = __toModule(require("@lwrjs/shared-utils"));
function setPreloadModulesMeta(specifier, uri, integrity, groups, preloads) {
  if (!uri) {
    throw (0, import_diagnostics.createSingleDiagnosticError)({
      description: import_diagnostics.descriptions.UNRESOLVABLE.PRELOAD_MODULE(specifier)
    }, import_diagnostics.LwrUnresolvableError);
  }
  const [removedVersion, version] = specifier.split("/v/");
  const normalizedSpecifier = version === import_shared_utils.VERSION_NOT_PROVIDED ? removedVersion : specifier;
  specifier = normalizedSpecifier;
  const preloadModulesSpecifiers = preloads.specifiers;
  const preloadBundleGroupsMap = preloads.groups;
  const preloadModulesURIs = preloads.uris;
  const preloadModuleIntegrities = preloads.integrities;
  preloadModulesSpecifiers.push(specifier);
  const {specifier: unversionedSpecifier} = (0, import_shared_utils.explodeSpecifier)(specifier);
  const groupName = (0, import_shared_utils.getGroupName)(unversionedSpecifier, groups);
  if (groupName && preloadBundleGroupsMap.has(groupName)) {
    return;
  }
  preloadModulesURIs.push(uri);
  groupName && preloadBundleGroupsMap.set(groupName, true);
  preloadModuleIntegrities.set(uri, integrity);
}
async function getPreloadModulesMeta(specifier, viewPreloads, bundleConfig, moduleRegistry, defRegistry, runtimeEnvironment, runtimeParams, pending) {
  const {exclude = [], external = {}, groups = {}} = bundleConfig;
  const isExternal = function(rawSpecifier) {
    const {specifier: specifier2} = (0, import_shared_utils.explodeSpecifier)(rawSpecifier);
    return Object.keys(external).includes(specifier2);
  };
  const isExclude = function(specifier2) {
    return exclude.includes(specifier2);
  };
  if (isExternal(specifier)) {
    import_diagnostics.logger.warn({
      label: `view-registry`,
      message: `"${specifier}" is configured in both bundleConfig.externals and bootstrap.preloadModules. We are treating it as external.`
    });
  } else {
    const versionedModuleId = await (0, import_shared_utils.getVersionedModuleId)(specifier, moduleRegistry, runtimeParams);
    const versionedModuleSpecifier = (0, import_shared_utils.getSpecifier)({
      specifier,
      version: (0, import_shared_utils.normalizeVersionToUri)(versionedModuleId.version)
    });
    const uri = await defRegistry.resolveModuleUri(versionedModuleId, runtimeEnvironment, runtimeParams);
    const normalizedSpecifier = versionedModuleId.version === import_shared_utils.VERSION_NOT_PROVIDED ? specifier : versionedModuleSpecifier;
    const preloadModuleRecord = await defRegistry.getModuleBundle(versionedModuleId, runtimeEnvironment, runtimeParams);
    const {integrity} = preloadModuleRecord;
    setPreloadModulesMeta(normalizedSpecifier, uri, integrity, groups, viewPreloads);
    if (exclude.length || Object.keys(groups).length) {
      const {imports} = preloadModuleRecord.bundleRecord;
      if (imports) {
        if (!pending) {
          pending = new Map();
        }
        for (let i = 0; i < imports.length; i++) {
          const imp = imports[i];
          if (!pending.has(imp.specifier) && (isExclude(imp.specifier) || (0, import_shared_utils.isGroupie)(imp.specifier, groups))) {
            pending.set(imp.specifier, true);
            await getPreloadModulesMeta(imp.specifier, viewPreloads, bundleConfig, moduleRegistry, defRegistry, runtimeEnvironment, runtimeParams, pending);
          }
        }
      }
    }
  }
}
