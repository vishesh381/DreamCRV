var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/view-registry/src/utils.ts
__markAsModule(exports);
__export(exports, {
  addExternalScriptNonce: () => addExternalScriptNonce,
  createJsonModule: () => createJsonModule,
  generateHtmlTag: () => generateHtmlTag,
  generateLinkHeaders: () => generateLinkHeaders,
  generatePageContext: () => generatePageContext,
  generateViewNonce: () => generateViewNonce,
  getModuleGraphCacheKey: () => getModuleGraphCacheKey,
  getModuleResource: () => getModuleResource,
  getModuleResourceByUri: () => getModuleResourceByUri,
  getViewDefCacheKey: () => getViewDefCacheKey,
  getViewNonce: () => getViewNonce,
  isViewDefinitionResponse: () => isViewDefinitionResponse,
  isViewResponse: () => isViewResponse,
  normalizeRenderOptions: () => normalizeRenderOptions,
  normalizeRenderedResult: () => normalizeRenderedResult,
  reduceSourceAssetReferences: () => reduceSourceAssetReferences,
  toJsonFormat: () => toJsonFormat
});
var import_path = __toModule(require("path"));
var import_shared_utils = __toModule(require("@lwrjs/shared-utils"));
var import_identity = __toModule(require("@lwrjs/app-service/identity"));
var import_crypto = __toModule(require("crypto"));
function generateExternalStyle(src) {
  return `<link rel="stylesheet" href="${src}">`;
}
function generateExternalScript(type = "application/javascript", src, async, defer, nonce, integrity) {
  let scriptLoadOrder = "";
  if (defer) {
    scriptLoadOrder = " defer";
  } else if (async) {
    scriptLoadOrder = " async";
  }
  let cspHashAttr = "";
  if ((0, import_shared_utils.getFeatureFlags)().ENABLE_NONCE) {
    if (integrity) {
      cspHashAttr = ` integrity="${integrity}"`;
    } else if (nonce) {
      cspHashAttr = ` nonce="${nonce}"`;
    }
  }
  return `<script type="${type}"${scriptLoadOrder}${cspHashAttr} src="${src}"></script>`;
}
function generateLinkPreloadTag({href, type}) {
  if (type === "module") {
    return `<link rel="modulepreload" href="${href}" />`;
  } else {
    return `<link rel="preload" href="${href}" type="${type}" />`;
  }
}
function generateExternalTag({
  type,
  src = "",
  async,
  defer,
  isPreload,
  nonce,
  integrity
}) {
  if (isPreload) {
    return generateLinkPreloadTag({href: src, type});
  } else if (type === "text/css") {
    return generateExternalStyle(src);
  } else {
    return generateExternalScript(type, src, async, defer, nonce, integrity);
  }
}
async function generateInlineTag({specifier, type, content, stream, nonce}) {
  const typeStr = type === "text/css" ? "" : ` type="${type}"`;
  const tag = type === "text/css" ? "style" : "script";
  const nonceStr = (0, import_shared_utils.getFeatureFlags)().ENABLE_NONCE && nonce && nonce ? ` nonce="${nonce}"` : "";
  if (!content && !stream) {
    throw new Error(`Invalid inline Resource Definition: must have either "content" or "stream": "${specifier}"`);
  }
  const code = stream ? await (0, import_shared_utils.streamToString)(stream()) : content;
  return `<${tag}${typeStr}${nonceStr}>${code}</${tag}>`;
}
async function generateHtmlTag(definition) {
  if (definition.inline) {
    return await generateInlineTag(definition);
  } else if (definition.src) {
    return generateExternalTag(definition);
  }
  throw new Error(`Invalid external Resource Definition: missing a "src": "${definition.specifier}"`);
}
function normalizeRenderedResult({
  renderedView,
  metadata,
  options,
  cache,
  status
}) {
  return {
    renderedView,
    metadata: {
      customElements: metadata ? metadata.customElements : [],
      assetReferences: metadata ? metadata.assetReferences : [],
      serverBundles: metadata ? metadata.serverBundles : new Set(),
      serverData: metadata ? metadata.serverData : {},
      serverDebug: metadata ? metadata.serverDebug : {}
    },
    options: {
      skipMetadataCollection: options ? options.skipMetadataCollection : false
    },
    cache: cache || {},
    status
  };
}
function reduceSourceAssetReferences(assets) {
  return assets.map(({url, tagName, override}) => {
    return {
      url,
      tagName,
      override
    };
  });
}
function normalizeRenderOptions(runtimeEnvironment, overrideRenderOptions, baseRenderOptions) {
  return {
    skipMetadataCollection: false,
    freezeAssets: runtimeEnvironment.immutableAssets,
    viewParamCacheKey: null,
    ...baseRenderOptions,
    ...overrideRenderOptions
  };
}
function getTitleFromFilePath(filePath) {
  return filePath && typeof filePath === "string" ? (0, import_path.basename)(filePath, (0, import_path.extname)(filePath)) : import_shared_utils.DEFAULT_TITLE;
}
function generatePageContext({requestPath: url}, {id, contentTemplate, properties}, runtimeParams) {
  const title = properties?.title || getTitleFromFilePath(contentTemplate);
  const locale = runtimeParams.locale;
  const basePath = runtimeParams.basePath;
  const assetBasePath = runtimeParams.assetBasePath;
  const uiBasePath = runtimeParams.uiBasePath;
  return {assetBasePath, basePath, id, locale, title, url, uiBasePath};
}
function isViewResponse(response) {
  return response.body !== void 0;
}
function isViewDefinitionResponse(response) {
  return response.view !== void 0;
}
async function toJsonFormat(viewRequest, viewDefinition, route, runtimeEnvironment, runtimeParams, moduleRegistry) {
  const {viewRecord} = viewDefinition;
  const {bootstrap, id: appName} = route;
  const workerSpecifiers = bootstrap?.workers || {};
  const workers = {};
  for (const id of Object.keys(workerSpecifiers)) {
    const appIdentity = {
      appName,
      format: runtimeEnvironment.format,
      resourceType: import_identity.AppResourceEnum.MODULE,
      subResource: {
        type: import_identity.ResourceIdentityTypes.WORKER,
        workerId: `${id}`
      }
    };
    const workerBootstrapSpecifier = (0, import_identity.getAppSpecifier)(appIdentity);
    workers[id] = await createJsonModule(workerBootstrapSpecifier, moduleRegistry, runtimeEnvironment, runtimeParams);
  }
  const modules = [];
  const resources = [];
  const bootstrapGraph = viewRecord.bootstrapModule;
  if (bootstrapGraph) {
    [bootstrapGraph.flatGraph.graphs[0].specifier, ...bootstrapGraph.flatGraph.graphs[0].static].map((module2) => {
      modules.push({
        specifier: module2,
        links: {
          self: bootstrapGraph.flatGraph.uriMap[module2]
        }
      });
    });
    resources.push({
      type: "application/javascript",
      src: (0, import_shared_utils.getClientBootstrapConfigurationUri)({url: viewRequest.url, id: route.id, query: viewRequest.query}, runtimeEnvironment, runtimeParams)
    });
  }
  const mappingUrl = (0, import_shared_utils.getMappingUriPrefix)(runtimeEnvironment, runtimeParams);
  const endpoints = {
    uris: {
      mapping: mappingUrl
    },
    ...runtimeEnvironment.debug && {modifiers: {debug: "true"}}
  };
  const preloadModules = viewRecord.customElements?.map((ce) => {
    return {
      specifier: ce.flatGraph.graphs[0].specifier,
      links: {
        self: ce.flatGraph.uriMap[ce.flatGraph.graphs[0].specifier]
      }
    };
  });
  viewRecord.assetReferences?.forEach((asset) => {
    if (asset.override?.uri) {
      const type = (0, import_shared_utils.mimeLookup)(asset.override?.uri);
      resources.push({type, src: asset.override?.uri});
    }
  });
  const importMetadata = !runtimeEnvironment.featureFlags?.LEGACY_LOADER && viewRecord.importMetadata;
  viewRecord.resources?.forEach((resource) => {
    resources.push({type: resource.type, src: resource.src});
  });
  const body = {
    ...importMetadata,
    modules,
    preloadModules,
    endpoints,
    resources,
    workers
  };
  return {
    body,
    headers: {
      "Content-Type": "application/json"
    }
  };
}
async function getModuleResource(moduleId, runtimeEnvironment, moduleResourceMeta, defRegistry, runtimeParams) {
  const {format} = runtimeEnvironment;
  const {isSSR = false, isPreload = false} = moduleResourceMeta;
  const moduleUri = await defRegistry.resolveModuleUri(moduleId, runtimeEnvironment, runtimeParams);
  return {
    src: moduleUri,
    type: format === "amd" ? "application/javascript" : "module",
    async: !isSSR && isPreload,
    defer: isSSR,
    isPreload: format !== "amd" && isPreload
  };
}
function getModuleResourceByUri(uri, runtimeEnvironment, moduleResourceMeta) {
  const {integrity, isSSR = false, isPreload = false, nonce} = moduleResourceMeta;
  const {format} = runtimeEnvironment;
  return {
    src: uri,
    type: format === "amd" ? "application/javascript" : "module",
    async: !isSSR && isPreload,
    defer: isSSR,
    isPreload: format !== "amd" && isPreload,
    integrity,
    nonce
  };
}
async function createJsonModule(specifier, moduleRegistry, environment, params) {
  const {version} = await moduleRegistry.getModuleEntry({specifier}, params);
  const {namespace, name} = (0, import_shared_utils.explodeSpecifier)(specifier);
  const moduleIdentifier = {
    specifier,
    namespace,
    name,
    version
  };
  const {ownHash} = await moduleRegistry.getModule(moduleIdentifier, params);
  return {
    specifier: (0, import_shared_utils.getSpecifier)(moduleIdentifier),
    version,
    ownHash,
    links: {
      self: await moduleRegistry.resolveModuleUri(moduleIdentifier, environment, params, ownHash)
    }
  };
}
function getViewNonce(viewParams) {
  return (0, import_shared_utils.getFeatureFlags)().ENABLE_NONCE ? viewParams?.page?.nonce : void 0;
}
function generateViewNonce(viewParams) {
  if ((0, import_shared_utils.getFeatureFlags)().ENABLE_NONCE) {
    const nonce = import_crypto.default.randomBytes(16).toString("base64");
    if (!viewParams.page) {
      viewParams.page = {nonce};
    } else {
      viewParams.page.nonce = nonce;
    }
  }
}
function addExternalScriptNonce(def, nonce) {
  if (nonce && (0, import_shared_utils.getFeatureFlags)().ENABLE_NONCE && !def.inline) {
    def.nonce = nonce;
  }
}
function generateLinkHeaders(assets, patterns) {
  const assetConfig = {};
  for (const assetRef of assets) {
    const path = assetRef.override?.uri || assetRef.url;
    let matched = null;
    for (const pattern of patterns) {
      const {match} = pattern;
      const matchPatterns = Array.isArray(match) ? match : [match];
      for (const filePattern of matchPatterns) {
        const regex = new RegExp(filePattern);
        if (regex.test(path)) {
          matched = pattern.attributes;
          break;
        }
      }
      if (matched)
        break;
    }
    if (matched) {
      assetConfig[path] = matched;
    }
  }
  return Object.keys(assetConfig).reduce((linkHeader, path) => {
    linkHeader = `${linkHeader ? linkHeader + ", " : ""}<${path}>`;
    const properties = assetConfig[path];
    for (const prop in properties) {
      linkHeader += properties[prop] !== "" ? `; ${prop}=${properties[prop]}` : `; ${prop}`;
    }
    return linkHeader;
  }, "");
}
function getViewDefCacheKey(view, runtimeEnvironment, freezeAssets, runtimeParams) {
  const {id, bootstrap, rootComponent, contentTemplate, layoutTemplate} = view;
  return (0, import_shared_utils.getCacheKeyFromJson)({
    id,
    bootstrap,
    rootComponent,
    contentTemplate,
    layoutTemplate,
    freezeAssets,
    locale: runtimeParams?.locale,
    basePath: runtimeParams?.basePath,
    debug: runtimeEnvironment.debug,
    nonceEnabled: (0, import_shared_utils.getFeatureFlags)().ENABLE_NONCE
  });
}
function getModuleGraphCacheKey(specifier, runtimeEnvironment, runtimeParams) {
  const updatedParams = {
    ...runtimeParams
  };
  delete updatedParams.url;
  delete updatedParams.query;
  return (0, import_shared_utils.getCacheKeyFromJson)({
    specifier,
    updatedParams,
    runtimeEnvironment
  });
}
