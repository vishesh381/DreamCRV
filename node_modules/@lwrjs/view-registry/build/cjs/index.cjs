var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/view-registry/src/index.ts
__markAsModule(exports);
__export(exports, {
  LwrViewHandler: () => import_view_handler.LwrViewHandler,
  LwrViewRegistry: () => LwrViewRegistry
});
var import_shared_utils = __toModule(require("@lwrjs/shared-utils"));
var import_instrumentation = __toModule(require("@lwrjs/instrumentation"));
var import_utils = __toModule(require("./utils.cjs"));
var import_link_lwr_resources = __toModule(require("./linkers/link-lwr-resources.cjs"));
var import_lru_cache = __toModule(require("lru-cache"));
var import_diagnostics = __toModule(require("@lwrjs/diagnostics"));
var import_view_handler = __toModule(require("./view-handler.cjs"));
var LwrViewRegistry = class {
  constructor(context, globalConfig) {
    this.viewProviders = [];
    this.compiledViews = new Map();
    this.immutableAssets = new Map();
    this.pendingViewDefinitions = new import_shared_utils.InflightTasks();
    this.name = "lwr-view-registry";
    this.resourceRegistry = context.resourceRegistry;
    this.runtimeEnvironment = context.runtimeEnvironment;
    this.moduleRegistry = context.moduleRegistry;
    this.moduleBundler = context.moduleBundler;
    this.assetRegistry = context.assetRegistry;
    this.viewTransformers = context.viewTransformers || [];
    this.globalConfig = globalConfig;
    this.globalData = context.globalData;
    this.appEmitter = context.appEmitter;
    const observer = context.appObserver;
    this.viewDefinitions = new import_lru_cache.LRUCache({
      max: parseInt(process.env.VIEW_CACHE_SIZE ?? "500", 10),
      dispose: (_value, key) => {
        import_diagnostics.logger.verbose(`View evicted from cache ${key}`);
      }
    });
    observer.onViewSourceChange(({payload}) => this.onViewSourceChange(payload));
    observer.onModuleDefinitionChange(({payload}) => this.onModuleDefinitionChange(payload));
    observer.onAssetSourceChange(({payload}) => this.onAssetSourceChange(payload));
  }
  async onModuleDefinitionChange(moduleDefinition) {
    if ((0, import_shared_utils.isLocalDev)()) {
      this.viewDefinitions.clear();
      return;
    }
    const versionedSpecifier = (0, import_shared_utils.getSpecifier)(moduleDefinition);
    for (const [id, viewDefEntry] of this.viewDefinitions.entries()) {
      const {
        viewDefinition: {viewRecord}
      } = viewDefEntry;
      const uriMap = viewRecord.bootstrapModule?.flatGraph.uriMap;
      if (uriMap) {
        Object.keys(uriMap);
      }
      const someBootstrapDeps = viewRecord.bootstrapModule?.specifier === versionedSpecifier || Object.keys(viewRecord.bootstrapModule?.flatGraph.uriMap || []).includes(versionedSpecifier);
      const someCustomElementsDeps = viewRecord.customElements?.some((element) => {
        return element.flatGraph.graphs[0].specifier === versionedSpecifier || Object.keys(element.flatGraph.uriMap || []).includes(versionedSpecifier);
      });
      if (someBootstrapDeps || someCustomElementsDeps) {
        this.viewDefinitions.delete(id);
      }
    }
  }
  async onViewSourceChange(compiledView) {
    if ((0, import_shared_utils.isLocalDev)()) {
      this.viewDefinitions.clear();
      return;
    }
    const {contentTemplate, rootComponent} = compiledView.viewId;
    const compiledViewCacheKey = (0, import_shared_utils.getCacheKeyFromJson)({contentTemplate, rootComponent});
    this.compiledViews.set(compiledViewCacheKey, compiledView);
    for (const [id, viewDefEntry] of this.viewDefinitions.entries()) {
      const {
        contentTemplate: eContentTempl,
        layoutTemplate: eLayoutTemplate,
        rootComponent: eRootComponent
      } = viewDefEntry.view;
      if (eContentTempl === contentTemplate || eLayoutTemplate === contentTemplate || eRootComponent === rootComponent) {
        this.viewDefinitions.delete(id);
      }
    }
  }
  onAssetSourceChange(asset) {
    const assetId = asset.entry;
    for (const [id, viewDefEntry] of this.viewDefinitions.entries()) {
      const {
        viewDefinition: {viewRecord}
      } = viewDefEntry;
      const someAssets = viewRecord.assetReferences?.some((ref) => {
        return ref.override?.entry === assetId;
      });
      if (someAssets) {
        this.viewDefinitions.delete(id);
      }
    }
  }
  getPublicApi() {
    return {
      getViewDefinition: this.getViewDefinition.bind(this),
      getView: this.getView.bind(this)
    };
  }
  addViewProviders(providers) {
    this.viewProviders.push(...providers);
  }
  addViewTransformers(transformers) {
    this.viewTransformers.push(...transformers);
  }
  initializeViewProviders() {
    return Promise.all(this.viewProviders.map((vp) => vp.initialize()));
  }
  async delegateGetView(viewId) {
    for (const vp of this.viewProviders) {
      const result = await vp.getView(viewId);
      if (result) {
        return result;
      }
    }
    throw new Error(`No View provider was able to resolve a view for template: ${viewId.contentTemplate}`);
  }
  async getView(viewId) {
    const {contentTemplate, rootComponent} = viewId;
    const compiledViewCacheKey = (0, import_shared_utils.getCacheKeyFromJson)({contentTemplate, rootComponent});
    import_diagnostics.logger.debug(`[view-registry][getView] compiledViewCacheKey=${compiledViewCacheKey}`);
    const route = this.globalConfig.routes.find((r) => r.id === viewId.id);
    const skipCaching = route?.cache?.ttl === 0;
    if (!skipCaching && this.compiledViews.has(compiledViewCacheKey)) {
      return this.compiledViews.get(compiledViewCacheKey);
    }
    const compiledView = await this.delegateGetView(viewId);
    if (!skipCaching) {
      this.compiledViews.set(compiledViewCacheKey, compiledView);
    }
    return compiledView;
  }
  hasViewDefinition(view, viewParams, runtimeEnvironment, runtimeParams, renderOptions) {
    const {freezeAssets, viewParamCacheKey} = (0, import_utils.normalizeRenderOptions)(this.runtimeEnvironment, renderOptions);
    const viewDefId = (0, import_utils.getViewDefCacheKey)(view, runtimeEnvironment, freezeAssets, runtimeParams);
    import_diagnostics.logger.debug(`[view-registry][hasViewDefinition] viewDefId=${viewDefId}`);
    const viewParamKey = viewParamCacheKey ? (0, import_shared_utils.getCacheKeyFromJson)(viewParamCacheKey) : (0, import_shared_utils.getCacheKeyFromJson)(viewParams);
    import_diagnostics.logger.debug(`[view-registry][hasViewDefinition] viewParamKey=${viewParamKey}`);
    if (this.viewDefinitions.has(viewDefId)) {
      const viewDef = this.viewDefinitions.get(viewDefId);
      if (viewDef && viewDef.paramKey === viewParamKey) {
        return true;
      }
    }
    return false;
  }
  async getViewDefinition(view, viewParams, runtimeEnvironment, runtimeParams = {requestCache: {}}, renderOptions) {
    runtimeParams.requestCache = runtimeParams.requestCache ?? {};
    try {
      const {freezeAssets, viewParamCacheKey} = (0, import_utils.normalizeRenderOptions)(this.runtimeEnvironment, renderOptions);
      const viewDefCacheKey = (0, import_utils.getViewDefCacheKey)(view, runtimeEnvironment, freezeAssets, runtimeParams);
      import_diagnostics.logger.debug(`[view-registry][getViewDefinition] viewDefCacheKey=${viewDefCacheKey}`);
      const viewParamKey = viewParamCacheKey ? (0, import_shared_utils.getCacheKeyFromJson)(viewParamCacheKey) : (0, import_shared_utils.getCacheKeyFromJson)(viewParams);
      import_diagnostics.logger.debug(`[view-registry][getViewDefinition] viewParamKey=${viewParamKey}`);
      if (this.viewDefinitions.has(viewDefCacheKey) || runtimeParams.requestCache[viewDefCacheKey]) {
        const viewDefinition2 = this.viewDefinitions.get(viewDefCacheKey) || runtimeParams.requestCache[viewDefCacheKey];
        if (viewDefinition2 && viewDefinition2.paramKey === viewParamKey && viewDefinition2.viewDefinition.immutable) {
          return viewDefinition2.viewDefinition;
        }
      }
      const updatableViewParams = {...viewParams};
      (0, import_utils.generateViewNonce)(updatableViewParams);
      const pendingViewDefCacheKey = viewDefCacheKey + viewParamKey;
      const viewDefinition = await this.pendingViewDefinitions.execute(pendingViewDefCacheKey, () => (0, import_instrumentation.getTracer)().trace({
        name: import_instrumentation.ViewSpan.RenderView,
        attributes: {
          view: view.id,
          ssr: view.bootstrap?.ssr === true
        }
      }, () => this.renderView(view, updatableViewParams, runtimeEnvironment, runtimeParams, pendingViewDefCacheKey, renderOptions)));
      viewDefinition.nonce = (0, import_utils.getViewNonce)(updatableViewParams);
      const route = this.globalConfig.routes.find((r) => r.id === view.id);
      const maxViewCacheTtl = (0, import_shared_utils.getFeatureFlags)().MAX_VIEW_CACHE_TTL;
      const maxTtl = maxViewCacheTtl && parseInt(maxViewCacheTtl, 10);
      const leastTtl = (0, import_shared_utils.shortestTtl)(viewDefinition.cache?.ttl, route?.cache?.ttl, maxTtl);
      const ttl = leastTtl !== void 0 ? leastTtl === 0 ? 10 : leastTtl * 1e3 : void 0;
      const viewDefCacheEntry = {view, viewDefinition, paramKey: viewParamKey};
      if (view.bootstrap?.includeCookiesForSSR) {
        runtimeParams.requestCache[viewDefCacheKey] = viewDefCacheEntry;
      } else {
        this.viewDefinitions.set(viewDefCacheKey, viewDefCacheEntry, {ttl});
      }
      return viewDefinition;
    } catch (err) {
      if (err instanceof import_diagnostics.DiagnosticsError) {
        throw err;
      }
      import_diagnostics.logger.error(`Failed to get view definition "${view.id}"`);
      import_diagnostics.logger.error(err);
      const message = err instanceof Error ? err.message : String(err);
      throw (0, import_diagnostics.createSingleDiagnosticError)({description: import_diagnostics.descriptions.SERVER.UNEXPECTED_ERROR(message)}, import_diagnostics.LwrServerError);
    }
  }
  async renderView(view, viewParams, runtimeEnvironment, runtimeParams, viewCacheKey, renderOptions) {
    const {id, contentTemplate, rootComponent, layoutTemplate} = view;
    const lwrResourcesId = `__LWR_RESOURCES__${Date.now()}`;
    const renderedContent = await this.render({id, contentTemplate, rootComponent}, {...viewParams, lwr_resources: lwrResourcesId}, runtimeParams, runtimeEnvironment);
    let normalizedRenderOptions = (0, import_utils.normalizeRenderOptions)(this.runtimeEnvironment, renderedContent.options, renderOptions);
    const layout = layoutTemplate || renderedContent.compiledView.layoutTemplate;
    if (!layout) {
      const renderedViewDef2 = await this.link(renderedContent, {
        view,
        viewParams,
        runtimeEnvironment,
        runtimeParams,
        renderOptions: normalizedRenderOptions,
        contentIds: {lwrResourcesId},
        viewCacheKey
      });
      return renderedViewDef2;
    }
    const layoutTemplatePath = (0, import_shared_utils.normalizeResourcePath)(layout, this.globalConfig);
    const renderedLayout = await this.render({id, contentTemplate: layoutTemplatePath}, {
      ...renderedContent.compiledView.properties,
      ...viewParams,
      body: renderedContent.renderedView,
      lwr_resources: lwrResourcesId
    }, runtimeParams, runtimeEnvironment);
    normalizedRenderOptions = (0, import_utils.normalizeRenderOptions)(this.runtimeEnvironment, renderedLayout.options, normalizedRenderOptions);
    const renderedViewDef = await this.link({
      ...renderedLayout,
      compiledView: {
        ...renderedLayout.compiledView,
        immutable: renderedContent.compiledView.immutable && renderedLayout.compiledView.immutable
      },
      metadata: {
        customElements: [
          ...renderedContent.metadata.customElements,
          ...renderedLayout.metadata.customElements
        ],
        assetReferences: [
          ...renderedContent.metadata.assetReferences,
          ...renderedLayout.metadata.assetReferences
        ],
        serverData: {
          ...renderedContent.metadata.serverData,
          ...renderedLayout.metadata.serverData
        },
        serverDebug: {
          ...renderedContent.metadata.serverDebug,
          ...renderedLayout.metadata.serverDebug
        },
        serverBundles: renderedContent.metadata.serverBundles
      },
      cache: renderedContent.cache,
      status: renderedContent.status
    }, {
      view: {...view, layoutTemplate: layoutTemplatePath},
      viewParams,
      runtimeEnvironment,
      runtimeParams,
      renderOptions: normalizedRenderOptions,
      contentIds: {lwrResourcesId},
      importer: renderedContent.compiledView.filePath,
      viewCacheKey
    });
    return renderedViewDef;
  }
  async render(viewId, viewParams, runtimeParams, runtimeEnvironment) {
    const globalContext = this.globalData;
    const {id, rootComponent, contentTemplate} = viewId;
    const compiledView = await this.getView({id, contentTemplate, rootComponent});
    const result = await compiledView.render({
      ...runtimeParams,
      ...globalContext,
      ...compiledView.properties,
      ...viewParams
    }, runtimeEnvironment);
    const normalizedResult = (0, import_utils.normalizeRenderedResult)(result);
    return {
      compiledView,
      ...normalizedResult
    };
  }
  async link(renderedView, viewContext) {
    const {
      view,
      viewParams,
      runtimeEnvironment: runtimeEnv,
      runtimeParams,
      renderOptions,
      contentIds,
      importer,
      viewCacheKey
    } = viewContext;
    const {skipMetadataCollection, freezeAssets} = renderOptions;
    const {lwrResourcesId} = contentIds;
    const {moduleRegistry, resourceRegistry, moduleBundler} = this;
    const runtimeEnvironment = {...runtimeEnv, immutableAssets: freezeAssets};
    const {
      renderedView: renderedViewContent,
      metadata: renderedViewMetadata,
      compiledView: {immutable = true}
    } = renderedView;
    const {linkedMetadata, stringBuilder} = (0, import_instrumentation.getTracer)().trace({
      name: import_instrumentation.ViewSpan.ParseView,
      attributes: {
        view: view.id,
        ssr: view.bootstrap?.ssr === true
      }
    }, () => {
      const linkedMetadata2 = skipMetadataCollection ? renderedViewMetadata : (0, import_shared_utils.extractMetadataFromHtml)(renderedViewContent, renderedViewMetadata, this.globalConfig);
      const stringBuilder2 = (0, import_shared_utils.createStringBuilder)(renderedViewContent);
      return {linkedMetadata: linkedMetadata2, stringBuilder: stringBuilder2};
    });
    const mergedViewContext = {
      ...viewContext,
      config: this.globalConfig,
      runtimeEnvironment,
      importer: importer || renderedView.compiledView.filePath
    };
    let pageTtl = renderedView.cache.ttl;
    let pageStatus = renderedView.status;
    for (const viewTransformer of this.viewTransformers) {
      const linkResults = await (0, import_instrumentation.getTracer)().trace({
        name: import_instrumentation.ViewSpan.Transform,
        attributes: {
          name: viewTransformer.name
        }
      }, () => viewTransformer.link?.(stringBuilder, mergedViewContext, linkedMetadata));
      const ttl = linkResults && linkResults.cache?.ttl;
      pageTtl = (0, import_shared_utils.shortestTtl)(ttl || void 0, pageTtl);
      if (!pageStatus && linkResults) {
        pageStatus = linkResults.status;
      }
    }
    const linkedAssetContent = stringBuilder.toString();
    if (linkedAssetContent.includes(lwrResourcesId)) {
      const {renderedView: linkedView, viewRecord} = await (0, import_link_lwr_resources.linkLwrResources)(linkedAssetContent, view, viewParams, {
        lwrResourcesId,
        viewMetadata: linkedMetadata,
        moduleRegistry,
        moduleBundler,
        resourceRegistry,
        runtimeEnvironment,
        runtimeParams,
        bundleConfig: this.globalConfig.bundleConfig,
        unsafeEnableViewLinkCaching: this.globalConfig.unsafeEnableViewLinkCaching,
        viewLinkCacheKey: viewCacheKey
      });
      if (viewRecord.resources?.length) {
        linkedMetadata.assetReferences.push(...viewRecord.resources.reduce((res, asset) => {
          if (!asset.src)
            return res;
          res.push({
            url: asset.src,
            relative: (0, import_shared_utils.isRelative)(asset.src)
          });
          return res;
        }, []));
      }
      return {
        renderedView: linkedView,
        immutable,
        viewRecord: {
          assetReferences: (0, import_utils.reduceSourceAssetReferences)(linkedMetadata.assetReferences),
          ...viewRecord,
          serverBundles: linkedMetadata.serverBundles
        },
        cache: {ttl: pageTtl},
        status: pageStatus
      };
    }
    return {
      renderedView: linkedAssetContent,
      immutable,
      viewRecord: {
        assetReferences: (0, import_utils.reduceSourceAssetReferences)(linkedMetadata.assetReferences),
        moduleResources: [],
        serverBundles: linkedMetadata.serverBundles
      },
      cache: {ttl: pageTtl},
      status: pageStatus
    };
  }
};
