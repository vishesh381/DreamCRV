import fs from 'fs-extra';
import { extname, normalize } from 'path';
import { logger } from '@lwrjs/diagnostics';
import { mimeLookup, normalizeAssetSpecifier } from '@lwrjs/shared-utils';
function hash(filePath) {
    const result = fs.statSync(filePath);
    return (result.mtimeMs * 10000).toString();
}
export default class FsAssetProvider {
    constructor(_pluginConfig, providerConfig) {
        this.name = 'fs-asset-provider';
        this.cachedAssets = new Map();
        const { appEmitter, runtimeEnvironment: { watchFiles }, watcherFactory, } = providerConfig;
        const { assets, rootDir, layoutsDir, contentDir, basePath } = providerConfig.config;
        this.basePath = basePath;
        this.resourcePaths = { assets, rootDir, layoutsDir, contentDir };
        this.assetPathMap = assets.reduce((map, asset) => {
            const urlPath = `${basePath}${asset.urlPath}`;
            map.set(urlPath, asset.dir || asset.file);
            return map;
        }, new Map());
        this.emitter = appEmitter;
        if (watchFiles && watcherFactory) {
            this.watcher = watcherFactory.setupWatcher(this.onModuleChange.bind(this));
        }
    }
    async onModuleChange(fileChanged) {
        let cachedAsset = this.cachedAssets.get(fileChanged);
        if (!cachedAsset) {
            throw new Error("We are observing a file we have not yet processed, this shouldn't happen...");
        }
        // Update the cache entry
        this.cachedAssets.delete(fileChanged);
        cachedAsset = await this.getAssetFromFSPath(fileChanged);
        this.emitter.notifyAssetSourceChanged(cachedAsset);
    }
    // -- Public API --------------------------------------------------------------------
    async initialize() {
        return;
    }
    /**
     * Public API to get an AssetSource object from an asset identifier
     */
    async getAsset(assetId) {
        const fullAssetPath = normalizeAssetSpecifier(assetId, this.assetPathMap, this.resourcePaths, this.basePath);
        return this.getAssetFromFSPath(fullAssetPath);
    }
    /**
     * Get and AssetSource object from a resolved filesystem file path.
     */
    async getAssetFromFSPath(assetPath) {
        assetPath = normalize(assetPath);
        const fullAssetPath = decodeURI(assetPath); // decodeURIComponent decodes too many things (eg: /)
        if (!this.cachedAssets.has(fullAssetPath)) {
            const [assetPath] = fullAssetPath.split('?'); // remove query params
            // Clever normalization to avoid corner cases
            const ext = extname(`x.${assetPath}`).toLowerCase().substring(1);
            if (ext && fs.existsSync(assetPath)) {
                const ownHash = hash(assetPath);
                const mimeType = mimeLookup(assetPath);
                const assetDef = {
                    entry: assetPath,
                    ext: ext,
                    mime: mimeType,
                    ownHash,
                    content: (passedEncoding) => {
                        const encoding = passedEncoding ||
                            (mimeType && mimeType.startsWith('text/') ? 'utf-8' : null);
                        return fs.readFileSync(assetPath, { encoding });
                    },
                };
                this.cachedAssets.set(fullAssetPath, assetDef);
                if (this.watcher) {
                    this.watcher.add(assetPath);
                }
            }
            else {
                logger.debug({
                    label: `${this.name}`,
                    message: `Asset ${fullAssetPath} did not exist on filesystem at ${assetPath}`,
                });
                // returned undefined move on to next provider
                return undefined;
            }
        }
        return this.cachedAssets.get(fullAssetPath);
    }
}
//# sourceMappingURL=index.js.map