import path from 'path';
import express from 'express';
import { getRuntime } from '@salesforce/pwa-kit-runtime/ssr/server/express.js';
import { getConfig } from '@salesforce/pwa-kit-runtime/utils/ssr-config.js';
import LwrApp from '@lwrjs/server/express';
import { requestProcessorMiddleware, localeMiddleware, bundleMiddleware, mappingMiddleware, assetMiddleware, resourceMiddleware, viewMiddleware, } from '@lwrjs/core/middleware';
import { executeInstrumentationHooks } from '@lwrjs/config';
import { getTracer, LambdaSpan } from '@lwrjs/instrumentation';
import instrumentationHook from '@lwrjs/instrumentation/aws-init';
import { logger } from '@lwrjs/diagnostics';
import { createServerContext } from './context/server-context.js';
import { addMrtStaticBundleMiddleware } from './utils.js';
import { isLambdaEnv } from '@lwrjs/shared-utils';
/**
 * Create a Lambda handler that uses serverless-express and LWR middleware
 *
 * @remarks
 * The server context must be fully initialized prior to creating the handler.  Asynchronous
 * initialization may cause the handler to improperly respond to requests.
 *
 * @privateRemarks
 * Asynchronous server context initialization can be supported with top-level await once MRT
 * enables ESM support.
 *
 * @param {ServerContext} context - the LWR server context
 * @returns a lambda handler
 */
export function createHandler(build) {
    try {
        let instrumentation;
        if (build.hooks.length) {
            instrumentation = executeInstrumentationHooks(build.hooks);
        }
        if (!instrumentation) {
            instrumentation = executeInstrumentationHooks([new instrumentationHook()]);
        }
        // creating a span without setting context to avoid rooting all request handles
        const span = getTracer().startSpan({ name: LambdaSpan.CreateHandler });
        // Log LWR/LWC versions if available on MRT
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore Only available on MRT
        if (globalThis.LWR_VERSION) {
            logger.info({
                label: 'versions',
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore Only available on MRT
                message: `LWR_VERSION: ${globalThis.LWR_VERSION}; LWC_VERSION: ${globalThis.LWC_VERSION}; PWA_KIT_RUNTIME_VERSION: ${globalThis.PWA_KIT_RUNTIME_VERSION};`,
            });
        }
        // Remove Existing unhandledRejection Listeners
        // AWS -> https://github.com/aws/aws-lambda-nodejs-runtime-interface-client/blob/main/src/index.mjs#L33
        // PWA Kit -> https://github.com/SalesforceCommerceCloud/pwa-kit/blob/3.0.0/packages/pwa-kit-runtime/src/ssr/server/build-remote-server.js#L904
        process.removeAllListeners('unhandledRejection');
        process.on('unhandledRejection', (err) => {
            // creating immediately closed span to mark the unhandled rejection
            getTracer().startSpan({ name: LambdaSpan.UnhandledRejection }).end();
            logger.error(`LWR Unhandled Promise Rejection: ${err?.message}`);
            logger.error(err);
        });
        // MRT assume a folder named app is the root of the application content
        const outputDir = build.buildDir;
        const buildDir = path.resolve(process.cwd(), outputDir);
        // check if the handler is running on lambda
        if (isLambdaEnv()) {
            // configure working directory and root dir when running on lambda
            process.chdir(__dirname);
            build.appConfig.rootDir = __dirname;
            // cache dir must be in the tmp directory for write access
            build.appConfig.cacheDir = '/tmp/__lwr_cache__';
        }
        else {
            // Set the working directory to be the buildDir
            process.chdir(buildDir);
            build.appConfig.rootDir = buildDir;
        }
        const serverContext = getTracer().trace({ name: LambdaSpan.CreateServerContext }, () => createServerContext(build));
        const options = {
            // The build directory (an absolute path)
            buildDir,
            // The cache time for SSR'd pages (defaults to 600 seconds)
            defaultCacheTimeSeconds: 600,
            // The port that the local dev server listens on
            port: serverContext.appConfig.port || 3000,
            // The protocol on which the development Express app listens.
            // Note that http://localhost is treated as a secure context for development.
            protocol: 'http',
            mobify: getConfig(),
        };
        const runtime = getRuntime();
        // mute pwa-kit startup log
        runtime._logStartupMessage = () => undefined;
        const { handler } = runtime.createHandler(options, (app) => {
            const { appConfig: { basePath, staticSiteGenerator }, } = serverContext;
            // creating a router for lwr to support base path
            const router = express.Router({
                caseSensitive: build.appConfig.caseSensitiveRoutes,
            });
            // flush all metrics after each request to prevent reporting during resolution
            router.use((req, res, next) => {
                res.on('finish', () => {
                    instrumentation?.flush();
                });
                next();
            });
            // If this is a dev server attach the static bundle endpoint to proxy bundle asset requests to the local app directory.
            if (process.env?.BUNDLE_ID == undefined) {
                addMrtStaticBundleMiddleware(app, staticSiteGenerator);
            }
            // mounting the lwr express router to mrt
            app.use(basePath, router);
            // creating lwr express application
            const lwrApp = new LwrApp({ app: router });
            // attaching all required middleware for running in lambda
            requestProcessorMiddleware(lwrApp, serverContext);
            localeMiddleware(lwrApp, serverContext);
            bundleMiddleware(lwrApp, serverContext);
            mappingMiddleware(lwrApp, serverContext);
            assetMiddleware(lwrApp, serverContext);
            resourceMiddleware(lwrApp, serverContext);
            viewMiddleware(lwrApp, serverContext);
        });
        span.end();
        return handler;
    }
    catch (error) {
        logger.error(error);
        throw error;
    }
}
//# sourceMappingURL=index.js.map