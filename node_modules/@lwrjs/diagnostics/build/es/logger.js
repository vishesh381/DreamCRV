import { DiagnosticsError } from './errors.js';
import { inspect } from 'util';
export const SILENT = 'silent';
export const VERBOSE = 'verbose';
export const DEBUG = 'debug';
export const INFO = 'info';
export const WARN = 'warn';
export const ERROR = 'error';
let options = {};
const DUPES = new Set();
function isLevelEnabled(level) {
    const LOG_LEVEL = getLogLevel();
    switch (level) {
        case VERBOSE:
            return LOG_LEVEL == VERBOSE;
        case DEBUG:
            return LOG_LEVEL == VERBOSE || LOG_LEVEL == DEBUG;
        case INFO:
            return LOG_LEVEL == VERBOSE || LOG_LEVEL == DEBUG || LOG_LEVEL == INFO;
        case WARN:
            return LOG_LEVEL == VERBOSE || LOG_LEVEL == DEBUG || LOG_LEVEL == INFO || LOG_LEVEL == WARN;
        case ERROR:
            return true;
        case SILENT:
        default:
            return false;
    }
}
function getLogLevel() {
    return process.env.LWR_LOG_LEVEL || INFO; // TODO control for invalid log levels being set
}
function log(level, message, additionalInfo) {
    // if log level not enabled, don't log
    if (!isLevelEnabled(level)) {
        return;
    }
    // Check if we should suppress dupes and we have already logged this message
    if (options.dedupe && options.dedupe.has(level)) {
        const key = `[${level}] : ${message}`;
        if (DUPES.has(key)) {
            return; // Don't log duplicates
        }
        else {
            DUPES.add(key); // add key to de-duplicate cache
        }
    }
    const logMessage = `[${level}]${gap(message)}${message}`;
    const additionalMessage = additionalInfo ? `Additional Info: ${inspect(additionalInfo)}` : undefined;
    if (level == ERROR) {
        console.error('\x1b[31m%s\x1b[0m', logMessage); // red
        if (additionalInfo) {
            console.error('\n\x1b[31m%s\x1b[0m', additionalMessage); // red
        }
    }
    else if (level == WARN) {
        console.warn('\x1b[33m%s\x1b[0m', logMessage); // yellow
        if (additionalInfo) {
            console.warn('\n\x1b[33m%s\x1b[0m', additionalMessage); // yellow
        }
    }
    else if (level == DEBUG || level == VERBOSE) {
        console.log('\x1b[2m%s\x1b[0m', logMessage); // dim
        if (additionalInfo) {
            console.log('\n\x1b[2m%s\x1b[0m', additionalMessage); // dim
        }
    }
    else {
        console.log(logMessage);
        if (additionalInfo) {
            console.log(`\n${additionalMessage}`);
        }
    }
}
export const stringifyError = (error, count = 0) => {
    if (error instanceof DiagnosticsError) {
        return JSON.stringify({
            // Message may have been encoded to prevent XSS
            message: decodeMessage(error.message),
            diagnostics: error.diagnostics,
            stack: error.stack,
        });
    }
    else if (error.message) {
        const message = error.message;
        const cause = error.cause && count < 1 ? `\nCause: ${stringifyError(error.cause, 1)}` : '';
        // Message may have been encoded to prevent XSS
        return decodeMessage(message) + cause;
    }
    else if (typeof error === 'string' || error instanceof String) {
        // Message may have been encoded to prevent XSS
        return decodeMessage(error);
    }
    else {
        const propertyNames = Object.getOwnPropertyNames(error);
        const retObj = {};
        for (let property, i = 0, len = propertyNames.length; i < len; ++i) {
            property = propertyNames[i];
            const descriptor = Object.getOwnPropertyDescriptor(error, property);
            // Message may have been encoded to prevent XSS
            retObj[property] = decodeMessage(descriptor?.value);
        }
        return inspect(retObj);
    }
};
function decodeMessage(message) {
    return typeof message === 'string' || message instanceof String
        ? decodeURIComponent(message)
        : message;
}
// Return a space if there should be a space between the message and the level
function gap(message) {
    return String(message)?.indexOf('[') === 0 ? '' : ' ';
}
function logError(err, additionalInfo) {
    if (err instanceof DiagnosticsError || !err || !err.message) {
        log(ERROR, stringifyError(err), additionalInfo);
    }
    // If this is an error with a message update the message header and log as is...
    if (err && err.message) {
        console.error('\x1b[31m%s\x1b[0m', `[${ERROR}]${gap(err.message)}${err.message}`);
        console.error('\x1b[90m%s\x1b[0m', err);
    }
}
export const logger = {
    verbose: (info, additionalInfo) => {
        if (typeof info === 'string') {
            log(VERBOSE, info, additionalInfo);
        }
        else {
            log(VERBOSE, `[${info.label}] ${info.message}`, info.additionalInfo || additionalInfo);
        }
    },
    debug: (info, additionalInfo) => {
        if (typeof info === 'string') {
            log(DEBUG, info, additionalInfo);
        }
        else {
            log(DEBUG, `[${info.label}] ${info.message}`, info.additionalInfo || additionalInfo);
        }
    },
    info: (info, additionalInfo) => {
        if (typeof info === 'string') {
            log(INFO, info, additionalInfo);
        }
        else {
            log(INFO, `[${info.label}] ${info.message}`, info.additionalInfo || additionalInfo);
        }
    },
    warn: (info, additionalInfo) => {
        if (typeof info === 'string') {
            log(WARN, info, additionalInfo);
        }
        else {
            log(WARN, `[${info.label}] ${info.message}`, info.additionalInfo || additionalInfo);
        }
    },
    // TODO should logger.error accept a label or is that overkill
    error: (error, additionalInfo) => logError(error, additionalInfo),
    log,
    setOptions: (opts) => {
        options = opts;
    },
    getLogLevel,
    isDebugEnabled: () => isLevelEnabled(DEBUG),
    isVerboseEnabled: () => isLevelEnabled(VERBOSE),
    isWarnEnabled: () => isLevelEnabled(WARN),
    isInfoEnabled: () => isLevelEnabled(INFO),
    isErrorEnabled: () => isLevelEnabled(ERROR),
};
//# sourceMappingURL=logger.js.map