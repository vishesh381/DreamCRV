// The NodeJS Error is different from the JavaScript Error (e.g. NodeJS Error has a code)
export function isNodeError(error) {
    return error instanceof Error;
}
export function createSingleDiagnosticError(diag, errorClass = DiagnosticsError) {
    return new errorClass(diag.description.message, [diag]);
}
export class DiagnosticsError extends Error {
    constructor(message, diagnostics) {
        if (diagnostics.length === 0) {
            throw new Error('No diagnostics');
        }
        super();
        this._memoMessage = undefined;
        this._message = message;
        this.diagnostics = diagnostics;
        this.name = 'DiagnosticsError';
    }
    // Lazily instantiate this. If we ever catchDiagnostics we wont even care about the `message`
    // so this avoids having to print it to a string
    get message() {
        if (this._memoMessage !== undefined) {
            return this._memoMessage;
        }
        const message = this._message === undefined ? '' : this._message + '\n';
        return message;
    }
    // Allow set message can be called from rollup ModuleLoader.addModuleSource
    set message(message) {
        this._message = message;
    }
}
export class LwrConfigValidationError extends DiagnosticsError {
}
export class LwrUnresolvableError extends DiagnosticsError {
}
export class LwrServerError extends DiagnosticsError {
    constructor(message, diagnostics) {
        super(message, diagnostics);
        this.name = 'ServerError';
    }
}
export class LwrApplicationError extends DiagnosticsError {
    constructor(message, diagnostics) {
        super(message, diagnostics);
        this.name = 'ApplicationError';
    }
}
//# sourceMappingURL=errors.js.map