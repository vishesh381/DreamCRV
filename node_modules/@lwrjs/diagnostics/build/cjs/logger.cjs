var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/diagnostics/src/logger.ts
__markAsModule(exports);
__export(exports, {
  DEBUG: () => DEBUG,
  ERROR: () => ERROR,
  INFO: () => INFO,
  SILENT: () => SILENT,
  VERBOSE: () => VERBOSE,
  WARN: () => WARN,
  logger: () => logger,
  stringifyError: () => stringifyError
});
var import_errors = __toModule(require("./errors.cjs"));
var import_util = __toModule(require("util"));
var SILENT = "silent";
var VERBOSE = "verbose";
var DEBUG = "debug";
var INFO = "info";
var WARN = "warn";
var ERROR = "error";
var options = {};
var DUPES = new Set();
function isLevelEnabled(level) {
  const LOG_LEVEL = getLogLevel();
  switch (level) {
    case VERBOSE:
      return LOG_LEVEL == VERBOSE;
    case DEBUG:
      return LOG_LEVEL == VERBOSE || LOG_LEVEL == DEBUG;
    case INFO:
      return LOG_LEVEL == VERBOSE || LOG_LEVEL == DEBUG || LOG_LEVEL == INFO;
    case WARN:
      return LOG_LEVEL == VERBOSE || LOG_LEVEL == DEBUG || LOG_LEVEL == INFO || LOG_LEVEL == WARN;
    case ERROR:
      return true;
    case SILENT:
    default:
      return false;
  }
}
function getLogLevel() {
  return process.env.LWR_LOG_LEVEL || INFO;
}
function log(level, message, additionalInfo) {
  if (!isLevelEnabled(level)) {
    return;
  }
  if (options.dedupe && options.dedupe.has(level)) {
    const key = `[${level}] : ${message}`;
    if (DUPES.has(key)) {
      return;
    } else {
      DUPES.add(key);
    }
  }
  const logMessage = `[${level}]${gap(message)}${message}`;
  const additionalMessage = additionalInfo ? `Additional Info: ${(0, import_util.inspect)(additionalInfo)}` : void 0;
  if (level == ERROR) {
    console.error("[31m%s[0m", logMessage);
    if (additionalInfo) {
      console.error("\n[31m%s[0m", additionalMessage);
    }
  } else if (level == WARN) {
    console.warn("[33m%s[0m", logMessage);
    if (additionalInfo) {
      console.warn("\n[33m%s[0m", additionalMessage);
    }
  } else if (level == DEBUG || level == VERBOSE) {
    console.log("[2m%s[0m", logMessage);
    if (additionalInfo) {
      console.log("\n[2m%s[0m", additionalMessage);
    }
  } else {
    console.log(logMessage);
    if (additionalInfo) {
      console.log(`
${additionalMessage}`);
    }
  }
}
var stringifyError = (error, count = 0) => {
  if (error instanceof import_errors.DiagnosticsError) {
    return JSON.stringify({
      message: decodeMessage(error.message),
      diagnostics: error.diagnostics,
      stack: error.stack
    });
  } else if (error.message) {
    const message = error.message;
    const cause = error.cause && count < 1 ? `
Cause: ${stringifyError(error.cause, 1)}` : "";
    return decodeMessage(message) + cause;
  } else if (typeof error === "string" || error instanceof String) {
    return decodeMessage(error);
  } else {
    const propertyNames = Object.getOwnPropertyNames(error);
    const retObj = {};
    for (let property, i = 0, len = propertyNames.length; i < len; ++i) {
      property = propertyNames[i];
      const descriptor = Object.getOwnPropertyDescriptor(error, property);
      retObj[property] = decodeMessage(descriptor?.value);
    }
    return (0, import_util.inspect)(retObj);
  }
};
function decodeMessage(message) {
  return typeof message === "string" || message instanceof String ? decodeURIComponent(message) : message;
}
function gap(message) {
  return String(message)?.indexOf("[") === 0 ? "" : " ";
}
function logError(err, additionalInfo) {
  if (err instanceof import_errors.DiagnosticsError || !err || !err.message) {
    log(ERROR, stringifyError(err), additionalInfo);
  }
  if (err && err.message) {
    console.error("[31m%s[0m", `[${ERROR}]${gap(err.message)}${err.message}`);
    console.error("[90m%s[0m", err);
  }
}
var logger = {
  verbose: (info, additionalInfo) => {
    if (typeof info === "string") {
      log(VERBOSE, info, additionalInfo);
    } else {
      log(VERBOSE, `[${info.label}] ${info.message}`, info.additionalInfo || additionalInfo);
    }
  },
  debug: (info, additionalInfo) => {
    if (typeof info === "string") {
      log(DEBUG, info, additionalInfo);
    } else {
      log(DEBUG, `[${info.label}] ${info.message}`, info.additionalInfo || additionalInfo);
    }
  },
  info: (info, additionalInfo) => {
    if (typeof info === "string") {
      log(INFO, info, additionalInfo);
    } else {
      log(INFO, `[${info.label}] ${info.message}`, info.additionalInfo || additionalInfo);
    }
  },
  warn: (info, additionalInfo) => {
    if (typeof info === "string") {
      log(WARN, info, additionalInfo);
    } else {
      log(WARN, `[${info.label}] ${info.message}`, info.additionalInfo || additionalInfo);
    }
  },
  error: (error, additionalInfo) => logError(error, additionalInfo),
  log,
  setOptions: (opts) => {
    options = opts;
  },
  getLogLevel,
  isDebugEnabled: () => isLevelEnabled(DEBUG),
  isVerboseEnabled: () => isLevelEnabled(VERBOSE),
  isWarnEnabled: () => isLevelEnabled(WARN),
  isInfoEnabled: () => isLevelEnabled(INFO),
  isErrorEnabled: () => isLevelEnabled(ERROR)
};
