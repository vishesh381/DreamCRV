import fs from 'fs-extra';
import path from 'path';
import { logger } from '@lwrjs/diagnostics';
import { SiteMetadataImpl, parseSiteId } from '../site-metadata.js';
import { LOCALE_SIGIL, hashContent } from '@lwrjs/shared-utils';
export async function dedupeBundles(rootDir, i18n) {
    const siteMetadata = new SiteMetadataImpl({
        rootDir,
        i18n,
    });
    const siteBundles = siteMetadata.getSiteBundles();
    const decisionTree = siteMetadata.getSiteBundlesDecisionTree();
    logger.info({
        label: `dedupeBundles`,
        message: `Deduplicating ${Object.keys(siteBundles.bundles).length} bundles`,
    });
    for (const [siteIdStr, metadata] of Object.entries(siteBundles.bundles)) {
        const siteId = parseSiteId(siteIdStr);
        const localeId = siteId.variants[LOCALE_SIGIL];
        // If this is already the default locale has no fall backs skip
        if (!localeId || localeId === i18n.defaultLocale) {
            continue;
        }
        // Read the content from the current metadata
        const currentPath = path.join(rootDir, metadata.path);
        const currentSrc = fs.readFileSync(currentPath);
        logger.debug({
            label: `dedupeBundles`,
            message: `${siteIdStr} -> ${hashContent(currentSrc)}`,
        });
        // Find the current locale
        const locale = i18n.locales.find((l) => l.id === localeId);
        const fallBackLocale = locale?.fallback ?? i18n.defaultLocale;
        const fallbackMetadata = decisionTree.find(siteIdStr, false, false, fallBackLocale);
        if (fallbackMetadata) {
            // Read the content of the fallback metadata
            const fallbackSrc = fs.readFileSync(path.join(rootDir, fallbackMetadata.path));
            logger.debug({
                label: `dedupeBundles`,
                message: `fallback ${siteIdStr},${fallBackLocale} -> ${hashContent(fallbackSrc)}`,
            });
            if (currentSrc.equals(fallbackSrc)) {
                logger.debug({
                    label: `dedupeBundles`,
                    message: `Remove duplicate variant ${siteIdStr}`,
                });
                delete siteBundles.bundles[siteIdStr];
                // Do not remove the file if it is the same path as the fallback
                if (metadata.path != fallbackMetadata.path) {
                    fs.removeSync(currentPath);
                }
            }
        }
    }
    logger.info({
        label: `dedupeBundles`,
        message: `Deduplicated down to ${Object.keys(siteBundles.bundles).length} bundles`,
    });
    // Save the updated bundle metadata
    await siteMetadata.persistSiteMetadata();
    // Clean up empty folders
    deleteEmptyFolders(rootDir);
}
function deleteEmptyFolders(directory) {
    if (!fs.existsSync(directory)) {
        logger.warn({ label: `dedupeBundles`, message: `Directory does not exist: ${directory}` });
        return;
    }
    const files = fs.readdirSync(directory);
    if (files.length === 0) {
        fs.rmdirSync(directory);
        logger.debug({ label: `dedupeBundles`, message: `Deleted empty folder: ${directory}` });
        return;
    }
    files.forEach((file) => {
        const filePath = path.join(directory, file);
        const isDirectory = fs.statSync(filePath).isDirectory();
        if (isDirectory) {
            deleteEmptyFolders(filePath);
        }
    });
    // Check if the directory is empty after deleting its subdirectories
    const updatedFiles = fs.readdirSync(directory);
    if (updatedFiles.length === 0) {
        fs.rmdirSync(directory);
        logger.debug({ label: `dedupeBundles`, message: `Deleted empty folder: ${directory}` });
    }
}
//# sourceMappingURL=dedupe-bundles.js.map