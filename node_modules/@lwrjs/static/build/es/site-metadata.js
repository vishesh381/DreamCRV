import path from 'path';
import fs from 'fs-extra';
import { logger } from '@lwrjs/diagnostics';
import DecisionTree, { createFallbackMap } from './utils/decision-tree.js';
import { LOCALE_SIGIL, SSR_SIGIL, VERSION_NOT_PROVIDED, VERSION_SIGIL, normalizeVersionToUri, } from '@lwrjs/shared-utils';
const SITE_METADATA_PATH = '.metadata';
const STATIC_BUNDLE_METADATA_PATH = path.join(SITE_METADATA_PATH, '/bundle-metadata.json');
const DEBUG_STATIC_BUNDLE_METADATA_PATH = path.join(SITE_METADATA_PATH, '/bundle-metadata-debug.json');
const STATIC_RESOURCE_METADATA_PATH = path.join(SITE_METADATA_PATH, '/resource-metadata.json');
const DEBUG_STATIC_RESOURCE_METADATA_PATH = path.join(SITE_METADATA_PATH, '/resource-metadata-debug.json');
const STATIC_ASSET_METADATA_PATH = path.join(SITE_METADATA_PATH, '/asset-metadata.json');
export const SITE_VERSION_PREFIX = `|${VERSION_SIGIL}/`;
export const SITE_LOCALE_PREFIX = `|${LOCALE_SIGIL}/`;
export const SITE_SSR_PREFIX = `|${SSR_SIGIL}`;
export class SiteMetadataImpl {
    constructor(options) {
        this.options = options;
        this.siteBundles = this.readStaticBundleMetadata(options.rootDir, STATIC_BUNDLE_METADATA_PATH);
        this.debugSiteBundles = this.readStaticBundleMetadata(options.rootDir, DEBUG_STATIC_BUNDLE_METADATA_PATH);
        this.siteResources = this.readStaticResourceMetadata(options.rootDir, STATIC_RESOURCE_METADATA_PATH);
        this.debugSiteResources = this.readStaticResourceMetadata(options.rootDir, DEBUG_STATIC_RESOURCE_METADATA_PATH);
        this.siteAssets = this.readStaticAssetsMetadata(options.rootDir, STATIC_ASSET_METADATA_PATH);
    }
    getSiteRootDir() {
        return this.options.rootDir;
    }
    getSiteBundles() {
        return this.siteBundles;
    }
    getDebugSiteBundles() {
        return this.debugSiteBundles;
    }
    getSiteResources() {
        return this.siteResources;
    }
    getDebugSiteResources() {
        return this.debugSiteResources;
    }
    getSiteAssets() {
        return this.siteAssets;
    }
    /**
     * Returns a decision tree for site bundles in the form [debug, specifier, version, locale].
     * It is assumed this is static after creation subsequent calls will return the same instance.
     */
    getSiteBundlesDecisionTree() {
        if (!this.bundleDecisionTree) {
            this.bundleDecisionTree = new DecisionTree();
            // Normalize i18NConfig fallback paths
            const localeFallbacks = createFallbackMap(this.options.i18n);
            // Add All the Bundles path keys [specifier][prod][version? (version || '') : ('' || '*')][localeId || fallbacks]
            for (const [key, bundle] of Object.entries(this.siteBundles.bundles)) {
                this.bundleDecisionTree.insert(key, bundle, false, localeFallbacks);
            }
            // Add All the Bundles path keys [specifier][debug][[version? (version || '') : ('' || '*')][localeId || fallbacks]
            for (const [key, bundle] of Object.entries(this.debugSiteBundles.bundles)) {
                this.bundleDecisionTree.insert(key, bundle, true, localeFallbacks);
            }
        }
        return this.bundleDecisionTree;
    }
    /**
     * Returns a decision tree for site resources.
     * It is assumed this is static after creation subsequent calls will return the same instance.
     */
    getSiteResourcesDecisionTree() {
        if (!this.resourceDecisionTree) {
            this.resourceDecisionTree = new DecisionTree();
            // Add All the prod resources path keys [specifier][prod][version? (version || '') : ('' || '*')][*]
            for (const [key, resource] of Object.entries(this.siteResources.resources)) {
                this.resourceDecisionTree.insert(key, resource, false);
            }
            // Add All the debug resources path keys [specifier][debug][version? (version || '') : ('' || '*')][*]
            for (const [key, resource] of Object.entries(this.debugSiteResources.resources)) {
                this.resourceDecisionTree.insert(key, resource, true);
            }
        }
        return this.resourceDecisionTree;
    }
    async persistSiteMetadata() {
        // Create the metadata directory if if does not exist
        const siteMetadataPath = path.join(this.options.rootDir, SITE_METADATA_PATH);
        if (siteMetadataPath.indexOf('__skip_directory_creation__') !== -1)
            return;
        try {
            if (!fs.existsSync(siteMetadataPath)) {
                await fs.mkdir(siteMetadataPath, { recursive: true });
            }
            // Save Bundle Metadata
            const bundleMetadataPath = path.join(this.options.rootDir, STATIC_BUNDLE_METADATA_PATH);
            await fs.writeJSON(bundleMetadataPath, this.siteBundles, { spaces: 2 });
            // Save Debug Bundle Metadata
            const debugBundleMetadataPath = path.join(this.options.rootDir, DEBUG_STATIC_BUNDLE_METADATA_PATH);
            await fs.writeJSON(debugBundleMetadataPath, this.debugSiteBundles, { spaces: 2 });
            // Save Resource Metadata
            const resourceMetadataPath = path.join(this.options.rootDir, STATIC_RESOURCE_METADATA_PATH);
            await fs.writeJSON(resourceMetadataPath, this.siteResources, { spaces: 2 });
            // Save Debug Resource Metadata
            const debugResourceMetadataPath = path.join(this.options.rootDir, DEBUG_STATIC_RESOURCE_METADATA_PATH);
            await fs.writeJSON(debugResourceMetadataPath, this.debugSiteResources, { spaces: 2 });
            // Save Resource Metadata
            const assetMetadataPath = path.join(this.options.rootDir, STATIC_ASSET_METADATA_PATH);
            return fs.writeJSON(assetMetadataPath, this.siteAssets, { spaces: 2 });
        }
        catch (err) {
            logger.error(`[SiteMetadata] Failed to save site metadata ${siteMetadataPath}`);
            logger.error(err);
        }
    }
    readStaticBundleMetadata(staticRoot, metadataPath) {
        let bundleMetadataPath;
        let siteBundles = { bundles: {} };
        try {
            bundleMetadataPath = path.join(staticRoot, metadataPath);
            const savedMetadata = fs.readJSONSync(bundleMetadataPath);
            siteBundles = savedMetadata;
        }
        catch (error) {
            if (error.code === 'ENOENT') {
                logger.debug({
                    label: `SiteMetadata`,
                    message: `Failed to load Static Bundle Metadata: ${bundleMetadataPath}`,
                });
            }
            else {
                throw error;
            }
        }
        return siteBundles;
    }
    /**
     * Read the metadata about the pre-built resources of the current site.
     */
    readStaticResourceMetadata(staticRoot, metadataPath) {
        let resourceMetadataPath;
        let siteResources = { resources: {} };
        try {
            resourceMetadataPath = path.join(staticRoot, metadataPath);
            const savedMetadata = fs.readJSONSync(resourceMetadataPath);
            siteResources = savedMetadata;
        }
        catch (error) {
            if (error.code === 'ENOENT') {
                logger.debug({
                    label: `SiteMetadata`,
                    message: `Failed to load Static Resource Metadata: ${resourceMetadataPath}`,
                });
            }
            else {
                throw error;
            }
        }
        return siteResources;
    }
    /**
     * Read the metadata about the pre-built assets of the current site.
     */
    readStaticAssetsMetadata(staticRoot, metadataPath) {
        let assetMetadataPath;
        let siteAssets = {
            assets: {},
        };
        try {
            assetMetadataPath = path.join(staticRoot, metadataPath);
            siteAssets = fs.readJSONSync(assetMetadataPath);
        }
        catch (error) {
            if (error.code === 'ENOENT') {
                logger.debug({
                    label: `SiteMetadata`,
                    message: `Failed to load Static Resource Metadata: ${assetMetadataPath}`,
                });
            }
            else {
                throw error;
            }
        }
        return siteAssets;
    }
}
/**
 * Return the version for a static module bundle.
 *
 * Version defined in the metadata > Requested Version > 'version-not-provided'
 */
export function resolveStaticBundleVersion(metadataVersion, requestedVersion) {
    return metadataVersion || requestedVersion || VERSION_NOT_PROVIDED;
}
/**
 * Parse a site artifact ids string in the form specifier(|sigil(/value)?)*
 */
export function parseSiteId(input) {
    const parts = input.split('|');
    const specifier = parts[0];
    const variants = {};
    // Process each variant part after the first element
    for (let i = 1; i < parts.length; i++) {
        const [sigil, value] = parts[i].split('/');
        if (sigil && value) {
            variants[sigil] = value;
        }
        else if (sigil) {
            variants[sigil] = 'true';
        }
    }
    return {
        specifier: specifier,
        variants: variants,
    };
}
/**
 * Get a  Site Bundle Identifier from a Root Module
 *
 * @param moduleId - Root Module Id
 * @param locale - Current locale
 * @param ssr - Component variant is required for SSR
 * @returns Site Bundle Identifier
 */
export function getSiteBundleId({ specifier, namespace, name = '', version }, locale, ssr, i18n) {
    if (!specifier) {
        specifier = namespace ? `${namespace}/${name}` : name;
    }
    // If a module has an explicit 'version-not-provided' version this will not be reflected in the specifier
    const versionedSpecifier = version && version !== VERSION_NOT_PROVIDED
        ? `${specifier}${SITE_VERSION_PREFIX}${normalizeVersionToUri(version)}`
        : specifier;
    const ssrSpecifier = ssr ? `${versionedSpecifier}${SITE_SSR_PREFIX}` : versionedSpecifier;
    return i18n?.defaultLocale === locale ? ssrSpecifier : `${ssrSpecifier}${SITE_LOCALE_PREFIX}${locale}`;
}
/**
 * Get a  Site Resource Identifier from a Resource Identifier
 *
 * @param resourceID -Resource Identifier
 * @returns Site Bundle Identifier
 */
export function getSiteResourceId({ specifier, version }) {
    // If a module has an explicit 'version-not-provided' version this will not be reflected in the specifier
    const versionedSpecifier = version && version !== VERSION_NOT_PROVIDED
        ? `${specifier}${SITE_VERSION_PREFIX}${normalizeVersionToUri(version)}`
        : specifier;
    return versionedSpecifier;
}
//# sourceMappingURL=site-metadata.js.map