import { logger } from '@lwrjs/diagnostics';
import { hashContent, mimeLookup, normalizeResourcePath } from '@lwrjs/shared-utils';
import path from 'path';
import fs from 'fs-extra';
export default class StaticAssetProvider {
    constructor(_config, context) {
        this.name = 'static-asset-provider';
        if (!context.siteMetadata) {
            throw new Error(`[${this.name}] Site metadata was not found`);
        }
        const { assets, rootDir, layoutsDir, contentDir } = context.config;
        this.siteAssets = context.siteMetadata.getSiteAssets();
        this.siteRootDir = context.siteMetadata.getSiteRootDir();
        this.basePath = context.runtimeEnvironment.basePath;
        this.assetsOnLambda = !!context.runtimeEnvironment.featureFlags?.ASSETS_ON_LAMBDA;
        // Adjust the assets directories to be rooted in ssg folder.
        const ssgAssets = Array.from(assets, (asset) => {
            if (asset.dir) {
                // Return the URI as the dir where it will be relative to the ssg root
                return {
                    ...asset,
                    dir: asset.urlPath,
                };
            }
            return asset;
        });
        this.resourcePaths = { assets: ssgAssets, rootDir, layoutsDir, contentDir };
    }
    async getAsset(assetIdentifier) {
        // Set all the asset path to resolve to the ssg root
        const fileAssetPath = this.normalizeSpecifier(assetIdentifier, this.resourcePaths);
        const metadata = this.siteAssets.assets[fileAssetPath];
        if (!metadata) {
            // Ignore root asset misses (may be views)
            if (path.dirname(fileAssetPath) !== (this.basePath ? this.basePath : '/')) {
                logger.warn({
                    label: `${this.name}`,
                    message: `Did not find requested specifier ${fileAssetPath}`,
                });
            }
            return undefined;
        }
        // FS path including ssg root
        const siteAssetPath = path.join(this.siteRootDir, metadata.path);
        // Figure out mime type
        const mime = metadata.mimeType || mimeLookup(siteAssetPath);
        // Normalize extension
        const ext = path.extname(`x.${siteAssetPath}`).toLowerCase().substring(1);
        // Unless assets on lambda feature flag is set indicate the asset source is external
        const type = this.assetsOnLambda ? 'asset' : 'external';
        const content = function (encoding) {
            return fs.readFileSync(siteAssetPath, encoding);
        };
        // Create URI
        const uri = this.assetsOnLambda ? fileAssetPath : path.join(this.siteRootDir, fileAssetPath);
        logger.debug({ label: `${this.name}`, message: `uri ${assetIdentifier.specifier} -> ${uri}` });
        return {
            entry: siteAssetPath,
            ext,
            mime,
            ownHash: hashContent(metadata.path),
            content,
            uri,
            // Type: external triggers a 302 when requested form the asset middleware.
            type,
            noTransform: true,
        };
    }
    /**
     * Replaces and aliased resource paths (i.e. $assetDir with a qualified specifier)
     */
    normalizeSpecifier(assetId, resourcePaths) {
        const { specifier } = assetId;
        // Remove query params from specifiers (i.e. /assets/styles/styles.css?e368d71b59)
        let normalizedSpecifier = specifier;
        if (normalizedSpecifier.includes('?')) {
            logger.debug({
                label: `${this.name}`,
                message: `Removed query param from asset specifier: ${specifier}`,
            });
            normalizedSpecifier = normalizedSpecifier.split('?')[0];
        }
        if (normalizedSpecifier[0] === '$') {
            // This is a fs path containing an asset alias
            return normalizeResourcePath(normalizedSpecifier, resourcePaths);
        }
        return normalizedSpecifier;
    }
}
//# sourceMappingURL=static-asset-provider.js.map