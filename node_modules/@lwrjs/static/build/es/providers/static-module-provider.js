import { logger } from '@lwrjs/diagnostics';
import { VERSION_SIGIL, explodeSpecifier, getSpecifier, isLambdaEnv } from '@lwrjs/shared-utils';
import path from 'path';
import { getSiteBundleId, parseSiteId, resolveStaticBundleVersion } from '../site-metadata.js';
export default class StaticModuleProvider {
    constructor(_config, context) {
        this.name = 'static-module-provider';
        if (!context.siteMetadata) {
            throw new Error(`[${this.name}] Site metadata was not found`);
        }
        this.externals = Object.keys(context.config.bundleConfig.external || {});
        this.siteRootDir = context.siteMetadata.getSiteRootDir();
        this.i18n = context.config.i18n;
        this.siteMetadata = context.siteMetadata;
        // If we are using fingerprints collect all the specifiers in the bundles and add them to an index for creating the mapping identities
        this.fingerprintIndex = buildFingerprintsIndex(context);
    }
    async getModule(moduleId, runtimeParams) {
        const localeId = (runtimeParams?.locale || this.i18n.defaultLocale);
        const ssr = runtimeParams?.ssr;
        const metadata = this.getBundleMetadata({ moduleId, localeId, debug: false, ssr });
        if (metadata && isLambdaEnv()) {
            logger.warn({
                label: `${this.name}`,
                message: `We should not be asking for module source we have in our site metadata: ${moduleId.specifier}`,
            });
            // proceed to next provider
            return undefined;
        }
        // proceed to next provider
        return undefined;
    }
    async getModuleEntry(moduleId, runtimeParams) {
        // TODO shouldn't we be passing the runtime environment here to test?
        const { specifier, version } = moduleId;
        const localeId = (runtimeParams?.locale || this.i18n.defaultLocale);
        const ssr = runtimeParams?.ssr;
        const metadata = this.getBundleMetadata({ moduleId, localeId, ssr, debug: false });
        if (metadata) {
            logger.debug({
                label: `${this.name}`,
                message: `Module Entry request for static bundle ${specifier}`,
            });
            // Have to make the bundle code available for SSR
            const bundlePath = path.join(this.siteRootDir, metadata.path);
            const resolvedVersion = resolveStaticBundleVersion(metadata.version, version);
            return {
                id: getSpecifier({ ...moduleId, version: resolvedVersion }),
                version: resolvedVersion,
                specifier: specifier,
                entry: 'entry-not-provided',
                src: bundlePath,
            };
        }
        else if (this.externals.includes(specifier)) {
            // Externals are not SSG'ed so hard coding definition
            const resolvedVersion = resolveStaticBundleVersion(undefined, version);
            return {
                id: getSpecifier({ ...moduleId, version: resolvedVersion }),
                version: resolvedVersion,
                specifier: specifier,
                entry: 'entry-not-provided',
            };
        }
        // checks the fingerprint index or proceeds to next provider
        return this.getEntryFromFingerprintIndex(moduleId);
    }
    getEntryFromFingerprintIndex(moduleId) {
        const versionedSpecifier = getSpecifier(moduleId);
        return this.fingerprintIndex[versionedSpecifier] || this.fingerprintIndex[moduleId.specifier];
    }
    getBundleMetadata({ moduleId, localeId, debug, ssr, }) {
        const siteBundleId = getSiteBundleId(moduleId, localeId, ssr, this.i18n);
        return this.siteMetadata.getSiteBundlesDecisionTree().find(siteBundleId, debug);
    }
}
/**
 * Map each of the includedModules for a bundle to the bundle src
 * This enables lookup of modules which are not top-level in the bundle metadata
 */
function buildFingerprintsIndex(context) {
    const fingerprintIndex = {};
    if (!context.runtimeEnvironment.featureFlags.LEGACY_LOADER) {
        const bundles = context.siteMetadata?.getSiteBundles().bundles || {};
        for (const bundle of Object.values(bundles)) {
            const bundlePath = path.join(String(context.siteMetadata?.getSiteRootDir()), bundle.path);
            const includedModules = bundle.includedModules || [];
            for (const includedModule of includedModules) {
                const versionedSpecifier = convertSiteIdToVersionedSpecifier(includedModule);
                const moduleId = explodeSpecifier(versionedSpecifier);
                if (!fingerprintIndex[versionedSpecifier]) {
                    fingerprintIndex[versionedSpecifier] = {
                        id: versionedSpecifier,
                        version: resolveStaticBundleVersion(moduleId.version),
                        specifier: moduleId.specifier,
                        entry: 'entry-not-provided',
                        src: bundlePath,
                    };
                }
                // Add an un-versioned match for the first hit
                if (!fingerprintIndex[moduleId.specifier]) {
                    fingerprintIndex[moduleId.specifier] = {
                        id: moduleId.specifier,
                        version: resolveStaticBundleVersion(moduleId.version),
                        specifier: moduleId.specifier,
                        entry: 'entry-not-provided',
                        src: bundlePath,
                    };
                }
            }
        }
    }
    return fingerprintIndex;
}
function convertSiteIdToVersionedSpecifier(siteId) {
    const parsedSiteId = parseSiteId(siteId);
    return getSpecifier({ specifier: parsedSiteId.specifier, version: parsedSiteId.variants[VERSION_SIGIL] });
}
//# sourceMappingURL=static-module-provider.js.map