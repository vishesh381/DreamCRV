/*!
 * Copyright (C) 2019 salesforce.com, inc.
 */
var _TrustedHTMLCtor$prot$LWS, _TrustedScriptCtor$pr$LWS, _URLCtor$prototype$LWS;
const {
  apply: ReflectApply$LWS$1,
  construct: ReflectConstruct$LWS,
  defineProperty: ReflectDefineProperty$LWS$1,
  deleteProperty: ReflectDeleteProperty$LWS$1,
  get: ReflectGet$LWS,
  getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor$LWS,
  getPrototypeOf: ReflectGetPrototypeOf$LWS$1,
  has: ReflectHas$LWS,
  isExtensible: ReflectIsExtensible$LWS,
  ownKeys: ReflectOwnKeys$LWS$1,
  preventExtensions: ReflectPreventExtensions$LWS,
  set: ReflectSet$LWS,
  setPrototypeOf: ReflectSetPrototypeOf$LWS$1
} = Reflect;
const ObjectCtor$LWS$1 = Object;
const {
  assign: ObjectAssign$LWS$1,
  freeze: ObjectFreeze$LWS$1,
  defineProperties: ObjectDefineProperties$LWS,
  getOwnPropertyDescriptors: ObjectGetOwnPropertyDescriptors$LWS,
  getOwnPropertySymbols: ObjectGetOwnPropertySymbols$LWS,
  keys: ObjectKeys$LWS$1,
  preventExtensions: ObjectPreventExtensions$LWS,
  prototype: ObjectProto$LWS$1
} = ObjectCtor$LWS$1;
const {
  hasOwn: OriginalObjectHasOwn$LWS$1
} = ObjectCtor$LWS$1;
const {
  __lookupGetter__: ObjectProtoLookupGetter$LWS$1,
  __lookupSetter__: ObjectProtoLookupSetter$LWS$1,
  hasOwnProperty: ObjectProtoHasOwnProperty$LWS$1
} = ObjectProto$LWS$1;
const {
  toString: ObjectProtoToString$LWS$1
} = ObjectProto$LWS$1;
function isObject$LWS$1(value$LWS) {
  return typeof value$LWS === 'object' && value$LWS !== null;
}
function isObjectLike$LWS(value$LWS) {
  return typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function';
}
const ObjectHasOwn$LWS$1 = typeof OriginalObjectHasOwn$LWS$1 === 'function' ? OriginalObjectHasOwn$LWS$1 : /* istanbul ignore next: currently unreachable via tests */function ObjectHasOwn$LWS(object$LWS, key$LWS) {
  return ReflectApply$LWS$1(ObjectProtoHasOwnProperty$LWS$1, object$LWS, [key$LWS]);
};
function ObjectLookupOwnGetter$LWS$1(object$LWS, key$LWS) {
  return object$LWS === null || object$LWS === undefined || !ObjectHasOwn$LWS$1(object$LWS, key$LWS) ? undefined : ReflectApply$LWS$1(ObjectProtoLookupGetter$LWS$1, object$LWS, [key$LWS]);
}
function ObjectLookupOwnSetter$LWS(object$LWS, key$LWS) {
  return object$LWS === null || object$LWS === undefined || !ObjectHasOwn$LWS$1(object$LWS, key$LWS) ? undefined : ReflectApply$LWS$1(ObjectProtoLookupSetter$LWS$1, object$LWS, [key$LWS]);
}
function ObjectLookupOwnValue$LWS(object$LWS, key$LWS) {
  return object$LWS === null || object$LWS === undefined || !ObjectHasOwn$LWS$1(object$LWS, key$LWS) ? undefined : object$LWS[key$LWS];
}
const SymbolCtor$LWS$1 = Symbol;
const {
  asyncIterator: SymbolAsyncIterator$LWS,
  for: SymbolFor$LWS$1,
  iterator: SymbolIterator$LWS$1,
  toStringTag: SymbolToStringTag$LWS$1,
  unscopables: SymbolUnscopables$LWS$1
} = SymbolCtor$LWS$1;
const {
  toString: SymbolProtoToString$LWS,
  valueOf: SymbolProtoValueOf$LWS
} = SymbolCtor$LWS$1.prototype;
const ArrayCtor$LWS$1 = Array;
const {
  prototype: ArrayProto$LWS$1
} = ArrayCtor$LWS$1;
const {
  at: ArrayProtoAt$LWS$1,
  concat: ArrayProtoConcat$LWS$1,
  copyWithin: ArrayProtoCopyWithin$LWS$1,
  entries: ArrayProtoEntries$LWS$1,
  every: ArrayProtoEvery$LWS$1,
  fill: ArrayProtoFill$LWS$1,
  findIndex: ArrayProtoFindIndex$LWS$1,
  flat: ArrayProtoFlat$LWS$1,
  flatMap: ArrayProtoFlatMap$LWS$1,
  forEach: ArrayProtoForEach$LWS$1,
  keys: ArrayProtoKeys$LWS$1,
  lastIndexOf: ArrayProtoLastIndexOf$LWS$1,
  pop: ArrayProtoPop$LWS$1,
  reduce: ArrayProtoReduce$LWS$1,
  reduceRight: ArrayProtoReduceRight$LWS$1,
  reverse: ArrayProtoReverse$LWS$1,
  some: ArrayProtoSome$LWS$1,
  toLocaleString: ArrayProtoToLocaleString$LWS$1,
  values: ArrayProtoValues$LWS$1,
  [SymbolIterator$LWS$1]: ArrayProtoSymbolIterator$LWS$1
} = ArrayProto$LWS$1;
const ArrayUnscopables$LWS$1 = ObjectFreeze$LWS$1(ObjectAssign$LWS$1({
  __proto__: null
}, ArrayProto$LWS$1[SymbolUnscopables$LWS$1]));
// Used by '@locker/near-membrane-dom'.
const {
  includes: ArrayProtoIncludes$LWS$1,
  map: ArrayProtoMap$LWS$1,
  splice: ArrayProtoSplice$LWS$1,
  sort: ArrayProtoSort$LWS$1,
  unshift: ArrayProtoUnshift$LWS$1
} = ArrayProto$LWS$1;
const {
  filter: ArrayProtoFilter$LWS$1,
  find: ArrayProtoFind$LWS$1,
  indexOf: ArrayProtoIndexOf$LWS$1,
  join: ArrayProtoJoin$LWS$1,
  push: ArrayProtoPush$LWS$1,
  shift: ArrayProtoShift$LWS$1,
  slice: ArrayProtoSlice$LWS$1,
  toString: ArrayProtoToString$LWS$1
} = ArrayProto$LWS$1;
const {
  isArray: ArrayIsArray$LWS$1
} = ArrayCtor$LWS$1;
function ArrayConcat$LWS(array$LWS, ...args$LWS) {
  // Re-implement Array#concat to avoid prototype poisoning from Symbol.isConcatSpreadable.
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/isConcatSpreadable
  const result$LWS = ReflectApply$LWS$1(ArrayProtoSlice$LWS$1, array$LWS, [0]);
  for (let i$LWS = 0, {
      length: length$LWS
    } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const value$LWS = args$LWS[i$LWS];
    if (ArrayIsArray$LWS$1(value$LWS)) {
      ReflectApply$LWS$1(ArrayProtoPush$LWS$1, result$LWS, value$LWS);
    } else {
      result$LWS[result$LWS.length] = value$LWS;
    }
  }
  return result$LWS;
}
function toSafeArray$LWS$1(array$LWS) {
  ReflectSetPrototypeOf$LWS$1(array$LWS, null);
  array$LWS.at = ArrayProtoAt$LWS$1;
  array$LWS.concat = ArrayProtoConcat$LWS$1;
  // *** DO NOT SET THE ARRAY CONSTRUCTOR PROPERTY ***
  // https://bugs.chromium.org/p/v8/issues/detail?id=13202
  // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/lookup.cc;l=196-215?q=IsArraySpeciesLookupChainIntact
  //
  // In V8 setting the constructor property of an array, promise, regexp, or
  // typed array triggers a de-opt because it could change an instance's
  // @@species. This de-opt affects at least `Array#splice` and occurs even
  // if the prototype of the array is change or nulled beforehand. Further,
  // the de-opt persists after a page refresh. It is not until navigating to
  // a different page that the performance of `Array#splice` is restored.
  array$LWS.copyWithin = ArrayProtoCopyWithin$LWS$1;
  array$LWS.entries = ArrayProtoEntries$LWS$1;
  array$LWS.every = ArrayProtoEvery$LWS$1;
  array$LWS.fill = ArrayProtoFill$LWS$1;
  array$LWS.filter = ArrayProtoFilter$LWS$1;
  array$LWS.find = ArrayProtoFind$LWS$1;
  array$LWS.findIndex = ArrayProtoFindIndex$LWS$1;
  array$LWS.flat = ArrayProtoFlat$LWS$1;
  array$LWS.flatMap = ArrayProtoFlatMap$LWS$1;
  array$LWS.forEach = ArrayProtoForEach$LWS$1;
  array$LWS.includes = ArrayProtoIncludes$LWS$1;
  array$LWS.indexOf = ArrayProtoIndexOf$LWS$1;
  array$LWS.join = ArrayProtoJoin$LWS$1;
  array$LWS.keys = ArrayProtoKeys$LWS$1;
  array$LWS.lastIndexOf = ArrayProtoLastIndexOf$LWS$1;
  array$LWS.map = ArrayProtoMap$LWS$1;
  array$LWS.pop = ArrayProtoPop$LWS$1;
  array$LWS.push = ArrayProtoPush$LWS$1;
  array$LWS.reduce = ArrayProtoReduce$LWS$1;
  array$LWS.reduceRight = ArrayProtoReduceRight$LWS$1;
  array$LWS.reverse = ArrayProtoReverse$LWS$1;
  array$LWS.shift = ArrayProtoShift$LWS$1;
  array$LWS.slice = ArrayProtoSlice$LWS$1;
  array$LWS.some = ArrayProtoSome$LWS$1;
  array$LWS.sort = ArrayProtoSort$LWS$1;
  array$LWS.splice = ArrayProtoSplice$LWS$1;
  array$LWS.toLocaleString = ArrayProtoToLocaleString$LWS$1;
  array$LWS.toString = ArrayProtoToString$LWS$1;
  array$LWS.unshift = ArrayProtoUnshift$LWS$1;
  array$LWS.values = ArrayProtoValues$LWS$1;
  array$LWS[SymbolIterator$LWS$1] = ArrayProtoSymbolIterator$LWS$1;
  array$LWS[SymbolUnscopables$LWS$1] = ArrayUnscopables$LWS$1;
  ReflectSetPrototypeOf$LWS$1(array$LWS, ArrayProto$LWS$1);
  return array$LWS;
}
const ArrayBufferCtor$LWS = ArrayBuffer;
const {
  isView: ArrayBufferIsView$LWS
} = ArrayBufferCtor$LWS;
const ArrayBufferProtoByteLengthGetter$LWS = ObjectLookupOwnGetter$LWS$1(ArrayBufferCtor$LWS.prototype, 'byteLength');

// https://caniuse.com/bigint
const SUPPORTS_BIG_INT$LWS = typeof BigInt === 'function';
const BigIntProtoValueOf$LWS = SUPPORTS_BIG_INT$LWS ? BigInt.prototype.valueOf : /* istanbul ignore next: currently unreachable via tests */undefined;
const {
  valueOf: BooleanProtoValueOf$LWS
} = Boolean.prototype;

// Locker build constants.
const LOCKER_IDENTIFIER_MARKER$LWS = '$LWS';
// This package is bundled by third-parties that have their own build time
// replacement logic. Instead of customizing each build system to be aware
// of this package we implement a two phase debug mode by performing small
// runtime checks to determine phase one, our code is unminified, and
// phase two, the user opted-in to custom devtools formatters. Phase one
// is used for light weight initialization time debug while phase two is
// reserved for post initialization runtime
const LOCKER_UNMINIFIED_FLAG$LWS$1 =
// eslint-disable-next-line @typescript-eslint/naming-convention
/* istanbul ignore next */
`${function LOCKER_UNMINIFIED_FLAG$LWS() {
  return LOCKER_UNMINIFIED_FLAG$LWS.name;
}()}`.includes('LOCKER_UNMINIFIED_FLAG');
// Locker key constants.
const LOCKER_SERVICE_KEY$LWS = 'LSKey';
const LOCKER_SERVICE_KEY_LOWERED$LWS = 'lskey';
// Character constants.
const CHAR_QUOTE_DOUBLE$LWS = '"';
const CHAR_QUOTE_SINGLE$LWS = "'";
// Compiler constants.
const UNCOMPILED_LOCATION_NAME$LWS = `uncompiledLocation${LOCKER_IDENTIFIER_MARKER$LWS}`;
const UNCOMPILED_TOP_NAME$LWS = `uncompiledTop${LOCKER_IDENTIFIER_MARKER$LWS}`;
const WEBPACK_REQUIRE_NAME$LWS = '__webpack_require__';
// Error message constants.
const ERR_ILLEGAL_PROPERTY_ACCESS$LWS = 'Illegal property access.';
const ERR_INVALID_SANDBOX_KEY$LWS = 'Invalid sandbox key.';
// Near-membrane constants.
const LOCKER_NEAR_MEMBRANE_IS_MASKED_SYMBOL$LWS = SymbolFor$LWS$1('@@lockerNearMembraneIsMasked');
const LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS$1 = SymbolFor$LWS$1('@@lockerNearMembraneSerializedValue');
const LOCKER_NEAR_MEMBRANE_SYMBOL$LWS$1 = SymbolFor$LWS$1('@@lockerNearMembrane');
const LOCKER_NEAR_MEMBRANE_UNMASKED_VALUE_SYMBOL$LWS = SymbolFor$LWS$1('@@lockerNearMembraneUnmaskedValue');
const SYMBOL_LIVE_OBJECT$LWS = SymbolFor$LWS$1('@@lockerLiveValue');
// Object brand constants.
const TO_STRING_BRAND_ARRAY$LWS = '[object Array]';
const TO_STRING_BRAND_ARRAY_BUFFER$LWS = '[object ArrayBuffer]';
const TO_STRING_BRAND_BIG_INT$LWS$1 = '[object BigInt]';
const TO_STRING_BRAND_BOOLEAN$LWS$1 = '[object Boolean]';
const TO_STRING_BRAND_DATE$LWS = '[object Date]';
const TO_STRING_BRAND_FUNCTION$LWS = '[object Function]';
const TO_STRING_BRAND_MAP$LWS = '[object Map]';
const TO_STRING_BRAND_NULL$LWS = '[object Null]';
const TO_STRING_BRAND_NUMBER$LWS$1 = '[object Number]';
const TO_STRING_BRAND_OBJECT$LWS = '[object Object]';
const TO_STRING_BRAND_REG_EXP$LWS = '[object RegExp]';
const TO_STRING_BRAND_SET$LWS = '[object Set]';
const TO_STRING_BRAND_STRING$LWS$1 = '[object String]';
const TO_STRING_BRAND_SYMBOL$LWS$1 = '[object Symbol]';
const TO_STRING_BRAND_UNDEFINED$LWS = '[object Undefined]';
const TO_STRING_BRAND_WEAK_MAP$LWS = '[object WeakMap]';
const TO_STRING_BRAND_WEAK_SET$LWS = '[object WeakSet]';
// Sandbox constants.
const SANDBOX_EVAL_CONTEXT_NAME$LWS = '$lockerEvalContext$';
const SANDBOX_EVAL_HELPERS_NAME$LWS = '$lockerEvalHelpers$';
const DateCtor$LWS = Date;
const {
  now: DateNow$LWS
} = DateCtor$LWS;
const {
  valueOf: DateProtoValueOf$LWS
} = DateCtor$LWS.prototype;

// Used by '@locker/near-membrane-base'
const ErrorCtor$LWS$1 = Error;
// Used by '@locker/near-membrane-' packages.
const TypeErrorCtor$LWS$1 = TypeError;
class LockerSecurityError$LWS extends Error {
  constructor(message$LWS) {
    super(`Lightning Web Security: ${message$LWS}`);
  }
}
const ProxyCtor$LWS = Proxy;
const {
  revocable: ProxyRevocable$LWS
} = ProxyCtor$LWS;
function createRevokedProxy$LWS(object$LWS) {
  const revocable$LWS = ProxyRevocable$LWS(object$LWS, {
    __proto__: null
  });
  revocable$LWS.revoke();
  return revocable$LWS.proxy;
}
function isRevokedProxy$LWS(value$LWS) {
  try {
    // 7.2.2 IsArray ( argument )
    // https://tc39.es/ecma262/#sec-isarray
    // Step 3a: Perform ? ValidateNonRevokedProxy(argument).
    ArrayIsArray$LWS$1(value$LWS);
    return false;
    // eslint-disable-next-line no-empty
  } catch (_unused$LWS) {}
  return true;
}
const {
  bind: FunctionProtoBind$LWS,
  toString: FunctionProtoToString$LWS
} = Function.prototype;
function createUnmaskableTraps$LWS(func$LWS) {
  let handshakeUnmaskFlag$LWS = false;
  return {
    defineProperty(target$LWS, key$LWS, desc$LWS) {
      // Defining forgeries of handshake properties is not allowed.
      // istanbul ignore else: it is unnecessary to cover the else path here
      if (key$LWS === LOCKER_NEAR_MEMBRANE_UNMASKED_VALUE_SYMBOL$LWS) {
        throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
      }
      return ReflectDefineProperty$LWS$1(target$LWS, key$LWS, desc$LWS);
    },
    get(target$LWS, key$LWS, receiver$LWS, handshake$LWS = false) {
      // Only allow accessing handshake property values if the "has"
      // trap has been triggered immediately BEFORE and the property
      // does NOT exist.
      handshakeUnmaskFlag$LWS && (handshakeUnmaskFlag$LWS = handshake$LWS);
      const isUnmaskedSymbol$LWS = key$LWS === LOCKER_NEAR_MEMBRANE_UNMASKED_VALUE_SYMBOL$LWS;
      // istanbul ignore else: it is unnecessary to cover the else path here
      if (handshakeUnmaskFlag$LWS) {
        // Exit without performing a [[Get]] for
        // `LOCKER_NEAR_MEMBRANE_UNMASKED_VALUE_SYMBOL` properties
        // because we know that when the
        // `handshakeUnmaskFlag` is ON that
        // there are NO shadowed values.
        // istanbul ignore else: it is unnecessary to cover the else path here
        if (isUnmaskedSymbol$LWS) {
          return func$LWS;
        }
      }
      const result$LWS = ReflectGet$LWS(target$LWS, key$LWS, receiver$LWS);
      // Getting forged values of `LOCKER_NEAR_MEMBRANE_UNMASKED_VALUE_SYMBOL`
      // properties is not allowed.
      // istanbul ignore else: it is unnecessary to cover the else path here
      if (result$LWS !== undefined && isUnmaskedSymbol$LWS) {
        throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
      }
      return result$LWS;
    },
    getOwnPropertyDescriptor(target$LWS, key$LWS) {
      const result$LWS = ReflectGetOwnPropertyDescriptor$LWS(target$LWS, key$LWS);
      // Getting forged descriptors of handshake properties is not allowed.
      // istanbul ignore else: it is unnecessary to cover the else path here
      if (result$LWS && key$LWS === LOCKER_NEAR_MEMBRANE_UNMASKED_VALUE_SYMBOL$LWS) {
        throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
      }
      return result$LWS;
    },
    has(target$LWS, key$LWS) {
      const result$LWS = ReflectHas$LWS(target$LWS, key$LWS);
      const isUnmaskedSymbol$LWS = key$LWS === LOCKER_NEAR_MEMBRANE_UNMASKED_VALUE_SYMBOL$LWS;
      if (result$LWS) {
        handshakeUnmaskFlag$LWS = false;
        // Checking the existence of forged `LOCKER_NEAR_MEMBRANE_UNMASKED_VALUE_SYMBOL`
        // properties is not allowed.
        // istanbul ignore else: it is unnecessary to cover the else path here
        if (isUnmaskedSymbol$LWS) {
          throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
        }
      } else {
        // The `handshakeUnmaskFlag` is ON if the
        // handshake property does NOT exist on the object or its
        // [[Prototype]].
        handshakeUnmaskFlag$LWS = isUnmaskedSymbol$LWS;
      }
      return result$LWS;
    },
    set(target$LWS, key$LWS, value$LWS, receiver$LWS) {
      // Setting forged values of handshake properties is not allowed.
      // istanbul ignore else: it is unnecessary to cover the else path here
      if (key$LWS === LOCKER_NEAR_MEMBRANE_UNMASKED_VALUE_SYMBOL$LWS) {
        throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
      }
      return ReflectSet$LWS(target$LWS, key$LWS, value$LWS, receiver$LWS);
    }
  };
}
function getUnmaskedFunction$LWS(func$LWS) {
  const unmasked$LWS = LOCKER_NEAR_MEMBRANE_UNMASKED_VALUE_SYMBOL$LWS in func$LWS ? /* istanbul ignore next */undefined : func$LWS[LOCKER_NEAR_MEMBRANE_UNMASKED_VALUE_SYMBOL$LWS];
  return unmasked$LWS === undefined ? func$LWS : unmasked$LWS;
}
function isMaskedFunction$LWS(value$LWS) {
  // To extract the flag value of a blue near-membrane proxy we must perform
  // a two step handshake. First, we trigger the "has" trap for the
  // `LOCKER_NEAR_MEMBRANE_IS_MASKED_SYMBOL` property which must report
  // `false`. Second, we trigger the "get" trap to return the flag value.
  return typeof value$LWS === 'function' && !(LOCKER_NEAR_MEMBRANE_IS_MASKED_SYMBOL$LWS in value$LWS) && value$LWS[LOCKER_NEAR_MEMBRANE_IS_MASKED_SYMBOL$LWS] === true;
}
function maskFunction$LWS(func$LWS, maskFunc$LWS, trapInvokers$LWS) {
  let applyTrapInvoker$LWS = ReflectApply$LWS$1;
  let constructTrapInvoker$LWS = ReflectConstruct$LWS;
  let definePropertyTrapInvoker$LWS = ReflectDefineProperty$LWS$1;
  let getTrapInvoker$LWS = ReflectGet$LWS;
  let getOwnPropertyDescriptorTrapInvoker$LWS = ReflectGetOwnPropertyDescriptor$LWS;
  let hasTrapInvoker$LWS = ReflectHas$LWS;
  let setTrapInvoker$LWS = ReflectSet$LWS;
  if (trapInvokers$LWS) {
    ({
      apply: applyTrapInvoker$LWS = ReflectApply$LWS$1,
      construct: constructTrapInvoker$LWS = ReflectConstruct$LWS,
      defineProperty: definePropertyTrapInvoker$LWS = ReflectDefineProperty$LWS$1,
      get: getTrapInvoker$LWS = ReflectGet$LWS,
      getOwnPropertyDescriptor: getOwnPropertyDescriptorTrapInvoker$LWS = ReflectGetOwnPropertyDescriptor$LWS,
      has: hasTrapInvoker$LWS = ReflectHas$LWS,
      set: setTrapInvoker$LWS = ReflectSet$LWS
    } = trapInvokers$LWS);
  }
  let handshakeFlag$LWS = false;
  let handshakeProxyMaskedFlag$LWS = false;
  let lastProxyTrapCalled$LWS = 0 /* ProxyHandlerTraps.None */;
  const proxy$LWS = new ProxyCtor$LWS(maskFunc$LWS, {
    apply(_target$LWS, thisArg$LWS, args$LWS) {
      lastProxyTrapCalled$LWS = 1 /* ProxyHandlerTraps.Apply */;
      if (thisArg$LWS === proxy$LWS || thisArg$LWS === maskFunc$LWS) {
        thisArg$LWS = func$LWS;
      }
      return applyTrapInvoker$LWS(func$LWS, thisArg$LWS, args$LWS);
    },
    construct(_target$LWS, args$LWS, newTarget$LWS) {
      lastProxyTrapCalled$LWS = 2 /* ProxyHandlerTraps.Construct */;
      if (newTarget$LWS === proxy$LWS || newTarget$LWS === maskFunc$LWS) {
        newTarget$LWS = func$LWS;
      }
      return constructTrapInvoker$LWS(func$LWS, args$LWS, newTarget$LWS);
    },
    defineProperty(target$LWS, key$LWS, desc$LWS) {
      lastProxyTrapCalled$LWS = 4 /* ProxyHandlerTraps.DefineProperty */;
      // Defining forgeries of handshake properties is not allowed.
      if (key$LWS === LOCKER_NEAR_MEMBRANE_IS_MASKED_SYMBOL$LWS) {
        throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
      }
      return definePropertyTrapInvoker$LWS(target$LWS, key$LWS, desc$LWS);
    },
    deleteProperty(target$LWS, key$LWS) {
      lastProxyTrapCalled$LWS = 32 /* ProxyHandlerTraps.GetOwnPropertyDescriptor */;
      return ReflectDeleteProperty$LWS$1(target$LWS, key$LWS);
    },
    get(target$LWS, key$LWS, receiver$LWS) {
      // Only allow accessing handshake property values if the "has"
      // trap has been triggered immediately BEFORE and the property does
      // NOT exist.
      handshakeFlag$LWS && (handshakeFlag$LWS = lastProxyTrapCalled$LWS === 128 /* ProxyHandlerTraps.Has */);
      handshakeProxyMaskedFlag$LWS && (handshakeProxyMaskedFlag$LWS = handshakeFlag$LWS);
      lastProxyTrapCalled$LWS = 16 /* ProxyHandlerTraps.Get */;
      const isProxyMaskedSymbol$LWS = key$LWS === LOCKER_NEAR_MEMBRANE_IS_MASKED_SYMBOL$LWS;
      if (handshakeProxyMaskedFlag$LWS) {
        // Exit without performing a [[Get]] for
        // `LOCKER_NEAR_MEMBRANE_IS_MASKED_SYMBOL` properties
        // because we know that when the `handshakeProxyMaskedFlag`
        // is ON that there are NO shadowed values.
        // istanbul ignore else: returns immediately
        if (isProxyMaskedSymbol$LWS) {
          return true;
        }
      }
      const result$LWS = getTrapInvoker$LWS(target$LWS, key$LWS, receiver$LWS, handshakeFlag$LWS);
      // Getting forged values of handshake properties is not allowed.
      if (result$LWS !== undefined && isProxyMaskedSymbol$LWS) {
        throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
      }
      return result$LWS;
    },
    getOwnPropertyDescriptor(target$LWS, key$LWS) {
      lastProxyTrapCalled$LWS = 32 /* ProxyHandlerTraps.GetOwnPropertyDescriptor */;
      const result$LWS = getOwnPropertyDescriptorTrapInvoker$LWS(target$LWS, key$LWS);
      // Getting forged descriptors of handshake properties is not allowed.
      if (result$LWS && key$LWS === LOCKER_NEAR_MEMBRANE_IS_MASKED_SYMBOL$LWS) {
        throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
      }
      return result$LWS;
    },
    getPrototypeOf(target$LWS) {
      lastProxyTrapCalled$LWS = 64 /* ProxyHandlerTraps.GetPrototypeOf */;
      return ReflectGetPrototypeOf$LWS$1(target$LWS);
    },
    has(target$LWS, key$LWS) {
      lastProxyTrapCalled$LWS = 128 /* ProxyHandlerTraps.Has */;
      const result$LWS = hasTrapInvoker$LWS(target$LWS, key$LWS);
      const isProxyMaskedSymbol$LWS = key$LWS === LOCKER_NEAR_MEMBRANE_IS_MASKED_SYMBOL$LWS;
      if (result$LWS) {
        handshakeFlag$LWS = false;
        // Checking the existence of forged handshake properties is not allowed.
        if (isProxyMaskedSymbol$LWS) {
          throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
        }
      } else {
        // The `handshakeFlag` is ON if the handshake property does NOT
        // exist on the object or its [[Prototype]].
        handshakeFlag$LWS = true;
        handshakeProxyMaskedFlag$LWS = isProxyMaskedSymbol$LWS;
      }
      return result$LWS;
    },
    isExtensible(target$LWS) {
      lastProxyTrapCalled$LWS = 256 /* ProxyHandlerTraps.IsExtensible */;
      return ReflectIsExtensible$LWS(target$LWS);
    },
    ownKeys(target$LWS) {
      lastProxyTrapCalled$LWS = 512 /* ProxyHandlerTraps.OwnKeys */;
      return ReflectOwnKeys$LWS$1(target$LWS);
    },
    preventExtensions(target$LWS) {
      lastProxyTrapCalled$LWS = 1024 /* ProxyHandlerTraps.PreventExtensions */;
      return ReflectPreventExtensions$LWS(target$LWS);
    },
    set(target$LWS, key$LWS, value$LWS, receiver$LWS) {
      lastProxyTrapCalled$LWS = 2048 /* ProxyHandlerTraps.Set */;
      // Setting forged values of handshake properties is not allowed.
      if (key$LWS === LOCKER_NEAR_MEMBRANE_IS_MASKED_SYMBOL$LWS) {
        throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
      }
      return setTrapInvoker$LWS(target$LWS, key$LWS, value$LWS, receiver$LWS);
    },
    setPrototypeOf(target$LWS, proto$LWS) {
      lastProxyTrapCalled$LWS = 4096 /* ProxyHandlerTraps.SetPrototypeOf */;
      return ReflectSetPrototypeOf$LWS$1(target$LWS, proto$LWS);
    }
  });
  return proxy$LWS;
}
function noop$LWS$1() {
  // No operation performed.
}
const MapCtor$LWS$1 = Map;
const {
  prototype: MapProto$LWS$1
} = MapCtor$LWS$1;
const {
  clear: MapProtoClear$LWS$1,
  delete: MapProtoDelete$LWS$1,
  forEach: MapProtoForEach$LWS$1,
  get: MapProtoGet$LWS$1,
  has: MapProtoHas$LWS$1,
  keys: MapProtoKeys$LWS$1,
  values: MapProtoValues$LWS$1,
  [SymbolIterator$LWS$1]: MapProtoSymbolIterator$LWS$1,
  [SymbolToStringTag$LWS$1]: MapProtoSymbolToStringTag$LWS$1
} = MapProto$LWS$1;
const {
  entries: MapProtoEntries$LWS$1,
  set: MapProtoSet$LWS$1
} = MapProto$LWS$1;
const MapProtoSizeGetter$LWS$1 = ObjectLookupOwnGetter$LWS$1(MapProto$LWS$1, 'size');
function toSafeMap$LWS$1(map$LWS) {
  ReflectSetPrototypeOf$LWS$1(map$LWS, null);
  map$LWS.clear = MapProtoClear$LWS$1;
  map$LWS.delete = MapProtoDelete$LWS$1;
  map$LWS.entries = MapProtoEntries$LWS$1;
  map$LWS.forEach = MapProtoForEach$LWS$1;
  map$LWS.get = MapProtoGet$LWS$1;
  map$LWS.has = MapProtoHas$LWS$1;
  map$LWS.keys = MapProtoKeys$LWS$1;
  map$LWS.set = MapProtoSet$LWS$1;
  ReflectDefineProperty$LWS$1(map$LWS, 'size', {
    __proto__: null,
    configurable: true,
    enumerable: true,
    get: MapProtoSizeGetter$LWS$1,
    set: undefined
  });
  map$LWS.values = MapProtoValues$LWS$1;
  map$LWS[SymbolIterator$LWS$1] = MapProtoSymbolIterator$LWS$1;
  map$LWS[SymbolToStringTag$LWS$1] = MapProtoSymbolToStringTag$LWS$1;
  ReflectSetPrototypeOf$LWS$1(map$LWS, MapProto$LWS$1);
  return map$LWS;
}
const NumberCtor$LWS$1 = Number;
// Used by '@locker/near-membrane-dom'.
const {
  isFinite: NumberIsFinite$LWS$1,
  isInteger: NumberIsInteger$LWS$1,
  isNaN: NumberIsNaN$LWS$1
} = NumberCtor$LWS$1;
const {
  toFixed: NumberProtoToFixed$LWS,
  valueOf: NumberProtoValueOf$LWS
} = NumberCtor$LWS$1.prototype;

// @ts-nocheck
const StringCtor$LWS$1 = String;
const {
  prototype: StringProto$LWS$1
} = StringCtor$LWS$1;
const {
  charAt: StringProtoCharAt$LWS,
  charCodeAt: StringProtoCharCodeAt$LWS,
  endsWith: StringProtoEndsWith$LWS,
  includes: StringProtoIncludes$LWS,
  indexOf: StringProtoIndexOf$LWS,
  lastIndexOf: StringProtoLastIndexOf$LWS,
  match: StringProtoMatch$LWS,
  replace: StringProtoReplace$LWS,
  slice: StringProtoSlice$LWS$1,
  split: StringProtoSplit$LWS,
  startsWith: StringProtoStartsWith$LWS,
  substring: StringProtoSubstring$LWS,
  toLowerCase: StringProtoToLowerCase$LWS,
  toUpperCase: StringProtoToUpperCase$LWS,
  valueOf: StringProtoValueOf$LWS$1
} = StringProto$LWS$1;
const quoteCharRegExpRegistry$LWS = {
  __proto__: null,
  [CHAR_QUOTE_DOUBLE$LWS]: /\\?"/g,
  [CHAR_QUOTE_SINGLE$LWS]: /\\?'/g
};
const TrustedHTMLCtor$LWS = typeof TrustedHTML === 'function' ? TrustedHTML : /* istanbul ignore next: unreachable in test env */undefined;
// istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
const TrustedHTMLProtoToString$LWS = TrustedHTMLCtor$LWS == null || (_TrustedHTMLCtor$prot$LWS = TrustedHTMLCtor$LWS.prototype) == null ? void 0 : _TrustedHTMLCtor$prot$LWS.toString;
const TrustedScriptCtor$LWS = typeof TrustedScript === 'function' ? TrustedScript : /* istanbul ignore next: unreachable in test env */undefined;
// istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
const TrustedScriptProtoToString$LWS = TrustedScriptCtor$LWS == null || (_TrustedScriptCtor$pr$LWS = TrustedScriptCtor$LWS.prototype) == null ? void 0 : _TrustedScriptCtor$pr$LWS.toString;
const URLCtor$LWS$1 = typeof URL === 'function' ? URL : /* istanbul ignore next: unreachable in test env */undefined;
// istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
const URLProtoToString$LWS = URLCtor$LWS$1 == null || (_URLCtor$prototype$LWS = URLCtor$LWS$1.prototype) == null ? void 0 : _URLCtor$prototype$LWS.toString;
// To extract the function body start the match from the beginning of the
// source code with the character class `[\s\S]` instead of `.` because `[\s\S]`
// matches everything including newlines where as `.` matches everything except
// newlines. Next, continue matching past the opening left curly bracket of the
// function and beyond optional whitespace and newline. Finally, capture the
// function body up to, but not including, optional newline and whitespace by
// the closing right curly bracket at the end of the source code. The alternate
// pattern matches arrow functions without brackets.
const funcBodyRegExp$LWS = /^[\s\S]+?\{[\t ]*(?:\r?\n)?([\s\S]*?)(?:\r?\n)?[\t ]*\}$|[\s\S]+?=>\s*([\s\S]+?)\s*$/;
function capitalizeFirstChar$LWS(string$LWS) {
  const {
    length: length$LWS
  } = string$LWS;
  if (length$LWS) {
    const upper$LWS = ReflectApply$LWS$1(StringProtoToUpperCase$LWS, string$LWS[0], []);
    return length$LWS === 1 ? upper$LWS : upper$LWS + ReflectApply$LWS$1(StringProtoSlice$LWS$1, string$LWS, [1]);
  }
  return '';
}
function enquote$LWS(string$LWS, quoteChar$LWS = CHAR_QUOTE_SINGLE$LWS) {
  return quoteChar$LWS + ReflectApply$LWS$1(StringProtoReplace$LWS, string$LWS, [quoteCharRegExpRegistry$LWS[quoteChar$LWS], `\\${quoteChar$LWS}`]) + quoteChar$LWS;
}
function extractFunctionBodySource$LWS(func$LWS) {
  var _ref$LWS, _match$$LWS;
  const source$LWS = ReflectApply$LWS$1(FunctionProtoToString$LWS, func$LWS, []);
  const match$LWS = ReflectApply$LWS$1(StringProtoMatch$LWS, source$LWS, [funcBodyRegExp$LWS]);
  // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
  return (_ref$LWS = (_match$$LWS = match$LWS == null ? void 0 : match$LWS[1]) != null ? _match$$LWS : match$LWS == null ? void 0 : match$LWS[2]) != null ? _ref$LWS : '';
}
// Use `toSafeStringValue()` to coerce values using the default string concatenation
// operation. This must be done ONLY once on incoming values to avoid creating
// shape-shifting exploits, ie. passing { toString() {...} } where a string
// is otherwise expected.
function toSafeStringValue$LWS(value$LWS) {
  return typeof value$LWS === 'string' ? value$LWS :
  // Attempt to coerce `value` to a string with the ToString operation.
  // Section 7.1.17 ToString ( argument )
  // https://tc39.es/ecma262/#sec-tostring
  `${value$LWS}`;
}
// Use `toSafeTemplateStringValue()` for values embedded in template strings,
// like error messages, because it coerces more values, including symbols,
// to strings without throwing exceptions.
function toSafeTemplateStringValue$LWS(value$LWS) {
  if (typeof value$LWS === 'string') {
    return value$LWS;
  }
  try {
    if (typeof value$LWS === 'function') {
      return ReflectApply$LWS$1(FunctionProtoToString$LWS, value$LWS, []);
    }
    if (typeof value$LWS === 'object' && value$LWS !== null) {
      /* istanbul ignore next: unreachable in test env */
      if (TrustedHTMLCtor$LWS && value$LWS instanceof TrustedHTMLCtor$LWS) {
        return ReflectApply$LWS$1(TrustedHTMLProtoToString$LWS, value$LWS, []);
      }
      /* istanbul ignore next: unreachable in test env */
      if (TrustedScriptCtor$LWS && value$LWS instanceof TrustedScriptCtor$LWS) {
        return ReflectApply$LWS$1(TrustedScriptProtoToString$LWS, value$LWS, []);
      }
      if (URLCtor$LWS$1 && value$LWS instanceof URLCtor$LWS$1) {
        return ReflectApply$LWS$1(URLProtoToString$LWS, value$LWS, []);
      }
      const result$LWS = ReflectApply$LWS$1(ObjectProtoToString$LWS$1, value$LWS, []);
      return result$LWS === TO_STRING_BRAND_SYMBOL$LWS$1 ? ReflectApply$LWS$1(SymbolProtoToString$LWS, value$LWS, []) : result$LWS;
    }
    if (typeof value$LWS === 'symbol') {
      return ReflectApply$LWS$1(SymbolProtoToString$LWS, value$LWS, []);
    }
    // Attempt to coerce `value` to a string with the String() constructor.
    // Section 22.1.1.1 String ( value )
    // https://tc39.es/ecma262/#sec-string-constructor-string-value
    return StringCtor$LWS$1(value$LWS);
    // eslint-disable-next-line no-empty
  } catch (_unused2$LWS) {}
  return '[object Unknown]';
}
const RegExpCtor$LWS$1 = RegExp;
const {
  prototype: RegExpProto$LWS$1
} = RegExpCtor$LWS$1;
const {
  exec: RegExpProtoExec$LWS,
  test: RegExpProtoTest$LWS$1
} = RegExpProto$LWS$1;
const RegExpProtoSourceGetter$LWS = ObjectLookupOwnGetter$LWS$1(RegExpProto$LWS$1, 'source');
const endsWithWordCharRegExp$LWS = /\w$/;
const specialCharRegExp$LWS = /[\\^$.*+?()[\]{}|]/g;
const startsWithWordCharRegExp$LWS = /^\w/;
function toRegExpEscapedIdentifierName$LWS(identifier$LWS) {
  return (startsWithWordCharRegExp$LWS.test(identifier$LWS) ? '\\b' : '') + toRegExpEscapedString$LWS(identifier$LWS) + (endsWithWordCharRegExp$LWS.test(identifier$LWS) ? '\\b' : '');
}
function toRegExpEscapedString$LWS(string$LWS) {
  return ReflectApply$LWS$1(StringProtoReplace$LWS, string$LWS, [specialCharRegExp$LWS, '\\$&']);
}
const SetCtor$LWS$1 = Set;
const {
  prototype: SetProto$LWS$1
} = SetCtor$LWS$1;
const {
  clear: SetProtoClear$LWS,
  delete: SetProtoDelete$LWS,
  entries: SetProtoEntries$LWS,
  forEach: SetProtoForEach$LWS,
  has: SetProtoHas$LWS$1,
  keys: SetProtoKeys$LWS,
  [SymbolIterator$LWS$1]: SetProtoSymbolIterator$LWS,
  [SymbolToStringTag$LWS$1]: SetProtoSymbolToStringTag$LWS
} = SetProto$LWS$1;
const {
  add: SetProtoAdd$LWS$1,
  values: SetProtoValues$LWS$1
} = SetProto$LWS$1;
const SetProtoSizeGetter$LWS = ObjectLookupOwnGetter$LWS$1(SetProto$LWS$1, 'size');
function toSafeSet$LWS(set$LWS) {
  ReflectSetPrototypeOf$LWS$1(set$LWS, null);
  set$LWS.add = SetProtoAdd$LWS$1;
  set$LWS.clear = SetProtoClear$LWS;
  set$LWS.delete = SetProtoDelete$LWS;
  set$LWS.entries = SetProtoEntries$LWS;
  set$LWS.forEach = SetProtoForEach$LWS;
  set$LWS.has = SetProtoHas$LWS$1;
  set$LWS.keys = SetProtoKeys$LWS;
  ReflectDefineProperty$LWS$1(set$LWS, 'size', {
    __proto__: null,
    configurable: true,
    enumerable: true,
    get: SetProtoSizeGetter$LWS,
    set: undefined
  });
  set$LWS.values = SetProtoValues$LWS$1;
  set$LWS[SymbolIterator$LWS$1] = SetProtoSymbolIterator$LWS;
  set$LWS[SymbolToStringTag$LWS$1] = SetProtoSymbolToStringTag$LWS;
  ReflectSetPrototypeOf$LWS$1(set$LWS, SetProto$LWS$1);
  return set$LWS;
}
const WeakMapCtor$LWS$1 = WeakMap;
const {
  prototype: WeakMapProto$LWS$1
} = WeakMapCtor$LWS$1;
const {
  has: WeakMapProtoHas$LWS$1
} = WeakMapProto$LWS$1;
const {
  delete: WeakMapProtoDelete$LWS$1,
  get: WeakMapProtoGet$LWS$1,
  set: WeakMapProtoSet$LWS$1,
  [SymbolToStringTag$LWS$1]: WeakMapProtoSymbolToStringTag$LWS$1
} = WeakMapProto$LWS$1;
function toSafeWeakMap$LWS$1(weakMap$LWS) {
  ReflectSetPrototypeOf$LWS$1(weakMap$LWS, null);
  weakMap$LWS.delete = WeakMapProtoDelete$LWS$1;
  weakMap$LWS.get = WeakMapProtoGet$LWS$1;
  weakMap$LWS.has = WeakMapProtoHas$LWS$1;
  weakMap$LWS.set = WeakMapProtoSet$LWS$1;
  weakMap$LWS[SymbolToStringTag$LWS$1] = WeakMapProtoSymbolToStringTag$LWS$1;
  ReflectSetPrototypeOf$LWS$1(weakMap$LWS, WeakMapProto$LWS$1);
  return weakMap$LWS;
}
const WeakSetCtor$LWS$1 = WeakSet;
const {
  prototype: WeakSetProto$LWS$1
} = WeakSetCtor$LWS$1;
const {
  has: WeakSetProtoHas$LWS$1
} = WeakSetProto$LWS$1;
const {
  add: WeakSetProtoAdd$LWS$1,
  delete: WeakSetProtoDelete$LWS$1,
  [SymbolToStringTag$LWS$1]: WeakSetProtoSymbolToStringTag$LWS$1
} = WeakSetProto$LWS$1;
function toSafeWeakSet$LWS$1(weakSet$LWS) {
  ReflectSetPrototypeOf$LWS$1(weakSet$LWS, null);
  weakSet$LWS.add = WeakSetProtoAdd$LWS$1;
  weakSet$LWS.delete = WeakSetProtoDelete$LWS$1;
  weakSet$LWS.has = WeakSetProtoHas$LWS$1;
  weakSet$LWS[SymbolToStringTag$LWS$1] = WeakSetProtoSymbolToStringTag$LWS$1;
  ReflectSetPrototypeOf$LWS$1(weakSet$LWS, WeakSetProto$LWS$1);
  return weakSet$LWS;
}
const {
  toStringTag: TO_STRING_TAG_SYMBOL$LWS
} = Symbol;
// Regular expressions from Acorn:
//     acorn/src/parseutil.js
//     acorn/src/whitespace.js
const expressionCharRegExp$LWS = /[(`.[+\-/*%<>=,?^&]/;
const lineBreakRegExp$LWS = /\r\n?|\n|\u2028|\u2029/;
const skipWhiteSpacesRegExp$LWS = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
const stringLiteralRegExp$LWS = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
function getBrandByTrialAndError$LWS(value$LWS) {
  // Trail and error attempts are performed in order of most likely,
  // e.g. those values that have a @@toStringTag defined by default,
  // to least likely.
  //
  // Internally these brand checks rely on native methods that throw and catch
  // an exception when they operate on values with unexpected internal slot
  // entries.
  // Section 25.1.5.1 get ArrayBuffer.prototype.byteLength
  // https://tc39.es/ecma262/#sec-get-arraybuffer.prototype.bytelength
  // Step 2: Perform RequireInternalSlot(O, [[ArrayBufferData]]).
  try {
    if ('byteLength' in value$LWS) {
      ReflectApply$LWS$1(ArrayBufferProtoByteLengthGetter$LWS, value$LWS, []);
      return TO_STRING_BRAND_ARRAY_BUFFER$LWS;
    }
    // eslint-disable-next-line no-empty
  } catch (_unused3$LWS) {}
  // Section 21.4.4 Properties of the Date Prototype Object
  // https://tc39.es/ecma262/#thistimevalue
  // Step 1: If Type(value) is Object and value has a [[DateValue]] internal slot, then
  //     a. Return value.[[DateValue]].
  // Step 2: Throw a TypeError exception.
  try {
    if ('toLocaleDateString' in value$LWS) {
      ReflectApply$LWS$1(DateProtoValueOf$LWS, value$LWS, []);
      return TO_STRING_BRAND_DATE$LWS;
    }
    // eslint-disable-next-line no-empty
  } catch (_unused4$LWS) {}
  // Section 24.1.3.10 get Map.prototype.size
  // https://tc39.es/ecma262/#sec-get-map.prototype.size
  // Step 2: Perform ? RequireInternalSlot(M, [[MapData]]).
  try {
    if ('get' in value$LWS && 'size' in value$LWS) {
      ReflectApply$LWS$1(MapProtoSizeGetter$LWS$1, value$LWS, []);
      return TO_STRING_BRAND_MAP$LWS;
    }
    // eslint-disable-next-line no-empty
  } catch (_unused5$LWS) {}
  // Section 24.2.3.9 get Set.prototype.size
  // https://tc39.es/ecma262/#sec-get-set.prototype.size
  // Step 2: Perform ? RequireInternalSlot(S, [[SetData]]).
  try {
    if ('add' in value$LWS && 'size' in value$LWS) {
      ReflectApply$LWS$1(SetProtoSizeGetter$LWS, value$LWS, []);
      return TO_STRING_BRAND_SET$LWS;
    }
    // eslint-disable-next-line no-empty
  } catch (_unused6$LWS) {}
  // Section 24.3.3.4 WeakMap.prototype.has ( key )
  // https://tc39.es/ecma262/#sec-weakmap.prototype.has
  // Step 2: Perform RequireInternalSlot(M, [[WeakMapData]]).
  try {
    if ('get' in value$LWS && !('size' in value$LWS)) {
      ReflectApply$LWS$1(WeakMapProtoHas$LWS$1, value$LWS, []);
      return TO_STRING_BRAND_WEAK_MAP$LWS;
    }
    // eslint-disable-next-line no-empty
  } catch (_unused7$LWS) {}
  // Section 24.4.3.4 WeakSet.prototype.has ( value )
  // https://tc39.es/ecma262/#sec-weakset.prototype.has
  // Step 2: 2. Perform RequireInternalSlot(S, [[WeakSetData]]).
  try {
    if ('add' in value$LWS && !('size' in value$LWS)) {
      ReflectApply$LWS$1(WeakSetProtoHas$LWS$1, value$LWS, []);
      return TO_STRING_BRAND_WEAK_SET$LWS;
    }
    // eslint-disable-next-line no-empty
  } catch (_unused8$LWS) {}
  // The following checks are for the rare occurrence of object, i.e. boxed,
  // primitive values or those objects without a default @@toStringTag.
  // Section 21.1.3 Properties of the Number Prototype Object
  // https://tc39.es/ecma262/#thisnumbervalue
  // Step 2: If Type(value) is Object and value has a [[NumberData]] internal slot, then
  //     a. Let n be value.[[NumberData]].
  //     b. Assert: Type(n) is Number.
  try {
    if ('toPrecision' in value$LWS) {
      ReflectApply$LWS$1(NumberProtoValueOf$LWS, value$LWS, []);
      return TO_STRING_BRAND_NUMBER$LWS$1;
    }
    // eslint-disable-next-line no-empty
  } catch (_unused9$LWS) {}
  // Section 20.4.3 Properties of the Symbol Prototype Object
  // https://tc39.es/ecma262/#thissymbolvalue
  // Step 2: If Type(value) is Object and value has a [[SymbolData]] internal slot, then
  //     a. Let s be value.[[SymbolData]].
  //     b. Assert: Type(s) is Symbol.
  try {
    if ('description' in value$LWS) {
      ReflectApply$LWS$1(SymbolProtoValueOf$LWS, value$LWS, []);
      return TO_STRING_BRAND_SYMBOL$LWS$1;
    }
    // eslint-disable-next-line no-empty
  } catch (_unused10$LWS) {}
  // Perform heavier checks last.
  // Section 22.2.6.13 get RegExp.prototype.source
  // https://tc39.es/ecma262/#sec-get-regexp.prototype.source
  // Step 3: If R does not have an [[OriginalSource]] internal slot, then
  //     a. If SameValue(R, %RegExp.prototype%) is true, return "(?:)".
  //     b. Otherwise, throw a TypeError exception.
  try {
    if (ObjectHasOwn$LWS$1(value$LWS, 'lastIndex')) {
      ReflectApply$LWS$1(RegExpProtoSourceGetter$LWS, value$LWS, []);
      return TO_STRING_BRAND_REG_EXP$LWS;
    }
    // eslint-disable-next-line no-empty
  } catch (_unused11$LWS) {}
  // Section 22.1.3 Properties of the String Prototype Object
  // https://tc39.es/ecma262/#thisstringvalue
  // Step 2: If Type(value) is Object and value has a [[StringData]] internal slot, then
  //     a. Let s be value.[[StringData]].
  //     b. Assert: Type(s) is String.
  try {
    if (ObjectHasOwn$LWS$1(value$LWS, 'length')) {
      ReflectApply$LWS$1(StringProtoValueOf$LWS$1, value$LWS, []);
      return TO_STRING_BRAND_STRING$LWS$1;
    }
    // eslint-disable-next-line no-empty
  } catch (_unused12$LWS) {}
  // Section 20.3.3 Properties of the Boolean Prototype Object
  // https://tc39.es/ecma262/#thisbooleanvalue
  // Step 2: If Type(value) is Object and value has a [[BooleanData]] internal slot, then
  //     a. Let b be value.[[BooleanData]].
  //     b. Assert: Type(b) is Boolean.
  try {
    ReflectApply$LWS$1(BooleanProtoValueOf$LWS, value$LWS, []);
    return TO_STRING_BRAND_BOOLEAN$LWS$1;
    // eslint-disable-next-line no-empty
  } catch (_unused13$LWS) {}
  // istanbul ignore else: All platforms that LWS runs tests in support BigInt
  if (SUPPORTS_BIG_INT$LWS) {
    try {
      // Section 21.2.3 Properties of the BigInt Prototype Object
      // https://tc39.es/ecma262/#thisbigintvalue
      // Step 2: If Type(value) is Object and value has a [[BigIntData]] internal slot, then
      //     a. Assert: Type(value.[[BigIntData]]) is BigInt.
      ReflectApply$LWS$1(BigIntProtoValueOf$LWS, value$LWS, []);
      return TO_STRING_BRAND_BIG_INT$LWS$1;
      // eslint-disable-next-line no-empty
    } catch (_unused14$LWS) {}
  }
  // Cannot detect brands for Arguments and Error objects.
  return TO_STRING_BRAND_OBJECT$LWS;
}
function getBrand$LWS(value$LWS) {
  // Section 20.1.3.6 Object.prototype.toString ( )
  // https://tc39.es/ecma262/#sec-object.prototype.tostring
  if (value$LWS === null) {
    return TO_STRING_BRAND_NULL$LWS;
  }
  if (value$LWS === undefined) {
    return TO_STRING_BRAND_UNDEFINED$LWS;
  }
  // eslint-disable-next-line default-case
  switch (typeof value$LWS) {
    case 'bigint':
      return TO_STRING_BRAND_BIG_INT$LWS$1;
    case 'boolean':
      return TO_STRING_BRAND_BOOLEAN$LWS$1;
    case 'function':
      return TO_STRING_BRAND_FUNCTION$LWS;
    case 'number':
      return TO_STRING_BRAND_NUMBER$LWS$1;
    case 'string':
      return TO_STRING_BRAND_STRING$LWS$1;
    case 'symbol':
      return TO_STRING_BRAND_SYMBOL$LWS$1;
  }
  if (ArrayIsArray$LWS$1(value$LWS)) {
    return TO_STRING_BRAND_ARRAY$LWS;
  }
  return TO_STRING_TAG_SYMBOL$LWS in value$LWS ? getBrandByTrialAndError$LWS(value$LWS) : ReflectApply$LWS$1(ObjectProtoToString$LWS$1, value$LWS, []);
}
typeof performance === 'undefined' ? /* istanbul ignore next: unreachable in test env */DateNow$LWS : ReflectApply$LWS$1(FunctionProtoBind$LWS, performance.now, [performance]);
// Based on Acorn strictDirective() parser utility.
// Copyright 2012-2022. Released under MIT License.
// https://github.com/acornjs/acorn/blob/master/acorn/src/parseutil.js
function indexOfPragma$LWS(source$LWS, pragma$LWS) {
  let pos$LWS = 0;
  // eslint-disable-next-line no-constant-condition
  while (true) {
    skipWhiteSpacesRegExp$LWS.lastIndex = pos$LWS;
    pos$LWS += ReflectApply$LWS$1(RegExpProtoExec$LWS, skipWhiteSpacesRegExp$LWS, [source$LWS])[0].length;
    const stringLiteralMatch$LWS = ReflectApply$LWS$1(RegExpProtoExec$LWS, stringLiteralRegExp$LWS, [ReflectApply$LWS$1(StringProtoSlice$LWS$1, source$LWS, [pos$LWS])]);
    if (stringLiteralMatch$LWS === null) {
      return -1;
    }
    if ((stringLiteralMatch$LWS[1] || stringLiteralMatch$LWS[2]) === pragma$LWS) {
      skipWhiteSpacesRegExp$LWS.lastIndex = pos$LWS + stringLiteralMatch$LWS[0].length;
      const spaceAfterMatch$LWS = ReflectApply$LWS$1(RegExpProtoExec$LWS, skipWhiteSpacesRegExp$LWS, [source$LWS]);
      const end$LWS = spaceAfterMatch$LWS.index + spaceAfterMatch$LWS[0].length;
      const nextChar$LWS = source$LWS[end$LWS];
      if (nextChar$LWS === ';' || nextChar$LWS === '}') {
        return pos$LWS;
      }
      const indexAfterNext$LWS = end$LWS + 1;
      if (ReflectApply$LWS$1(RegExpProtoTest$LWS$1, lineBreakRegExp$LWS, [spaceAfterMatch$LWS[0]]) && !(nextChar$LWS === '!' && indexAfterNext$LWS < source$LWS.length && source$LWS[indexAfterNext$LWS] === '=' || ReflectApply$LWS$1(RegExpProtoTest$LWS$1, expressionCharRegExp$LWS, [nextChar$LWS]))) {
        return pos$LWS;
      }
    }
    pos$LWS += stringLiteralMatch$LWS[0].length;
    // Skip semicolon, if any.
    skipWhiteSpacesRegExp$LWS.lastIndex = pos$LWS;
    pos$LWS += ReflectApply$LWS$1(RegExpProtoExec$LWS, skipWhiteSpacesRegExp$LWS, [source$LWS])[0].length;
    if (source$LWS[pos$LWS] === ';') {
      pos$LWS += 1;
    }
  }
}
const {
  parse: JSONParse$LWS
} = JSON;
function getNearMembraneProxySerializedValue$LWS$1(object$LWS) {
  if (typeof object$LWS === 'object' && object$LWS !== null || typeof object$LWS === 'function') {
    // To extract the serialized value of a blue near-membrane proxy we must
    // perform a two step handshake. First, we trigger the "has" trap for
    // the `LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL` property which
    // must report `false`. Second, we trigger the "get" trap to return the
    // serialized value.
    return LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS$1 in object$LWS ? undefined : object$LWS[LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS$1];
  }
  return undefined;
}
function isNearMembraneProxy$LWS$1(value$LWS) {
  if (typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function') {
    // To extract the flag value of a blue near-membrane proxy we must
    // perform a two step handshake. First, we trigger the "has" trap for
    // the `LOCKER_NEAR_MEMBRANE_SYMBOL` property which must report `false`.
    // Second, we trigger the "get" trap to return the flag value.
    return !(LOCKER_NEAR_MEMBRANE_SYMBOL$LWS$1 in value$LWS) && value$LWS[LOCKER_NEAR_MEMBRANE_SYMBOL$LWS$1] === true;
  }
  return false;
}
const SEEN_OBJECTS$LWS = toSafeMap$LWS$1(new MapCtor$LWS$1());
// istanbul ignore next: this may be dead code, further investigation needed
function cloneBoxedPrimitive$LWS(object$LWS) {
  return ObjectCtor$LWS$1(getNearMembraneProxySerializedValue$LWS$1(object$LWS));
}
function cloneMap$LWS(map$LWS, queue$LWS) {
  // Section 2.7.3 StructuredSerializeInternal:
  // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
  // Step 26.1.1: Let copiedList be a new empty List.
  const clone$LWS = new MapCtor$LWS$1();
  // Step 26.1.2: For each Record { [[Key]], [[Value]] } entry of value.[[MapData]]...
  const entriesIterable$LWS = ReflectApply$LWS$1(MapProtoEntries$LWS$1, map$LWS, []);
  // Step 26.1.3 For each Record { [[Key]], [[Value]] } entry of copiedList:
  let {
    length: queueOffset$LWS
  } = queue$LWS;
  // eslint-disable-next-line no-constant-condition
  while (true) {
    const {
      done: done$LWS,
      value: subKeyValuePair$LWS
    } = entriesIterable$LWS.next();
    if (done$LWS) {
      break;
    }
    const {
      0: subKey$LWS,
      1: subValue$LWS
    } = subKeyValuePair$LWS;
    let subCloneKey$LWS;
    // Step 26.1.3.1: Let serializedKey be ? StructuredSerializeInternal(entry.[[Key]], forStorage, memory).
    queue$LWS[queueOffset$LWS++] = [subClone$LWS => {
      subCloneKey$LWS = subClone$LWS;
    }, subKey$LWS];
    // Step 26.1.3.2: Let serializedValue be ? StructuredSerializeInternal(entry.[[Value]], forStorage, memory).
    queue$LWS[queueOffset$LWS++] = [subCloneValue$LWS => {
      ReflectApply$LWS$1(MapProtoSet$LWS$1, clone$LWS, [subCloneKey$LWS, subCloneValue$LWS]);
    }, subValue$LWS];
  }
  return clone$LWS;
}
// istanbul ignore next: this may be dead code, further investigation needed
function cloneRegExp$LWS(regexp$LWS) {
  const {
    flags: flags$LWS,
    source: source$LWS
  } = JSONParse$LWS(getNearMembraneProxySerializedValue$LWS$1(regexp$LWS));
  return new RegExpCtor$LWS$1(source$LWS, flags$LWS);
}
function cloneSet$LWS(set$LWS, queue$LWS) {
  // Section 2.7.3 StructuredSerializeInternal:
  // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
  // Step 26.2.1: Let copiedList be a new empty List.
  const clone$LWS = new SetCtor$LWS$1();
  // Step 26.2.2: For each entry of value.[[SetData]]...
  const valuesIterable$LWS = ReflectApply$LWS$1(SetProtoValues$LWS$1, set$LWS, []);
  // Step 26.2.3: For each entry of copiedList:
  let {
    length: queueOffset$LWS
  } = queue$LWS;
  // eslint-disable-next-line no-constant-condition
  while (true) {
    const {
      done: done$LWS,
      value: subValue$LWS
    } = valuesIterable$LWS.next();
    if (done$LWS) {
      break;
    }
    // Step 26.2.3.1: Let serializedEntry be ? StructuredSerializeInternal(entry, forStorage, memory).
    queue$LWS[queueOffset$LWS++] = [subCloneValue$LWS => {
      ReflectApply$LWS$1(SetProtoAdd$LWS$1, clone$LWS, [subCloneValue$LWS]);
    }, subValue$LWS];
  }
  return clone$LWS;
}
function enqueue$LWS(queue$LWS, originalValue$LWS, cloneValue$LWS) {
  // Section 2.7.3 StructuredSerializeInternal:
  // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
  // Step 26.4: Otherwise, for each key in ! EnumerableOwnPropertyNames(value, key)...
  // Note: Object.keys() performs EnumerableOwnPropertyNames() internally as
  // defined in ECMA262:
  // https://tc39.es/ecma262/#sec-object.keys
  const keys$LWS = ObjectKeys$LWS$1(originalValue$LWS);
  let {
    length: queueOffset$LWS
  } = queue$LWS;
  for (let i$LWS = 0, {
      length: length$LWS
    } = keys$LWS; i$LWS < length$LWS; i$LWS += 1) {
    // Step 26.4.1.1: Let inputValue be ? value.[[Get]](key, value).
    // The [[Get]] operation is defined in ECMA262 for ordinary objects,
    // argument objects, integer-indexed exotic objects, module namespace
    // objects, and proxy objects.
    // https://tc39.es/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-get-p-receiver
    const key$LWS = keys$LWS[i$LWS];
    const subValue$LWS = originalValue$LWS[key$LWS];
    queue$LWS[queueOffset$LWS++] = [subCloneValue$LWS => {
      // Step 26.4.1.3: Property descriptor attributes are not
      // preserved during deserialization because only keys and
      // values are captured in serialized.[[Properties]].
      cloneValue$LWS[key$LWS] = subCloneValue$LWS;
    }, subValue$LWS];
  }
}
// This function is the unguarded internal variant of `partialStructuredClone()`.
// Any error thrown that is captured by `partialStructuredClone()` is treated as
// a `DataCloneError`. This function clones blue membrane proxied arrays, plain
// objects, maps, regexps, sets, and boxed primitives. The following non-membrane
// proxied objects are set by reference instead of cloning:
//   ArrayBuffer
//   BigInt64Array
//   BigUint64Array
//   Blob
//   DataView
//   Date
//   DOMException
//   DOMMatrix
//   DOMMatrixReadOnly
//   DOMPoint
//   DOMPointReadOnly
//   DOMQuad
//   DOMRect
//   DOMRectReadOnly
//   Error
//   EvalError
//   File
//   FileList
//   Float32Array
//   Float64Array
//   ImageBitMap
//   ImageData
//   Int8Array
//   Int16Array
//   Int32Array
//   RangeError
//   ReferenceError
//   SyntaxError
//   TypeError
//   Uint8Array
//   Uint8ClampedArray
//   Uint16Array
//   Uint32Array
//   URIError
//
// Note:
// This function performs brand checks using `Object.prototype.toString`. The
// results can be faked with `Symbol.toStringTag` property values and are a poor
// substitute for native internal slot checks. However, for our purposes they
// are perfectly fine and avoid having to repeatedly walk the prototype of proxied
// values. Cloned values should be passed to native methods, like `postMessage()`,
// which perform their own validation with internal slot checks.
function partialStructuredCloneInternal$LWS(value$LWS) {
  // Using a queue instead of recursive function calls avoids call stack limits
  // and enables cloning more complex and deeply nested objects.
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Too_much_recursion
  let result$LWS;
  const queue$LWS = [[subClone$LWS => {
    result$LWS = subClone$LWS;
  }, value$LWS]];
  // eslint-disable-next-line no-labels
  queueLoop: while (queue$LWS.length) {
    // Section 2.7.3 StructuredSerializeInternal:
    // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
    // prettier-ignore
    const {
      0: setter$LWS,
      1: originalValue$LWS
    } = ReflectApply$LWS$1(ArrayProtoShift$LWS$1, queue$LWS, []);
    // Step 4: If Type(value) is Undefined, Null, Boolean, Number, BigInt, or String
    if (originalValue$LWS === null || originalValue$LWS === undefined || typeof originalValue$LWS === 'boolean' || typeof originalValue$LWS === 'number' || typeof originalValue$LWS === 'string' || typeof originalValue$LWS === 'bigint') {
      setter$LWS(originalValue$LWS);
      // eslint-disable-next-line no-continue, no-extra-label, no-labels
      continue queueLoop;
    }
    // Step 5: If Type(value) is Symbol, then throw a 'DataCloneError' DOMException.
    if (typeof originalValue$LWS === 'symbol') {
      // Stop cloning and set the original value and defer throwing to
      // native methods.
      setter$LWS(originalValue$LWS);
      // eslint-disable-next-line no-extra-label, no-labels
      break queueLoop;
    }
    // To support circular references check if the original value has been
    // seen. If it has then use the clone associated with its record instead
    // of creating a new clone.
    let cloneValue$LWS = SEEN_OBJECTS$LWS.get(originalValue$LWS);
    if (cloneValue$LWS) {
      setter$LWS(cloneValue$LWS);
      // eslint-disable-next-line no-continue, no-extra-label, no-labels
      continue queueLoop;
    }
    // Perform a brand check on originalValue.
    const brand$LWS = getBrand$LWS(originalValue$LWS);
    // eslint-disable-next-line default-case
    switch (brand$LWS) {
      // Step 19: Otherwise, if value is a platform object...
      case TO_STRING_BRAND_OBJECT$LWS:
        {
          const proto$LWS = ReflectGetPrototypeOf$LWS$1(originalValue$LWS);
          if (proto$LWS === ObjectProto$LWS$1 || proto$LWS === null ||
          // Possible `Object.prototype` from another document.
          ReflectGetPrototypeOf$LWS$1(proto$LWS) === null) {
            cloneValue$LWS = {};
            // Step 19.4: Set deep to true.
            enqueue$LWS(queue$LWS, originalValue$LWS, cloneValue$LWS);
          }
          break;
        }
      // Step 18: Otherwise, if value is an Array exotic object...
      case TO_STRING_BRAND_ARRAY$LWS:
        // Step 18.1 Let valueLenDescriptor be ? OrdinaryGetOwnProperty(value, 'length').
        // Note: Rather than perform the more complex OrdinaryGetOwnProperty()
        // operation for 'length' because it is a non-configurable property
        // we can access it with the simpler [[Get]]() operation defined
        // in ECMA262.
        // https://tc39.es/ecma262/#sec-integer-indexed-exotic-objects-get-p-receiver
        cloneValue$LWS = ArrayCtor$LWS$1(originalValue$LWS.length);
        // Step 18.4: Set deep to true.
        enqueue$LWS(queue$LWS, originalValue$LWS, cloneValue$LWS);
        break;
      // Step 15: Otherwise, if value has [[MapData]] internal slot...
      // Step 15.2: Set deep to true.
      case TO_STRING_BRAND_MAP$LWS:
        cloneValue$LWS = cloneMap$LWS(originalValue$LWS, queue$LWS);
        break;
      // Step 16: Otherwise, if value has [[SetData]] internal slot...
      // Step 16.2: Set deep to true.
      case TO_STRING_BRAND_SET$LWS:
        cloneValue$LWS = cloneSet$LWS(originalValue$LWS, queue$LWS);
        break;
    }
    if (cloneValue$LWS === undefined) {
      // istanbul ignore else
      if (!isNearMembraneProxy$LWS$1(originalValue$LWS)) {
        // Skip cloning non-membrane proxied objects.
        SEEN_OBJECTS$LWS.set(originalValue$LWS, originalValue$LWS);
        setter$LWS(originalValue$LWS);
        // eslint-disable-next-line no-extra-label, no-labels
        continue queueLoop;
      }
      // Cases ordered by a guestimate on frequency of encounter.
      // eslint-disable-next-line default-case
      switch (brand$LWS) {
        // Step 12: Otherwise, if value has a [[RegExpMatcher]] internal slot...
        case TO_STRING_BRAND_REG_EXP$LWS:
          // istanbul ignore next: this may be dead code, further investigation needed
          cloneValue$LWS = cloneRegExp$LWS(originalValue$LWS);
          // istanbul ignore next: this may be dead code, further investigation needed
          break;
        // Step 7: If value has a [[BooleanData]] internal slot...
        case TO_STRING_BRAND_BOOLEAN$LWS$1:
        // Step 8: Otherwise, if value has a [[NumberData]] internal slot...
        // eslint-disable-next-line no-fallthrough
        case TO_STRING_BRAND_NUMBER$LWS$1:
        // Step 9: Otherwise, if value has a [[BigIntData]] internal slot...
        // eslint-disable-next-line no-fallthrough
        case TO_STRING_BRAND_BIG_INT$LWS$1:
        // Step 10: Otherwise, if value has a [[StringData]] internal slot...
        // eslint-disable-next-line no-fallthrough
        case TO_STRING_BRAND_STRING$LWS$1:
          // istanbul ignore next: this may be dead code, further investigation needed
          cloneValue$LWS = cloneBoxedPrimitive$LWS(originalValue$LWS);
          // istanbul ignore next: this may be dead code, further investigation needed
          break;
      }
    }
    // Step 21: Otherwise, if IsCallable(value) is true, then throw a 'DataCloneError'
    // Step 20: Otherwise, if value is a platform object, then throw a 'DataCloneError'
    if (cloneValue$LWS === undefined) {
      // Stop cloning and set the original value and defer throwing to
      // native methods.
      setter$LWS(originalValue$LWS);
      // eslint-disable-next-line no-extra-label, no-labels
      break queueLoop;
    }
    SEEN_OBJECTS$LWS.set(originalValue$LWS, cloneValue$LWS);
    setter$LWS(cloneValue$LWS);
  }
  return result$LWS;
}
function partialStructuredClone$LWS(value$LWS) {
  let result$LWS = value$LWS;
  if (typeof value$LWS === 'object' && value$LWS !== null) {
    try {
      result$LWS = partialStructuredCloneInternal$LWS(value$LWS);
      // eslint-disable-next-line no-empty
    } catch (_unused15$LWS) {}
    SEEN_OBJECTS$LWS.clear();
  }
  return result$LWS;
}
function shallowCloneArray$LWS(array$LWS) {
  return ReflectApply$LWS$1(ArrayProtoSlice$LWS$1, array$LWS, [0]);
}
function shallowCloneOptions$LWS(options$LWS) {
  const ownKeys$LWS = ReflectOwnKeys$LWS$1(options$LWS);
  const clone$LWS = {
    __proto__: null
  };
  for (let i$LWS = 0, {
      length: length$LWS
    } = ownKeys$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const key$LWS = ownKeys$LWS[i$LWS];
    clone$LWS[key$LWS] = options$LWS[key$LWS];
  }
  return clone$LWS;
}
const consoleRef$LWS = console;
const {
  warn: consoleWarnRef$LWS
} = consoleRef$LWS;
function consoleWarn$LWS(...args$LWS) {
  ReflectApply$LWS$1(consoleWarnRef$LWS, consoleRef$LWS, args$LWS);
}
const gaterEnabledFeatures$LWS = toSafeSet$LWS(new SetCtor$LWS$1());
const FEATURE_NAME_PREFIX$LWS = 'com.salesforce.locker.';
const fullName$LWS = featureName$LWS => featureName$LWS.startsWith(FEATURE_NAME_PREFIX$LWS) ? featureName$LWS : `${FEATURE_NAME_PREFIX$LWS}${featureName$LWS}`;
function isGaterEnabledFeature$LWS(featureName$LWS) {
  return gaterEnabledFeatures$LWS.has(fullName$LWS(featureName$LWS));
}
const ENABLE_MAX_PERF_MODE_GATE$LWS = 'enableMaxPerfMode';
const ENABLE_SANDBOXED_SAMEORIGIN_IFRAME_GATE$LWS = 'enableSandboxedSameOriginIframe';
const omniStudioPredicates$LWS = [key$LWS => key$LWS === 'omnistudio', key$LWS => ReflectApply$LWS$1(StringProtoStartsWith$LWS, key$LWS, ['devopsimpkg'])];
const gaterEnabledOverrideRegistry$LWS = {
  __proto__: null,
  $lwsBogusFeatureDisabledTrue: [() => true],
  $lwsBogusFeatureDisabledFalse: [() => false],
  [ENABLE_MAX_PERF_MODE_GATE$LWS]: omniStudioPredicates$LWS,
  // Temporarily disable this feature gate
  // Ref:
  //  "W-17049687: [LWS] Temporarily disable same origin iframe sandbox security fix for OS and devopsimpkg"
  //  https://gus.lightning.force.com/lightning/r/ADM_Work__c/a07EE000023unysYAA/view
  [ENABLE_SANDBOXED_SAMEORIGIN_IFRAME_GATE$LWS]: omniStudioPredicates$LWS
};
function isAllowedToOverrideGaterEnabledFeature$LWS(sandboxKey$LWS, featureName$LWS) {
  var _gaterEnabledOverride$LWS;
  const gaterEnabledOverridePredicates$LWS = toSafeArray$LWS$1((_gaterEnabledOverride$LWS = gaterEnabledOverrideRegistry$LWS[featureName$LWS]) != null ? _gaterEnabledOverride$LWS : []);
  return gaterEnabledOverridePredicates$LWS.some(predicate$LWS => predicate$LWS(sandboxKey$LWS));
}
function isNotAllowedToOverrideGaterEnabledFeature$LWS(...args$LWS) {
  return !isAllowedToOverrideGaterEnabledFeature$LWS(...args$LWS);
}
const trackedLiveTargets$LWS = toSafeWeakSet$LWS$1(new WeakSetCtor$LWS$1());
function isTargetLive$LWS(target$LWS, targetTraits$LWS = 0 /* TargetTraits.None */) {
  if (targetTraits$LWS & 1 /* TargetTraits.IsArray */ || targetTraits$LWS & 2 /* TargetTraits.IsArrayBufferView */ || targetTraits$LWS & 64 /* TargetTraits.Revoked */ || target$LWS === null || target$LWS === undefined || target$LWS === ObjectProto$LWS$1 || target$LWS === RegExpProto$LWS$1) {
    return false;
  }
  if (typeof target$LWS === 'function') {
    try {
      return trackedLiveTargets$LWS.has(target$LWS) || ObjectHasOwn$LWS$1(target$LWS, SYMBOL_LIVE_OBJECT$LWS);
      // eslint-disable-next-line no-empty
    } catch (_unused16$LWS) {}
    return false;
  }
  if (typeof target$LWS === 'object') {
    try {
      if (trackedLiveTargets$LWS.has(target$LWS) || ObjectHasOwn$LWS$1(target$LWS, SYMBOL_LIVE_OBJECT$LWS)) {
        return true;
      }
      // eslint-disable-next-line no-empty
    } catch (_unused17$LWS) {}
    let constructor$LWS;
    try {
      ({
        constructor: constructor$LWS
      } = target$LWS);
      if (constructor$LWS === ObjectCtor$LWS$1) {
        // If the constructor, own or inherited, points to `Object`
        // then `target` is not likely a prototype object.
        return true;
      }
      // eslint-disable-next-line no-empty
    } catch (_unused18$LWS) {}
    try {
      if (ReflectGetPrototypeOf$LWS$1(target$LWS) === null && (
      // Ensure `target` is not an `Object.prototype` from an iframe.
      typeof constructor$LWS !== 'function' || constructor$LWS.prototype !== target$LWS)) {
        return true;
      }
      // eslint-disable-next-line no-empty
    } catch (_unused19$LWS) {}
    if (targetTraits$LWS === 0 /* TargetTraits.None */) {
      try {
        if (ArrayIsArray$LWS$1(target$LWS)) {
          return true;
        }
      } catch (_unused20$LWS) {
        // The target is a revoked proxy.
        return false;
      }
      if (ArrayBufferIsView$LWS(target$LWS)) {
        return true;
      }
    }
    // Section 25.1.5.1 get ArrayBuffer.prototype.byteLength
    // https://tc39.es/ecma262/#sec-get-regexp.prototype.source
    // Step 3: If R does not have an [[OriginalSource]] internal slot, then
    //     a. If SameValue(R, %RegExp.prototype%) is true, return "(?:)".
    //     b. Otherwise, throw a TypeError exception.
    try {
      if (ObjectHasOwn$LWS$1(target$LWS, 'lastIndex')) {
        ReflectApply$LWS$1(RegExpProtoSourceGetter$LWS, target$LWS, []);
        return true;
      }
      // eslint-disable-next-line no-empty
    } catch (_unused21$LWS) {}
    // Section 25.1.5.1 get ArrayBuffer.prototype.byteLength
    // https://tc39.es/ecma262/#sec-get-arraybuffer.prototype.bytelength
    // Step 2: Perform RequireInternalSlot(O, [[ArrayBufferData]]).
    try {
      if ('byteLength' in target$LWS) {
        ReflectApply$LWS$1(ArrayBufferProtoByteLengthGetter$LWS, target$LWS, []);
        return true;
      }
      // eslint-disable-next-line no-empty
    } catch (_unused22$LWS) {}
  }
  return false;
}
function trackAsLiveTarget$LWS(target$LWS) {
  trackedLiveTargets$LWS.add(target$LWS);
  return target$LWS;
}
const lockerFeatures$LWS = {};
function isLockerFeatureEnabled$LWS(featureName$LWS) {
  return lockerFeatures$LWS[featureName$LWS];
}
const NS_HEAD$LWS = `${LOCKER_SERVICE_KEY$LWS}-`;
const NS_TAIL$LWS = '$';
const STORAGE_NS_HEAD$LWS = `${LOCKER_SERVICE_KEY$LWS}[`;
const STORAGE_NS_TAIL$LWS = ']';
function getNamespaceMarker$LWS(namespace$LWS) {
  return `${NS_HEAD$LWS}${namespace$LWS}${NS_TAIL$LWS}`;
}
function getStorageNamespaceMarker$LWS(namespace$LWS) {
  return `${STORAGE_NS_HEAD$LWS}${namespace$LWS}${STORAGE_NS_TAIL$LWS}`;
}
function prependNamespaceMarker$LWS(key$LWS, namespace$LWS) {
  return `${getNamespaceMarker$LWS(namespace$LWS)}${key$LWS}`;
}
function prependStorageNamespaceMarker$LWS(key$LWS, namespace$LWS) {
  return `${getStorageNamespaceMarker$LWS(namespace$LWS)}${key$LWS}`;
}
function removeNamespaceMarker$LWS(key$LWS, namespace$LWS) {
  if (typeof key$LWS === 'string') {
    const marker$LWS = getNamespaceMarker$LWS(namespace$LWS);
    return ReflectApply$LWS$1(StringProtoStartsWith$LWS, key$LWS, [marker$LWS]) ? ReflectApply$LWS$1(StringProtoSlice$LWS$1, key$LWS, [marker$LWS.length]) : key$LWS;
  }
  return '';
}
function removeStorageNamespaceMarker$LWS(key$LWS, namespace$LWS) {
  if (typeof key$LWS === 'string') {
    const marker$LWS = getStorageNamespaceMarker$LWS(namespace$LWS);
    return ReflectApply$LWS$1(StringProtoStartsWith$LWS, key$LWS, [marker$LWS]) ? ReflectApply$LWS$1(StringProtoSlice$LWS$1, key$LWS, [marker$LWS.length]) : key$LWS;
  }
  return '';
}
function startsWithNamespaceMarker$LWS(key$LWS, namespace$LWS) {
  return typeof key$LWS === 'string' && ReflectApply$LWS$1(StringProtoStartsWith$LWS, key$LWS, [getNamespaceMarker$LWS(namespace$LWS)]);
}
function startsWithStorageNamespaceMarker$LWS(key$LWS, namespace$LWS) {
  return typeof key$LWS === 'string' && ReflectApply$LWS$1(StringProtoStartsWith$LWS, key$LWS, [getStorageNamespaceMarker$LWS(namespace$LWS)]);
}
const PromiseCtor$LWS = Promise;
const {
  catch: PromiseProtoCatch$LWS,
  then: PromiseProtoThen$LWS
} = PromiseCtor$LWS.prototype;
const PromiseResolve$LWS = PromiseCtor$LWS.resolve.bind(PromiseCtor$LWS);
const PromiseReject$LWS = PromiseCtor$LWS.reject.bind(PromiseCtor$LWS);
/*! version: 0.23.6 */

/*!
 * Copyright (C) 2019 salesforce.com, inc.
 */
const AbortControllerCtor$LWS = AbortController;
const {
  prototype: AbortControllerProto$LWS
} = AbortControllerCtor$LWS;
const {
  abort: AbortControllerProtoAbort$LWS
} = AbortControllerProto$LWS;
const AbortControllerProtoSignalGetter$LWS = ObjectLookupOwnGetter$LWS$1(AbortControllerProto$LWS, 'signal');
const {
  prototype: AttrProto$LWS
} = Attr;
const AttrProtoNameGetter$LWS = ObjectLookupOwnGetter$LWS$1(AttrProto$LWS, 'name');
const AttrProtoNamespaceURIGetter$LWS = ObjectLookupOwnGetter$LWS$1(AttrProto$LWS, 'namespaceURI');
const AttrProtoOwnerElementGetter$LWS = ObjectLookupOwnGetter$LWS$1(AttrProto$LWS, 'ownerElement');
const {
  get: AttrProtoValueGetter$LWS,
  set: AttrProtoValueSetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(AttrProto$LWS, 'value');
function normalizeNamespacedAttributeName$LWS(attrName$LWS) {
  const href$LWS = 'href';
  // Prevent arbitrary:href from being treated like a valid namespaced href value
  if (ReflectApply$LWS$1(StringProtoEndsWith$LWS, attrName$LWS, [href$LWS]) &&
  // ...But we don't want to match "xlink:href"
  !ReflectApply$LWS$1(StringProtoStartsWith$LWS, attrName$LWS, ['xlink:href'])) {
    return href$LWS;
  }
  return attrName$LWS;
}
const rootDocument$LWS = document;
const {
  prototype: DocumentProto$LWS$1
} = Document;
// Used by '@locker/near-membrane/dom'.
const {
  close: DocumentProtoClose$LWS$1,
  open: DocumentProtoOpen$LWS$1
} = DocumentProto$LWS$1;
const {
  createComment: DocumentProtoCreateComment$LWS,
  createDocumentFragment: DocumentProtoCreateDocumentFragment$LWS,
  createElement: DocumentProtoCreateElement$LWS$1,
  createElementNS: DocumentProtoCreateElementNS$LWS,
  getElementById: DocumentProtoGetElementById$LWS
} = DocumentProto$LWS$1;
const DocumentProtoBodyGetter$LWS$1 = ObjectLookupOwnGetter$LWS$1(DocumentProto$LWS$1, 'body');
const {
  get: DocumentProtoCookieGetter$LWS,
  set: DocumentProtoCookieSetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(DocumentProto$LWS$1, 'cookie');
const DocumentProtoDefaultViewGetter$LWS = ObjectLookupOwnGetter$LWS$1(DocumentProto$LWS$1, 'defaultView');
const DocumentProtoDocumentElementGetter$LWS = ObjectLookupOwnGetter$LWS$1(DocumentProto$LWS$1, 'documentElement');
const DocumentProtoHeadGetter$LWS = ObjectLookupOwnGetter$LWS$1(DocumentProto$LWS$1, 'head');
const DocumentProtoImplementationGetter$LWS = ObjectLookupOwnGetter$LWS$1(DocumentProto$LWS$1, 'implementation');
const {
  append: DocumentFragmentProtoAppend$LWS,
  getElementById: DocumentFragmentProtoGetElementById$LWS
} = DocumentFragment.prototype;
const {
  prototype: ElementProto$LWS
} = Element;
const ElementAriaAttributesToPropertyName$LWS = {
  __proto__: null,
  'aria-activedescendant': 'ariaActiveDescendant',
  'aria-atomic': 'ariaAtomic',
  'aria-autocomplete': 'ariaAutoComplete',
  'aria-busy': 'ariaBusy',
  'aria-checked': 'ariaChecked',
  'aria-colcount': 'ariaColCount',
  'aria-colindex': 'ariaColIndex',
  'aria-colspan': 'ariaColSpan',
  'aria-controls': 'ariaControls',
  'aria-current': 'ariaCurrent',
  'aria-describedby': 'ariaDescribedBy',
  'aria-details': 'ariaDetails',
  'aria-disabled': 'ariaDisabled',
  'aria-errormessage': 'ariaErrorMessage',
  'aria-expanded': 'ariaExpanded',
  'aria-flowto': 'ariaFlowTo',
  'aria-haspopup': 'ariaHasPopup',
  'aria-hidden': 'ariaHidden',
  'aria-invalid': 'ariaInvalid',
  'aria-keyshortcuts': 'ariaKeyShortcuts',
  'aria-label': 'ariaLabel',
  'aria-labelledby': 'ariaLabelledBy',
  'aria-level': 'ariaLevel',
  'aria-live': 'ariaLive',
  'aria-modal': 'ariaModal',
  'aria-multiline': 'ariaMultiLine',
  'aria-multiselectable': 'ariaMultiSelectable',
  'aria-orientation': 'ariaOrientation',
  'aria-owns': 'ariaOwns',
  'aria-placeholder': 'ariaPlaceholder',
  'aria-posinset': 'ariaPosInSet',
  'aria-pressed': 'ariaPressed',
  'aria-readonly': 'ariaReadOnly',
  'aria-relevant': 'ariaRelevant',
  'aria-required': 'ariaRequired',
  'aria-roledescription': 'ariaRoleDescription',
  'aria-rowcount': 'ariaRowCount',
  'aria-rowindex': 'ariaRowIndex',
  'aria-rowspan': 'ariaRowSpan',
  'aria-selected': 'ariaSelected',
  'aria-setsize': 'ariaSetSize',
  'aria-sort': 'ariaSort',
  'aria-valuemax': 'ariaValueMax',
  'aria-valuemin': 'ariaValueMin',
  'aria-valuenow': 'ariaValueNow',
  'aria-valuetext': 'ariaValueText'
};
// Used by '@locker/near-membrane-dom'.
const {
  remove: ElementProtoRemove$LWS$1
} = ElementProto$LWS;
const {
  closest: ElementProtoClosest$LWS,
  getAttribute: ElementProtoGetAttribute$LWS,
  getAttributeNode: ElementProtoGetAttributeNode$LWS,
  getAttributeNodeNS: ElementProtoGetAttributeNodeNS$LWS,
  hasAttribute: ElementProtoHasAttribute$LWS,
  querySelector: ElementProtoQuerySelector$LWS,
  querySelectorAll: ElementProtoQuerySelectorAll$LWS,
  removeAttribute: ElementProtoRemoveAttribute$LWS,
  removeAttributeNode: ElementProtoRemoveAttributeNode$LWS,
  removeAttributeNS: ElementProtoRemoveAttributeNS$LWS,
  setAttribute: ElementProtoSetAttribute$LWS$1,
  setAttributeNS: ElementProtoSetAttributeNS$LWS,
  toggleAttribute: ElementProtoToggleAttribute$LWS
} = ElementProto$LWS;
const {
  get: ElementProtoInnerHTMLGetter$LWS,
  set: ElementProtoInnerHTMLSetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(ElementProto$LWS, 'innerHTML');
const ElementProtoNamespaceURIGetter$LWS = ObjectLookupOwnGetter$LWS$1(ElementProto$LWS, 'namespaceURI');
const {
  get: ElementProtoOuterHTMLGetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(ElementProto$LWS, 'outerHTML');
const ElementProtoTagNameGetter$LWS = ObjectLookupOwnGetter$LWS$1(ElementProto$LWS, 'tagName');

// Check for the noopener feature being enabled:
// - noopener
// - noopener=1
// - noopener=yes
const noopenerRegExp$LWS = /(^|,)(\s*noopener\s*=\s*(?:yes|1)\s*)(,|$)/g;
const rootWindow$LWS$1 = window;
// These properties are part of the WindowOrGlobalScope mixin and not on
// Window.prototype.
// https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope
const {
  setTimeout: WindowSetTimeout$LWS
} = rootWindow$LWS$1;
const {
  clearInterval: WindowClearInterval$LWS,
  decodeURIComponent: WindowDecodeURIComponent$LWS,
  encodeURIComponent: WindowEncodeURIComponent$LWS,
  fetch: WindowFetch$LWS,
  location: rootWindowLocation$LWS,
  setInterval: WindowSetInterval$LWS,
  top: rootWindowTop$LWS
} = rootWindow$LWS$1;
const WindowQueueMicrotask$LWS = (() => {
  const {
    queueMicrotask: queueMicrotask$LWS
  } = rootWindow$LWS$1;
  // istanbul ignore else
  if (typeof queueMicrotask$LWS === 'function') {
    return queueMicrotask$LWS;
  }
  // Edge 15 does not support `queueMicrotask()`.
  // https://caniuse.com/mdn-api_queuemicrotask
  // https://developer.mozilla.org/en-US/docs/Web/API/queueMicrotask#when_queuemicrotask_isnt_available
  // istanbul ignore next: coverage is not measured in Edge 15, which means this whole fallback is considered "uncovered" when the tests are run in Chrome.
  // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow
  return function queueMicrotask$LWS(callback$LWS) {
    let promise$LWS = PromiseResolve$LWS();
    promise$LWS = ReflectApply$LWS$1(PromiseProtoThen$LWS, promise$LWS, [callback$LWS]);
    ReflectApply$LWS$1(PromiseProtoCatch$LWS, promise$LWS, [error => WindowSetTimeout$LWS(() => {
      throw error;
    }, 0)]);
  };
})();
const WindowDocumentGetter$LWS = ObjectLookupOwnGetter$LWS$1(rootWindow$LWS$1, 'document');
const WindowFrameElementGetter$LWS = ObjectLookupOwnGetter$LWS$1(rootWindow$LWS$1, 'frameElement');
const WindowLengthGetter$LWS = ObjectLookupOwnGetter$LWS$1(rootWindow$LWS$1, 'length');
const WindowLocationGetter$LWS = ObjectLookupOwnGetter$LWS$1(rootWindow$LWS$1, 'location');
function initWindowOpenChildWindow$LWS(win$LWS, url$LWS) {
  // Skip if `url` is an empty string or `undefined` as a blank page will be
  // opened into the targeted browsing context and not navigated away from.
  // https://developer.mozilla.org/en-US/docs/Web/API/Window/open#parameters
  if (typeof url$LWS === 'string' && url$LWS !== '') {
    // `WindowDocumentGetter` will throw if `win` is an opaque cross-origin
    // window.
    try {
      const doc$LWS = ReflectApply$LWS$1(WindowDocumentGetter$LWS, win$LWS, []);
      // `win.location` is a non-configurable property so can be accessed
      // directly.
      const {
        location: location$LWS
      } = win$LWS;
      // Check if the `location.href` is an intermediate value different
      // than `url`.
      // `location.href` is a non-configurable property so can be accessed
      // directly.
      // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false
      if (location$LWS.href !== url$LWS) {
        // Opening and closing `doc` prevents the default browser
        // redirect behavior.
        ReflectApply$LWS$1(DocumentProtoOpen$LWS$1, doc$LWS, []);
        ReflectApply$LWS$1(DocumentProtoClose$LWS$1, doc$LWS, []);
        // `location.replace` is a non-configurable property so can be
        // accessed directly.
        location$LWS.replace(url$LWS);
      }
      // eslint-disable-next-line no-empty
    } catch (_unused$LWS) {}
  }
  return win$LWS;
}
// This is only used by window.open() and document.open(x, y, z) distortions to
// block access to unsafe properties of the child window that's returned by those
// APIs. These properties must be otherwise available directly on the sandbox window,
// or via iframe.contentWindow created within the sandbox.
// To be effective, we mark the blocked thing with a symbol, so that can be detected by
// the distortion, otherwise the distortion will replace whatever we define here with
// whatever it provides.
const CHILD_WINDOW_BLOCKED_PROPERTY_SYMBOL$LWS = SymbolFor$LWS$1('@@lwsChildWindowBlockedProperty');
const CHILD_WINDOW_BLOCKED_PROPERTIES$LWS = ['eval', 'Function', 'setInterval', 'setTimeout'];
function markForUnsafePropertyBlocking$LWS(childWindow$LWS) {
  // If this function somehow receives the rootWindow, just return it.
  if (!childWindow$LWS || childWindow$LWS === rootWindow$LWS$1) {
    return childWindow$LWS;
  }
  for (const blocked$LWS of CHILD_WINDOW_BLOCKED_PROPERTIES$LWS) {
    const descriptor$LWS = ReflectGetOwnPropertyDescriptor$LWS(childWindow$LWS, blocked$LWS);
    const replacement$LWS = /* istanbul ignore next: this replacement function will never actually be called */() => {};
    ReflectDefineProperty$LWS$1(replacement$LWS, CHILD_WINDOW_BLOCKED_PROPERTY_SYMBOL$LWS, {
      __proto__: null,
      configurable: false,
      enumerable: false,
      get() {
        return true;
      }
    });
    // istanbul ignore else: currently unreachable via tests
    if (typeof childWindow$LWS[blocked$LWS] === 'function') {
      descriptor$LWS.value = replacement$LWS;
    }
    /* Eventually there will be other types of blocked properties
    else {
        descriptor.get = replacement;
    }
    */
    ReflectDefineProperty$LWS$1(childWindow$LWS, blocked$LWS, descriptor$LWS);
  }
  return childWindow$LWS;
}
function throwIfMarkedAsUnsafeInChildWindow$LWS(virtualEnvironmentEvaluator$LWS, name$LWS) {
  // This seemingly strange approach is necessary because this distortion will
  // otherwise replace whatever was force-assigned to the childWindow property
  // by markForUnsafePropertyBlocking with this distortion, effectively acting
  // as an UNDO of markForUnsafePropertyBlocking(). We have to dig into
  // the sandbox's global object and look at the actual property to see if it was
  // marked for unsafe property blocking, because indirect property (ie. eval) will bypass
  // any "this" property lookups.
  const getPossiblyBlockedPropertyFromSandbox$LWS = virtualEnvironmentEvaluator$LWS(`() => globalThis.${name$LWS}`);
  // istanbul ignore else: it is unnecessary to cover the else path here
  if (getPossiblyBlockedPropertyFromSandbox$LWS()[CHILD_WINDOW_BLOCKED_PROPERTY_SYMBOL$LWS]) {
    throw new LockerSecurityError$LWS(`Cannot call ${name$LWS} on this window.`);
  }
}
function isWindow$LWS(value$LWS) {
  if (typeof value$LWS === 'object' && value$LWS !== null && ObjectHasOwn$LWS$1(value$LWS, 'window') && value$LWS.window === value$LWS) {
    // Slower check that must certainly detect a window object.
    try {
      // window.self getter only works for a window object, otherwise it
      // throws, additionally, this works fine for a detached window as
      // well, which is important since it will guarantee that this check
      // works also for iframes that are disconnected, and could be connected
      // later on, that should not bypass this check. This check is is also
      // equivalent to window.frames, and here is the very simple spec for
      // this getter:
      // https://html.spec.whatwg.org/multipage/window-object.html#dom-self
      ReflectApply$LWS$1(WindowLocationGetter$LWS, value$LWS, []);
      return true;
      // eslint-disable-next-line no-empty
    } catch (_unused2$LWS) {}
  }
  return false;
}
function normalizeWindowOpenArguments$LWS(args$LWS) {
  const normalizedArgs$LWS = shallowCloneArray$LWS(args$LWS);
  const {
    length: length$LWS
  } = normalizedArgs$LWS;
  if (length$LWS) {
    const url$LWS = normalizedArgs$LWS[0];
    if (typeof url$LWS !== 'string') {
      normalizedArgs$LWS[0] = url$LWS ? `${url$LWS}` : undefined;
    }
  }
  if (length$LWS > 1) {
    const target$LWS = normalizedArgs$LWS[1];
    if (typeof target$LWS !== 'string') {
      normalizedArgs$LWS[1] = target$LWS ? `${target$LWS}` : undefined;
    }
  }
  if (length$LWS > 2) {
    let features$LWS = normalizedArgs$LWS[2];
    if (typeof features$LWS !== 'string') {
      features$LWS = features$LWS ? `${features$LWS}` : undefined;
    }
    if (features$LWS) {
      // Lowercase the features string because it is case insensitive.
      // https://html.spec.whatwg.org/multipage/window-object.html#normalizing-the-feature-name
      let loweredFeatures$LWS = ReflectApply$LWS$1(StringProtoToLowerCase$LWS, features$LWS, []);
      // RegExp.prototype[Symbol.replace] resets the lastIndex of global
      // regexp to 0.
      // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
      if (ReflectApply$LWS$1(RegExpProtoTest$LWS$1, noopenerRegExp$LWS, [loweredFeatures$LWS])) {
        // Replacing noopener with an enabled state that is supported
        // across all browsers. Firefox Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=1566619
        loweredFeatures$LWS = ReflectApply$LWS$1(StringProtoReplace$LWS, loweredFeatures$LWS, [
        // RegExp.prototype[Symbol.replace] resets the lastIndex of
        // global regexp to 0.
        // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
        noopenerRegExp$LWS, (_match$LWS, leading$LWS, _feature$LWS, ending$LWS) => `${leading$LWS}noopener${ending$LWS}`]);
      }
      features$LWS = loweredFeatures$LWS;
    }
    normalizedArgs$LWS[2] = features$LWS;
  }
  return normalizedArgs$LWS;
}
const HTMLElement$LWS = getUnmaskedFunction$LWS(rootWindow$LWS$1.HTMLElement);
const {
  prototype: HTMLElementProto$LWS
} = HTMLElement$LWS;
const HTMLElementProtoInnerTextGetter$LWS = ObjectLookupOwnGetter$LWS$1(HTMLElementProto$LWS, 'innerText');
// Used by '@locker/near-membrane-dom'.
ObjectLookupOwnGetter$LWS$1(HTMLElementProto$LWS, 'style');
const HTMLElementGlobalAttributesToPropertyName$LWS = {
  __proto__: null,
  accesskey: 'accessKey',
  contenteditable: 'contentEditable',
  enterkeyhint: 'enterKeyHint',
  inputmode: 'inputMode',
  tabindex: 'tabIndex'
};
const HTMLTemplateElementProtoContentGetter$LWS = ObjectLookupOwnGetter$LWS$1(HTMLTemplateElement.prototype, 'content');
const {
  prototype: NodeProto$LWS$1
} = Node;
const {
  appendChild: NodeProtoAppendChild$LWS$1,
  cloneNode: NodeProtoCloneNode$LWS,
  isEqualNode: NodeProtoIsEqualNode$LWS
} = NodeProto$LWS$1;
const NodeProtoChildNodesGetter$LWS = ObjectLookupOwnGetter$LWS$1(NodeProto$LWS$1, 'childNodes');
const NodeProtoFirstChildGetter$LWS = ObjectLookupOwnGetter$LWS$1(NodeProto$LWS$1, 'firstChild');
const NodeProtoIsConnectedGetter$LWS = ObjectLookupOwnGetter$LWS$1(NodeProto$LWS$1, 'isConnected');
// Used by '@locker/near-membrane-dom'.
ObjectLookupOwnGetter$LWS$1(NodeProto$LWS$1, 'lastChild');
const NodeProtoNodeNameGetter$LWS = ObjectLookupOwnGetter$LWS$1(NodeProto$LWS$1, 'nodeName');
const NodeProtoOwnerDocumentGetter$LWS = ObjectLookupOwnGetter$LWS$1(NodeProto$LWS$1, 'ownerDocument');
const NodeProtoParentNodeGetter$LWS = ObjectLookupOwnGetter$LWS$1(NodeProto$LWS$1, 'parentNode');
ReflectGetOwnPropertyDescriptor$LWS(NodeProto$LWS$1, 'textContent');
const rootDocumentDetachedFragment$LWS = ReflectApply$LWS$1(DocumentProtoCreateDocumentFragment$LWS, rootDocument$LWS, []);
const rootDocumentDetachedContainer$LWS = ReflectApply$LWS$1(DocumentProtoCreateElement$LWS$1, rootDocument$LWS, ['div']);
/* eslint-disable no-underscore-dangle */
class Validator$LWS {
  constructor(document$LWS, {
    HTMLLinkElement: HTMLLinkElement$LWS,
    HTMLScriptElement: HTMLScriptElement$LWS,
    HTMLStyleElement: HTMLStyleElement$LWS
  }) {
    this.isAllowedSharedElementChild = element$LWS => element$LWS instanceof this._constructors.HTMLLinkElement || element$LWS instanceof this._constructors.HTMLScriptElement || element$LWS instanceof this._constructors.HTMLStyleElement;
    this.isEqualDomString = (leftString$LWS, rightString$LWS) => {
      ReflectApply$LWS$1(ElementProtoInnerHTMLSetter$LWS, this._templates.left, [leftString$LWS]);
      ReflectApply$LWS$1(ElementProtoInnerHTMLSetter$LWS, this._templates.right, [rightString$LWS]);
      return deepIsEqualNode$LWS(this._templates.left, this._templates.right);
    };
    // There is no reason to ever allow any HTML or XML that contains all three of these substrings.
    // eslint-disable-next-line class-methods-use-this
    this.isInherentlyUnsecure = input$LWS => {
      const hasIframe$LWS = hasTag$LWS(input$LWS, 'iframe') && ReflectApply$LWS$1(StringProtoIncludes$LWS, input$LWS, ['srcdoc']);
      const hasScript$LWS = hasTag$LWS(input$LWS, 'script');
      // If neither an iframe or a script was detected, then this input is safe.
      // istanbul ignore else: returns immediately
      if (!hasIframe$LWS && !hasScript$LWS) {
        return false;
      }
      // If the string contains both the words iframe and srcdoc, it is unsafe
      // istanbul ignore else: returns immediately
      if (hasIframe$LWS) {
        return true;
      }
      // If the input contained the word "script", then we need to confirm that the string
      // that was seen is actually markup.
      //
      // IMPORTANT: We CANNOT reuse this.template.left/right for this check. Template elements
      // do not return innerText or textContent, which makes the following innerHTML/innerText
      // check useless.
      ReflectApply$LWS$1(DocumentFragmentProtoAppend$LWS, rootDocumentDetachedFragment$LWS, [rootDocumentDetachedContainer$LWS]);
      ReflectApply$LWS$1(ElementProtoInnerHTMLSetter$LWS, rootDocumentDetachedContainer$LWS, [input$LWS]);
      // This MUST BE CHECKED AFTER IT IS RENDERED. The nature of these attacks requires
      // the actual source to be set to the innerHTML to allow the browser to render
      const innerHTML$LWS = ReflectApply$LWS$1(ElementProtoInnerHTMLGetter$LWS, rootDocumentDetachedContainer$LWS, []);
      const innerText$LWS = ReflectApply$LWS$1(HTMLElementProtoInnerTextGetter$LWS, rootDocumentDetachedContainer$LWS, []);
      ReflectApply$LWS$1(ElementProtoRemove$LWS$1, rootDocumentDetachedContainer$LWS, []);
      // If innerHTML contains "script", but innerText does not, then the string
      // was hiding a script element through some kind of obfuscation, and is unsecure.
      return hasTag$LWS(innerHTML$LWS, 'script') && !hasTag$LWS(innerText$LWS, 'script');
    };
    this.isSharedElement = element$LWS => element$LWS === ReflectApply$LWS$1(DocumentProtoHeadGetter$LWS, this._document, []) || element$LWS === ReflectApply$LWS$1(DocumentProtoBodyGetter$LWS$1, this._document, []) || element$LWS === ReflectApply$LWS$1(DocumentProtoDocumentElementGetter$LWS, this._document, []);
    this._constructors = {
      HTMLLinkElement: HTMLLinkElement$LWS,
      HTMLScriptElement: HTMLScriptElement$LWS,
      HTMLStyleElement: HTMLStyleElement$LWS
    };
    this._document = document$LWS;
    this._templates = {
      left: ReflectApply$LWS$1(DocumentProtoCreateElement$LWS$1, this._document, ['template']),
      right: ReflectApply$LWS$1(DocumentProtoCreateElement$LWS$1, this._document, ['template'])
    };
  }
}
/* eslint-enable no-underscore-dangle */
function deepIsEqualNode$LWS(leftRoot$LWS, rightRoot$LWS) {
  const leftRootNode$LWS = leftRoot$LWS instanceof HTMLTemplateElement ? ReflectApply$LWS$1(HTMLTemplateElementProtoContentGetter$LWS, leftRoot$LWS, []) : leftRoot$LWS;
  const rightRootNode$LWS = rightRoot$LWS instanceof HTMLTemplateElement ? ReflectApply$LWS$1(HTMLTemplateElementProtoContentGetter$LWS, rightRoot$LWS, []) : rightRoot$LWS;
  if (ReflectApply$LWS$1(NodeProtoIsEqualNode$LWS, leftRootNode$LWS, [rightRootNode$LWS])) {
    const leftChildNodes$LWS = ReflectApply$LWS$1(NodeProtoChildNodesGetter$LWS, leftRootNode$LWS, []);
    const childCount$LWS = leftChildNodes$LWS.length;
    if (childCount$LWS > 0) {
      const rightChildNodes$LWS = ReflectApply$LWS$1(NodeProtoChildNodesGetter$LWS, rightRootNode$LWS, []);
      for (let i$LWS = 0; i$LWS < childCount$LWS; i$LWS += 1) {
        if (deepIsEqualNode$LWS(leftChildNodes$LWS[i$LWS], rightChildNodes$LWS[i$LWS]) === false) {
          return false;
        }
      }
    }
    return true;
  }
  return false;
}
function hasTag$LWS(input$LWS, tag$LWS) {
  return ReflectApply$LWS$1(StringProtoIncludes$LWS, input$LWS, [`<${tag$LWS} `]) || ReflectApply$LWS$1(StringProtoIncludes$LWS, input$LWS, [`:${tag$LWS} `]) || ReflectApply$LWS$1(StringProtoIncludes$LWS, input$LWS, [`<${tag$LWS}>`]) || ReflectApply$LWS$1(StringProtoIncludes$LWS, input$LWS, [`:${tag$LWS}>`]);
}
const rootValidator$LWS = new Validator$LWS(rootDocument$LWS, rootWindow$LWS$1);
const documentToValidatorMap$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1([[rootDocument$LWS, rootValidator$LWS]]));
function getValidator$LWS(document$LWS, globalObject$LWS) {
  // Fast path validator lookup for top level window.
  if (globalObject$LWS === undefined || globalObject$LWS === rootWindow$LWS$1) {
    return rootValidator$LWS;
  }
  // Use the `document` as the key because a window object maintains its identity
  // continuity when its location changes and while the non-configurable document
  // property does not.
  let validator$LWS = documentToValidatorMap$LWS.get(document$LWS);
  if (validator$LWS === undefined) {
    validator$LWS = new Validator$LWS(document$LWS, globalObject$LWS);
    documentToValidatorMap$LWS.set(document$LWS, validator$LWS);
  }
  return validator$LWS;
}
const BlobCtor$LWS = Blob;
const {
  prototype: BlobProto$LWS
} = BlobCtor$LWS;
const {
  slice: BlobProtoSlice$LWS
} = BlobProto$LWS;
const BlobProtoSizeGetter$LWS = ObjectLookupOwnGetter$LWS$1(BlobProto$LWS, 'size');
const BlobProtoTypeGetter$LWS = ObjectLookupOwnGetter$LWS$1(BlobProto$LWS, 'type');
const {
  // We don't cherry-pick the 'userAgent' property from `navigator` here
  // to avoid triggering its getter.
  navigator: navigator$LWS$1,
  navigator: {
    userAgentData: userAgentData$LWS$1
  }
} = rootWindow$LWS$1;
// The user-agent client hints API is experimental and subject to change.
// https://caniuse.com/mdn-api_navigator_useragentdata
// istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
const brands$LWS$1 = userAgentData$LWS$1 == null ? void 0 : userAgentData$LWS$1.brands;
// Note: Chromium identifies itself as Chrome in its user-agent string.
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent
const chromiumUserAgentRegExp$LWS$1 = / (?:Headless)?Chrome\/\d+/;
const webKitUserAgentRegExp$LWS = /WebKit/i;
let userAgent$LWS$1;
function getUserAgent$LWS$1() {
  if (userAgent$LWS$1 === undefined) {
    userAgent$LWS$1 = navigator$LWS$1.userAgent;
  }
  return userAgent$LWS$1;
}
const CUSTOM_ELEMENT_REGISTRY_ATTRIBUTE_NAME$LWS = LOCKER_SERVICE_KEY_LOWERED$LWS;
// Used by '@locker/near-membrane-dom'.
const IS_CHROMIUM_BROWSER$LWS$1 =
// While experimental, `navigator.userAgentData.brands` may be defined as an
// empty array in headless Chromium based browsers.
ArrayIsArray$LWS$1(brands$LWS$1) && brands$LWS$1.length ?
// Use user-agent client hints API if available to avoid deprecation
// warnings.
// https://developer.mozilla.org/en-US/docs/Web/API/User-Agent_Client_Hints_API
// istanbul ignore next: this code is not reachable in the coverage run.
ReflectApply$LWS$1(ArrayProtoFind$LWS$1, brands$LWS$1, [
// prettier-ignore
// istanbul ignore next: this code is not reachable in the coverage run.
item$LWS => (item$LWS == null ? void 0 : item$LWS.brand) === 'Chromium']) !== undefined :
// Fallback to a standard user-agent string sniff.
ReflectApply$LWS$1(RegExpProtoTest$LWS$1, chromiumUserAgentRegExp$LWS$1, [getUserAgent$LWS$1()]);
const IS_WEBKIT_BROWSER$LWS = !IS_CHROMIUM_BROWSER$LWS$1 && (
// istanbul ignore next: this code is not reachable in the coverage run.
ArrayIsArray$LWS$1(brands$LWS$1) && brands$LWS$1.length ? ReflectApply$LWS$1(ArrayProtoFind$LWS$1, brands$LWS$1, [
// istanbul ignore next
item$LWS => {
  const brand$LWS = item$LWS == null ? void 0 : item$LWS.brand;
  return typeof brand$LWS === 'string' && ReflectApply$LWS$1(RegExpProtoTest$LWS$1, webKitUserAgentRegExp$LWS, [brand$LWS]);
}]) !== undefined : ReflectApply$LWS$1(RegExpProtoTest$LWS$1, webKitUserAgentRegExp$LWS, [getUserAgent$LWS$1()]));

// Used by '@locker/near-membrane-shared-dom'.
// The DOMException constructor was exposed in Edge 12 but wasn't invocable
// until Edge 79. As long as this is used for instanceof checks it should be fine.
// https://developer.mozilla.org/en-US/docs/Web/API/DOMException#browser_compatibility
const DOMExceptionCtor$LWS$1 = DOMException;
ObjectLookupOwnGetter$LWS$1(DOMExceptionCtor$LWS$1.prototype, 'code');
const {
  createDocument: DOMImplementationProtoCreateDocument$LWS
} = DOMImplementation.prototype;
const DOMTokenListCtor$LWS = DOMTokenList;
const {
  prototype: DOMTokenListProto$LWS
} = DOMTokenListCtor$LWS;
const {
  add: DOMTokenListProtoAdd$LWS,
  contains: DOMTokenListProtoContains$LWS,
  remove: DOMTokenListProtoRemove$LWS
} = DOMTokenListProto$LWS;
const DOMTokenListProtoLengthGetter$LWS = ObjectLookupOwnGetter$LWS$1(DOMTokenListProto$LWS, 'length');
const DOMTokenListProtoValueGetter$LWS = ObjectLookupOwnGetter$LWS$1(DOMTokenListProto$LWS, 'value');
const EventCtor$LWS = Event;
const {
  prototype: EventProto$LWS
} = EventCtor$LWS;
const {
  stopPropagation: EventProtoStopPropagation$LWS
} = EventProto$LWS;
const EventProtoCurrentTargetGetter$LWS = ObjectLookupOwnGetter$LWS$1(EventProto$LWS, 'currentTarget');
const {
  addEventListener: EventTargetProtoAddEventListener$LWS,
  dispatchEvent: EventTargetProtoDispatchEvent$LWS,
  removeEventListener: EventTargetProtoRemoveEventListener$LWS
} = EventTarget.prototype;
const {
  prototype: HTMLAnchorElementProto$LWS
} = HTMLAnchorElement;
const HTMLAnchorElementProtoHostnameGetter$LWS = ObjectLookupOwnGetter$LWS$1(HTMLAnchorElementProto$LWS, 'hostname');
const {
  get: HTMLAnchorElementProtoHrefGetter$LWS,
  set: HTMLAnchorElementProtoHrefSetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(HTMLAnchorElementProto$LWS, 'href');
const HTMLAnchorElementProtoPathnameGetter$LWS = ObjectLookupOwnGetter$LWS$1(HTMLAnchorElementProto$LWS, 'pathname');
const HTMLAnchorElementProtoProtocolGetter$LWS = ObjectLookupOwnGetter$LWS$1(HTMLAnchorElementProto$LWS, 'protocol');
const {
  prototype: HTMLIFrameElementProto$LWS
} = HTMLIFrameElement;
// Used by '@locker/near-membrane-dom'.
ObjectLookupOwnGetter$LWS$1(HTMLIFrameElementProto$LWS, 'contentWindow');
const HTMLIFrameElementProtoSandboxGetter$LWS = ObjectLookupOwnGetter$LWS$1(HTMLIFrameElementProto$LWS, 'sandbox');
const HTMLIFrameElementProtoSandboxSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLIFrameElementProto$LWS, 'sandbox');
const HTMLIFrameElementProtoSrcGetter$LWS = ObjectLookupOwnGetter$LWS$1(HTMLIFrameElementProto$LWS, 'src');
const HTMLIFrameElementProtoSrcSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLIFrameElementProto$LWS, 'src');
const HTMLScriptElementCtor$LWS = HTMLScriptElement;
const {
  prototype: HTMLScriptElementProto$LWS
} = HTMLScriptElementCtor$LWS;
const {
  get: HTMLScriptElementProtoSrcGetter$LWS,
  set: HTMLScriptElementProtoSrcSetter$LWS
} = ReflectGetOwnPropertyDescriptor$LWS(HTMLScriptElementProto$LWS, 'src');
const NAMESPACE_DEFAULT$LWS = 'default';
const NAMESPACE_SVG$LWS = 'http://www.w3.org/2000/svg';
const NAMESPACE_XHTML$LWS = 'http://www.w3.org/1999/xhtml';
const NAMESPACE_XLINK$LWS = 'http://www.w3.org/1999/xlink';
const RequestProtoURLGetter$LWS = ObjectLookupOwnGetter$LWS$1(Request.prototype, 'url');
const ResponseCtor$LWS = Response;
const ResponseProto$LWS = ResponseCtor$LWS.prototype;
const ResponseProtoOkGetter$LWS = ObjectLookupOwnGetter$LWS$1(ResponseProto$LWS, 'ok');
ObjectLookupOwnGetter$LWS$1(ResponseProto$LWS, 'status');
ObjectLookupOwnGetter$LWS$1(ResponseProto$LWS, 'statusText');
const {
  text: ResponseProtoText$LWS
} = ResponseProto$LWS;
const URLCtor$LWS = URL;
const URLProtoOriginGetter$LWS = ObjectLookupOwnGetter$LWS$1(URLCtor$LWS.prototype, 'origin');
const {
  createObjectURL: URLCreateObjectURL$LWS,
  revokeObjectURL: URLRevokeObjectURL$LWS
} = URLCtor$LWS;
const SCRIPT_EVALUATOR_PROPERTY_NAME$LWS = '$evaluator$';
const SCRIPT_HOOK_SOURCE_TEXT$LWS = `document.currentScript.${SCRIPT_EVALUATOR_PROPERTY_NAME$LWS}`;
const evaluatedScriptElements$LWS = toSafeWeakSet$LWS$1(new WeakSetCtor$LWS$1());
const originalScriptPropertyCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
const resolvedURLRegistryCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
function defineScriptAccessorProperty$LWS(script$LWS, propKey$LWS, getter$LWS, setter$LWS) {
  ReflectDefineProperty$LWS$1(script$LWS, propKey$LWS, {
    __proto__: null,
    configurable: true,
    enumerable: true,
    get: getter$LWS,
    set: setter$LWS
  });
}
function defineScriptEvaluatorProperty$LWS(script$LWS, callback$LWS) {
  // istanbul ignore if: require a test to get the evaluator in a bad state. Like code that tried to access it in between. This is mostly a "the universe is not as expected error"
  if (!ReflectDefineProperty$LWS$1(script$LWS, SCRIPT_EVALUATOR_PROPERTY_NAME$LWS, {
    __proto__: null,
    configurable: true,
    // Create a bound function to obscure the getter source as "[native code]".
    get: ReflectApply$LWS$1(FunctionProtoBind$LWS, () => {
      // Track the script element evaluation to ensure the element
      // is evaluated only once.
      evaluatedScriptElements$LWS.add(script$LWS);
      deleteScriptEvaluatorProperty$LWS(script$LWS);
      const ownerDoc$LWS = ReflectApply$LWS$1(NodeProtoOwnerDocumentGetter$LWS, script$LWS, []);
      const defaultView$LWS = ReflectApply$LWS$1(DocumentProtoDefaultViewGetter$LWS, ownerDoc$LWS, []);
      // We don't need to use something like `WindowLocationGetter()`
      // because the 'location' and 'top' property are non-configurable.
      const context$LWS = {
        [UNCOMPILED_LOCATION_NAME$LWS]: defaultView$LWS.location,
        [UNCOMPILED_TOP_NAME$LWS]: defaultView$LWS.top
      };
      callback$LWS(context$LWS, defaultView$LWS, ownerDoc$LWS);
    }, [])
  })) {
    // istanbul ignore next: require a test to get the evaluator in a bad state. Like code that tried to access it in between. This is mostly a "the universe is not as expected error"
    throw new LockerSecurityError$LWS(`Cannot evaluate ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, script$LWS, [])}`);
  }
}
function deleteOriginalScriptProperty$LWS(script$LWS) {
  originalScriptPropertyCache$LWS.delete(script$LWS);
}
function deleteScriptEvaluatorProperty$LWS(script$LWS) {
  ReflectDeleteProperty$LWS$1(script$LWS, SCRIPT_EVALUATOR_PROPERTY_NAME$LWS);
}
function getOriginalScriptProperty$LWS(script$LWS) {
  return originalScriptPropertyCache$LWS.get(script$LWS);
}
function isScriptEvaluated$LWS(script$LWS) {
  return evaluatedScriptElements$LWS.has(script$LWS);
}
function isScriptPropertyEvaluatorHookDefined$LWS(script$LWS) {
  return originalScriptPropertyCache$LWS.has(script$LWS);
}
function isScriptURLEvaluatorHookDefined$LWS(script$LWS) {
  return resolvedURLRegistryCache$LWS.has(script$LWS);
}
function setOriginalScriptScriptProperty$LWS(script$LWS, scriptProperty$LWS) {
  return originalScriptPropertyCache$LWS.set(script$LWS, scriptProperty$LWS);
}
const documentPattern$LWS = 'document';
const windowPattern$LWS = 'document\\.defaultView|frames|globalThis|self|window';
const webpackGlobalPattern$LWS = `${windowPattern$LWS}|global`;
const webpackGlobalDocumentPattern$LWS = `${documentPattern$LWS}|global.document`;
// While fully qualified member expression access can be unambiguously detected,
// ie. window.location or window.top, bare-word references to location and top
// cannot. This means that code containing the fully qualified member expressions
// can have all occurrences replaced by transforms and given special names controlled
// by LWS in Aura. This process will also result in the program knowing that it
// applied a given transform, which it can then use to populate a context names
// list to be used in the declaration assignment code injected into wrapped Aura
// component code. Because the unqualified member expressions cannot be unambiguously
// detected, there is no way for the program to know that, eg. location.search was
// used in the Aura component code and subsequently transformed, which means it
// cannot be relied upon to when populating a context names list to be used in
// the declaration assignment code. As a result, location and top must be universally
// and explicitly included in the context object, and universally and explicitly
// included in the context names list.
const UNIVERSAL_CONTEXT_NAMES$LWS = [UNCOMPILED_LOCATION_NAME$LWS, UNCOMPILED_TOP_NAME$LWS, 'location', 'top'];
const locationReferencesRegExp$LWS = createPropertyReferenceRegExp$LWS(`${documentPattern$LWS}|${windowPattern$LWS}`, 'location');
const locationReferencesWithWebpackRegExp$LWS = createPropertyReferenceRegExp$LWS(`${webpackGlobalDocumentPattern$LWS}|${webpackGlobalPattern$LWS}`, 'location');
const sandboxEvalContextNameRegExp$LWS = new RegExpCtor$LWS$1(`(?:^|\\W)${toRegExpEscapedString$LWS(SANDBOX_EVAL_CONTEXT_NAME$LWS)}(?:\\W|$)`);
const webpackRequireNameRegExp$LWS = new RegExpCtor$LWS$1(toRegExpEscapedIdentifierName$LWS(WEBPACK_REQUIRE_NAME$LWS));
const windowTopReferencesRegExp$LWS = createPropertyReferenceRegExp$LWS(windowPattern$LWS, 'top');
const windowTopReferencesWithWebpackRegExp$LWS = createPropertyReferenceRegExp$LWS(webpackGlobalPattern$LWS, 'top');
function createPropertyReferenceRegExp$LWS(objectPattern$LWS, key$LWS) {
  // An assignment operator is defined by
  // https://tc39.es/ecma262/#prod-AssignmentOperator
  // as one of the following:
  //     *= /= %= += -= <<= >>= >>>= &= ^= |= **=
  return new RegExpCtor$LWS$1(`\\b(?:${objectPattern$LWS})\\.${key$LWS}\\b(\\s*(?:[?*/%&^|+-]|>>>?|<<)*=(?=[^=]))?`, 'g');
}
function compileSourceText$LWS(sourceText$LWS) {
  // To avoid conflicts with anyone else using `SANDBOX_EVAL_CONTEXT_NAME`,
  // we sniff the source text to see if it is present, and in that case we
  // don't proceed with the string replacement.
  if (ReflectApply$LWS$1(RegExpProtoTest$LWS$1, sandboxEvalContextNameRegExp$LWS, [sourceText$LWS])) {
    return sourceText$LWS;
  }
  let locationRegExp$LWS;
  let topRegExp$LWS;
  if (ReflectApply$LWS$1(RegExpProtoTest$LWS$1, webpackRequireNameRegExp$LWS, [sourceText$LWS])) {
    locationRegExp$LWS = locationReferencesWithWebpackRegExp$LWS;
    topRegExp$LWS = windowTopReferencesWithWebpackRegExp$LWS;
  } else {
    locationRegExp$LWS = locationReferencesRegExp$LWS;
    topRegExp$LWS = windowTopReferencesRegExp$LWS;
  }
  // Input `sourceText` is non-compiled, so `window.location` returns `null`
  // inside the detached iframe sandbox. Our compiler solves this problem by
  // transforming the red `location` reference into a blue `location` reference.
  // The solution below emulates what our compiler does, but using a simple
  // string replacement.
  sourceText$LWS = ReflectApply$LWS$1(StringProtoReplace$LWS, sourceText$LWS, [locationRegExp$LWS, (_match$LWS, assignmentOperator$LWS) => assignmentOperator$LWS ? `${UNCOMPILED_LOCATION_NAME$LWS}.href${assignmentOperator$LWS}` : UNCOMPILED_LOCATION_NAME$LWS]);
  // In non-compiled source text `window.top` is null when evaluated in a
  // sandbox. We perform a naive transformation to replace references of
  // `window.top` to use our internal sandbox helpers.
  sourceText$LWS = ReflectApply$LWS$1(StringProtoReplace$LWS, sourceText$LWS, [topRegExp$LWS, () => UNCOMPILED_TOP_NAME$LWS]);
  return sourceText$LWS;
}
function generateContextAssignmentCodeFromContextNames$LWS(names$LWS) {
  return `const {${ReflectApply$LWS$1(ArrayProtoToString$LWS$1, names$LWS, [])}}=${SANDBOX_EVAL_CONTEXT_NAME$LWS}`;
}
function transformSourceText$LWS(sourceText$LWS) {
  if (ReflectApply$LWS$1(RegExpProtoTest$LWS$1, sandboxEvalContextNameRegExp$LWS, [sourceText$LWS])) {
    return sourceText$LWS;
  }
  const code$LWS = compileSourceText$LWS(sourceText$LWS);
  const prefix$LWS = `${generateContextAssignmentCodeFromContextNames$LWS(UNIVERSAL_CONTEXT_NAMES$LWS)};`;
  const pragmaIndex$LWS = indexOfPragma$LWS(code$LWS, 'use strict');
  if (pragmaIndex$LWS === -1) {
    return prefix$LWS + code$LWS;
  }
  // The "use strict" pragma, including quotes, is 12 characters long.
  let afterPragmaIndex$LWS = pragmaIndex$LWS + 12;
  // istanbul ignore else
  if (afterPragmaIndex$LWS < code$LWS.length && code$LWS[afterPragmaIndex$LWS] === ';') {
    // Move index after the semicolon.
    afterPragmaIndex$LWS += 1;
  }
  return ReflectApply$LWS$1(StringProtoSlice$LWS$1, code$LWS, [0, afterPragmaIndex$LWS]) + prefix$LWS + ReflectApply$LWS$1(StringProtoSlice$LWS$1, code$LWS, [afterPragmaIndex$LWS]);
}
const {
  key: StorageProtoKey$LWS,
  getItem: StorageProtoGetItem$LWS,
  removeItem: StorageProtoRemoveItem$LWS,
  setItem: StorageProtoSetItem$LWS
} = Storage.prototype;
ReflectGetOwnPropertyDescriptor$LWS(SVGScriptElement.prototype, 'href');

// This has to be done 1-by-1 because putting a full file ignore in this file
// will result in dist/index.mjs.js containing the directive and subsequently being
// ignored.
// istanbul ignore next
const XhrCtor$LWS = XMLHttpRequest;
const {
  prototype: XhrProto$LWS
} = XhrCtor$LWS;
const {
  abort: XhrProtoAbort$LWS,
  open: XhrProtoOpen$LWS,
  send: XhrProtoSend$LWS
} = XhrProto$LWS;
const XhrProtoResponseTextGetter$LWS = ObjectLookupOwnGetter$LWS$1(XhrProto$LWS, 'responseText');
const XhrProtoStatusGetter$LWS = ObjectLookupOwnGetter$LWS$1(XhrProto$LWS, 'status');
ObjectLookupOwnSetter$LWS(XhrProto$LWS, 'withCredentials');
/*! version: 0.23.6 */

/*!
 * Copyright (C) 2019 salesforce.com, inc.
 */
const ALLOWED_MIME_TYPES$LWS = ['application/octet-stream', 'application/json', 'application/pdf', 'video/', 'audio/', 'image/', 'font/', 'text/plain', 'text/markdown', 'application/zip', 'application/x-bzip', 'application/x-rar-compressed', 'application/x-tar'];
const validMimeTypeRegExp$LWS = /^[a-z]+\/[a-z0-9.+-]+$/;
function isMIMETypeAllowed$LWS(mimeType$LWS) {
  // W-4896359 Avoid MIME types which try to escape using special characters:
  // Allow only alphanumeric, '-', '+', and '.' characters.
  if (ReflectApply$LWS$1(RegExpProtoTest$LWS$1, validMimeTypeRegExp$LWS, [mimeType$LWS])) {
    for (let i$LWS = 0, {
        length: length$LWS
      } = ALLOWED_MIME_TYPES$LWS; i$LWS < length$LWS; i$LWS += 1) {
      if (ReflectApply$LWS$1(StringProtoStartsWith$LWS, mimeType$LWS, [ALLOWED_MIME_TYPES$LWS[i$LWS]])) {
        return true;
      }
    }
  }
  return false;
}
const TRUSTED_DOMAINS_REG_EXP$LWS = /\.(force|salesforce|visualforce|documentforce|my\.site|salesforce-sites)\.com$/;
const URL_SCHEMES_LIST$LWS = toSafeArray$LWS$1(['about:', 'http:', 'https:']);
const newlinesAndTabsRegExp$LWS = /[\u2028\u2029\n\r\t]/g;
const normalizerAnchor$LWS = ReflectApply$LWS$1(DocumentProtoCreateElement$LWS$1, rootDocument$LWS, ['a']);
// @TODO: W-7302311 Make paths and domains configurable.
function isValidURL$LWS(parsedURL$LWS) {
  // Need to add /services to isValidUrl unit test and locker/scripts/test/disallowed-endpoints.js once we remove the gate.
  const DISALLOWED_ENDPOINTS_LIST$LWS = isGaterEnabledFeature$LWS('enableBlockServicesEndpoint') ? ['/aura', '/webruntime', '/services'] : ['/aura', '/webruntime'];
  const loweredPathname$LWS = ReflectApply$LWS$1(StringProtoToLowerCase$LWS, parsedURL$LWS.pathname, []);
  for (let i$LWS = 0, {
      length: length$LWS
    } = DISALLOWED_ENDPOINTS_LIST$LWS; i$LWS < length$LWS; i$LWS += 1) {
    if (ReflectApply$LWS$1(StringProtoEndsWith$LWS, loweredPathname$LWS, [DISALLOWED_ENDPOINTS_LIST$LWS[i$LWS]]) || ReflectApply$LWS$1(StringProtoIncludes$LWS, loweredPathname$LWS, [`${DISALLOWED_ENDPOINTS_LIST$LWS[i$LWS]}/`])) {
      return false;
    }
  }
  return true;
}
function isValidURLScheme$LWS(url$LWS) {
  ReflectApply$LWS$1(HTMLAnchorElementProtoHrefSetter$LWS, normalizerAnchor$LWS, [url$LWS]);
  return URL_SCHEMES_LIST$LWS.includes(ReflectApply$LWS$1(HTMLAnchorElementProtoProtocolGetter$LWS, normalizerAnchor$LWS, []));
}
function parseURL$LWS(url$LWS) {
  const normalizedURL$LWS = sanitizeURLForElement$LWS(url$LWS);
  return {
    normalizedURL: normalizedURL$LWS,
    pathname: WindowDecodeURIComponent$LWS(ReflectApply$LWS$1(HTMLAnchorElementProtoPathnameGetter$LWS, normalizerAnchor$LWS, []))
  };
}
function resolveURL$LWS(url$LWS) {
  ReflectApply$LWS$1(HTMLAnchorElementProtoHrefSetter$LWS, normalizerAnchor$LWS, [url$LWS]);
  return ReflectApply$LWS$1(HTMLAnchorElementProtoHrefGetter$LWS, normalizerAnchor$LWS, []);
}
function sanitizeURLForElement$LWS(url$LWS) {
  return resolveURL$LWS(sanitizeURLString$LWS(url$LWS));
}
function sanitizeURLString$LWS(urlString$LWS) {
  return urlString$LWS === '' ? urlString$LWS : ReflectApply$LWS$1(StringProtoReplace$LWS, urlString$LWS, [newlinesAndTabsRegExp$LWS, '']);
}
/*! version: 0.23.6 */

/*! @license DOMPurify 3.1.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.1.6/LICENSE */

const {
  entries,
  setPrototypeOf,
  isFrozen,
  getPrototypeOf,
  getOwnPropertyDescriptor
} = Object;
let {
  freeze,
  seal,
  create
} = Object; // eslint-disable-line import/no-mutable-exports
let {
  apply,
  construct
} = typeof Reflect !== 'undefined' && Reflect;
if (!freeze) {
  freeze = function freeze(x) {
    return x;
  };
}
if (!seal) {
  seal = function seal(x) {
    return x;
  };
}
if (!apply) {
  apply = function apply(fun, thisValue, args) {
    return fun.apply(thisValue, args);
  };
}
if (!construct) {
  construct = function construct(Func, args) {
    return new Func(...args);
  };
}
const arrayForEach = unapply(Array.prototype.forEach);
const arrayPop = unapply(Array.prototype.pop);
const arrayPush = unapply(Array.prototype.push);
const stringToLowerCase = unapply(String.prototype.toLowerCase);
const stringToString = unapply(String.prototype.toString);
const stringMatch = unapply(String.prototype.match);
const stringReplace = unapply(String.prototype.replace);
const stringIndexOf = unapply(String.prototype.indexOf);
const stringTrim = unapply(String.prototype.trim);
const objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);
const regExpTest = unapply(RegExp.prototype.test);
const typeErrorCreate = unconstruct(TypeError);

/**
 * Creates a new function that calls the given function with a specified thisArg and arguments.
 *
 * @param {Function} func - The function to be wrapped and called.
 * @returns {Function} A new function that calls the given function with a specified thisArg and arguments.
 */
function unapply(func) {
  return function (thisArg) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return apply(func, thisArg, args);
  };
}

/**
 * Creates a new function that constructs an instance of the given constructor function with the provided arguments.
 *
 * @param {Function} func - The constructor function to be wrapped and called.
 * @returns {Function} A new function that constructs an instance of the given constructor function with the provided arguments.
 */
function unconstruct(func) {
  return function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return construct(func, args);
  };
}

/**
 * Add properties to a lookup table
 *
 * @param {Object} set - The set to which elements will be added.
 * @param {Array} array - The array containing elements to be added to the set.
 * @param {Function} transformCaseFunc - An optional function to transform the case of each element before adding to the set.
 * @returns {Object} The modified set with added elements.
 */
function addToSet(set, array) {
  let transformCaseFunc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : stringToLowerCase;
  if (setPrototypeOf) {
    // Make 'in' and truthy checks like Boolean(set.constructor)
    // independent of any properties defined on Object.prototype.
    // Prevent prototype setters from intercepting set as a this value.
    setPrototypeOf(set, null);
  }
  let l = array.length;
  while (l--) {
    let element = array[l];
    if (typeof element === 'string') {
      const lcElement = transformCaseFunc(element);
      if (lcElement !== element) {
        // Config presets (e.g. tags.js, attrs.js) are immutable.
        if (!isFrozen(array)) {
          array[l] = lcElement;
        }
        element = lcElement;
      }
    }
    set[element] = true;
  }
  return set;
}

/**
 * Clean up an array to harden against CSPP
 *
 * @param {Array} array - The array to be cleaned.
 * @returns {Array} The cleaned version of the array
 */
function cleanArray(array) {
  for (let index = 0; index < array.length; index++) {
    const isPropertyExist = objectHasOwnProperty(array, index);
    if (!isPropertyExist) {
      array[index] = null;
    }
  }
  return array;
}

/**
 * Shallow clone an object
 *
 * @param {Object} object - The object to be cloned.
 * @returns {Object} A new object that copies the original.
 */
function clone(object) {
  const newObject = create(null);
  for (const [property, value] of entries(object)) {
    const isPropertyExist = objectHasOwnProperty(object, property);
    if (isPropertyExist) {
      if (Array.isArray(value)) {
        newObject[property] = cleanArray(value);
      } else if (value && typeof value === 'object' && value.constructor === Object) {
        newObject[property] = clone(value);
      } else {
        newObject[property] = value;
      }
    }
  }
  return newObject;
}

/**
 * This method automatically checks if the prop is function or getter and behaves accordingly.
 *
 * @param {Object} object - The object to look up the getter function in its prototype chain.
 * @param {String} prop - The property name for which to find the getter function.
 * @returns {Function} The getter function found in the prototype chain or a fallback function.
 */
function lookupGetter(object, prop) {
  while (object !== null) {
    const desc = getOwnPropertyDescriptor(object, prop);
    if (desc) {
      if (desc.get) {
        return unapply(desc.get);
      }
      if (typeof desc.value === 'function') {
        return unapply(desc.value);
      }
    }
    object = getPrototypeOf(object);
  }
  function fallbackValue() {
    return null;
  }
  return fallbackValue;
}

const html$1 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);

// SVG
const svg$1 = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);
const svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feDropShadow', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);

// List of SVG elements that are disallowed by default.
// We still need to know them so that we can do namespace
// checks properly in case one wants to add them to
// allow-list.
const svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);
const mathMl$1 = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover', 'mprescripts']);

// Similarly to SVG, we want to know all MathML elements,
// even those that we disallow by default.
const mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);
const text = freeze(['#text']);

const html = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'popover', 'popovertarget', 'popovertargetaction', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'wrap', 'xmlns', 'slot']);
const svg = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);
const mathMl = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);
const xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);

// eslint-disable-next-line unicorn/better-regex
const MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode
const ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
const TMPLIT_EXPR = seal(/\${[\w\W]*}/gm);
const DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/); // eslint-disable-line no-useless-escape
const ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape
const IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
);
const IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
const ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
);
const DOCTYPE_NAME = seal(/^html$/i);
const CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);

var EXPRESSIONS = /*#__PURE__*/Object.freeze({
  __proto__: null,
  MUSTACHE_EXPR: MUSTACHE_EXPR,
  ERB_EXPR: ERB_EXPR,
  TMPLIT_EXPR: TMPLIT_EXPR,
  DATA_ATTR: DATA_ATTR,
  ARIA_ATTR: ARIA_ATTR,
  IS_ALLOWED_URI: IS_ALLOWED_URI,
  IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,
  ATTR_WHITESPACE: ATTR_WHITESPACE,
  DOCTYPE_NAME: DOCTYPE_NAME,
  CUSTOM_ELEMENT: CUSTOM_ELEMENT
});

// https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType
const NODE_TYPE = {
  element: 1,
  attribute: 2,
  text: 3,
  cdataSection: 4,
  entityReference: 5,
  // Deprecated
  entityNode: 6,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9,
  documentType: 10,
  documentFragment: 11,
  notation: 12 // Deprecated
};
const getGlobal = function getGlobal() {
  return typeof window === 'undefined' ? null : window;
};

/**
 * Creates a no-op policy for internal use only.
 * Don't export this function outside this module!
 * @param {TrustedTypePolicyFactory} trustedTypes The policy factory.
 * @param {HTMLScriptElement} purifyHostElement The Script element used to load DOMPurify (to determine policy name suffix).
 * @return {TrustedTypePolicy} The policy created (or null, if Trusted Types
 * are not supported or creating the policy failed).
 */
const _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, purifyHostElement) {
  if (typeof trustedTypes !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
    return null;
  }

  // Allow the callers to control the unique policy name
  // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
  // Policy creation with duplicate names throws in Trusted Types.
  let suffix = null;
  const ATTR_NAME = 'data-tt-policy-suffix';
  if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
    suffix = purifyHostElement.getAttribute(ATTR_NAME);
  }
  const policyName = 'dompurify' + (suffix ? '#' + suffix : '');
  try {
    return trustedTypes.createPolicy(policyName, {
      createHTML(html) {
        return html;
      },
      createScriptURL(scriptUrl) {
        return scriptUrl;
      }
    });
  } catch (_) {
    // Policy creation failed (most likely another DOMPurify script has
    // already run). Skip creating the policy, as this will only cause errors
    // if TT are enforced.
    console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
    return null;
  }
};
function createDOMPurify() {
  let window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();
  const DOMPurify = root => createDOMPurify(root);

  /**
   * Version label, exposed for easier checks
   * if DOMPurify is up to date or not
   */
  DOMPurify.version = '3.1.6';

  /**
   * Array of elements that DOMPurify removed during sanitation.
   * Empty if nothing was removed.
   */
  DOMPurify.removed = [];
  if (!window || !window.document || window.document.nodeType !== NODE_TYPE.document) {
    // Not running in a browser, provide a factory function
    // so that you can pass your own Window
    DOMPurify.isSupported = false;
    return DOMPurify;
  }
  let {
    document
  } = window;
  const originalDocument = document;
  const currentScript = originalDocument.currentScript;
  const {
    DocumentFragment,
    HTMLTemplateElement,
    Node,
    Element,
    NodeFilter,
    NamedNodeMap = window.NamedNodeMap || window.MozNamedAttrMap,
    HTMLFormElement,
    DOMParser,
    trustedTypes
  } = window;
  const ElementPrototype = Element.prototype;
  const cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
  const remove = lookupGetter(ElementPrototype, 'remove');
  const getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
  const getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
  const getParentNode = lookupGetter(ElementPrototype, 'parentNode');

  // As per issue #47, the web-components registry is inherited by a
  // new document created via createHTMLDocument. As per the spec
  // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
  // a new empty registry is used when creating a template contents owner
  // document, so we use that as our parent document to ensure nothing
  // is inherited.
  if (typeof HTMLTemplateElement === 'function') {
    const template = document.createElement('template');
    if (template.content && template.content.ownerDocument) {
      document = template.content.ownerDocument;
    }
  }
  let trustedTypesPolicy;
  let emptyHTML = '';
  const {
    implementation,
    createNodeIterator,
    createDocumentFragment,
    getElementsByTagName
  } = document;
  const {
    importNode
  } = originalDocument;
  let hooks = {};

  /**
   * Expose whether this browser supports running the full DOMPurify.
   */
  DOMPurify.isSupported = typeof entries === 'function' && typeof getParentNode === 'function' && implementation && implementation.createHTMLDocument !== undefined;
  const {
    MUSTACHE_EXPR,
    ERB_EXPR,
    TMPLIT_EXPR,
    DATA_ATTR,
    ARIA_ATTR,
    IS_SCRIPT_OR_DATA,
    ATTR_WHITESPACE,
    CUSTOM_ELEMENT
  } = EXPRESSIONS;
  let {
    IS_ALLOWED_URI: IS_ALLOWED_URI$1
  } = EXPRESSIONS;

  /**
   * We consider the elements and attributes below to be safe. Ideally
   * don't add any new ones but feel free to remove unwanted ones.
   */

  /* allowed element names */
  let ALLOWED_TAGS = null;
  const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);

  /* Allowed attribute names */
  let ALLOWED_ATTR = null;
  const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);

  /*
   * Configure how DOMPUrify should handle custom elements and their attributes as well as customized built-in elements.
   * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)
   * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)
   * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.
   */
  let CUSTOM_ELEMENT_HANDLING = Object.seal(create(null, {
    tagNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: false
    }
  }));

  /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */
  let FORBID_TAGS = null;

  /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */
  let FORBID_ATTR = null;

  /* Decide if ARIA attributes are okay */
  let ALLOW_ARIA_ATTR = true;

  /* Decide if custom data attributes are okay */
  let ALLOW_DATA_ATTR = true;

  /* Decide if unknown protocols are okay */
  let ALLOW_UNKNOWN_PROTOCOLS = false;

  /* Decide if self-closing tags in attributes are allowed.
   * Usually removed due to a mXSS issue in jQuery 3.0 */
  let ALLOW_SELF_CLOSE_IN_ATTR = true;

  /* Output should be safe for common template engines.
   * This means, DOMPurify removes data attributes, mustaches and ERB
   */
  let SAFE_FOR_TEMPLATES = false;

  /* Output should be safe even for XML used within HTML and alike.
   * This means, DOMPurify removes comments when containing risky content.
   */
  let SAFE_FOR_XML = true;

  /* Decide if document with <html>... should be returned */
  let WHOLE_DOCUMENT = false;

  /* Track whether config is already set on this instance of DOMPurify. */
  let SET_CONFIG = false;

  /* Decide if all elements (e.g. style, script) must be children of
   * document.body. By default, browsers might move them to document.head */
  let FORCE_BODY = false;

  /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
   * string (or a TrustedHTML object if Trusted Types are supported).
   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
   */
  let RETURN_DOM = false;

  /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
   * string  (or a TrustedHTML object if Trusted Types are supported) */
  let RETURN_DOM_FRAGMENT = false;

  /* Try to return a Trusted Type object instead of a string, return a string in
   * case Trusted Types are not supported  */
  let RETURN_TRUSTED_TYPE = false;

  /* Output should be free from DOM clobbering attacks?
   * This sanitizes markups named with colliding, clobberable built-in DOM APIs.
   */
  let SANITIZE_DOM = true;

  /* Achieve full DOM Clobbering protection by isolating the namespace of named
   * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.
   *
   * HTML/DOM spec rules that enable DOM Clobbering:
   *   - Named Access on Window (§7.3.3)
   *   - DOM Tree Accessors (§3.1.5)
   *   - Form Element Parent-Child Relations (§4.10.3)
   *   - Iframe srcdoc / Nested WindowProxies (§4.8.5)
   *   - HTMLCollection (§4.2.10.2)
   *
   * Namespace isolation is implemented by prefixing `id` and `name` attributes
   * with a constant string, i.e., `user-content-`
   */
  let SANITIZE_NAMED_PROPS = false;
  const SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';

  /* Keep element content when removing element? */
  let KEEP_CONTENT = true;

  /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
   * of importing it into a new Document and returning a sanitized copy */
  let IN_PLACE = false;

  /* Allow usage of profiles like html, svg and mathMl */
  let USE_PROFILES = {};

  /* Tags to ignore content of when KEEP_CONTENT is true */
  let FORBID_CONTENTS = null;
  const DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);

  /* Tags that are safe for data: URIs */
  let DATA_URI_TAGS = null;
  const DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);

  /* Attributes safe for values like "javascript:" */
  let URI_SAFE_ATTRIBUTES = null;
  const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);
  const MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
  const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
  const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
  /* Document namespace */
  let NAMESPACE = HTML_NAMESPACE;
  let IS_EMPTY_INPUT = false;

  /* Allowed XHTML+XML namespaces */
  let ALLOWED_NAMESPACES = null;
  const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);

  /* Parsing of strict XHTML documents */
  let PARSER_MEDIA_TYPE = null;
  const SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];
  const DEFAULT_PARSER_MEDIA_TYPE = 'text/html';
  let transformCaseFunc = null;

  /* Keep a reference to config to pass to hooks */
  let CONFIG = null;

  /* Ideally, do not touch anything below this line */
  /* ______________________________________________ */

  const formElement = document.createElement('form');
  const isRegexOrFunction = function isRegexOrFunction(testValue) {
    return testValue instanceof RegExp || testValue instanceof Function;
  };

  /**
   * _parseConfig
   *
   * @param  {Object} cfg optional config literal
   */
  // eslint-disable-next-line complexity
  const _parseConfig = function _parseConfig() {
    let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (CONFIG && CONFIG === cfg) {
      return;
    }

    /* Shield configuration object from tampering */
    if (!cfg || typeof cfg !== 'object') {
      cfg = {};
    }

    /* Shield configuration object from prototype pollution */
    cfg = clone(cfg);
    PARSER_MEDIA_TYPE =
    // eslint-disable-next-line unicorn/prefer-includes
    SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;

    // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.
    transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? stringToString : stringToLowerCase;

    /* Set configuration parameters */
    ALLOWED_TAGS = objectHasOwnProperty(cfg, 'ALLOWED_TAGS') ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = objectHasOwnProperty(cfg, 'ALLOWED_ATTR') ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
    ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, 'ALLOWED_NAMESPACES') ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
    URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, 'ADD_URI_SAFE_ATTR') ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES),
    // eslint-disable-line indent
    cfg.ADD_URI_SAFE_ATTR,
    // eslint-disable-line indent
    transformCaseFunc // eslint-disable-line indent
    ) // eslint-disable-line indent
    : DEFAULT_URI_SAFE_ATTRIBUTES;
    DATA_URI_TAGS = objectHasOwnProperty(cfg, 'ADD_DATA_URI_TAGS') ? addToSet(clone(DEFAULT_DATA_URI_TAGS),
    // eslint-disable-line indent
    cfg.ADD_DATA_URI_TAGS,
    // eslint-disable-line indent
    transformCaseFunc // eslint-disable-line indent
    ) // eslint-disable-line indent
    : DEFAULT_DATA_URI_TAGS;
    FORBID_CONTENTS = objectHasOwnProperty(cfg, 'FORBID_CONTENTS') ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
    FORBID_TAGS = objectHasOwnProperty(cfg, 'FORBID_TAGS') ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
    FORBID_ATTR = objectHasOwnProperty(cfg, 'FORBID_ATTR') ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
    USE_PROFILES = objectHasOwnProperty(cfg, 'USE_PROFILES') ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true
    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true
    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false
    ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true
    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false
    SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false; // Default true
    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false
    RETURN_DOM = cfg.RETURN_DOM || false; // Default false
    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false
    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false
    FORCE_BODY = cfg.FORCE_BODY || false; // Default false
    SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true
    SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false
    KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true
    IN_PLACE = cfg.IN_PLACE || false; // Default false
    IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
    CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {
      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
    }
    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }
    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }

    /* Parse profile info */
    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet({}, text);
      ALLOWED_ATTR = [];
      if (USE_PROFILES.html === true) {
        addToSet(ALLOWED_TAGS, html$1);
        addToSet(ALLOWED_ATTR, html);
      }
      if (USE_PROFILES.svg === true) {
        addToSet(ALLOWED_TAGS, svg$1);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.svgFilters === true) {
        addToSet(ALLOWED_TAGS, svgFilters);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.mathMl === true) {
        addToSet(ALLOWED_TAGS, mathMl$1);
        addToSet(ALLOWED_ATTR, mathMl);
        addToSet(ALLOWED_ATTR, xml);
      }
    }

    /* Merge configuration parameters */
    if (cfg.ADD_TAGS) {
      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
        ALLOWED_TAGS = clone(ALLOWED_TAGS);
      }
      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
    }
    if (cfg.ADD_ATTR) {
      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
        ALLOWED_ATTR = clone(ALLOWED_ATTR);
      }
      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
    }
    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
    }
    if (cfg.FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone(FORBID_CONTENTS);
      }
      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
    }

    /* Add #text in case KEEP_CONTENT is set to true */
    if (KEEP_CONTENT) {
      ALLOWED_TAGS['#text'] = true;
    }

    /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */
    if (WHOLE_DOCUMENT) {
      addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
    }

    /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */
    if (ALLOWED_TAGS.table) {
      addToSet(ALLOWED_TAGS, ['tbody']);
      delete FORBID_TAGS.tbody;
    }
    if (cfg.TRUSTED_TYPES_POLICY) {
      if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== 'function') {
        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
      }
      if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== 'function') {
        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
      }

      // Overwrite existing TrustedTypes policy.
      trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;

      // Sign local variables required by `sanitize`.
      emptyHTML = trustedTypesPolicy.createHTML('');
    } else {
      // Uninitialized policy, attempt to initialize the internal dompurify policy.
      if (trustedTypesPolicy === undefined) {
        trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
      }

      // If creating the internal policy succeeded sign internal variables.
      if (trustedTypesPolicy !== null && typeof emptyHTML === 'string') {
        emptyHTML = trustedTypesPolicy.createHTML('');
      }
    }

    // Prevent further manipulation of configuration.
    // Not available in IE8, Safari 5, etc.
    if (freeze) {
      freeze(cfg);
    }
    CONFIG = cfg;
  };
  const MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);
  const HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'annotation-xml']);

  // Certain elements are allowed in both SVG and HTML
  // namespace. We need to specify them explicitly
  // so that they don't get erroneously deleted from
  // HTML namespace.
  const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ['title', 'style', 'font', 'a', 'script']);

  /* Keep track of all possible SVG and MathML tags
   * so that we can perform the namespace checks
   * correctly. */
  const ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]);
  const ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]);

  /**
   * @param  {Element} element a DOM element whose namespace is being checked
   * @returns {boolean} Return false if the element has a
   *  namespace that a spec-compliant parser would never
   *  return. Return true otherwise.
   */
  const _checkValidNamespace = function _checkValidNamespace(element) {
    let parent = getParentNode(element);

    // In JSDOM, if we're inside shadow DOM, then parentNode
    // can be null. We just simulate parent in this case.
    if (!parent || !parent.tagName) {
      parent = {
        namespaceURI: NAMESPACE,
        tagName: 'template'
      };
    }
    const tagName = stringToLowerCase(element.tagName);
    const parentTagName = stringToLowerCase(parent.tagName);
    if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
      return false;
    }
    if (element.namespaceURI === SVG_NAMESPACE) {
      // The only way to switch from HTML namespace to SVG
      // is via <svg>. If it happens via any other tag, then
      // it should be killed.
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === 'svg';
      }

      // The only way to switch from MathML to SVG is via`
      // svg if parent is either <annotation-xml> or MathML
      // text integration points.
      if (parent.namespaceURI === MATHML_NAMESPACE) {
        return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
      }

      // We only allow elements that are defined in SVG
      // spec. All others are disallowed in SVG namespace.
      return Boolean(ALL_SVG_TAGS[tagName]);
    }
    if (element.namespaceURI === MATHML_NAMESPACE) {
      // The only way to switch from HTML namespace to MathML
      // is via <math>. If it happens via any other tag, then
      // it should be killed.
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === 'math';
      }

      // The only way to switch from SVG to MathML is via
      // <math> and HTML integration points
      if (parent.namespaceURI === SVG_NAMESPACE) {
        return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
      }

      // We only allow elements that are defined in MathML
      // spec. All others are disallowed in MathML namespace.
      return Boolean(ALL_MATHML_TAGS[tagName]);
    }
    if (element.namespaceURI === HTML_NAMESPACE) {
      // The only way to switch from SVG to HTML is via
      // HTML integration points, and from MathML to HTML
      // is via MathML text integration points
      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }

      // We disallow tags that are specific for MathML
      // or SVG and should never appear in HTML namespace
      return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
    }

    // For XHTML and XML documents that support custom namespaces
    if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && ALLOWED_NAMESPACES[element.namespaceURI]) {
      return true;
    }

    // The code should never reach this place (this means
    // that the element somehow got namespace that is not
    // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).
    // Return false just in case.
    return false;
  };

  /**
   * _forceRemove
   *
   * @param  {Node} node a DOM node
   */
  const _forceRemove = function _forceRemove(node) {
    arrayPush(DOMPurify.removed, {
      element: node
    });
    try {
      // eslint-disable-next-line unicorn/prefer-dom-node-remove
      getParentNode(node).removeChild(node);
    } catch (_) {
      remove(node);
    }
  };

  /**
   * _removeAttribute
   *
   * @param  {String} name an Attribute name
   * @param  {Node} node a DOM node
   */
  const _removeAttribute = function _removeAttribute(name, node) {
    try {
      arrayPush(DOMPurify.removed, {
        attribute: node.getAttributeNode(name),
        from: node
      });
    } catch (_) {
      arrayPush(DOMPurify.removed, {
        attribute: null,
        from: node
      });
    }
    node.removeAttribute(name);

    // We void attribute values for unremovable "is"" attributes
    if (name === 'is' && !ALLOWED_ATTR[name]) {
      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
        try {
          _forceRemove(node);
        } catch (_) {}
      } else {
        try {
          node.setAttribute(name, '');
        } catch (_) {}
      }
    }
  };

  /**
   * _initDocument
   *
   * @param  {String} dirty a string of dirty markup
   * @return {Document} a DOM, filled with the dirty markup
   */
  const _initDocument = function _initDocument(dirty) {
    /* Create a HTML document */
    let doc = null;
    let leadingWhitespace = null;
    if (FORCE_BODY) {
      dirty = '<remove></remove>' + dirty;
    } else {
      /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
      const matches = stringMatch(dirty, /^[\r\n\t ]+/);
      leadingWhitespace = matches && matches[0];
    }
    if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && NAMESPACE === HTML_NAMESPACE) {
      // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)
      dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + '</body></html>';
    }
    const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    /*
     * Use the DOMParser API by default, fallback later if needs be
     * DOMParser not work for svg when has multiple root element.
     */
    if (NAMESPACE === HTML_NAMESPACE) {
      try {
        doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
      } catch (_) {}
    }

    /* Use createHTMLDocument in case DOMParser is not available */
    if (!doc || !doc.documentElement) {
      doc = implementation.createDocument(NAMESPACE, 'template', null);
      try {
        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
      } catch (_) {
        // Syntax error if dirtyPayload is invalid xml
      }
    }
    const body = doc.body || doc.documentElement;
    if (dirty && leadingWhitespace) {
      body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
    }

    /* Work on whole document or just its body */
    if (NAMESPACE === HTML_NAMESPACE) {
      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
    }
    return WHOLE_DOCUMENT ? doc.documentElement : body;
  };

  /**
   * Creates a NodeIterator object that you can use to traverse filtered lists of nodes or elements in a document.
   *
   * @param  {Node} root The root element or node to start traversing on.
   * @return {NodeIterator} The created NodeIterator
   */
  const _createNodeIterator = function _createNodeIterator(root) {
    return createNodeIterator.call(root.ownerDocument || root, root,
    // eslint-disable-next-line no-bitwise
    NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION, null);
  };

  /**
   * _isClobbered
   *
   * @param  {Node} elm element to check for clobbering attacks
   * @return {Boolean} true if clobbered, false if safe
   */
  const _isClobbered = function _isClobbered(elm) {
    return elm instanceof HTMLFormElement && (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function' || typeof elm.hasChildNodes !== 'function');
  };

  /**
   * Checks whether the given object is a DOM node.
   *
   * @param  {Node} object object to check whether it's a DOM node
   * @return {Boolean} true is object is a DOM node
   */
  const _isNode = function _isNode(object) {
    return typeof Node === 'function' && object instanceof Node;
  };

  /**
   * _executeHook
   * Execute user configurable hooks
   *
   * @param  {String} entryPoint  Name of the hook's entry point
   * @param  {Node} currentNode node to work on with the hook
   * @param  {Object} data additional hook parameters
   */
  const _executeHook = function _executeHook(entryPoint, currentNode, data) {
    if (!hooks[entryPoint]) {
      return;
    }
    arrayForEach(hooks[entryPoint], hook => {
      hook.call(DOMPurify, currentNode, data, CONFIG);
    });
  };

  /**
   * _sanitizeElements
   *
   * @protect nodeName
   * @protect textContent
   * @protect removeChild
   *
   * @param   {Node} currentNode to check for permission to exist
   * @return  {Boolean} true if node was killed, false if left alive
   */
  const _sanitizeElements = function _sanitizeElements(currentNode) {
    let content = null;

    /* Execute a hook if present */
    _executeHook('beforeSanitizeElements', currentNode, null);

    /* Check if element is clobbered or can clobber */
    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Now let's check the element's type and name */
    const tagName = transformCaseFunc(currentNode.nodeName);

    /* Execute a hook if present */
    _executeHook('uponSanitizeElement', currentNode, {
      tagName,
      allowedTags: ALLOWED_TAGS
    });

    /* Detect mXSS attempts abusing namespace confusion */
    if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Remove any occurrence of processing instructions */
    if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {
      _forceRemove(currentNode);
      return true;
    }

    /* Remove any kind of possibly harmful comments */
    if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\w]/g, currentNode.data)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Remove element if anything forbids its presence */
    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
      /* Check if we have a custom element to handle */
      if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {
          return false;
        }
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {
          return false;
        }
      }

      /* Keep content except for bad-listed elements */
      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
        const parentNode = getParentNode(currentNode) || currentNode.parentNode;
        const childNodes = getChildNodes(currentNode) || currentNode.childNodes;
        if (childNodes && parentNode) {
          const childCount = childNodes.length;
          for (let i = childCount - 1; i >= 0; --i) {
            const childClone = cloneNode(childNodes[i], true);
            childClone.__removalCount = (currentNode.__removalCount || 0) + 1;
            parentNode.insertBefore(childClone, getNextSibling(currentNode));
          }
        }
      }
      _forceRemove(currentNode);
      return true;
    }

    /* Check whether element has a valid namespace */
    if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Make sure that older browsers don't get fallback-tag mXSS */
    if ((tagName === 'noscript' || tagName === 'noembed' || tagName === 'noframes') && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Sanitize element content to be template-safe */
    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {
      /* Get the element's text content */
      content = currentNode.textContent;
      arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {
        content = stringReplace(content, expr, ' ');
      });
      if (currentNode.textContent !== content) {
        arrayPush(DOMPurify.removed, {
          element: currentNode.cloneNode()
        });
        currentNode.textContent = content;
      }
    }

    /* Execute a hook if present */
    _executeHook('afterSanitizeElements', currentNode, null);
    return false;
  };

  /**
   * _isValidAttribute
   *
   * @param  {string} lcTag Lowercase tag name of containing element.
   * @param  {string} lcName Lowercase attribute name.
   * @param  {string} value Attribute value.
   * @return {Boolean} Returns true if `value` is valid, otherwise false.
   */
  // eslint-disable-next-line complexity
  const _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
    /* Make sure attribute cannot clobber */
    if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
      return false;
    }

    /* Allow valid data-* attributes: At least one character after "-"
        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
        We don't need to check the value; it's always URI safe. */
    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      if (
      // First condition does a very basic check if a) it's basically a valid custom element tagname AND
      // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
      // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
      _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) ||
      // Alternative, second condition checks if it's an `is`-attribute, AND
      // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
      lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ; else {
        return false;
      }
      /* Check value is safe. First, is attr inert? If so, is safe */
    } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, ''))) ; else if (value) {
      return false;
    } else ;
    return true;
  };

  /**
   * _isBasicCustomElement
   * checks if at least one dash is included in tagName, and it's not the first char
   * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name
   *
   * @param {string} tagName name of the tag of the node to sanitize
   * @returns {boolean} Returns true if the tag name meets the basic criteria for a custom element, otherwise false.
   */
  const _isBasicCustomElement = function _isBasicCustomElement(tagName) {
    return tagName !== 'annotation-xml' && stringMatch(tagName, CUSTOM_ELEMENT);
  };

  /**
   * _sanitizeAttributes
   *
   * @protect attributes
   * @protect nodeName
   * @protect removeAttribute
   * @protect setAttribute
   *
   * @param  {Node} currentNode to sanitize
   */
  const _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
    /* Execute a hook if present */
    _executeHook('beforeSanitizeAttributes', currentNode, null);
    const {
      attributes
    } = currentNode;

    /* Check if we have attributes; if not we might have a text node */
    if (!attributes) {
      return;
    }
    const hookEvent = {
      attrName: '',
      attrValue: '',
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR
    };
    let l = attributes.length;

    /* Go backwards over all attributes; safely remove bad ones */
    while (l--) {
      const attr = attributes[l];
      const {
        name,
        namespaceURI,
        value: attrValue
      } = attr;
      const lcName = transformCaseFunc(name);
      let value = name === 'value' ? attrValue : stringTrim(attrValue);

      /* Execute a hook if present */
      hookEvent.attrName = lcName;
      hookEvent.attrValue = value;
      hookEvent.keepAttr = true;
      hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set
      _executeHook('uponSanitizeAttribute', currentNode, hookEvent);
      value = hookEvent.attrValue;

      /* Work around a security issue with comments inside attributes */
      if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\/(style|title)/i, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }

      /* Did the hooks approve of the attribute? */
      if (hookEvent.forceKeepAttr) {
        continue;
      }

      /* Remove attribute */
      _removeAttribute(name, currentNode);

      /* Did the hooks approve of the attribute? */
      if (!hookEvent.keepAttr) {
        continue;
      }

      /* Work around a security issue in jQuery 3.0 */
      if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }

      /* Sanitize attribute content to be template-safe */
      if (SAFE_FOR_TEMPLATES) {
        arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {
          value = stringReplace(value, expr, ' ');
        });
      }

      /* Is `value` valid for this attribute? */
      const lcTag = transformCaseFunc(currentNode.nodeName);
      if (!_isValidAttribute(lcTag, lcName, value)) {
        continue;
      }

      /* Full DOM Clobbering protection via namespace isolation,
       * Prefix id and name attributes with `user-content-`
       */
      if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {
        // Remove the attribute with this value
        _removeAttribute(name, currentNode);

        // Prefix the value and later re-create the attribute with the sanitized value
        value = SANITIZE_NAMED_PROPS_PREFIX + value;
      }

      /* Handle attributes that require Trusted Types */
      if (trustedTypesPolicy && typeof trustedTypes === 'object' && typeof trustedTypes.getAttributeType === 'function') {
        if (namespaceURI) ; else {
          switch (trustedTypes.getAttributeType(lcTag, lcName)) {
            case 'TrustedHTML':
              {
                value = trustedTypesPolicy.createHTML(value);
                break;
              }
            case 'TrustedScriptURL':
              {
                value = trustedTypesPolicy.createScriptURL(value);
                break;
              }
          }
        }
      }

      /* Handle invalid data-* attribute set by try-catching it */
      try {
        if (namespaceURI) {
          currentNode.setAttributeNS(namespaceURI, name, value);
        } else {
          /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
          currentNode.setAttribute(name, value);
        }
        if (_isClobbered(currentNode)) {
          _forceRemove(currentNode);
        } else {
          arrayPop(DOMPurify.removed);
        }
      } catch (_) {}
    }

    /* Execute a hook if present */
    _executeHook('afterSanitizeAttributes', currentNode, null);
  };

  /**
   * _sanitizeShadowDOM
   *
   * @param  {DocumentFragment} fragment to iterate over recursively
   */
  const _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
    let shadowNode = null;
    const shadowIterator = _createNodeIterator(fragment);

    /* Execute a hook if present */
    _executeHook('beforeSanitizeShadowDOM', fragment, null);
    while (shadowNode = shadowIterator.nextNode()) {
      /* Execute a hook if present */
      _executeHook('uponSanitizeShadowNode', shadowNode, null);

      /* Sanitize tags and elements */
      if (_sanitizeElements(shadowNode)) {
        continue;
      }

      /* Deep shadow DOM detected */
      if (shadowNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(shadowNode.content);
      }

      /* Check attributes, sanitize if necessary */
      _sanitizeAttributes(shadowNode);
    }

    /* Execute a hook if present */
    _executeHook('afterSanitizeShadowDOM', fragment, null);
  };

  /**
   * Sanitize
   * Public method providing core sanitation functionality
   *
   * @param {String|Node} dirty string or DOM node
   * @param {Object} cfg object
   */
  // eslint-disable-next-line complexity
  DOMPurify.sanitize = function (dirty) {
    let cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let body = null;
    let importedNode = null;
    let currentNode = null;
    let returnNode = null;
    /* Make sure we have a string to sanitize.
      DO NOT return early, as this will return the wrong type if
      the user has requested a DOM object rather than a string */
    IS_EMPTY_INPUT = !dirty;
    if (IS_EMPTY_INPUT) {
      dirty = '<!-->';
    }

    /* Stringify, in case dirty is an object */
    if (typeof dirty !== 'string' && !_isNode(dirty)) {
      if (typeof dirty.toString === 'function') {
        dirty = dirty.toString();
        if (typeof dirty !== 'string') {
          throw typeErrorCreate('dirty is not a string, aborting');
        }
      } else {
        throw typeErrorCreate('toString is not a function');
      }
    }

    /* Return dirty HTML if DOMPurify cannot run */
    if (!DOMPurify.isSupported) {
      return dirty;
    }

    /* Assign config vars */
    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }

    /* Clean up removed elements */
    DOMPurify.removed = [];

    /* Check if dirty is correctly typed for IN_PLACE */
    if (typeof dirty === 'string') {
      IN_PLACE = false;
    }
    if (IN_PLACE) {
      /* Do some early pre-sanitization to avoid unsafe root nodes */
      if (dirty.nodeName) {
        const tagName = transformCaseFunc(dirty.nodeName);
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');
        }
      }
    } else if (dirty instanceof Node) {
      /* If dirty is a DOM element, append to an empty document to avoid
         elements being stripped by the parser */
      body = _initDocument('<!---->');
      importedNode = body.ownerDocument.importNode(dirty, true);
      if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === 'BODY') {
        /* Node is already a body, use as is */
        body = importedNode;
      } else if (importedNode.nodeName === 'HTML') {
        body = importedNode;
      } else {
        // eslint-disable-next-line unicorn/prefer-dom-node-append
        body.appendChild(importedNode);
      }
    } else {
      /* Exit directly if we have nothing to do */
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&
      // eslint-disable-next-line unicorn/prefer-includes
      dirty.indexOf('<') === -1) {
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
      }

      /* Initialize the document to work on */
      body = _initDocument(dirty);

      /* Check we have a DOM node from the data */
      if (!body) {
        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';
      }
    }

    /* Remove first element node (ours) if FORCE_BODY is set */
    if (body && FORCE_BODY) {
      _forceRemove(body.firstChild);
    }

    /* Get node iterator */
    const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);

    /* Now start iterating over the created document */
    while (currentNode = nodeIterator.nextNode()) {
      /* Sanitize tags and elements */
      if (_sanitizeElements(currentNode)) {
        continue;
      }

      /* Shadow DOM detected, sanitize it */
      if (currentNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(currentNode.content);
      }

      /* Check attributes, sanitize if necessary */
      _sanitizeAttributes(currentNode);
    }

    /* If we sanitized `dirty` in-place, return it. */
    if (IN_PLACE) {
      return dirty;
    }

    /* Return sanitized string or DOM */
    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body.ownerDocument);
        while (body.firstChild) {
          // eslint-disable-next-line unicorn/prefer-dom-node-append
          returnNode.appendChild(body.firstChild);
        }
      } else {
        returnNode = body;
      }
      if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {
        /*
          AdoptNode() is not used because internal state is not reset
          (e.g. the past names map of a HTMLFormElement), this is safe
          in theory but we would rather not risk another attack vector.
          The state that is cloned by importNode() is explicitly defined
          by the specs.
        */
        returnNode = importNode.call(originalDocument, returnNode, true);
      }
      return returnNode;
    }
    let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;

    /* Serialize doctype if allowed */
    if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
      serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\n' + serializedHTML;
    }

    /* Sanitize final string template-safe */
    if (SAFE_FOR_TEMPLATES) {
      arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {
        serializedHTML = stringReplace(serializedHTML, expr, ' ');
      });
    }
    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };

  /**
   * Public method to set the configuration once
   * setConfig
   *
   * @param {Object} cfg configuration object
   */
  DOMPurify.setConfig = function () {
    let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _parseConfig(cfg);
    SET_CONFIG = true;
  };

  /**
   * Public method to remove the configuration
   * clearConfig
   *
   */
  DOMPurify.clearConfig = function () {
    CONFIG = null;
    SET_CONFIG = false;
  };

  /**
   * Public method to check if an attribute value is valid.
   * Uses last set config, if any. Otherwise, uses config defaults.
   * isValidAttribute
   *
   * @param  {String} tag Tag name of containing element.
   * @param  {String} attr Attribute name.
   * @param  {String} value Attribute value.
   * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.
   */
  DOMPurify.isValidAttribute = function (tag, attr, value) {
    /* Initialize shared config vars if necessary. */
    if (!CONFIG) {
      _parseConfig({});
    }
    const lcTag = transformCaseFunc(tag);
    const lcName = transformCaseFunc(attr);
    return _isValidAttribute(lcTag, lcName, value);
  };

  /**
   * AddHook
   * Public method to add DOMPurify hooks
   *
   * @param {String} entryPoint entry point for the hook to add
   * @param {Function} hookFunction function to execute
   */
  DOMPurify.addHook = function (entryPoint, hookFunction) {
    if (typeof hookFunction !== 'function') {
      return;
    }
    hooks[entryPoint] = hooks[entryPoint] || [];
    arrayPush(hooks[entryPoint], hookFunction);
  };

  /**
   * RemoveHook
   * Public method to remove a DOMPurify hook at a given entryPoint
   * (pops it from the stack of hooks if more are present)
   *
   * @param {String} entryPoint entry point for the hook to remove
   * @return {Function} removed(popped) hook
   */
  DOMPurify.removeHook = function (entryPoint) {
    if (hooks[entryPoint]) {
      return arrayPop(hooks[entryPoint]);
    }
  };

  /**
   * RemoveHooks
   * Public method to remove all DOMPurify hooks at a given entryPoint
   *
   * @param  {String} entryPoint entry point for the hooks to remove
   */
  DOMPurify.removeHooks = function (entryPoint) {
    if (hooks[entryPoint]) {
      hooks[entryPoint] = [];
    }
  };

  /**
   * RemoveAllHooks
   * Public method to remove all DOMPurify hooks
   */
  DOMPurify.removeAllHooks = function () {
    hooks = {};
  };
  return DOMPurify;
}
var purify = createDOMPurify();

/*!
 * Copyright (C) 2023 salesforce.com, inc.
 */
// @ts-ignore: Prevent cannot find name 'trustedTypes' error.
const SUPPORTS_TRUSTED_TYPES = typeof trustedTypes !== 'undefined';
function createTrustedTypesPolicy(name, options) {
  // @ts-ignore: Prevent cannot find name 'trustedTypes' error.
  return trustedTypes.createPolicy(name, options);
}
function createFallbackPolicy(_name, options) {
  return options;
}
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/trusted-types
const createPolicy = SUPPORTS_TRUSTED_TYPES ? createTrustedTypesPolicy : createFallbackPolicy;
const policyOptions = {
  createHTML(value) {
    return value;
  },
  createScript(value) {
    return value;
  },
  createScriptURL(value) {
    return value;
  }
};
// Temporarily surround in try-catch until migration to AMD run.
try {
  // istanbul ignore next: this creates a special policy described here https://developer.mozilla.org/en-US/docs/Web/API/TrustedTypePolicyFactory/createPolicy
  createPolicy('default', {
    createHTML(dirty) {
      // Treat null & undefined separately
      if (dirty === 'null' || dirty === 'undefined') {
        return dirty;
      }
      return dirty;
    },
    // Ignore typescript type validation for this policy.
    // Returning `undefined` from a TT policy blocks usages
    // of specific DOM sinks affected by this hook.
    // We want to block eval and inline scripts.
    // @ts-ignore
    createScript(dirty) {
      // Treat null & undefined separately
      if (dirty === 'null' || dirty === 'undefined') {
        return dirty;
      }
      // Block script evaluation
      return undefined;
    },
    createScriptURL(dirty) {
      // Treat null & undefined separately
      if (dirty === 'null' || dirty === 'undefined') {
        return dirty;
      }
      return dirty;
    }
  });
} catch (_unused) {
  // swallow
}
const trusted = createPolicy('trusted', policyOptions);
/*! version: 0.23.6 */

/*!
 * Copyright (C) 2019 salesforce.com, inc.
 */
const additionalAttributes$LWS = ['role', 'part', 'target'];
const htmlTags$LWS = ['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blockquote', 'body', 'br', 'button', 'caption', 'canvas', 'center', 'cite', 'code', 'col', 'colgroup', 'command', 'datalist', 'dd', 'del', 'details', 'dfn', 'dir', 'div', 'dl', 'dt', 'em', 'fieldset', 'figure', 'figcaption', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'i', 'iframe', 'img', 'input', 'ins', 'keygen', 'kbd', 'label', 'legend', 'li', 'map', 'mark', 'menu', 'meter', 'nav', 'ol', 'optgroup', 'option', 'output', 'p', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'small', 'source', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr'];
const miscTags$LWS = ['#comment', '#document-fragment'];
const svgTags$LWS = ['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'audio', 'canvas', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'video', 'view', 'vkern', 'use'];
const allHTMLTags$LWS = ArrayConcat$LWS(htmlTags$LWS, svgTags$LWS, miscTags$LWS);
const allSVGTags$LWS = ArrayConcat$LWS(svgTags$LWS, miscTags$LWS);
const CUSTOM_ELEMENT_HANDLING$LWS = {
  attributeNameCheck: /.+/,
  allowCustomizedBuiltInElements: false,
  // The regexp is based on the WHATWG spec:
  // https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name
  // However, DOMPurify sanitizes unicode characters (\u0000-\uFFFF) in tag name.
  tagNameCheck: /^[a-z][-_.\w]*-[-.0-9_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u37D0\u37F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u10000-\uEFFFF]*$/
};
// A generic config in which the sanitizer attempts in place sanitization and
// returns node.
const NODE_ALL_IN_PLACE$LWS = {
  ADD_ATTR: shallowCloneArray$LWS(additionalAttributes$LWS),
  // Add '#document-fragment' to ALLOWED_TAGS to avoid a forbidden root node
  // exception.
  // https://github.com/cure53/DOMPurify/issues/664
  ALLOWED_TAGS: shallowCloneArray$LWS(allHTMLTags$LWS),
  CUSTOM_ELEMENT_HANDLING: ObjectAssign$LWS$1({}, CUSTOM_ELEMENT_HANDLING$LWS),
  IN_PLACE: true,
  // @ts-ignore this type is on DOMPurifyConfig
  TRUSTED_TYPES_POLICY: trusted
};
// A config to use only svg tags in which the sanitizer returns a document
// fragment.
const NODE_SVG$LWS = {
  ADD_ATTR: shallowCloneArray$LWS(additionalAttributes$LWS),
  ALLOWED_TAGS: shallowCloneArray$LWS(allSVGTags$LWS),
  CUSTOM_ELEMENT_HANDLING: ObjectAssign$LWS$1({}, CUSTOM_ELEMENT_HANDLING$LWS),
  RETURN_DOM_FRAGMENT: true,
  SANITIZE_DOM: false,
  // @ts-ignore this type is on DOMPurifyConfig
  TRUSTED_TYPES_POLICY: trusted
};
// A config to use only tags allowed for blob and file.
const STRING_BLOB_HTML$LWS = {
  ADD_ATTR: shallowCloneArray$LWS(additionalAttributes$LWS),
  ALLOWED_TAGS: ReflectApply$LWS$1(ArrayProtoFilter$LWS$1, allHTMLTags$LWS, [tag$LWS => tag$LWS !== 'iframe']),
  CUSTOM_ELEMENT_HANDLING: ObjectAssign$LWS$1({}, CUSTOM_ELEMENT_HANDLING$LWS),
  SANITIZE_DOM: false,
  // @ts-ignore this type is on DOMPurifyConfig
  TRUSTED_TYPES_POLICY: trusted
};
var CONFIG$LWS = /*#__PURE__*/Object.freeze({
  __proto__: null,
  NODE_ALL_IN_PLACE: NODE_ALL_IN_PLACE$LWS,
  NODE_SVG: NODE_SVG$LWS,
  STRING_BLOB_HTML: STRING_BLOB_HTML$LWS
});
const instancesBySandboxKeyRegistry$LWS = {
  __proto__: null
};
const SANITIZE_ATTRIBUTES_LIST$LWS = toSafeArray$LWS$1(['href', 'xlink:href']);
const SHARED_SVG_SANITIZER_KEY$LWS = 'SHARED_SVG_SANITIZER_KEY';
ReflectApply$LWS$1(DocumentProtoCreateElement$LWS$1, document, ['template']);
// Queue for managing pending XHR requests.
const queue$LWS = toSafeSet$LWS(new SetCtor$LWS$1());
// A regexp to find all non lowercase alphanumeric.
const urlReplacerRegExp$LWS = /[^a-z0-9]+/gi;
function createSantizerHooksRegistry$LWS(sandboxKey$LWS) {
  return {
    __proto__: null,
    // uponSanitizeAttribute is generic, so its definition can be a reused function
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    uponSanitizeAttribute: uponSanitizeAttribute$LWS,
    // uponSanitizeElement is sandbox-key-specific
    uponSanitizeElement(node$LWS, data$LWS, config$LWS) {
      var _config$CUSTOM_ELEMEN$LWS;
      const {
        tagName: tagName$LWS
      } = data$LWS;
      // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
      const tagNameCheck$LWS = config$LWS == null || (_config$CUSTOM_ELEMEN$LWS = config$LWS.CUSTOM_ELEMENT_HANDLING) == null ? void 0 : _config$CUSTOM_ELEMEN$LWS.tagNameCheck;
      if (tagNameCheck$LWS && ReflectApply$LWS$1(RegExpProtoTest$LWS$1, tagNameCheck$LWS, [tagName$LWS]) &&
      // This MUST be called ONLY after we've ensured the previous
      // two conditions have been met, otherwise it may result in an
      // unwanted "Illegal invocation" on a node we don't care about.
      !ReflectApply$LWS$1(ElementProtoHasAttribute$LWS, node$LWS, [CUSTOM_ELEMENT_REGISTRY_ATTRIBUTE_NAME$LWS])) {
        ReflectApply$LWS$1(ElementProtoSetAttribute$LWS$1, node$LWS, [CUSTOM_ELEMENT_REGISTRY_ATTRIBUTE_NAME$LWS, sandboxKey$LWS]);
      }
    }
  };
}
function createUrlContainer$LWS(url$LWS) {
  const container$LWS = ReflectApply$LWS$1(DocumentProtoCreateElement$LWS$1, document, ['div']);
  ReflectApply$LWS$1(ElementProtoSetAttribute$LWS$1, container$LWS, ['style', 'display:none']);
  ReflectApply$LWS$1(ElementProtoSetAttribute$LWS$1, container$LWS, ['id', url$LWS]);
  const body$LWS = ReflectApply$LWS$1(DocumentProtoBodyGetter$LWS$1, document, []);
  ReflectApply$LWS$1(NodeProtoAppendChild$LWS$1, body$LWS, [container$LWS]);
  return container$LWS;
}
function getSanitizerForConfig$LWS(sandboxKey$LWS, configName$LWS) {
  if (typeof sandboxKey$LWS !== 'string') {
    throw new LockerSecurityError$LWS(ERR_INVALID_SANDBOX_KEY$LWS);
  }
  if (typeof configName$LWS !== 'string') {
    throw new LockerSecurityError$LWS('Invalid config name.');
  }
  let sandboxConfiguredSanitizerInstances$LWS = instancesBySandboxKeyRegistry$LWS[sandboxKey$LWS];
  if (sandboxConfiguredSanitizerInstances$LWS === undefined) {
    sandboxConfiguredSanitizerInstances$LWS = instancesBySandboxKeyRegistry$LWS[sandboxKey$LWS] = {
      __proto__: null
    };
  }
  let configuredDOMPurifyInstance$LWS = sandboxConfiguredSanitizerInstances$LWS[configName$LWS];
  if (configuredDOMPurifyInstance$LWS === undefined) {
    const config$LWS = CONFIG$LWS[configName$LWS];
    configuredDOMPurifyInstance$LWS = purify();
    configuredDOMPurifyInstance$LWS.setConfig(config$LWS);
    const hooksRegistry$LWS = createSantizerHooksRegistry$LWS(sandboxKey$LWS);
    for (const hookName$LWS in hooksRegistry$LWS) {
      configuredDOMPurifyInstance$LWS.addHook(hookName$LWS, hooksRegistry$LWS[hookName$LWS]);
    }
    sandboxConfiguredSanitizerInstances$LWS[configName$LWS] = configuredDOMPurifyInstance$LWS;
  }
  return configuredDOMPurifyInstance$LWS;
}
function sanitizeSvgTextReturnDOM$LWS(dirty$LWS) {
  const svgSanitizer$LWS = getSanitizerForConfig$LWS(SHARED_SVG_SANITIZER_KEY$LWS, 'NODE_SVG');
  return svgSanitizer$LWS.sanitize(dirty$LWS);
}
function sanitizeSvgHref$LWS(url$LWS) {
  const urlAsString$LWS = toSafeStringValue$LWS(url$LWS);
  if (ReflectApply$LWS$1(StringProtoStartsWith$LWS, urlAsString$LWS, ['#'])) {
    return url$LWS;
  }
  const normalizedHref$LWS = parseHref$LWS(urlAsString$LWS);
  // Sanitize only for supported URL_SCHEMES_LIST.
  if (URL_SCHEMES_LIST$LWS.includes(normalizedHref$LWS.protocol)) {
    const container$LWS = ReflectApply$LWS$1(DocumentProtoGetElementById$LWS, document, [normalizedHref$LWS.normalizedURL]);
    // Have we sanitized this URL already?
    if (container$LWS && normalizedHref$LWS.normalizedFragment) {
      checkExistingAndDequeue$LWS(container$LWS, normalizedHref$LWS);
    } else if (!container$LWS) {
      fetchAndSanitize$LWS(normalizedHref$LWS);
    }
    // If this has been in the form of http://my-url/file.svg#fragment we
    // return the normalized fragment otherwise we return the normalized URL.
    return normalizedHref$LWS.requestedFragment ? `#${normalizedHref$LWS.normalizedFragment}` : `#${normalizedHref$LWS.normalizedURL}`;
  }
  return url$LWS;
}
function updater$LWS(container$LWS, normalizedHref$LWS) {
  const {
    normalizedFragment: normalizedFragment$LWS,
    requestedFragment: requestedFragment$LWS
  } = normalizedHref$LWS;
  let el$LWS = ReflectApply$LWS$1(ElementProtoQuerySelector$LWS, container$LWS, [`#${normalizedFragment$LWS}`]);
  // istanbul ignore else
  if (el$LWS === null) {
    try {
      el$LWS = ReflectApply$LWS$1(ElementProtoQuerySelector$LWS, container$LWS, [`#${requestedFragment$LWS}`]);
      ReflectApply$LWS$1(ElementProtoSetAttribute$LWS$1, el$LWS, ['id', normalizedFragment$LWS]);
    } catch (_unused$LWS) {
      // Catch all malformed CSS3 selectors.
      // getElementById not available on Node.
      // Cannot use document.getElementById because multiple containers
      // may have the same ids for SVG elements.
    }
  }
}
function checkExistingAndDequeue$LWS(container$LWS, normalizedHref$LWS) {
  if (queue$LWS.has(normalizedHref$LWS.normalizedURL)) {
    // Wait for request to finish, then update content.
    const interval$LWS = WindowSetInterval$LWS(() => {
      // istanbul ignore else
      if (!queue$LWS.has(normalizedHref$LWS.normalizedURL)) {
        updater$LWS(container$LWS, normalizedHref$LWS);
        WindowClearInterval$LWS(interval$LWS);
      }
    }, 50);
  } else {
    updater$LWS(container$LWS, normalizedHref$LWS);
  }
}
function fetchAndSanitize$LWS(normalizedHref$LWS) {
  // This is the first time we see this href.
  const container$LWS = createUrlContainer$LWS(normalizedHref$LWS.normalizedURL);
  // Put the URL we're fetching in a queue.
  queue$LWS.add(normalizedHref$LWS.normalizedURL);
  // Initiate an XHR to fetch the resource.
  const xhr$LWS = new XhrCtor$LWS();
  ReflectApply$LWS$1(EventTargetProtoAddEventListener$LWS, xhr$LWS, ['load', () => {
    const status$LWS = ReflectApply$LWS$1(XhrProtoStatusGetter$LWS, xhr$LWS, []);
    // istanbul ignore next: the following is well tested via integration-karma
    if (status$LWS === 200) {
      // Retrieved content should be sanitized immediately.
      const responseText$LWS = ReflectApply$LWS$1(XhrProtoResponseTextGetter$LWS, xhr$LWS, []);
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      const fragment$LWS = sanitizeSvgTextReturnDOM$LWS(responseText$LWS);
      // Look for the container again in case other requests have finished
      // earlier for the same URL.
      if (normalizedHref$LWS.requestedFragment) {
        const el$LWS = ReflectApply$LWS$1(DocumentFragmentProtoGetElementById$LWS, fragment$LWS, [normalizedHref$LWS.requestedFragment]);
        if (el$LWS) {
          ReflectApply$LWS$1(ElementProtoSetAttribute$LWS$1, el$LWS, ['id', normalizedHref$LWS.normalizedFragment]);
        }
      }
      ReflectApply$LWS$1(NodeProtoAppendChild$LWS$1, container$LWS, [fragment$LWS]);
      queue$LWS.delete(normalizedHref$LWS.normalizedURL);
    }
  }]);
  ReflectApply$LWS$1(XhrProtoOpen$LWS, xhr$LWS, ['GET', normalizedHref$LWS.requestedURL]);
  ReflectApply$LWS$1(XhrProtoSend$LWS, xhr$LWS, []);
}
function parseHref$LWS(url$LWS) {
  ReflectApply$LWS$1(HTMLAnchorElementProtoHrefSetter$LWS, normalizerAnchor$LWS, [url$LWS]);
  const href$LWS = ReflectApply$LWS$1(HTMLAnchorElementProtoHrefGetter$LWS, normalizerAnchor$LWS, []);
  const protocol$LWS = ReflectApply$LWS$1(HTMLAnchorElementProtoProtocolGetter$LWS, normalizerAnchor$LWS, []);
  const {
    0: requestedURL$LWS,
    1: requestedFragment$LWS
  } = ReflectApply$LWS$1(StringProtoSplit$LWS, href$LWS, ['#']);
  const loweredUrl$LWS = ReflectApply$LWS$1(StringProtoToLowerCase$LWS, requestedURL$LWS, []);
  // RegExp.prototype[Symbol.replace] resets the lastIndex of global regexp to 0.
  // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
  const normalizedURL$LWS = ReflectApply$LWS$1(StringProtoReplace$LWS, loweredUrl$LWS, [urlReplacerRegExp$LWS, '']);
  const normalizedFragment$LWS = requestedFragment$LWS ? `${normalizedURL$LWS}_${ReflectApply$LWS$1(StringProtoReplace$LWS, requestedFragment$LWS, [urlReplacerRegExp$LWS, ''])}` : '';
  return {
    normalizedFragment: normalizedFragment$LWS,
    normalizedURL: normalizedURL$LWS,
    protocol: protocol$LWS,
    requestedFragment: requestedFragment$LWS,
    requestedURL: requestedURL$LWS
  };
}
// Sanitize a URL representing a SVG href attribute value.
function uponSanitizeAttribute$LWS(node$LWS, data$LWS, _config$LWS) {
  const {
    attrValue: attrValue$LWS,
    attrName: attrName$LWS
  } = data$LWS;
  if (attrValue$LWS && ReflectApply$LWS$1(StringProtoToUpperCase$LWS, ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, node$LWS, []), []) === 'USE' && SANITIZE_ATTRIBUTES_LIST$LWS.includes(attrName$LWS)) {
    data$LWS.attrValue = sanitizeSvgHref$LWS(attrValue$LWS);
  }
  // To support Lit, we must tell DOMPurify that attributes starting with "@", ".", or "?" are allowed.
  // Ref:
  // https://lit.dev/docs/components/events/
  // https://lit.dev/docs/templates/expressions/#property-expressions
  // https://lit.dev/docs/templates/expressions/#boolean-attribute-expressions
  // istanbul ignore next: this is tested under all normal CI runs, but is not included in coverage
  if (attrName$LWS && (ReflectApply$LWS$1(StringProtoStartsWith$LWS, attrName$LWS, ['@']) || ReflectApply$LWS$1(StringProtoStartsWith$LWS, attrName$LWS, ['.']) || ReflectApply$LWS$1(StringProtoStartsWith$LWS, attrName$LWS, ['?']))) {
    data$LWS.forceKeepAttr = true;
  }
  return data$LWS;
}
function blobSanitizer$LWS(sandboxKey$LWS) {
  if (typeof sandboxKey$LWS !== 'string') {
    throw new LockerSecurityError$LWS(ERR_INVALID_SANDBOX_KEY$LWS);
  }
  return getSanitizerForConfig$LWS(sandboxKey$LWS, 'STRING_BLOB_HTML');
}
/*! version: 0.23.6 */

/*!
 * Copyright (C) 2023 salesforce.com, inc.
 */
const inflightRequests$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
async function getSourceText$LWS(resourceURL$LWS, targetElement$LWS) {
  abortInFlightRequest$LWS(targetElement$LWS);
  const controller$LWS = new AbortControllerCtor$LWS();
  inflightRequests$LWS.set(targetElement$LWS, controller$LWS);
  // The error "The value of the 'Access-Control-Allow-Origin' header in the
  // response must not be the wildcard '*' when the request's credentials mode
  // is 'include'" occurs when the Access-Control-Allow-Credentials header is
  // set to true and the Access-Control-Allow-Origin header is set to an asterisk *.
  //
  // The error may be resolved in one of two ways:
  //   1) Set the Access-Control-Allow-Credentials header to 'false' and keep
  //      the Access-Control-Allow-Origin header as an asterisk * to allow all
  //      origins to access your server.
  //   2) Set the Access-Control-Allow-Origin header to a specific origin,
  //      e.g. 'http://localhost:3000' or a list of allowlisted origins that
  //      are allowed to access your server. Note that the origin must specify
  //      the protocol, domain and port.
  const hostname$LWS = ReflectApply$LWS$1(HTMLAnchorElementProtoHostnameGetter$LWS, normalizerAnchor$LWS, []);
  // To avoid the CORS error above without burdening users with header adjustments
  // we limit credentials mode of 'include' to "trusted" domains.
  const credentials$LWS = ReflectApply$LWS$1(RegExpProtoTest$LWS$1, TRUSTED_DOMAINS_REG_EXP$LWS, [hostname$LWS]) ? 'include' : 'same-origin';
  const signal$LWS = ReflectApply$LWS$1(AbortControllerProtoSignalGetter$LWS, controller$LWS, []);
  const response$LWS = await WindowFetch$LWS(resourceURL$LWS, {
    __proto__: null,
    method: 'GET',
    credentials: credentials$LWS,
    signal: signal$LWS
  });
  inflightRequests$LWS.delete(targetElement$LWS);
  if (!ReflectApply$LWS$1(ResponseProtoOkGetter$LWS, response$LWS, [])) {
    throw new ErrorCtor$LWS$1('Request failed.');
  }
  const sourceText$LWS = await ReflectApply$LWS$1(ResponseProtoText$LWS, response$LWS, []);
  return sourceText$LWS;
}
function abortInFlightRequest$LWS(element$LWS) {
  const abortController$LWS = inflightRequests$LWS.get(element$LWS);
  // istanbul ignore if: currently unreachable via tests (this path can be invoked, however it will cause the tests to time out)
  if (abortController$LWS) {
    ReflectApply$LWS$1(AbortControllerProtoAbort$LWS, abortController$LWS, []);
  }
}
const EVALUATOR_PROPERTY_KEY$LWS = '$evaluator$';
const BLOB_SCRIPT_SOURCE$LWS = `document.currentScript['${EVALUATOR_PROPERTY_KEY$LWS}']`;

// eslint-disable-next-line no-shadow
var ContentType$LWS;
(function (ContentType$LWS) {
  ContentType$LWS[ContentType$LWS["HTML"] = 0] = "HTML";
  ContentType$LWS[ContentType$LWS["SVG"] = 1] = "SVG";
  ContentType$LWS[ContentType$LWS["XML"] = 2] = "XML";
})(ContentType$LWS || (ContentType$LWS = {}));
const evaluatedScripts$LWS = toSafeWeakSet$LWS$1(new WeakSetCtor$LWS$1());
const scriptURLsCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
const htmlTemplate$LWS = ReflectApply$LWS$1(DocumentProtoCreateElement$LWS$1, document, ['template']);
const policyOptions$LWS = {
  createHTML(dirty$LWS, lwsKey$LWS, contentType$LWS) {
    // istanbul ignore if: currently unreachable via tests, may indicate a dead code path
    if (dirty$LWS === null || dirty$LWS === undefined) {
      return '';
    }
    if (typeof lwsKey$LWS !== 'string') {
      throw new LockerSecurityError$LWS(ERR_INVALID_SANDBOX_KEY$LWS);
    }
    switch (contentType$LWS) {
      case ContentType$LWS.HTML:
        {
          ReflectApply$LWS$1(ElementProtoInnerHTMLSetter$LWS, htmlTemplate$LWS, [trusted.createHTML(dirty$LWS)]);
          const content$LWS = ReflectApply$LWS$1(HTMLTemplateElementProtoContentGetter$LWS, htmlTemplate$LWS, []);
          const sanitizer$LWS = getSanitizerForConfig$LWS(lwsKey$LWS, 'NODE_ALL_IN_PLACE');
          sanitizer$LWS.sanitize(content$LWS);
          return ReflectApply$LWS$1(ElementProtoInnerHTMLGetter$LWS, htmlTemplate$LWS, []);
        }
      case ContentType$LWS.SVG:
        {
          const tplElement$LWS = ReflectApply$LWS$1(DocumentProtoCreateElement$LWS$1, document, ['template']);
          ReflectApply$LWS$1(ElementProtoInnerHTMLSetter$LWS, tplElement$LWS, [trusted.createHTML(dirty$LWS)]);
          const wrappedDirty$LWS = ReflectApply$LWS$1(DocumentProtoCreateElementNS$LWS, document, [NAMESPACE_SVG$LWS, 'svg']);
          ReflectApply$LWS$1(ElementProtoInnerHTMLSetter$LWS, wrappedDirty$LWS, [trusted.createHTML(dirty$LWS)]);
          const sanitized$LWS = getSanitizerForConfig$LWS('SHARED_SVG_SANITIZER_KEY', 'NODE_SVG').sanitize(wrappedDirty$LWS);
          const firstChild$LWS = ReflectApply$LWS$1(NodeProtoFirstChildGetter$LWS, sanitized$LWS, []);
          return ReflectApply$LWS$1(ElementProtoInnerHTMLGetter$LWS, firstChild$LWS, []);
        }
      case ContentType$LWS.XML:
        return dirty$LWS;
      default:
        return '';
    }
  },
  createScript(_dirty$LWS, _evaluator$LWS) {
    return '';
  },
  createScriptURL(dirty$LWS, evaluator$LWS, targetElement$LWS) {
    const setURL$LWS = encloseSrcSetter$LWS(targetElement$LWS);
    dirty$LWS = `${dirty$LWS}`;
    // Passthrough for any script element evaluated by us
    // or if userland code tries to set a falsy value.
    if (evaluatedScripts$LWS.has(targetElement$LWS) || dirty$LWS === '' || dirty$LWS === 'undefined' || dirty$LWS === 'null') {
      setURL$LWS(trusted.createScriptURL(dirty$LWS));
      return dirty$LWS;
    }
    const targetElementIsConnected$LWS = ReflectApply$LWS$1(NodeProtoIsConnectedGetter$LWS, targetElement$LWS, []);
    const resolvedURL$LWS = resolveURL$LWS(dirty$LWS);
    if (targetElementIsConnected$LWS) {
      // When the script is connected and has a .src value it is safe to let the url passthrough
      // because it will never be evaluated again.
      if (getURL$LWS(targetElement$LWS)) {
        evaluatedScripts$LWS.add(targetElement$LWS);
        setURL$LWS(trusted.createScriptURL(dirty$LWS));
        return dirty$LWS;
      }
      // There is a small window while the source code is asynchronously fetched but the script may
      // have already been placed in the DOM without having yet our blob URL set as the .src value.
      // We block the request in this scenario and set the last URL after we evaluate.
      if (scriptURLsCache$LWS.has(targetElement$LWS)) {
        return '';
      }
    }
    const asyncRequest$LWS = getSourceText$LWS(resolvedURL$LWS, targetElement$LWS);
    scriptURLsCache$LWS.set(targetElement$LWS, resolvedURL$LWS);
    const safeURL$LWS = createSandboxURL$LWS();
    const onFulfill$LWS = sourceText$LWS => {
      ReflectDefineProperty$LWS$1(targetElement$LWS, EVALUATOR_PROPERTY_KEY$LWS, {
        __proto__: null,
        configurable: true,
        get: ReflectApply$LWS$1(FunctionProtoBind$LWS, () => {
          ReflectDeleteProperty$LWS$1(targetElement$LWS, EVALUATOR_PROPERTY_KEY$LWS);
          URLRevokeObjectURL$LWS(safeURL$LWS);
          const cachedURL$LWS = scriptURLsCache$LWS.get(targetElement$LWS);
          scriptURLsCache$LWS.delete(targetElement$LWS);
          evaluatedScripts$LWS.add(targetElement$LWS);
          // We sign & assign the original URL even though it will not be executed.
          // The wrappedEvaluator is guaranteed to run only one time once the script
          // is appended in the dom.
          // Re-assigning .src after it ran will not retrigger the evaluation
          // of the new URL.
          // However, TrustedTypes still requires this assignment to be signed.
          // We do this because we don't want to leave observable traces in the DOM.
          setURL$LWS(trusted.createScriptURL(cachedURL$LWS));
          evaluator$LWS(sourceText$LWS);
        }, [targetElement$LWS]),
        set: undefined
      });
      setURL$LWS(trusted.createScriptURL(safeURL$LWS));
    };
    const onReject$LWS = _error$LWS => {
      URLRevokeObjectURL$LWS(safeURL$LWS);
      const cachedURL$LWS = scriptURLsCache$LWS.get(targetElement$LWS);
      scriptURLsCache$LWS.delete(targetElement$LWS);
      // We are only able to generate 404 errors and we cannot trust any other URL.
      // This blob URL will be sufficient to trigger error event handlers.
      // We still have to sign this URL, TrustedTypes does not take into consideration
      // the state of the script elements. It's an either or operation: either we set a
      // signed value and we are ok or we don't and the browser throws an error. We
      // want our 404 URL to be set and trigger the event handlers, hence we have to sign.
      setURL$LWS(trusted.createScriptURL('blob:http://localhost/not-found'));
      // This error event handler will get triggered after we set our 404 blob URL.
      const errorEventHandler$LWS = () => {
        // Similar to our wrappedEvaluator, we leave no traces.
        setURL$LWS(trusted.createScriptURL(cachedURL$LWS));
        ReflectApply$LWS$1(EventTargetProtoRemoveEventListener$LWS, targetElement$LWS, ['error', errorEventHandler$LWS]);
      };
      ReflectApply$LWS$1(EventTargetProtoAddEventListener$LWS, targetElement$LWS, ['error', errorEventHandler$LWS]);
    };
    ReflectApply$LWS$1(PromiseProtoThen$LWS, asyncRequest$LWS, [onFulfill$LWS, onReject$LWS]);
    return '';
  }
};
const lwsInternalPolicy$LWS = createPolicy('lwsInternal', policyOptions$LWS);
// Even though the content is always the same we use unique URLs for each script.
function createSandboxURL$LWS() {
  return URLCreateObjectURL$LWS(new BlobCtor$LWS([BLOB_SCRIPT_SOURCE$LWS], {
    __proto__: null,
    type: 'text/javascript'
  }));
}
function getURL$LWS(targetElement$LWS) {
  const isHTMLScriptElement$LWS = targetElement$LWS instanceof HTMLScriptElementCtor$LWS;
  if (isHTMLScriptElement$LWS) {
    return ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, targetElement$LWS, ['src']);
  }
  const hasHref$LWS = ReflectApply$LWS$1(ElementProtoHasAttribute$LWS, targetElement$LWS, ['href']);
  return hasHref$LWS ? ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, targetElement$LWS, ['href']) : ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, targetElement$LWS, ['xlink:href']);
}
function encloseSrcSetter$LWS(targetElement$LWS) {
  const namespaceURI$LWS = ReflectApply$LWS$1(ElementProtoNamespaceURIGetter$LWS, targetElement$LWS, []);
  const attributeNamespaceURI$LWS = namespaceURI$LWS === NAMESPACE_XHTML$LWS ? '' : NAMESPACE_XLINK$LWS;
  const attributeName$LWS = targetElement$LWS instanceof HTMLScriptElementCtor$LWS ? 'src' : 'href';
  return function (src$LWS) {
    ReflectApply$LWS$1(ElementProtoSetAttributeNS$LWS, targetElement$LWS, [attributeNamespaceURI$LWS, attributeName$LWS, src$LWS]);
  };
}
/*! version: 0.23.6 */

/*!
 * Copyright (C) 2019 salesforce.com, inc.
 */
var _rootWindow$CustomEle$LWS;
const ERR_ILLEGAL_CONSTRUCTOR$LWS = 'Illegal constructor';
const ERR_ILLEGAL_INVOCATION$LWS = 'Illegal invocation.';
const ERR_NO_NEW_OP_HTML_ELEMENT$LWS = "Failed to construct 'HTMLElement': Please use the 'new' operator, this DOM object constructor cannot be called as a function.";
let currentRegistry$LWS;
let currentUpgradingInstance$LWS;
const definitionCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
const globalRegistryCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
const pivotCtorCache$LWS = toSafeMap$LWS$1(new MapCtor$LWS$1());
const sandboxRegistryCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
// istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
const CustomElementRegistryProto$LWS = (_rootWindow$CustomEle$LWS = rootWindow$LWS$1.CustomElementRegistry) == null ? void 0 : _rootWindow$CustomEle$LWS.prototype;
const CustomElementRegistryProtoDefine$LWS = CustomElementRegistryProto$LWS ? getUnmaskedFunction$LWS(CustomElementRegistryProto$LWS.define) : /* istanbul ignore next: this is a safety precaution that is unreachable via tests */undefined;
const CustomElementRegistryProtoWhenDefined$LWS = CustomElementRegistryProto$LWS ? getUnmaskedFunction$LWS(CustomElementRegistryProto$LWS.whenDefined) : /* istanbul ignore next: this is a safety precaution that is unreachable via tests */undefined;
const CustomElementRegistryProtoUpgrade$LWS = CustomElementRegistryProto$LWS ? getUnmaskedFunction$LWS(CustomElementRegistryProto$LWS.upgrade) : /* istanbul ignore next: this is a safety precaution that is unreachable via tests */undefined;
/* eslint-disable no-underscore-dangle */
class VirtualRegistry$LWS {
  constructor(document$LWS, originalHTMLElementCtor$LWS = getUnmaskedFunction$LWS(ReflectApply$LWS$1(DocumentProtoDefaultViewGetter$LWS, document$LWS, []).HTMLElement)) {
    this._awaitingUpgrade = toSafeMap$LWS$1(new MapCtor$LWS$1());
    this._definedCtors = toSafeSet$LWS(new SetCtor$LWS$1());
    this._definitionByElement = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
    this._definitionByTag = toSafeMap$LWS$1(new MapCtor$LWS$1());
    this._pendingRegistryByElement = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
    this._document = document$LWS;
    this._originalHTMLElementCtor = originalHTMLElementCtor$LWS;
  }
  applyDefine(cer$LWS, args$LWS) {
    const {
      0: tagName$LWS,
      1: LocalCtor$LWS,
      2: options$LWS
    } = args$LWS;
    if (options$LWS && options$LWS.extends) {
      throw new DOMExceptionCtor$LWS$1("NotSupportedError: 'extends' key in customElements.define() options is not supported.");
    }
    if (this._definitionByTag.has(tagName$LWS)) {
      throw new DOMExceptionCtor$LWS$1(`Failed to execute 'define' on 'CustomElementRegistry': the name "${tagName$LWS}" has already been used with this registry.`);
    }
    if (this._definedCtors.has(LocalCtor$LWS)) {
      throw new DOMExceptionCtor$LWS$1("Failed to execute 'define' on 'CustomElementRegistry': this constructor has already been used with this registry.");
    }
    const definition$LWS = getDefinitionForCtor$LWS(LocalCtor$LWS);
    let PivotCtor$LWS = pivotCtorCache$LWS.get(tagName$LWS);
    if (PivotCtor$LWS === undefined) {
      PivotCtor$LWS = createPivotingClass$LWS(this._document, this._originalHTMLElementCtor, definition$LWS, tagName$LWS);
      // Register a pivoting class which will handle global registry initializations.
      ReflectApply$LWS$1(CustomElementRegistryProtoDefine$LWS, cer$LWS, [tagName$LWS, PivotCtor$LWS]);
    } else {
      // When there is already a PivotCtor for the given tagName, we need to ensure that
      // this definition doesn't have a conflicting formAssociated value for that tagName.
      //
      // NOTE: This is always going to be a definition that's been passed through
      // createDefinitionRecord(), so it will always have either a true or false value
      // (there will never be a need to provide a default value here)
      const {
        formAssociated: formAssociated$LWS
      } = definition$LWS;
      if (PivotCtor$LWS.formAssociated !== formAssociated$LWS) {
        throw new LockerSecurityError$LWS(`Cannot create a definition for <${tagName$LWS}> with "formAssociated = ${formAssociated$LWS}". Either use "formAssociated = ${PivotCtor$LWS.formAssociated}" for this component or rename the component to not conflict with <${tagName$LWS}>`);
      }
    }
    // We MUST keep track of the constructor used to define custom elements
    // to prevent accidental re-use of constructors in userland code.
    //
    // Only cache AFTER `CustomElementRegistryProtoDefine` has been called
    // because if it throws an error (e.g. for an invalid tag name), then we
    // don't want to cache anything.
    pivotCtorCache$LWS.set(tagName$LWS, PivotCtor$LWS);
    definitionCache$LWS.set(LocalCtor$LWS, definition$LWS);
    this._definedCtors.add(LocalCtor$LWS);
    this._definitionByTag.set(tagName$LWS, definition$LWS);
    // For globally defined custom elements, the definition associated
    // with the `LocalCtor` has a back-pointer to `PivotCtor` in case the
    // user new's the `LocalCtor`, so we know how to create the underlying
    // element.
    definition$LWS.PivotCtor = PivotCtor$LWS;
    // Immediately upgrade any elements created in this scope before define was called,
    // e.g. LWC using a tagName in a template before the same tagName is
    // registered.
    const awaiting$LWS = this._awaitingUpgrade.get(tagName$LWS);
    if (awaiting$LWS) {
      awaiting$LWS.forEach(element$LWS => {
        const originalDefinition$LWS = this._pendingRegistryByElement.get(element$LWS);
        // istanbul ignore else: it is unnecessary to cover the else path here
        if (originalDefinition$LWS) {
          this._pendingRegistryByElement.delete(element$LWS);
          this.upgrade(element$LWS, originalDefinition$LWS, definition$LWS);
        }
      });
    }
  }
  applyGet(cer$LWS, args$LWS) {
    const tagName$LWS = args$LWS[0];
    const definition$LWS = this._definitionByTag.get(tagName$LWS);
    return definition$LWS ? definition$LWS.LocalCtor : undefined;
  }
  applyUpgrade(cer$LWS, args$LWS) {
    const element$LWS = args$LWS[0];
    const tagName$LWS = ReflectApply$LWS$1(ElementProtoTagNameGetter$LWS, element$LWS, []);
    const tagNameLowerCased$LWS = ReflectApply$LWS$1(StringProtoToLowerCase$LWS, tagName$LWS, []);
    const definition$LWS = this._definitionByTag.get(tagNameLowerCased$LWS);
    // There is no way to to tell `customElements.upgrade` which definition to use to upgrade,
    // so we're only using the definition as a check to make sure this sandbox actually has a
    // definition for the given not-yet-upgraded-element. Regardless of the code being run in a
    // sandbox, or not, when the browser invokes the process to upgrade, it will take our
    // patched path and the result will be the correct definition.
    if (definition$LWS) {
      ReflectApply$LWS$1(CustomElementRegistryProtoUpgrade$LWS, cer$LWS, [element$LWS]);
    }
  }
  applyWhenDefined(cer$LWS, args$LWS) {
    const tagName$LWS = args$LWS[0];
    const promise$LWS = ReflectApply$LWS$1(CustomElementRegistryProtoWhenDefined$LWS, cer$LWS, args$LWS);
    return new PromiseCtor$LWS((resolve$LWS, reject$LWS) => {
      ReflectApply$LWS$1(PromiseProtoThen$LWS, promise$LWS, [() => {
        const definition$LWS = this._definitionByTag.get(tagName$LWS);
        if (definition$LWS) {
          resolve$LWS(definition$LWS.LocalCtor);
        }
      }, reject$LWS]);
    });
  }
  getDefinition(instance$LWS) {
    return this._definitionByElement.get(instance$LWS);
  }
  newCtor(instance$LWS, newTarget$LWS, originalHTMLElementCtor$LWS) {
    // Upgrading case: the pivoting class constructor was run by the
    // browser's native custom elements and we're in the process of running
    // the "constructor call trick" on the natively constructed instance,
    // so just return that here.
    const pendingUpgrade$LWS = currentUpgradingInstance$LWS;
    if (pendingUpgrade$LWS) {
      currentUpgradingInstance$LWS = undefined;
      return pendingUpgrade$LWS;
    }
    // NOTE: This precaution is necessary because custom elements created outside
    // of the sandbox are not discoverable, which would result in a failure.
    // In case the custom element is not found, the code will automatically
    // resort to using the global custom element registry.
    // Construction case: We need to construct the pivoting instance and
    // return it. This is possible when the user instantiate it via
    // `new LocalCtor()`.
    const {
      constructor: LocalCtor$LWS
    } = instance$LWS;
    const definition$LWS = definitionCache$LWS.get(LocalCtor$LWS);
    if (definition$LWS === undefined || typeof definition$LWS.PivotCtor !== 'function') {
      // If we can get the tag name without triggering "Illegal invocation", then
      // it's plausible that this is an instance of a registered custom element
      // that was defined _before_ LWS was run. Attempting to invoke the getter
      // on an instance that wasn't constructed from a registered definition
      // will not have the Element prototype in its chain and will fail with
      // an "Illegal invocation" exception.
      try {
        ReflectApply$LWS$1(ElementProtoTagNameGetter$LWS, this, []);
        // istanbul ignore next: this is a safety precaution, not reachable via any normal execution
        return instance$LWS;
      } catch (_unused$LWS) {
        return ReflectConstruct$LWS(originalHTMLElementCtor$LWS, [], newTarget$LWS);
      }
    }
    // This constructor is ONLY invoked when it is the user instantiating
    // an element via `new LocalCtor(`) while `LocalCtor` is a locally
    // registered constructor.
    return new definition$LWS.PivotCtor(this, definition$LWS);
  }
  scheduleConnectedCallback(instance$LWS, tagName$LWS) {
    // Register for upgrade when defined (only when connected, so we don't leak).
    let awaiting$LWS = this._awaitingUpgrade.get(tagName$LWS);
    if (awaiting$LWS === undefined) {
      awaiting$LWS = toSafeSet$LWS(new SetCtor$LWS$1());
      this._awaitingUpgrade.set(tagName$LWS, awaiting$LWS);
    }
    awaiting$LWS.add(instance$LWS);
  }
  scheduleDisconnectedCallback(instance$LWS, tagName$LWS) {
    // Un-register for upgrade when defined (so we don't leak).
    const awaiting$LWS = this._awaitingUpgrade.get(tagName$LWS);
    // istanbul ignore else: currently unreachable via tests
    if (awaiting$LWS) {
      awaiting$LWS.delete(instance$LWS);
    }
  }
  scheduleOrUpgrade(instance$LWS, tagName$LWS, originalDefinition$LWS) {
    const definition$LWS = this._definitionByTag.get(tagName$LWS);
    if (definition$LWS) {
      // Browser's initiated a controlled instantiation where we
      // were able to set up the internal registry and the definition.
      this.upgrade(instance$LWS, originalDefinition$LWS, definition$LWS);
    } else {
      // This is the case in which there is no definition yet, and we
      // need to add it to the pending queue just in case it eventually
      // gets defined locally.
      this._pendingRegistryByElement.set(instance$LWS, originalDefinition$LWS);
      // We need to install the minimum HTMLElement prototype so that
      // this instance works like a regular element without a registered
      // definition. `instanceRegistryMap.get(this)!.upgrade()` will eventually
      // install the full custom element prototype.
      ReflectSetPrototypeOf$LWS$1(instance$LWS, this._originalHTMLElementCtor.prototype);
    }
  }
  setDefinition(instance$LWS, definition$LWS) {
    ReflectSetPrototypeOf$LWS$1(instance$LWS, definition$LWS.LocalCtor.prototype);
    this._definitionByElement.set(instance$LWS, definition$LWS);
  }
  // Helper to upgrade an instance with a custom element definition using the
  // "constructor call trick".
  upgrade(instance$LWS, originalDefinition$LWS, definition$LWS) {
    const {
      LocalCtor: LocalCtor$LWS,
      connectedCallback: connectedCallback$LWS
    } = definition$LWS;
    this.setDefinition(instance$LWS, definition$LWS);
    // This path will be taken when any _globally_ registered tag name has
    // more than one possible definition. See explanation at `patchAttributes()`.
    if (definition$LWS !== originalDefinition$LWS) {
      patchAttributes$LWS(instance$LWS, originalDefinition$LWS, definition$LWS);
    }
    // Tricking the construction path to believe that a new instance is being
    // created, that way it will execute the super initialization mechanism
    // but the HTMLElement constructor will reuse the instance by returning
    // the `currentUpgradingInstance`. This is by far the most important piece
    // of the puzzle.
    currentUpgradingInstance$LWS = instance$LWS;
    ReflectConstruct$LWS(LocalCtor$LWS, []);
    const tagName$LWS = ReflectApply$LWS$1(ElementProtoTagNameGetter$LWS, instance$LWS, []);
    const tagNameLowerCased$LWS = ReflectApply$LWS$1(StringProtoToLowerCase$LWS, tagName$LWS, []);
    const awaiting$LWS = this._awaitingUpgrade.get(tagNameLowerCased$LWS);
    if (awaiting$LWS && awaiting$LWS.size) {
      triggerAttributeChangedCallbackDuringUpgrade$LWS(instance$LWS, originalDefinition$LWS);
      // @TODO: Maybe this should only be done when there is something
      // awaiting upgrade?
      // `awaiting` is a safe Set.
      const needsConnectedCallback$LWS = awaiting$LWS.has(instance$LWS);
      // istanbul ignore else: currently unreachable via tests
      if (needsConnectedCallback$LWS && ReflectApply$LWS$1(NodeProtoIsConnectedGetter$LWS, instance$LWS, [])) {
        if (typeof connectedCallback$LWS === 'function') {
          ReflectApply$LWS$1(connectedCallback$LWS, instance$LWS, []);
        }
        awaiting$LWS.delete(instance$LWS);
        if (!awaiting$LWS.size) {
          this._awaitingUpgrade.delete(tagNameLowerCased$LWS);
        }
      }
    }
  }
}
/* eslint-enable no-underscore-dangle */
function createDefinitionRecord$LWS(LocalCtor$LWS) {
  let attributeChangedCallback$LWS, formAssociatedCallback$LWS, formDisabledCallback$LWS, formResetCallback$LWS, formStateRestoreCallback$LWS;
  const {
    formAssociated: formAssociated$LWS = false,
    observedAttributes: observedAttributesIterable$LWS,
    prototype: LocalCtorProto$LWS
  } = LocalCtor$LWS;
  const {
    adoptedCallback: adoptedCallback$LWS,
    connectedCallback: connectedCallback$LWS,
    disconnectedCallback: disconnectedCallback$LWS
  } = LocalCtorProto$LWS;
  if (formAssociated$LWS) {
    ({
      formAssociatedCallback: formAssociatedCallback$LWS,
      formDisabledCallback: formDisabledCallback$LWS,
      formResetCallback: formResetCallback$LWS,
      formStateRestoreCallback: formStateRestoreCallback$LWS
    } = LocalCtorProto$LWS);
  }
  // Step 14 > Step 5 > Step 2
  // Convert the iterable into an array.
  // https://html.spec.whatwg.org/multipage/custom-elements.html#dom-customelementregistry-define
  let observedAttributes$LWS = observedAttributesIterable$LWS ? [...observedAttributesIterable$LWS] : undefined;
  if (observedAttributes$LWS && !observedAttributes$LWS.length) {
    observedAttributes$LWS = undefined;
  }
  if (observedAttributes$LWS) {
    ({
      attributeChangedCallback: attributeChangedCallback$LWS
    } = LocalCtorProto$LWS);
    if (typeof attributeChangedCallback$LWS !== 'function') {
      attributeChangedCallback$LWS = undefined;
      observedAttributes$LWS = undefined;
    }
  }
  return {
    LocalCtor: LocalCtor$LWS,
    PivotCtor: undefined,
    formAssociated: formAssociated$LWS,
    observedAttributes: observedAttributes$LWS,
    // The set variation of the observedAttributes array used for faster lookups.
    observedAttributesAsSet: observedAttributes$LWS ? toSafeSet$LWS(new SetCtor$LWS$1(observedAttributes$LWS)) : undefined,
    adoptedCallback: typeof adoptedCallback$LWS === 'function' ? adoptedCallback$LWS : undefined,
    attributeChangedCallback: attributeChangedCallback$LWS,
    connectedCallback: typeof connectedCallback$LWS === 'function' ? connectedCallback$LWS : undefined,
    disconnectedCallback: typeof disconnectedCallback$LWS === 'function' ? disconnectedCallback$LWS : undefined,
    formAssociatedCallback: typeof formAssociatedCallback$LWS === 'function' ? formAssociatedCallback$LWS : undefined,
    formDisabledCallback: typeof formDisabledCallback$LWS === 'function' ? formDisabledCallback$LWS : undefined,
    formResetCallback: typeof formResetCallback$LWS === 'function' ? formResetCallback$LWS : undefined,
    formStateRestoreCallback: typeof formStateRestoreCallback$LWS === 'function' ? formStateRestoreCallback$LWS : undefined
  };
}
const instanceRegistryMap$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
// Helper to create stand-in element for each tagName registered that delegates
// out to the registry for the given element.
function createPivotingClass$LWS(document$LWS, originalHTMLElementCtor$LWS,
// This is the definition based on the LocalCtor the user code provided to
// `customElements.define(tagName, definition)`.
originalDefinition$LWS, tagName$LWS) {
  var _a$LWS;
  return _a$LWS = class PivotCtor$LWS extends originalHTMLElementCtor$LWS {
    constructor(localRegistry$LWS, definition$LWS) {
      // This constructor can only be invoked by:
      // a) The browser instantiating  an element from parsing or via
      //    `document.createElement()`.
      // b) A `new LocalCtor()` call from the blue realm (system mode).
      // c) A `new LocalCtor()` call from the red realm (sandbox).
      super();
      let instanceRegistry$LWS;
      if (localRegistry$LWS && definition$LWS) {
        instanceRegistry$LWS = localRegistry$LWS;
        localRegistry$LWS.setDefinition(this, definition$LWS);
      } else {
        instanceRegistry$LWS =
        // Usually `el.innerHTML` or any other parsing driven
        // initialization.
        getNodeRegistry$LWS(document$LWS, this) ||
        // Usually `document.createElement()`,
        // or any DOM API that has been patched to call
        // `setCustomElementsRegistry(globalObject, key)`
        // prior to element creation.
        getCurrentRegistry$LWS() ||
        // Global stuff.
        getGlobalCustomElementRegistry$LWS(document$LWS, originalHTMLElementCtor$LWS);
        instanceRegistry$LWS.scheduleOrUpgrade(this, tagName$LWS, originalDefinition$LWS);
      }
      instanceRegistryMap$LWS.set(this, instanceRegistry$LWS);
    }
    adoptedCallback() {
      const definition$LWS = instanceRegistryMap$LWS.get(this).getDefinition(this);
      const adoptedCallback$LWS = definition$LWS && definition$LWS.adoptedCallback;
      // istanbul ignore else: currently unreachable via tests
      if (adoptedCallback$LWS) {
        ReflectApply$LWS$1(adoptedCallback$LWS, this, []);
      }
    }
    attributeChangedCallback(attrName$LWS, oldValue$LWS, newValue$LWS) {
      const definition$LWS = instanceRegistryMap$LWS.get(this).getDefinition(this);
      const attributeChangedCallback$LWS = definition$LWS && definition$LWS.attributeChangedCallback;
      if (attributeChangedCallback$LWS && (
      // If both definitions are the same, then the observedAttributes
      // is the same, but if they are different and only if the
      // runtime definition has the attribute marked as observed,
      // then it should invoke attributeChangedCallback.
      originalDefinition$LWS === definition$LWS || definition$LWS.observedAttributesAsSet.has(attrName$LWS))) {
        ReflectApply$LWS$1(attributeChangedCallback$LWS, this, [attrName$LWS, oldValue$LWS, newValue$LWS]);
      }
    }
    connectedCallback() {
      const instanceRegistry$LWS = instanceRegistryMap$LWS.get(this);
      const definition$LWS = instanceRegistry$LWS.getDefinition(this);
      if (definition$LWS) {
        const {
          connectedCallback: connectedCallback$LWS
        } = definition$LWS;
        if (connectedCallback$LWS) {
          ReflectApply$LWS$1(connectedCallback$LWS, this, []);
        }
      } else {
        instanceRegistry$LWS.scheduleConnectedCallback(this, tagName$LWS);
      }
    }
    disconnectedCallback() {
      const instanceRegistry$LWS = instanceRegistryMap$LWS.get(this);
      const definition$LWS = instanceRegistry$LWS.getDefinition(this);
      if (definition$LWS) {
        const {
          disconnectedCallback: disconnectedCallback$LWS
        } = definition$LWS;
        if (disconnectedCallback$LWS) {
          ReflectApply$LWS$1(disconnectedCallback$LWS, this, []);
        }
      } else {
        instanceRegistry$LWS.scheduleDisconnectedCallback(this, tagName$LWS);
      }
    }
    formAssociatedCallback(form$LWS) {
      const definition$LWS = instanceRegistryMap$LWS.get(this).getDefinition(this);
      const formAssociatedCallback$LWS = definition$LWS && definition$LWS.formAssociatedCallback;
      if (formAssociatedCallback$LWS) {
        ReflectApply$LWS$1(formAssociatedCallback$LWS, this, [form$LWS]);
      }
    }
    formDisabledCallback(disabled$LWS) {
      const definition$LWS = instanceRegistryMap$LWS.get(this).getDefinition(this);
      const formDisabledCallback$LWS = definition$LWS && definition$LWS.formDisabledCallback;
      if (formDisabledCallback$LWS) {
        ReflectApply$LWS$1(formDisabledCallback$LWS, this, [disabled$LWS]);
      }
    }
    formResetCallback() {
      const definition$LWS = instanceRegistryMap$LWS.get(this).getDefinition(this);
      const formResetCallback$LWS = definition$LWS && definition$LWS.formResetCallback;
      if (formResetCallback$LWS) {
        ReflectApply$LWS$1(formResetCallback$LWS, this, []);
      }
    }
    // istanbul ignore next: currently unreachable via tests because the browser mechanics that would result in its execution cannot be simulated or reproduced.
    formStateRestoreCallback(state$LWS, reason$LWS) {
      const definition$LWS = instanceRegistryMap$LWS.get(this).getDefinition(this);
      const formStateRestoreCallback$LWS = definition$LWS && definition$LWS.formStateRestoreCallback;
      if (formStateRestoreCallback$LWS) {
        ReflectApply$LWS$1(formStateRestoreCallback$LWS, this, [state$LWS, reason$LWS]);
      }
    }
  },
  // This ensures that the first-come definition for the given tagName gets
  // to define the formAssociated-ness of the tag. In the likely case
  // that formAssociated is not explicitly defined, coerce the "undefined"
  // value to a boolean to ensure we get a true or false.
  _a$LWS.formAssociated = Boolean(originalDefinition$LWS.formAssociated), _a$LWS.observedAttributes = originalDefinition$LWS.observedAttributes ? shallowCloneArray$LWS(originalDefinition$LWS.observedAttributes) : [], _a$LWS;
}
function getCurrentRegistry$LWS() {
  const registry$LWS = currentRegistry$LWS;
  currentRegistry$LWS = undefined;
  return registry$LWS;
}
function getDefinitionForCtor$LWS(LocalCtor$LWS) {
  const proto$LWS = typeof LocalCtor$LWS === 'function' ? LocalCtor$LWS.prototype : undefined;
  if (!isObject$LWS$1(proto$LWS)) {
    throw new TypeErrorCtor$LWS$1('Invalid custom element constructor.');
  }
  let definition$LWS = definitionCache$LWS.get(LocalCtor$LWS);
  // istanbul ignore else: getDefinitionForCtor is only called after a this._definedCtors.has(LocalCtor) check, which would throw if LocalCtor already existed. this._definedCtors & definitionCache are updated at the same time.
  if (definition$LWS === undefined) {
    definition$LWS = createDefinitionRecord$LWS(LocalCtor$LWS);
    definitionCache$LWS.set(LocalCtor$LWS, definition$LWS);
  }
  // istanbul ignore next: this is a safety precaution, not reachable via any normal execution
  return definition$LWS;
}
function getGlobalCustomElementRegistry$LWS(document$LWS, originalHTMLElementCtor$LWS) {
  let registry$LWS = globalRegistryCache$LWS.get(document$LWS);
  if (registry$LWS) {
    return registry$LWS;
  }
  registry$LWS = new VirtualRegistry$LWS(document$LWS, originalHTMLElementCtor$LWS);
  globalRegistryCache$LWS.set(document$LWS, registry$LWS);
  return registry$LWS;
}
function getNodeRegistry$LWS(document$LWS, node$LWS) {
  const key$LWS = ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, node$LWS, [CUSTOM_ELEMENT_REGISTRY_ATTRIBUTE_NAME$LWS]);
  if (key$LWS === null) {
    return undefined;
  }
  ReflectApply$LWS$1(ElementProtoRemoveAttribute$LWS, node$LWS, [CUSTOM_ELEMENT_REGISTRY_ATTRIBUTE_NAME$LWS]);
  const ownerDoc$LWS = ReflectApply$LWS$1(NodeProtoOwnerDocumentGetter$LWS, node$LWS, []);
  // istanbul ignore if: it's unclear how this could actually happen, if the node is coming from parsed/sanitized html.
  if (ownerDoc$LWS !== document$LWS) {
    // This is an extra restriction when the node is coming from a different
    // document. @TODO: We're sure how they can achieve this, but just being
    // defensive.
    return undefined;
  }
  const registries$LWS = sandboxRegistryCache$LWS.get(document$LWS);
  return registries$LWS ? registries$LWS.get(key$LWS) : /* istanbul ignore next: currently unreachable via tests */undefined;
}
function getObservedAttributesDifference$LWS(originalDefinition$LWS, definition$LWS) {
  // Natively, the attributes observed by the original definition are going to
  // be taken care of by the browser, only the difference between the two sets
  // has to be taken care by the patched version.
  const {
    observedAttributes: observedAttributes$LWS
  } = definition$LWS;
  // istanbul ignore if: this is a safety precaution that is unreachable via tests
  if (originalDefinition$LWS === definition$LWS || observedAttributes$LWS === undefined) {
    return undefined;
  }
  const {
    observedAttributesAsSet: originalObservedAttributesAsSet$LWS
  } = originalDefinition$LWS;
  if (originalObservedAttributesAsSet$LWS === undefined) {
    return toSafeSet$LWS(new SetCtor$LWS$1(observedAttributes$LWS));
  }
  const difference$LWS = toSafeSet$LWS(new SetCtor$LWS$1());
  for (let i$LWS = 0, {
      length: length$LWS
    } = observedAttributes$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const attrName$LWS = observedAttributes$LWS[i$LWS];
    if (!originalObservedAttributesAsSet$LWS.has(attrName$LWS)) {
      difference$LWS.add(attrName$LWS);
    }
  }
  return difference$LWS;
}
// Patches removeAttribute, setAttribute, toggleAttribute to ensure correctness
// of attributeChangedCallback when more than one definition is registered for a
// given tag name. There can be only one tag name + definition per sandbox, but
// multiple sandboxes may define custom elements with the same tag name. Since
// the first definition locks up the observedAttributes with its list, all
// following definitions must have their instances patched to correctly fire
// attributeChangedCallback on attributes that are listed in those subsequent
// custom elements observedAttributes.
function patchAttributes$LWS(instance$LWS, originalDefinition$LWS, definition$LWS) {
  const {
    attributeChangedCallback: attributeChangedCallback$LWS
  } = definition$LWS;
  // istanbul ignore if: there is no way to test that nothing happens when this condition is met
  if (attributeChangedCallback$LWS === undefined) {
    return;
  }
  const observedAttributesDifference$LWS = getObservedAttributesDifference$LWS(originalDefinition$LWS, definition$LWS);
  // If there are no unique attributes to observe, then there is no need to
  // patch removeAttribute, setAttribute and toggleAttribute
  // istanbul ignore if: there is no way to test that nothing happens when this condition is met
  if (observedAttributesDifference$LWS === undefined) {
    return;
  }
  instance$LWS.removeAttribute = maskFunction$LWS(function removeAttribute$LWS(attrName$LWS) {
    const args$LWS = [attrName$LWS];
    // `observedAttributesDifference` is a safe Set.
    if (observedAttributesDifference$LWS.has(attrName$LWS)) {
      const old$LWS = ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, this, args$LWS);
      ReflectApply$LWS$1(ElementProtoRemoveAttribute$LWS, this, args$LWS);
      args$LWS[1] = old$LWS;
      args$LWS[2] = null;
      ReflectApply$LWS$1(attributeChangedCallback$LWS, this, args$LWS);
    } else {
      ReflectApply$LWS$1(ElementProtoRemoveAttribute$LWS, this, args$LWS);
    }
  }, ElementProtoRemoveAttribute$LWS);
  instance$LWS.setAttribute = maskFunction$LWS(function setAttribute$LWS(attrName$LWS, value$LWS) {
    const args$LWS = [attrName$LWS];
    const stringifiedValue$LWS = toSafeStringValue$LWS(value$LWS);
    const setAttributeArgs$LWS = [attrName$LWS, stringifiedValue$LWS];
    // `observedAttributesDifference` is a safe Set.
    if (observedAttributesDifference$LWS.has(attrName$LWS)) {
      const old$LWS = ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, this, args$LWS);
      ReflectApply$LWS$1(ElementProtoSetAttribute$LWS$1, this, setAttributeArgs$LWS);
      args$LWS[1] = old$LWS;
      args$LWS[2] = stringifiedValue$LWS;
      ReflectApply$LWS$1(attributeChangedCallback$LWS, this, args$LWS);
    } else {
      ReflectApply$LWS$1(ElementProtoSetAttribute$LWS$1, this, setAttributeArgs$LWS);
    }
  }, ElementProtoSetAttribute$LWS$1);
  instance$LWS.toggleAttribute = maskFunction$LWS(function toggleAttribute$LWS(attrName$LWS) {
    const args$LWS = [attrName$LWS];
    let returnValue$LWS;
    // `observedAttributesDifference` is a safe Set.
    if (observedAttributesDifference$LWS.has(attrName$LWS)) {
      const hasAttribute$LWS = ReflectApply$LWS$1(ElementProtoHasAttribute$LWS, this, args$LWS);
      const old$LWS = hasAttribute$LWS ? ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, this, args$LWS) : null;
      returnValue$LWS = ReflectApply$LWS$1(ElementProtoToggleAttribute$LWS, this, args$LWS);
      args$LWS[1] = old$LWS;
      if (hasAttribute$LWS) {
        args$LWS[2] = null;
      }
      ReflectApply$LWS$1(attributeChangedCallback$LWS, this, args$LWS);
    } else {
      returnValue$LWS = ReflectApply$LWS$1(ElementProtoToggleAttribute$LWS, this, args$LWS);
    }
    return returnValue$LWS;
  }, ElementProtoToggleAttribute$LWS);
  // `observedAttributesDifference` is a safe Set.
  for (const originalAttrName$LWS of observedAttributesDifference$LWS) {
    // Here we're ensuring support for attributes which have very explicit
    // names that differ from their property name:
    //
    // "accesskey" -> "accessKey"
    // "contenteditable" -> "contentEditable"
    // "tabindex" -> "tabIndex"
    //
    // As well as all of the aria-* properties
    //
    const attrPropName$LWS = HTMLElementGlobalAttributesToPropertyName$LWS[originalAttrName$LWS] || ElementAriaAttributesToPropertyName$LWS[originalAttrName$LWS] || originalAttrName$LWS;
    if (attrPropName$LWS in instance$LWS) {
      ReflectDefineProperty$LWS$1(instance$LWS, attrPropName$LWS, {
        __proto__: null,
        enumerable: true,
        configurable: true,
        get() {
          return ReflectGet$LWS(ReflectGetPrototypeOf$LWS$1(this), attrPropName$LWS, this);
        },
        set(value$LWS) {
          // This is necessary for both comparing the old attribute
          // value to the new attribute value and then for use in the
          // arguments that are passed to attributeChangedCallback.
          const oldValue$LWS = ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, this, [originalAttrName$LWS]);
          // Because property assignment to special built-in setters
          // may have "magic" behavior to determine the actual value
          // that gets set, we need to invoke the original setter,
          // then get the new attribute value for comparison.
          // If _that_ value is different from the old value, then we
          // trigger the attributeChangedCallback
          // ReflectApply(originalSetter, this, [value]);
          ReflectSet$LWS(ReflectGetPrototypeOf$LWS$1(this), attrPropName$LWS, value$LWS, this);
          const newValue$LWS = ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, this, [originalAttrName$LWS]);
          if (oldValue$LWS !== newValue$LWS) {
            ReflectApply$LWS$1(attributeChangedCallback$LWS, this, [originalAttrName$LWS, oldValue$LWS, newValue$LWS]);
          }
        }
      });
    }
  }
}
function patchCustomElementRegistry$LWS(globalObject$LWS, registry$LWS) {
  const {
    CustomElementRegistry: {
      prototype: globalCustomElementRegistryProto$LWS
    },
    customElements: customElements$LWS
  } = globalObject$LWS;
  const {
    define: originalDefine$LWS,
    get: originalGet$LWS,
    upgrade: originalUpgrade$LWS,
    whenDefined: originalWhenDefined$LWS
  } = globalCustomElementRegistryProto$LWS;
  globalCustomElementRegistryProto$LWS.define = maskFunction$LWS(function define$LWS(...args$LWS) {
    if (this !== customElements$LWS) {
      // This is more restricted than native behavior because
      // in native this is normally a runtime error when
      // attempting to define a class that setDefinition from a
      // constructor from another window. But right now, we
      // don't know how to do this runtime check, the safe bet
      // is to throw here.
      throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_INVOCATION$LWS);
    }
    return registry$LWS.applyDefine(this, args$LWS);
  }, originalDefine$LWS, createUnmaskableTraps$LWS(originalDefine$LWS));
  globalCustomElementRegistryProto$LWS.get = maskFunction$LWS(function get$LWS(...args$LWS) {
    if (this !== customElements$LWS) {
      // This is more restricted than native behavior because
      // in native this is going to leak constructors from
      // another windows. But right now, we don't know the
      // implications yet, the safe bet is to throw here.
      // @TODO: This could leak pivots from another document,
      // that's the concern.
      throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_INVOCATION$LWS);
    }
    return registry$LWS.applyGet(this, args$LWS);
  }, originalGet$LWS, createUnmaskableTraps$LWS(originalGet$LWS));
  globalCustomElementRegistryProto$LWS.upgrade = maskFunction$LWS(function upgrade$LWS(...args$LWS) {
    if (this !== customElements$LWS) {
      // This is more restricted than native behavior because
      // in native this is going to leak constructors from
      // another windows. But right now, we don't know the
      // implications yet, the safe bet is to throw here.
      // @TODO: This could leak pivots from another document,
      // that's the concern.
      throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_INVOCATION$LWS);
    }
    registry$LWS.applyUpgrade(this, args$LWS);
  }, originalUpgrade$LWS, createUnmaskableTraps$LWS(originalUpgrade$LWS));
  globalCustomElementRegistryProto$LWS.whenDefined = maskFunction$LWS(function whenDefined$LWS(...args$LWS) {
    if (this !== customElements$LWS) {
      // This is more restricted than native behavior because in native
      // this is going to leak constructors from another windows when
      // defined. But right now, we don't know the implications yet, the
      // safe bet is to throw here.
      // @TODO: Maybe returning a promise that never fulfills is better.
      return PromiseReject$LWS(new TypeErrorCtor$LWS$1(ERR_ILLEGAL_INVOCATION$LWS));
    }
    return registry$LWS.applyWhenDefined(this, args$LWS);
  }, originalWhenDefined$LWS, createUnmaskableTraps$LWS(originalWhenDefined$LWS));
}
function patchHTMLElement$LWS(globalObject$LWS, registry$LWS) {
  const {
    HTMLElement: originalHTMLElementCtor$LWS
  } = globalObject$LWS;
  globalObject$LWS.HTMLElement = maskFunction$LWS(function HTMLElement$LWS() {
    if (new.target === undefined) {
      throw new TypeErrorCtor$LWS$1(ERR_NO_NEW_OP_HTML_ELEMENT$LWS);
    }
    if (new.target === HTMLElement$LWS) {
      throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_CONSTRUCTOR$LWS);
    }
    return registry$LWS.newCtor(this, new.target, originalHTMLElementCtor$LWS);
  }, originalHTMLElementCtor$LWS, createUnmaskableTraps$LWS(originalHTMLElementCtor$LWS));
}
function triggerAttributeChangedCallbackDuringUpgrade$LWS(instance$LWS, originalDefinition$LWS) {
  // The below case patches observed attributes for the case where the HTML
  // element is upgraded from a pre-existing one in the DOM.
  const {
    attributeChangedCallback: attributeChangedCallback$LWS
  } = originalDefinition$LWS;
  // istanbul ignore if: current tests have no way of expressing a state that would cause this condition to evaluate true
  if (attributeChangedCallback$LWS === undefined) {
    return;
  }
  // Approximate observedAttributes from the user class, but only for the
  // new observed attributes.
  const {
    observedAttributes: observedAttributes$LWS
  } = originalDefinition$LWS;
  for (let i$LWS = 0, {
      length: length$LWS
    } = observedAttributes$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const attrName$LWS = observedAttributes$LWS[i$LWS];
    if (ReflectApply$LWS$1(ElementProtoHasAttribute$LWS, instance$LWS, [attrName$LWS])) {
      const newValue$LWS = ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, instance$LWS, [attrName$LWS]);
      ReflectApply$LWS$1(attributeChangedCallback$LWS, instance$LWS, [attrName$LWS, null, newValue$LWS]);
    }
  }
}
function getSandboxCustomElementRegistry$LWS(document$LWS, key$LWS) {
  let registries$LWS = sandboxRegistryCache$LWS.get(document$LWS);
  if (registries$LWS === undefined) {
    registries$LWS = toSafeMap$LWS$1(new MapCtor$LWS$1());
    sandboxRegistryCache$LWS.set(document$LWS, registries$LWS);
  }
  let registry$LWS = registries$LWS.get(key$LWS);
  if (registry$LWS) {
    return registry$LWS;
  }
  registry$LWS = new VirtualRegistry$LWS(document$LWS);
  registries$LWS.set(key$LWS, registry$LWS);
  return registry$LWS;
}
function patchGlobalObject$LWS(globalObject$LWS, /* istanbul ignore next: function is never called without a document */
document$LWS = globalObject$LWS.document) {
  const {
    HTMLElement: HTMLElementCtor$LWS
  } = globalObject$LWS;
  const isHTMLElementCtorPatched$LWS = isMaskedFunction$LWS(HTMLElementCtor$LWS);
  const isCustomElementRegistryPatched$LWS = isMaskedFunction$LWS(globalObject$LWS.CustomElementRegistry.prototype.get);
  const registry$LWS = !isHTMLElementCtorPatched$LWS || !isCustomElementRegistryPatched$LWS ? getGlobalCustomElementRegistry$LWS(document$LWS, getUnmaskedFunction$LWS(HTMLElementCtor$LWS)) : undefined;
  if (!isHTMLElementCtorPatched$LWS) {
    patchHTMLElement$LWS(globalObject$LWS, registry$LWS);
  }
  if (!isCustomElementRegistryPatched$LWS) {
    patchCustomElementRegistry$LWS(globalObject$LWS, registry$LWS);
  }
}
// This function is to be used by other distortions to prepare this library
// before creating a custom element using a native mechanism, so the key is in
// place for the internal registry.
function setCustomElementsRegistry$LWS(document$LWS, key$LWS) {
  currentRegistry$LWS = getSandboxCustomElementRegistry$LWS(document$LWS, key$LWS);
}
const DataTransferBlockedProperties$LWS = ['mozCursor', 'mozSourceNode', 'mozUserCancelled'];
const elementShadowRootBySandboxKeyRegistry$LWS = {
  __proto__: null
};
function registerShadowRootInSandbox$LWS(sandboxKey$LWS, shadowRoot$LWS) {
  const {
    [sandboxKey$LWS]: elementShadowRootRegistry$LWS = toSafeWeakSet$LWS$1(new WeakSetCtor$LWS$1())
  } = elementShadowRootBySandboxKeyRegistry$LWS;
  elementShadowRootRegistry$LWS.add(shadowRoot$LWS);
  if (!elementShadowRootBySandboxKeyRegistry$LWS[sandboxKey$LWS]) {
    elementShadowRootBySandboxKeyRegistry$LWS[sandboxKey$LWS] = elementShadowRootRegistry$LWS;
  }
}
function isShadowRootAccessibleInThisSandbox$LWS(sandboxKey$LWS, shadowRoot$LWS) {
  const elementShadowRootRegistry$LWS = elementShadowRootBySandboxKeyRegistry$LWS[sandboxKey$LWS];
  if (!elementShadowRootRegistry$LWS) {
    return false;
  }
  return elementShadowRootRegistry$LWS.has(shadowRoot$LWS);
}
function isContainerWithinAShadowRootAccessibleInThisSandbox$LWS(key$LWS, container$LWS) {
  let parentNode$LWS = container$LWS;
  do {
    if (isShadowRootAccessibleInThisSandbox$LWS(key$LWS, parentNode$LWS)) {
      return true;
    }
  } while (parentNode$LWS = ReflectApply$LWS$1(NodeProtoParentNodeGetter$LWS, parentNode$LWS, []));
  return false;
}
function initDistortionAbstractRangeEndContainerGetter$LWS({
  globalObject: {
    AbstractRange: AbstractRange$LWS
  }
}) {
  const originalEndContainerGetter$LWS = ObjectLookupOwnGetter$LWS$1(AbstractRange$LWS.prototype, 'endContainer');
  return function distortionEndContainerGetter$LWS({
    key: key$LWS
  }) {
    return [originalEndContainerGetter$LWS, function endContainer$LWS() {
      const realEndContainer$LWS = ReflectApply$LWS$1(originalEndContainerGetter$LWS, this, []);
      return isContainerWithinAShadowRootAccessibleInThisSandbox$LWS(key$LWS, realEndContainer$LWS) ? realEndContainer$LWS : null;
    }];
  };
}
function initDistortionAbstractRangeStartContainerGetter$LWS({
  globalObject: {
    AbstractRange: AbstractRange$LWS
  }
}) {
  const originalStartContainerGetter$LWS = ObjectLookupOwnGetter$LWS$1(AbstractRange$LWS.prototype, 'startContainer');
  return function distortionStartContainerGetter$LWS({
    key: key$LWS
  }) {
    return [originalStartContainerGetter$LWS, function startContainer$LWS() {
      const realStartContainer$LWS = ReflectApply$LWS$1(originalStartContainerGetter$LWS, this, []);
      return isContainerWithinAShadowRootAccessibleInThisSandbox$LWS(key$LWS, realStartContainer$LWS) ? realStartContainer$LWS : null;
    }];
  };
}
const attributeDistortionFactoriesCache$LWS = toSafeMap$LWS$1(new MapCtor$LWS$1());
const sandboxAttributeDistortionRegistryCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
function finalizeAttributeDistortions$LWS(record$LWS) {
  const attributeFactories$LWS = attributeDistortionFactoriesCache$LWS.get(record$LWS);
  // istanbul ignore if: currently unreachable via tests
  if (attributeFactories$LWS === undefined) {
    return;
  }
  attributeDistortionFactoriesCache$LWS.delete(record$LWS);
  const {
    document: document$LWS,
    key: key$LWS
  } = record$LWS;
  let sandboxAttributeDistortionRegistry$LWS = sandboxAttributeDistortionRegistryCache$LWS.get(document$LWS);
  if (sandboxAttributeDistortionRegistry$LWS === undefined) {
    sandboxAttributeDistortionRegistry$LWS = {
      __proto__: null
    };
    sandboxAttributeDistortionRegistryCache$LWS.set(document$LWS, sandboxAttributeDistortionRegistry$LWS);
  }
  const attributeDistortionRegistry$LWS = {
    __proto__: null
  };
  sandboxAttributeDistortionRegistry$LWS[key$LWS] = attributeDistortionRegistry$LWS;
  for (let i$LWS = 0, {
      length: length$LWS
    } = attributeFactories$LWS; i$LWS < length$LWS; i$LWS += 1) {
    attributeFactories$LWS[i$LWS](attributeDistortionRegistry$LWS);
  }
}
function getAttributeDistortion$LWS(record$LWS, element$LWS, attrName$LWS, attributeNamespace$LWS = NAMESPACE_DEFAULT$LWS) {
  const {
    document: document$LWS,
    key: key$LWS
  } = record$LWS;
  const sandboxAttributeDistortionRegistry$LWS = sandboxAttributeDistortionRegistryCache$LWS.get(document$LWS);
  // istanbul ignore if: currently unreachable via tests
  if (sandboxAttributeDistortionRegistry$LWS === undefined) {
    return undefined;
  }
  const attributeDistortionRegistry$LWS = sandboxAttributeDistortionRegistry$LWS[key$LWS];
  // istanbul ignore if: currently unreachable via tests
  if (attributeDistortionRegistry$LWS === undefined) {
    return undefined;
  }
  const elementCtorMapByAttributeNamespaceRegistry$LWS = attributeDistortionRegistry$LWS[ReflectApply$LWS$1(StringProtoToLowerCase$LWS, attrName$LWS, [])];
  if (elementCtorMapByAttributeNamespaceRegistry$LWS === undefined) {
    return undefined;
  }
  const elementCtorMap$LWS = elementCtorMapByAttributeNamespaceRegistry$LWS[attributeNamespace$LWS];
  if (elementCtorMap$LWS === undefined) {
    return undefined;
  }
  const mapIterator$LWS = elementCtorMap$LWS.entries();
  for (const {
    0: Ctor$LWS,
    1: distortion$LWS
  } of mapIterator$LWS) {
    // Element can inherit from Ctor but Ctor may not be the first entry in
    // the proto chain thus element.prototype checks are not sufficient.
    if (element$LWS instanceof Ctor$LWS) {
      return distortion$LWS;
    }
  }
  return undefined;
}
// Utility for normalizing namespaces which default to HTML behavior.
// script.setAttributeNS(null, 'src', 'foo.js') has the same behavior as
// script.setAttribute('src', 'foo.js').
function normalizeNamespace$LWS(ns$LWS) {
  return ns$LWS === null || ns$LWS === undefined || ns$LWS === '' ? NAMESPACE_DEFAULT$LWS : ns$LWS;
}
function registerAttributeDistortion$LWS(record$LWS, ElementCtor$LWS, attributeName$LWS, attributeNamespace$LWS, distortion$LWS) {
  let attributeFactories$LWS = attributeDistortionFactoriesCache$LWS.get(record$LWS);
  if (attributeFactories$LWS === undefined) {
    attributeFactories$LWS = [];
    attributeDistortionFactoriesCache$LWS.set(record$LWS, attributeFactories$LWS);
  }
  const loweredAttributeName$LWS = ReflectApply$LWS$1(StringProtoToLowerCase$LWS, attributeName$LWS, []);
  attributeFactories$LWS[attributeFactories$LWS.length] = attributeDistortionRegistry$LWS => {
    let elementCtorMapByAttributeNamespaceRegistry$LWS = attributeDistortionRegistry$LWS[loweredAttributeName$LWS];
    if (elementCtorMapByAttributeNamespaceRegistry$LWS === undefined) {
      elementCtorMapByAttributeNamespaceRegistry$LWS = {
        __proto__: null
      };
      attributeDistortionRegistry$LWS[loweredAttributeName$LWS] = elementCtorMapByAttributeNamespaceRegistry$LWS;
    }
    let elementCtorMap$LWS = elementCtorMapByAttributeNamespaceRegistry$LWS[attributeNamespace$LWS];
    if (elementCtorMap$LWS === undefined) {
      elementCtorMap$LWS = toSafeMap$LWS$1(new MapCtor$LWS$1());
      elementCtorMapByAttributeNamespaceRegistry$LWS[attributeNamespace$LWS] = elementCtorMap$LWS;
    }
    elementCtorMap$LWS.set(ElementCtor$LWS, distortion$LWS);
  };
}
function initDistortionAttrValueSetter$LWS({
  globalObject: {
    Attr: Attr$LWS
  }
}) {
  const originalAttrValueSetter$LWS = ObjectLookupOwnSetter$LWS(Attr$LWS.prototype, 'value');
  return function distortionAttrValueSetter$LWS(record$LWS) {
    return [originalAttrValueSetter$LWS, function value$LWS(val$LWS) {
      const ownerElement$LWS = ReflectApply$LWS$1(AttrProtoOwnerElementGetter$LWS, this, []);
      // istanbul ignore else: needs default platform behavior test
      if (ownerElement$LWS) {
        const attrName$LWS = ReflectApply$LWS$1(AttrProtoNameGetter$LWS, this, []);
        const attrNamespace$LWS = ReflectApply$LWS$1(AttrProtoNamespaceURIGetter$LWS, this, []);
        const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
        const distortion$LWS = getAttributeDistortion$LWS(record$LWS, ownerElement$LWS, attrName$LWS, normalizedNamespace$LWS);
        // istanbul ignore if: coverage missing, needs investigation
        if (distortion$LWS) {
          ReflectApply$LWS$1(distortion$LWS, ownerElement$LWS, [val$LWS]);
          return;
        }
      }
      ReflectApply$LWS$1(originalAttrValueSetter$LWS, this, [val$LWS]);
    }];
  };
}
function initDistortionAuraUtilGlobalEval$LWS({
  UNCOMPILED_CONTEXT: UNCOMPILED_CONTEXT$LWS,
  globalObject: globalObject$LWS
}) {
  var _globalObject$aura$LWS;
  // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
  const originalGlobalEval$LWS = (_globalObject$aura$LWS = globalObject$LWS.aura) == null || (_globalObject$aura$LWS = _globalObject$aura$LWS.util) == null ? void 0 : _globalObject$aura$LWS.globalEval;
  // istanbul ignore else: external is the default sandbox type for coverage runs
  if (typeof originalGlobalEval$LWS !== 'function') {
    return noop$LWS$1;
  }
  // istanbul ignore next: external is the default sandbox type for coverage runs and this distortion is internal only
  return function distortionAuraUtilGlobalEval$LWS({
    sandboxEvaluator: sandboxEvaluator$LWS
  }) {
    // Based on Aura.Utils.Util.prototype.globalEval from the aura/aura repository.
    return [originalGlobalEval$LWS, function globalEval$LWS(sourceText$LWS, descriptor$LWS, type$LWS) {
      let wrappedSourceText$LWS = `(function s(){return(${sourceText$LWS})})()`;
      if (typeof descriptor$LWS === 'string') {
        const split$LWS = ReflectApply$LWS$1(StringProtoSplit$LWS, descriptor$LWS, ['://']);
        const {
          length: length$LWS
        } = split$LWS;
        const name$LWS = length$LWS ? split$LWS[split$LWS.length - 1] : '';
        wrappedSourceText$LWS += this.sourceComment + (type$LWS === 'lib' ? `/libraries/${ReflectApply$LWS$1(StringProtoReplace$LWS, name$LWS, ['.', '/'])}` : `/components/${ReflectApply$LWS$1(StringProtoReplace$LWS, name$LWS, [':', '/'])}.js`);
      }
      return sandboxEvaluator$LWS(transformSourceText$LWS(wrappedSourceText$LWS), UNCOMPILED_CONTEXT$LWS);
    }];
  };
}
function initDistortionBroadcastChannelPostMessage$LWS({
  globalObject: globalObject$LWS
}) {
  const {
    BroadcastChannel: BroadcastChannel$LWS
  } = globalObject$LWS;
  // istanbul ignore if: this is a safety precaution, but currently unreachable via tests
  if (typeof BroadcastChannel$LWS !== 'function') {
    return noop$LWS$1;
  }
  const {
    prototype: {
      postMessage: originalPostMessage$LWS
    }
  } = BroadcastChannel$LWS;
  const distortionEntry$LWS = [originalPostMessage$LWS, function postMessage$LWS(...args$LWS) {
    try {
      return ReflectApply$LWS$1(originalPostMessage$LWS, this, args$LWS);
    } catch (error) {
      // We don't check if `error instance of DOMException` because
      // accessing `DOMException` of the `globalObject` will throw
      // an error for opaque windows.
      const {
        length: length$LWS
      } = args$LWS;
      if (length$LWS) {
        const message$LWS = args$LWS[0];
        if (isObject$LWS$1(message$LWS)) {
          args$LWS[0] = partialStructuredClone$LWS(message$LWS);
          return ReflectApply$LWS$1(originalPostMessage$LWS, this, args$LWS);
        }
      }
      throw error;
    }
  }];
  return function distortionBroadcastChannelPostMessage$LWS() {
    return distortionEntry$LWS;
  };
}

/* istanbul ignore next: only available in secure context */
function initDistortionCacheStorageDelete$LWS({
  globalObject: {
    CacheStorage: CacheStorage$LWS
  }
}) {
  var _CacheStorage$prototy$LWS;
  // Chrome and Safari will only expose CacheStorage over HTTPS.
  const originalDelete$LWS = CacheStorage$LWS == null || (_CacheStorage$prototy$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy$LWS.delete;
  if (typeof originalDelete$LWS !== 'function') {
    return noop$LWS$1;
  }
  return function distortionCacheStorageDelete$LWS({
    key: key$LWS
  }) {
    return [originalDelete$LWS, function patchedDelete$LWS(...args$LWS) {
      if (args$LWS.length) {
        const {
          0: rawCacheName$LWS
        } = args$LWS;
        const cacheName$LWS = toSafeStringValue$LWS(rawCacheName$LWS);
        args$LWS[0] = prependNamespaceMarker$LWS(cacheName$LWS, key$LWS);
      }
      return ReflectApply$LWS$1(originalDelete$LWS, this, args$LWS);
    }];
  };
}

/* istanbul ignore next: only available in secure context */
function initDistortionCacheStorageHas$LWS({
  globalObject: {
    CacheStorage: CacheStorage$LWS
  }
}) {
  var _CacheStorage$prototy2$LWS;
  // Chrome and Safari will only expose CacheStorage over HTTPS.
  const originalHas$LWS = CacheStorage$LWS == null || (_CacheStorage$prototy2$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy2$LWS.has;
  if (typeof originalHas$LWS !== 'function') {
    return noop$LWS$1;
  }
  return function distortionCacheStorageHas$LWS({
    key: key$LWS
  }) {
    return [originalHas$LWS, function has$LWS(...args$LWS) {
      if (args$LWS.length) {
        const {
          0: rawCacheName$LWS
        } = args$LWS;
        const cacheName$LWS = toSafeStringValue$LWS(rawCacheName$LWS);
        args$LWS[0] = prependNamespaceMarker$LWS(cacheName$LWS, key$LWS);
      }
      return ReflectApply$LWS$1(originalHas$LWS, this, args$LWS);
    }];
  };
}

/* istanbul ignore next: only available in secure context */
function initDistortionCacheStorageKeys$LWS({
  globalObject: {
    CacheStorage: CacheStorage$LWS
  }
}) {
  var _CacheStorage$prototy3$LWS;
  // Chrome and Safari will only expose CacheStorage over HTTPS.
  const originalKeys$LWS = CacheStorage$LWS == null || (_CacheStorage$prototy3$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy3$LWS.keys;
  if (typeof originalKeys$LWS !== 'function') {
    return noop$LWS$1;
  }
  return function distortionCacheStorageKeys$LWS({
    key: key$LWS
  }) {
    return [originalKeys$LWS, function keys$LWS() {
      const keysResultPromise$LWS = ReflectApply$LWS$1(originalKeys$LWS, this, []);
      return ReflectApply$LWS$1(PromiseProtoThen$LWS, keysResultPromise$LWS, [result$LWS => {
        const sandboxedCacheNames$LWS = [];
        for (let i$LWS = 0, j$LWS = 0, {
            length: length$LWS
          } = result$LWS; i$LWS < length$LWS; i$LWS += 1) {
          const cacheName$LWS = result$LWS[i$LWS];
          if (startsWithNamespaceMarker$LWS(cacheName$LWS, key$LWS)) {
            sandboxedCacheNames$LWS[j$LWS++] = removeNamespaceMarker$LWS(cacheName$LWS, key$LWS);
          }
        }
        return sandboxedCacheNames$LWS;
      }]);
    }];
  };
}

/* istanbul ignore next: only available in secure context */
function initDistortionCacheStorageMatch$LWS({
  globalObject: {
    CacheStorage: CacheStorage$LWS
  }
}) {
  var _CacheStorage$prototy4$LWS;
  // Chrome and Safari will only expose CacheStorage over HTTPS.
  const originalMatch$LWS = CacheStorage$LWS == null || (_CacheStorage$prototy4$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy4$LWS.match;
  if (typeof originalMatch$LWS !== 'function') {
    return noop$LWS$1;
  }
  return function distortionCacheStorageMatch$LWS({
    key: key$LWS
  }) {
    return [originalMatch$LWS, function match$LWS(...args$LWS) {
      const {
        length: length$LWS
      } = args$LWS;
      // Let the native method handle missing parameters.
      if (!length$LWS) {
        return ReflectApply$LWS$1(originalMatch$LWS, this, args$LWS);
      }
      // Next we check `length` is at least 2, which means options are present.
      const matchOptions$LWS = length$LWS >= 2 ? args$LWS[1] : undefined;
      // In order to enforce the sandbox partition, we must REQUIRE the
      // `options.cacheName` value. The value of `options.cacheName` must
      // also be safely convertible to a string.
      if (isObjectLike$LWS(matchOptions$LWS) && 'cacheName' in matchOptions$LWS) {
        const {
          cacheName: rawCacheName$LWS
        } = matchOptions$LWS;
        const cacheName$LWS = toSafeStringValue$LWS(rawCacheName$LWS);
        const clonedOptions$LWS = shallowCloneOptions$LWS(matchOptions$LWS);
        clonedOptions$LWS.cacheName = prependNamespaceMarker$LWS(cacheName$LWS, key$LWS);
        args$LWS[1] = clonedOptions$LWS;
        return ReflectApply$LWS$1(originalMatch$LWS, this, args$LWS);
      }
      return PromiseReject$LWS(new LockerSecurityError$LWS("caches.match() expects 'options.cacheName' to be present."));
    }];
  };
}

/* istanbul ignore next: only available in secure context */
function initDistortionCacheStorageOpen$LWS({
  globalObject: {
    CacheStorage: CacheStorage$LWS
  }
}) {
  var _CacheStorage$prototy5$LWS;
  // Chrome and Safari will only expose CacheStorage over HTTPS.
  const originalOpen$LWS = CacheStorage$LWS == null || (_CacheStorage$prototy5$LWS = CacheStorage$LWS.prototype) == null ? void 0 : _CacheStorage$prototy5$LWS.open;
  if (typeof originalOpen$LWS !== 'function') {
    return noop$LWS$1;
  }
  return function distortionCacheStorageOpen$LWS({
    key: key$LWS
  }) {
    return [originalOpen$LWS, function open$LWS(...args$LWS) {
      if (args$LWS.length) {
        const {
          0: rawCacheName$LWS
        } = args$LWS;
        const cacheName$LWS = toSafeStringValue$LWS(rawCacheName$LWS);
        args$LWS[0] = prependNamespaceMarker$LWS(cacheName$LWS, key$LWS);
      }
      return ReflectApply$LWS$1(originalOpen$LWS, this, args$LWS);
    }];
  };
}
const COOKIE_DELIMITER$LWS = '; ';
/* istanbul ignore next: only available in secure context */
function prefixCookieDetailsOrName$LWS(detailsOrName$LWS, namespace$LWS) {
  if (isObjectLike$LWS(detailsOrName$LWS)) {
    const clonedDetails$LWS = shallowCloneOptions$LWS(detailsOrName$LWS);
    clonedDetails$LWS.name = prependNamespaceMarker$LWS(clonedDetails$LWS.name, namespace$LWS);
    return clonedDetails$LWS;
  }
  return prependNamespaceMarker$LWS(detailsOrName$LWS, namespace$LWS);
}
function unprefixCookie$LWS(cookieEntry$LWS, namespace$LWS) {
  // First check that this cookie belongs to this sandbox,
  // if not then return `null`.
  if (!startsWithNamespaceMarker$LWS(cookieEntry$LWS, namespace$LWS)) {
    return null;
  }
  // If this cookie belongs to this sandbox, remove the marker.
  const marker$LWS = getNamespaceMarker$LWS(namespace$LWS);
  const {
    length: markerLength$LWS
  } = marker$LWS;
  const pos$LWS = cookieEntry$LWS.length > markerLength$LWS && cookieEntry$LWS[markerLength$LWS] === '=' ? markerLength$LWS + 1 : markerLength$LWS;
  return ReflectApply$LWS$1(StringProtoSlice$LWS$1, cookieEntry$LWS, [pos$LWS]);
}

/* istanbul ignore next: only available in secure context */
function initDistortionCookieStoreDelete$LWS({
  globalObject: {
    CookieStore: CookieStore$LWS
  }
}) {
  var _CookieStore$prototyp$LWS;
  const originalDelete$LWS = CookieStore$LWS == null || (_CookieStore$prototyp$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp$LWS.delete;
  if (typeof originalDelete$LWS !== 'function') {
    return noop$LWS$1;
  }
  return function distortionCookieStoreDelete$LWS({
    key: key$LWS
  }) {
    return [originalDelete$LWS, function deleteValue$LWS(...args$LWS) {
      const detailsOrName$LWS = args$LWS.length ? args$LWS[0] : undefined;
      if (detailsOrName$LWS !== null && detailsOrName$LWS !== undefined) {
        args$LWS[0] = prefixCookieDetailsOrName$LWS(detailsOrName$LWS, key$LWS);
      }
      return ReflectApply$LWS$1(originalDelete$LWS, this, args$LWS);
    }];
  };
}

/* istanbul ignore next: only available in secure context */
function initDistortionCookieStoreGet$LWS({
  globalObject: {
    CookieStore: CookieStore$LWS
  }
}) {
  var _CookieStore$prototyp2$LWS;
  const originalGet$LWS = CookieStore$LWS == null || (_CookieStore$prototyp2$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp2$LWS.get;
  if (typeof originalGet$LWS !== 'function') {
    return noop$LWS$1;
  }
  return function distortionCookieStoreGet$LWS({
    key: key$LWS
  }) {
    return [originalGet$LWS, function get$LWS(...args$LWS) {
      const detailsOrName$LWS = args$LWS.length ? args$LWS[0] : undefined;
      if (detailsOrName$LWS !== null && detailsOrName$LWS !== undefined) {
        args$LWS[0] = prefixCookieDetailsOrName$LWS(detailsOrName$LWS, key$LWS);
      }
      const getResultPromise$LWS = ReflectApply$LWS$1(originalGet$LWS, this, args$LWS);
      return ReflectApply$LWS$1(PromiseProtoThen$LWS, getResultPromise$LWS, [cookieListItem$LWS => {
        if (cookieListItem$LWS) {
          const {
            name: name$LWS
          } = cookieListItem$LWS;
          if (startsWithNamespaceMarker$LWS(name$LWS, key$LWS)) {
            cookieListItem$LWS.name = removeNamespaceMarker$LWS(name$LWS, key$LWS);
            return cookieListItem$LWS;
          }
        }
        return null;
      }]);
    }];
  };
}

/* istanbul ignore next: only available in secure context */
function initDistortionCookieStoreGetAll$LWS({
  globalObject: {
    CookieStore: CookieStore$LWS
  }
}) {
  var _CookieStore$prototyp3$LWS;
  const originalGetAll$LWS = CookieStore$LWS == null || (_CookieStore$prototyp3$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp3$LWS.getAll;
  if (typeof originalGetAll$LWS !== 'function') {
    return noop$LWS$1;
  }
  return function distortionCookieStoreGetAll$LWS({
    key: key$LWS
  }) {
    return [originalGetAll$LWS, function getAll$LWS(...args$LWS) {
      const detailsOrName$LWS = args$LWS.length ? args$LWS[0] : undefined;
      if (detailsOrName$LWS !== null && detailsOrName$LWS !== undefined) {
        args$LWS[0] = prefixCookieDetailsOrName$LWS(args$LWS[0], key$LWS);
      }
      const getAllResultPromise$LWS = ReflectApply$LWS$1(originalGetAll$LWS, this, args$LWS);
      return ReflectApply$LWS$1(PromiseProtoThen$LWS, getAllResultPromise$LWS, [result$LWS => {
        const sandboxedCookies$LWS = [];
        let sandboxedCookiesOffset$LWS = 0;
        for (let i$LWS = 0, {
            length: length$LWS
          } = result$LWS; i$LWS < length$LWS; i$LWS += 1) {
          const cookieListItem$LWS = result$LWS[i$LWS];
          if (cookieListItem$LWS) {
            const {
              name: name$LWS
            } = cookieListItem$LWS;
            if (startsWithNamespaceMarker$LWS(name$LWS, key$LWS)) {
              cookieListItem$LWS.name = removeNamespaceMarker$LWS(name$LWS, key$LWS);
              sandboxedCookies$LWS[sandboxedCookiesOffset$LWS++] = cookieListItem$LWS;
            }
          }
        }
        return sandboxedCookies$LWS;
      }]);
    }];
  };
}
const restrictedEventTargetRegistryBySandboxKeyRegistry$LWS = {
  __proto__: null
};
function isEventTargetRestricted$LWS(record$LWS, eventTarget$LWS, eventName$LWS) {
  const {
    key: key$LWS
  } = record$LWS;
  const {
    [key$LWS]: restrictedEventTargetRegistry$LWS
  } = restrictedEventTargetRegistryBySandboxKeyRegistry$LWS;
  if (restrictedEventTargetRegistry$LWS === undefined || restrictedEventTargetRegistry$LWS[eventName$LWS] === undefined) {
    return false;
  }
  let possiblyRestrictedConstructor$LWS = getUnmaskedFunction$LWS(eventTarget$LWS.constructor);
  // Walk UP the proto chain to check if super classes have a restriction on this event.
  // This can happen in cases where HTMLElement is the event target constructor, but
  // the event listener is being added to HTMLDivElement. Since we obviously want to
  // block all listeners for an event being blocked at HTMLElement level, we need to
  // walk up from the HTMLDivElement until we find the constructor for which we
  // registered a restriction.
  while (possiblyRestrictedConstructor$LWS !== null) {
    if (restrictedEventTargetRegistry$LWS[eventName$LWS].has(possiblyRestrictedConstructor$LWS)) {
      return true;
    }
    // eslint-disable-next-line no-proto
    possiblyRestrictedConstructor$LWS = possiblyRestrictedConstructor$LWS.__proto__;
  }
  return false;
}
function registerEventTargetRestriction$LWS(record$LWS, EventTargetCtor$LWS, eventName$LWS) {
  const unmaskedEventTargetCtor$LWS = getUnmaskedFunction$LWS(EventTargetCtor$LWS);
  // istanbul ignore if: this is a safety precaution that is unreachable via tests
  if (isEventTargetRestricted$LWS(record$LWS, unmaskedEventTargetCtor$LWS.prototype, eventName$LWS)) {
    return;
  }
  const {
    key: key$LWS
  } = record$LWS;
  const {
    [key$LWS]: restrictedEventTargetRegistry$LWS = {
      __proto__: null
    }
  } = restrictedEventTargetRegistryBySandboxKeyRegistry$LWS;
  const {
    [eventName$LWS]: restrictedEventTargetCtors$LWS = toSafeWeakSet$LWS$1(new WeakSetCtor$LWS$1())
  } = restrictedEventTargetRegistry$LWS;
  restrictedEventTargetCtors$LWS.add(unmaskedEventTargetCtor$LWS);
  restrictedEventTargetRegistry$LWS[eventName$LWS] = restrictedEventTargetCtors$LWS;
  restrictedEventTargetRegistryBySandboxKeyRegistry$LWS[key$LWS] = restrictedEventTargetRegistry$LWS;
}
// This is for use with DOM-0 style "event handler" distortions, eg.
// - window.onsecuritypolicyviolation
// - window.onstorage
function createEventHandlerExceptionMessage$LWS(instanceOrProto$LWS, eventName$LWS) {
  let exceptionMessage$LWS = `Cannot set '${eventName$LWS}' event handler`;
  const safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(instanceOrProto$LWS.constructor, 'name');
  // istanbul ignore else: needs default platform behavior test
  if (safeDesc$LWS) {
    ReflectSetPrototypeOf$LWS$1(safeDesc$LWS, null);
    const {
      value: name$LWS
    } = safeDesc$LWS;
    // istanbul ignore else: needs default platform behavior test
    if (typeof name$LWS === 'string') {
      exceptionMessage$LWS += ` on ${name$LWS} object`;
    }
  }
  return `${exceptionMessage$LWS}.`;
}
// This is for use with DOM-2 style "event listener" distortions, eg.
// - window.addEventListener('securitypolicyviolation', ...)
// - window.addEventListener('storage', ...)
function createEventListenerExceptionMessage$LWS(instanceOrProto$LWS, eventName$LWS) {
  let exceptionMessage$LWS = `Cannot add '${eventName$LWS}' event listener`;
  const safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(instanceOrProto$LWS.constructor, 'name');
  // istanbul ignore else: needs default platform behavior test
  if (safeDesc$LWS) {
    ReflectSetPrototypeOf$LWS$1(safeDesc$LWS, null);
    const {
      value: name$LWS
    } = safeDesc$LWS;
    // istanbul ignore else: needs default platform behavior test
    if (typeof name$LWS === 'string') {
      exceptionMessage$LWS += ` to ${name$LWS} object`;
    }
  }
  return `${exceptionMessage$LWS}.`;
}
function createEventDistortionFactory$LWS(eventHandlerTarget$LWS, eventListenerTarget$LWS, eventName$LWS) {
  const onEventHandlerName$LWS = `on${eventName$LWS}`;
  const originalEventHandlerSetter$LWS = ObjectLookupOwnSetter$LWS(eventHandlerTarget$LWS, onEventHandlerName$LWS);
  // istanbul ignore if: currently unreachable via tests
  if (typeof originalEventHandlerSetter$LWS !== 'function') {
    return noop$LWS$1;
  }
  const eventExceptionMessage$LWS = createEventHandlerExceptionMessage$LWS(eventHandlerTarget$LWS, onEventHandlerName$LWS);
  const distortionMapEntry$LWS = [originalEventHandlerSetter$LWS, function () {
    throw new LockerSecurityError$LWS(eventExceptionMessage$LWS);
  }];
  return function distortionEventHandler$LWS(record$LWS) {
    registerEventTargetRestriction$LWS(record$LWS, eventListenerTarget$LWS, eventName$LWS);
    return distortionMapEntry$LWS;
  };
}
function initDistortionCookieStoreOnChange$LWS({
  globalObject: {
    CookieStore: CookieStore$LWS
  }
}) {
  return createEventDistortionFactory$LWS( /* istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator */CookieStore$LWS == null ? void 0 : CookieStore$LWS.prototype, CookieStore$LWS, 'change');
}

/* istanbul ignore next: only available in secure context */
function initDistortionCookieStoreSet$LWS({
  globalObject: {
    CookieStore: CookieStore$LWS
  }
}) {
  var _CookieStore$prototyp4$LWS;
  const originalSet$LWS = CookieStore$LWS == null || (_CookieStore$prototyp4$LWS = CookieStore$LWS.prototype) == null ? void 0 : _CookieStore$prototyp4$LWS.set;
  if (typeof originalSet$LWS !== 'function') {
    return noop$LWS$1;
  }
  return function distortionCookieStoreSet$LWS({
    key: key$LWS
  }) {
    return [originalSet$LWS, function set$LWS(...args$LWS) {
      const {
        length: length$LWS
      } = args$LWS;
      if (length$LWS > 1) {
        args$LWS[0] = prependNamespaceMarker$LWS(args$LWS[0], key$LWS);
      } else if (length$LWS) {
        const {
          0: details$LWS
        } = args$LWS;
        if (isObjectLike$LWS(details$LWS)) {
          const clonedDetails$LWS = shallowCloneOptions$LWS(details$LWS);
          clonedDetails$LWS.name = prependNamespaceMarker$LWS(clonedDetails$LWS.name, key$LWS);
          args$LWS[0] = clonedDetails$LWS;
        }
      }
      return ReflectApply$LWS$1(originalSet$LWS, this, args$LWS);
    }];
  };
}
function initDistortionCSSStyleRuleStyleGetter$LWS({
  globalObject: {
    CSSStyleRule: CSSStyleRule$LWS
  }
}) {
  const originalStyleGetter$LWS = ObjectLookupOwnGetter$LWS$1(CSSStyleRule$LWS.prototype, 'style');
  const distortionEntry$LWS = [originalStyleGetter$LWS, function style$LWS() {
    return trackAsLiveTarget$LWS(ReflectApply$LWS$1(originalStyleGetter$LWS, this, []));
  }];
  return function distortionCSSStyleRuleStyleGetter$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionCustomElementRegistryDefine$LWS({
  document: document$LWS,
  globalObject: {
    CustomElementRegistry: CustomElementRegistry$LWS,
    customElements: customElements$LWS
  }
}) {
  var _CustomElementRegistr$LWS;
  // Next, we MUST use a reference to the now patched version of this API method,
  // or else we'll end up attempting to distort the wrong definition.
  // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
  const originalCustomElementsDefine$LWS = CustomElementRegistry$LWS == null || (_CustomElementRegistr$LWS = CustomElementRegistry$LWS.prototype) == null ? void 0 : _CustomElementRegistr$LWS.define;
  return function distortionCustomElementRegistryDefine$LWS({
    key: key$LWS
  }) {
    const registry$LWS = getSandboxCustomElementRegistry$LWS(document$LWS, key$LWS);
    return [originalCustomElementsDefine$LWS, function define$LWS(...args$LWS) {
      if (this !== customElements$LWS) {
        // This is more restricted than native behavior because in native
        // this is normally a runtime error when attempting to define a
        // class that inherit from a constructor from another window.
        // But right now, we don't know how to do this runtime check,
        // the safe bet is to throw here.
        throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_INVOCATION$LWS);
      }
      return registry$LWS.applyDefine(this, args$LWS);
    }];
  };
}
function initDistortionCustomElementRegistryGet$LWS({
  document: document$LWS,
  globalObject: {
    CustomElementRegistry: CustomElementRegistry$LWS,
    customElements: customElements$LWS
  }
}) {
  var _CustomElementRegistr2$LWS;
  // Next, we MUST use a reference to the now patched version of this API method,
  // or else we'll end up attempting to distort the wrong definition.
  // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
  const originalCustomElementsGet$LWS = CustomElementRegistry$LWS == null || (_CustomElementRegistr2$LWS = CustomElementRegistry$LWS.prototype) == null ? void 0 : _CustomElementRegistr2$LWS.get;
  return function distortionCustomElementRegistryGet$LWS({
    key: key$LWS
  }) {
    const registry$LWS = getSandboxCustomElementRegistry$LWS(document$LWS, key$LWS);
    return [originalCustomElementsGet$LWS, function get$LWS(...args$LWS) {
      if (this !== customElements$LWS) {
        // This is more restricted than native behavior because in
        // native this is going to leak constructors from another
        // windows. But right now, we don't know the implications yet,
        // the safe bet is to throw here.
        // @TODO: this could leak pivots from another document,
        // that's the concern.
        throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_INVOCATION$LWS);
      }
      return registry$LWS.applyGet(this, args$LWS);
    }];
  };
}
function initDistortionCustomElementRegistryUpgrade$LWS({
  document: document$LWS,
  globalObject: {
    CustomElementRegistry: CustomElementRegistry$LWS,
    customElements: customElements$LWS
  }
}) {
  var _CustomElementRegistr3$LWS;
  // Next, we MUST use a reference to the now patched version of this API method,
  // or else we'll end up attempting to distort the wrong definition.
  // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
  const originalCustomElementsUpgrade$LWS = CustomElementRegistry$LWS == null || (_CustomElementRegistr3$LWS = CustomElementRegistry$LWS.prototype) == null ? void 0 : _CustomElementRegistr3$LWS.upgrade;
  return function distortionCustomElementRegistryUpgrade$LWS({
    key: key$LWS
  }) {
    const registry$LWS = getSandboxCustomElementRegistry$LWS(document$LWS, key$LWS);
    return [originalCustomElementsUpgrade$LWS, function upgrade$LWS(...args$LWS) {
      if (this !== customElements$LWS) {
        // This is more restricted than native behavior because in native
        // this is normally a runtime error when attempting to upgrade a
        // class that inherit from a constructor from another window.
        // But right now, we don't know how to do this runtime check,
        // the safe bet is to throw here.
        throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_INVOCATION$LWS);
      }
      registry$LWS.applyUpgrade(this, args$LWS);
    }];
  };
}
function initDistortionCustomElementRegistryWhenDefined$LWS({
  document: document$LWS,
  globalObject: {
    CustomElementRegistry: CustomElementRegistry$LWS,
    customElements: customElements$LWS
  }
}) {
  var _CustomElementRegistr4$LWS;
  // Next, we MUST use a reference to the now patched version of this API method,
  // or else we'll end up attempting to distort the wrong definition.
  // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
  const originalCustomElementsWhenDefined$LWS = CustomElementRegistry$LWS == null || (_CustomElementRegistr4$LWS = CustomElementRegistry$LWS.prototype) == null ? void 0 : _CustomElementRegistr4$LWS.whenDefined;
  return function distortionCustomElementRegistryWhenDefined$LWS({
    key: key$LWS
  }) {
    const registry$LWS = getSandboxCustomElementRegistry$LWS(document$LWS, key$LWS);
    return [originalCustomElementsWhenDefined$LWS, function whenDefined$LWS(...args$LWS) {
      if (this !== customElements$LWS) {
        // This is more restricted than native behavior because in
        // native this is going to leak constructors from another
        // windows when defined. But right now, we don't know the
        // implications yet, the safe bet is to throw here.
        // @TODO: Maybe returning a promise that never fulfills is
        // better.
        return PromiseReject$LWS(new TypeErrorCtor$LWS$1(ERR_ILLEGAL_INVOCATION$LWS));
      }
      return registry$LWS.applyWhenDefined(this, args$LWS);
    }];
  };
}
function initDistortionDocumentCookieGetter$LWS({
  globalObject: {
    Document: Document$LWS
  }
}) {
  const originalCookieGetter$LWS = ObjectLookupOwnGetter$LWS$1(Document$LWS.prototype, 'cookie');
  return function distortionDocumentCookieGetter$LWS({
    key: key$LWS
  }) {
    return [originalCookieGetter$LWS, function get$LWS() {
      const documentCookieValue$LWS = ReflectApply$LWS$1(DocumentProtoCookieGetter$LWS, this, []);
      const cookies$LWS = ReflectApply$LWS$1(StringProtoSplit$LWS, documentCookieValue$LWS, [COOKIE_DELIMITER$LWS]);
      const sandboxedCookies$LWS = [];
      let sandboxedCookiesOffset$LWS = 0;
      for (let i$LWS = 0, {
          length: length$LWS
        } = cookies$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const cookie$LWS = unprefixCookie$LWS(cookies$LWS[i$LWS], key$LWS);
        if (cookie$LWS) {
          sandboxedCookies$LWS[sandboxedCookiesOffset$LWS++] = cookie$LWS;
        }
      }
      return ReflectApply$LWS$1(ArrayProtoJoin$LWS$1, sandboxedCookies$LWS, [COOKIE_DELIMITER$LWS]);
    }];
  };
}
function initDistortionDocumentCookieSetter$LWS({
  globalObject: {
    Document: Document$LWS
  }
}) {
  const originalCookieSetter$LWS = ObjectLookupOwnSetter$LWS(Document$LWS.prototype, 'cookie');
  return function distortionDocumentCookieSetter$LWS({
    key: key$LWS
  }) {
    return [originalCookieSetter$LWS, function set$LWS(value$LWS) {
      const cookieEntries$LWS = ReflectApply$LWS$1(StringProtoSplit$LWS, value$LWS, [COOKIE_DELIMITER$LWS]);
      let {
        0: newCookieEntry$LWS
      } = cookieEntries$LWS;
      if (newCookieEntry$LWS.length && newCookieEntry$LWS[0] === '=') {
        newCookieEntry$LWS = ReflectApply$LWS$1(StringProtoSlice$LWS$1, newCookieEntry$LWS, [1]);
      }
      cookieEntries$LWS[0] = prependNamespaceMarker$LWS(newCookieEntry$LWS, key$LWS);
      const cookie$LWS = ReflectApply$LWS$1(ArrayProtoJoin$LWS$1, cookieEntries$LWS, [COOKIE_DELIMITER$LWS]);
      ReflectApply$LWS$1(DocumentProtoCookieSetter$LWS, this, [cookie$LWS]);
    }];
  };
}
function initDistortionDocumentCreateElement$LWS({
  document: document$LWS,
  globalObject: {
    Document: {
      prototype: {
        createElement: originalDocumentCreateElement$LWS
      }
    }
  }
}) {
  return function distortionDocumentCreateElement$LWS({
    key: key$LWS
  }) {
    return [originalDocumentCreateElement$LWS, function (...args$LWS) {
      const {
        0: tagName$LWS
      } = args$LWS;
      // Slow path for potential custom elements that might be registered
      // in the sandbox's virtual custom element registry.
      if (ReflectApply$LWS$1(StringProtoIncludes$LWS, tagName$LWS, ['-'])) {
        // This must be called to signal to the virtual
        // CustomElementRegistry that the next thing created will be
        // a custom element and it must be marked for association to
        // this sandbox.
        setCustomElementsRegistry$LWS(document$LWS, key$LWS);
      }
      return ReflectApply$LWS$1(originalDocumentCreateElement$LWS, this, args$LWS);
    }];
  };
}
function initDistortionDocumentCreateElementNS$LWS({
  document: document$LWS,
  globalObject: {
    Document: {
      prototype: {
        createElementNS: originalDocumentCreateElementNS$LWS
      }
    }
  }
}) {
  return function distortionDocumentCreateElementNS$LWS({
    key: key$LWS
  }) {
    return [originalDocumentCreateElementNS$LWS, function (...args$LWS) {
      const {
        1: tagName$LWS
      } = args$LWS;
      // Slow path for potential custom elements that might
      // be registered in the sandbox's virtual custom element registry.
      if (ReflectApply$LWS$1(StringProtoIncludes$LWS, tagName$LWS, ['-'])) {
        // This must be called to signal to the virtual
        // CustomElementRegistry that the next thing created will be
        // a custom element and it must be marked for association to
        // this sandbox.
        setCustomElementsRegistry$LWS(document$LWS, key$LWS);
      }
      return ReflectApply$LWS$1(originalDocumentCreateElementNS$LWS, this, args$LWS);
    }];
  };
}
function domain$LWS() {
  throw new LockerSecurityError$LWS('Cannot set document.domain.');
}
function initDistortionDocumentDomainSetter$LWS({
  globalObject: {
    Document: Document$LWS
  }
}) {
  const originalDomainSetter$LWS = ObjectLookupOwnSetter$LWS(Document$LWS.prototype, 'domain');
  const distortionEntry$LWS = [originalDomainSetter$LWS, domain$LWS];
  return function distortionDocumentDomainSetter$LWS() {
    return distortionEntry$LWS;
  };
}
const {
  isSharedElement: isSharedElement$s$LWS
} = rootValidator$LWS;
function throwLockerSecurityError$LWS(command$LWS, target$LWS) {
  throw new LockerSecurityError$LWS(`Cannot execute command '${command$LWS}' on ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, target$LWS, [])}.`);
}
function initDistortionDocumentExecCommand$LWS({
  document: document$LWS,
  globalObject: {
    Document: {
      prototype: {
        execCommand: originalExecCommand$LWS
      }
    },
    HTMLElement: HTMLElement$LWS
  }
}) {
  const originalActiveElement$LWS = ObjectLookupOwnGetter$LWS$1(Document.prototype, 'activeElement');
  const originalIsContentEditable$LWS = ObjectLookupOwnGetter$LWS$1(HTMLElement$LWS.prototype, 'isContentEditable');
  return function distortionDocumentExecCommand$LWS({
    key: key$LWS,
    type: type$LWS
  }) {
    return [originalExecCommand$LWS, function execCommand$LWS(...args$LWS) {
      const {
        length: length$LWS
      } = args$LWS;
      if (length$LWS >= 1) {
        const command$LWS = toSafeStringValue$LWS(args$LWS[0]);
        const loweredCommand$LWS = ReflectApply$LWS$1(StringProtoToLowerCase$LWS, command$LWS, []);
        if (loweredCommand$LWS === 'selectall' && this === rootDocument$LWS) {
          throwLockerSecurityError$LWS(command$LWS, this);
        }
        // Guard against TOCTOU attacks by forcing execCommand to receive whatever
        // the first read value of the provided command is.
        args$LWS[0] = command$LWS;
        if (length$LWS > 2) {
          const {
            2: unsanitizedValue$LWS
          } = args$LWS;
          // istanbul ignore else: needs default platform behavior test
          if (unsanitizedValue$LWS !== null && unsanitizedValue$LWS !== undefined) {
            // istanbul ignore else: LWS does not test for all possible commands
            if (loweredCommand$LWS === 'inserthtml') {
              // istanbul ignore else: external is the default sandbox type for coverage runs
              if (type$LWS === 0 /* SandboxType.External */) {
                const activeElement$LWS = ReflectApply$LWS$1(originalActiveElement$LWS, this, []);
                if (isSharedElement$s$LWS(activeElement$LWS) && ReflectApply$LWS$1(originalIsContentEditable$LWS, activeElement$LWS, [])) {
                  throwLockerSecurityError$LWS(command$LWS, activeElement$LWS);
                }
              }
              // This must be called to signal to the virtual
              // CustomElementRegistry that the next thing created
              // MAY CONTAIN a custom element, which must be marked
              // for association to this sandbox.
              setCustomElementsRegistry$LWS(document$LWS, key$LWS);
              args$LWS[0] = command$LWS;
              args$LWS[2] = lwsInternalPolicy$LWS.createHTML(unsanitizedValue$LWS, key$LWS, ContentType$LWS.HTML);
            }
          }
        }
      }
      return ReflectApply$LWS$1(originalExecCommand$LWS, this, args$LWS);
    }];
  };
}
function initDistortionDocumentOnsecuritypolicyviolation$LWS({
  globalObject: {
    Document: {
      prototype: DocumentProto$LWS
    },
    HTMLDocument: HTMLDocument$LWS
  }
}) {
  return createEventDistortionFactory$LWS(DocumentProto$LWS, HTMLDocument$LWS, 'securitypolicyviolation');
}
function initDistortionDocumentOpen$LWS({
  globalObject: {
    Document: {
      prototype: {
        open: originalDocumentOpen$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalDocumentOpen$LWS, function open$LWS(...args$LWS) {
    const {
      length: length$LWS
    } = args$LWS;
    // @ts-ignore: document.open() can be called zero, one or two arguments which will open the current top-level document
    if (this === rootDocument$LWS && length$LWS < 3) {
      throw new LockerSecurityError$LWS(`Cannot open top level document.`);
    }
    // istanbul ignore else: needs default platform behavior test
    if (length$LWS >= 3) {
      // Distort three-argument document.open calls which is an alias
      // for window.open
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/open#three-argument_document.open
      const normalizedArgs$LWS = normalizeWindowOpenArguments$LWS(args$LWS);
      const childWindow$LWS = ReflectApply$LWS$1(originalDocumentOpen$LWS, this, normalizedArgs$LWS);
      // W-16032332
      // Block access to unsafe child window properties
      markForUnsafePropertyBlocking$LWS(childWindow$LWS);
      if (childWindow$LWS) {
        initWindowOpenChildWindow$LWS(childWindow$LWS, normalizedArgs$LWS[0]);
      }
      return childWindow$LWS;
    }
    // istanbul ignore next: needs default platform behavior test
    return ReflectApply$LWS$1(originalDocumentOpen$LWS, this, args$LWS);
  }];
  return function distortionDocumentOpen$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionDocumentReplaceChildren$LWS({
  globalObject: {
    Document: {
      prototype: {
        replaceChildren: originalReplaceChild$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalReplaceChild$LWS, function replaceChildren$LWS(...args$LWS) {
    if (this === rootDocument$LWS) {
      throw new LockerSecurityError$LWS(`Cannot replace children of document.`);
    }
    // istanbul ignore next: needs default platform behavior test
    return ReflectApply$LWS$1(originalReplaceChild$LWS, this, args$LWS);
  }];
  return function distortionDocumentReplaceChildren$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionDOMParserParseFromString$LWS({
  document: document$LWS,
  globalObject: globalObject$LWS,
  globalObject: {
    DOMParser: {
      prototype: {
        parseFromString: originalParseFromString$LWS
      }
    }
  }
}) {
  return function distortionDOMParserParseFromString$LWS({
    key: key$LWS
  }) {
    return [originalParseFromString$LWS, function parseFromString$LWS(...args$LWS) {
      const {
        isInherentlyUnsecure: isInherentlyUnsecure$LWS
      } = getValidator$LWS(document$LWS, globalObject$LWS);
      // DOMParser.prototype.parseFromString can only be called with
      // exactly two arguments. If it receives one argument, it will fail.
      // Some implementations will also fail if it receives more than two
      // arguments. Since any call that does not have at least two arguments
      // will fail no matter what, we only need to expend effort to sanitize
      // when we know that the operation is definitely NOT going to fail.
      if (args$LWS.length >= 2) {
        // Override the value of the first argument with a sanitized version
        // of that argument.
        const string$LWS = toSafeStringValue$LWS(args$LWS[0]);
        const mimeType$LWS = toSafeStringValue$LWS(args$LWS[1]);
        let contentType$LWS;
        switch (mimeType$LWS) {
          case 'application/xhtml+xml':
          case 'application/xml':
          case 'text/xml':
            contentType$LWS = ContentType$LWS.XML;
            break;
          case 'image/svg+xml':
            contentType$LWS = ContentType$LWS.SVG;
            break;
          default:
            contentType$LWS = ContentType$LWS.HTML;
        }
        if (contentType$LWS === ContentType$LWS.XML) {
          if (isInherentlyUnsecure$LWS(string$LWS)) {
            throw new LockerSecurityError$LWS(`Cannot 'parseFromString' using an unsecure ${toSafeTemplateStringValue$LWS(string$LWS)}.`);
          }
        }
        // This must be called to signal to the virtual
        // CustomElementRegistry that the next thing created
        // MAY CONTAIN a custom element, which must be marked for
        // association to this sandbox.
        setCustomElementsRegistry$LWS(document$LWS, key$LWS);
        args$LWS[0] = lwsInternalPolicy$LWS.createHTML(string$LWS, key$LWS, contentType$LWS);
      }
      return ReflectApply$LWS$1(originalParseFromString$LWS, this, args$LWS);
    }];
  };
}
const {
  isSharedElement: isSharedElement$r$LWS,
  isAllowedSharedElementChild: isAllowedSharedElementChild$6$LWS
} = rootValidator$LWS;
function initDistortionElementAfter$LWS({
  globalObject: {
    Element: {
      prototype: {
        after: originalAfter$LWS
      }
    },
    Node: Node$LWS
  }
}) {
  const distortionEntry$LWS = [originalAfter$LWS, function after$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$r$LWS(this)) {
      for (let i$LWS = 0, {
          length: length$LWS
        } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const argValue$LWS = args$LWS[i$LWS];
        if (!isAllowedSharedElementChild$6$LWS(argValue$LWS)) {
          const nodeNameOrString$LWS = argValue$LWS instanceof Node$LWS ? ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, argValue$LWS, []) : /* istanbul ignore next: currently unreachable via tests */toSafeStringValue$LWS(argValue$LWS);
          throw new LockerSecurityError$LWS(`Cannot insert ${nodeNameOrString$LWS} after ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
        }
      }
    }
    return ReflectApply$LWS$1(originalAfter$LWS, this, args$LWS);
  }];
  return function distortionElementAfter$LWS() {
    return distortionEntry$LWS;
  };
}
const {
  isSharedElement: isSharedElement$q$LWS,
  isAllowedSharedElementChild: isAllowedSharedElementChild$5$LWS
} = rootValidator$LWS;
function initDistortionElementAppend$LWS({
  globalObject: {
    Element: {
      prototype: {
        append: originalAppend$LWS
      }
    },
    Node: Node$LWS
  }
}) {
  const distortionEntry$LWS = [originalAppend$LWS, function append$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$q$LWS(this)) {
      // Element.prototype.append(...args) accepts an arbitrary number
      // of arguments which can be comprised of Nodes and DOMStrings.
      for (let i$LWS = 0, {
          length: length$LWS
        } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const argValue$LWS = args$LWS[i$LWS];
        // ...If any of the provided arguments is NOT a valid shared
        // element child which is limited to script and link, an
        // exception is thrown.
        if (!isAllowedSharedElementChild$5$LWS(argValue$LWS)) {
          const nodeNameOrString$LWS = argValue$LWS instanceof Node$LWS ? ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, argValue$LWS, []) : /* istanbul ignore next: currently unreachable via tests */toSafeStringValue$LWS(argValue$LWS);
          throw new LockerSecurityError$LWS(`Cannot append ${nodeNameOrString$LWS} to ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
        }
      }
    }
    return ReflectApply$LWS$1(originalAppend$LWS, this, args$LWS);
  }];
  return function distortionElementAppend$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionElementAttachShadow$LWS({
  globalObject: {
    Element: {
      prototype: {
        attachShadow: originalAttachShadow$LWS
      }
    }
  }
}) {
  return function distortionElementAttachShadow$LWS({
    key: key$LWS
  }) {
    return [originalAttachShadow$LWS, function attachShadow$LWS(...args$LWS) {
      const shadowRoot$LWS = ReflectApply$LWS$1(originalAttachShadow$LWS, this, args$LWS);
      registerShadowRootInSandbox$LWS(key$LWS, shadowRoot$LWS);
      return shadowRoot$LWS;
    }];
  };
}
const namedNodeMapToElementCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
function pairElement$LWS(attrInstance$LWS, element$LWS) {
  namedNodeMapToElementCache$LWS.set(attrInstance$LWS, element$LWS);
}
function setNamedItemWithAttr$LWS(record$LWS, originalMethod$LWS, nodeNameMap$LWS, attr$LWS) {
  const element$LWS = namedNodeMapToElementCache$LWS.get(nodeNameMap$LWS);
  // istanbul ignore else: nothing to do if there's no element
  if (element$LWS) {
    const attrName$LWS = ReflectApply$LWS$1(AttrProtoNameGetter$LWS, attr$LWS, []);
    const attrNamespace$LWS = ReflectApply$LWS$1(AttrProtoNamespaceURIGetter$LWS, attr$LWS, []);
    const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
    const distortion$LWS = getAttributeDistortion$LWS(record$LWS, element$LWS, attrName$LWS, normalizedNamespace$LWS);
    // istanbul ignore else: nothing to do if there's no distortion
    if (distortion$LWS) {
      const attrValue$LWS = ReflectApply$LWS$1(AttrProtoValueGetter$LWS, attr$LWS, []);
      return ReflectApply$LWS$1(distortion$LWS, element$LWS, [attrValue$LWS]);
    }
  }
  // istanbul ignore next: needs default platform behavior test
  return ReflectApply$LWS$1(originalMethod$LWS, nodeNameMap$LWS, [attr$LWS]);
}
function initDistortionElementAttributesGetter$LWS({
  globalObject: {
    Element: Element$LWS
  }
}) {
  const originalAttributesGetter$LWS = ObjectLookupOwnGetter$LWS$1(Element$LWS.prototype, 'attributes');
  const distortionEntry$LWS = [originalAttributesGetter$LWS, function attributes$LWS() {
    const attrs$LWS = ReflectApply$LWS$1(originalAttributesGetter$LWS, this, []);
    pairElement$LWS(attrs$LWS, this);
    return attrs$LWS;
  }];
  return function distortionElementAttributesGetter$LWS() {
    return distortionEntry$LWS;
  };
}
const {
  isSharedElement: isSharedElement$p$LWS,
  isAllowedSharedElementChild: isAllowedSharedElementChild$4$LWS
} = rootValidator$LWS;
function initDistortionElementBefore$LWS({
  globalObject: {
    Element: {
      prototype: {
        before: originalBefore$LWS
      }
    },
    Node: Node$LWS
  }
}) {
  const distortionEntry$LWS = [originalBefore$LWS, function before$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$p$LWS(this)) {
      for (let i$LWS = 0, {
          length: length$LWS
        } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const argValue$LWS = args$LWS[i$LWS];
        // istanbul ignore else: needs default platform behavior test
        if (!isAllowedSharedElementChild$4$LWS(argValue$LWS)) {
          const nodeNameOrString$LWS = argValue$LWS instanceof Node$LWS ? ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, argValue$LWS, []) : /* istanbul ignore next: currently unreachable via tests */toSafeStringValue$LWS(argValue$LWS);
          throw new LockerSecurityError$LWS(`Cannot insert ${nodeNameOrString$LWS} before ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
        }
      }
    }
    return ReflectApply$LWS$1(originalBefore$LWS, this, args$LWS);
  }];
  return function distortionElementBefore$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionElementGetInnerHTML$LWS({
  globalObject: {
    Element: {
      prototype: {
        getInnerHTML: originalGetInnerHTML$LWS
      }
    }
  }
}) {
  if (typeof originalGetInnerHTML$LWS !== 'function') {
    // istanbul ignore next: only runs in browsers without property
    return noop$LWS$1;
  }
  const distortionEntry$LWS = [originalGetInnerHTML$LWS, function getInnerHTML$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: options$LWS
      } = args$LWS;
      if (isObjectLike$LWS(options$LWS)) {
        const clonedOptions$LWS = shallowCloneOptions$LWS(options$LWS);
        clonedOptions$LWS.includeShadowRoots = false;
        args$LWS[0] = clonedOptions$LWS;
      } else {
        // If there was an argument, but it wasn't "object like",
        // it is considered invalid, so override it.
        args$LWS[0] = {
          __proto__: null,
          includeShadowRoots: false
        };
      }
    } else {
      args$LWS[0] = {
        __proto__: null,
        includeShadowRoots: false
      };
    }
    return ReflectApply$LWS$1(originalGetInnerHTML$LWS, this, args$LWS);
  }];
  return function distortionElementGetInnerHTML$LWS() {
    return distortionEntry$LWS;
  };
}
function scriptPropertySetters$LWS(incomingThis$LWS, property$LWS, valueAsTrustedString$LWS, originalScriptPropertyGetter$LWS, originalScriptPropertySetter$LWS, distortions$LWS, sandboxEvaluator$LWS, signedScriptHookSourceText$LWS) {
  const valueAsString$LWS = toSafeStringValue$LWS(valueAsTrustedString$LWS);
  if (!isScriptPropertyEvaluatorHookDefined$LWS(incomingThis$LWS)) {
    const distortedScriptPropertyGetter$LWS = distortions$LWS.get(originalScriptPropertyGetter$LWS);
    defineScriptAccessorProperty$LWS(incomingThis$LWS, property$LWS, distortedScriptPropertyGetter$LWS, originalScriptPropertySetter$LWS);
  }
  setOriginalScriptScriptProperty$LWS(incomingThis$LWS, valueAsString$LWS);
  if (!isScriptEvaluated$LWS(incomingThis$LWS)) {
    // Skip script property evaluation if script URL is already
    // specified.
    if (!isScriptURLEvaluatorHookDefined$LWS(incomingThis$LWS)) {
      defineScriptEvaluatorProperty$LWS(incomingThis$LWS, (context$LWS, defaultView$LWS, ownerDoc$LWS) => {
        deleteOriginalScriptProperty$LWS(incomingThis$LWS);
        ReflectDeleteProperty$LWS$1(incomingThis$LWS, property$LWS);
        // Set the script property immediately
        // after the evaluator hook fires to overwrite
        // the evaluator hook source text.
        ReflectApply$LWS$1(originalScriptPropertySetter$LWS, incomingThis$LWS, [valueAsTrustedString$LWS]);
        sandboxEvaluator$LWS(transformSourceText$LWS(valueAsString$LWS), context$LWS, defaultView$LWS, ownerDoc$LWS);
      });
      // Set the script property to the evaluator
      // hook which will run once the node is inserted
      // into a document. Subsequent changes to script
      // property are not evaluated.
      ReflectApply$LWS$1(originalScriptPropertySetter$LWS, incomingThis$LWS, [signedScriptHookSourceText$LWS]);
    }
    return true;
  }
  return false;
}
const {
  isInherentlyUnsecure: isInherentlyUnsecure$2$LWS,
  isSharedElement: isSharedElement$o$LWS
} = rootValidator$LWS;
function initDistortionElementInnerHTMLSetter$LWS({
  document: document$LWS,
  globalObject: {
    Element: Element$LWS,
    HTMLScriptElement: HTMLScriptElement$LWS,
    SVGElement: SVGElement$LWS,
    XMLDocument: XMLDocument$LWS
  },
  root: {
    distortions: distortions$LWS
  }
}) {
  const {
    get: originalInnerHTMLGetter$LWS,
    set: originalInnerHTMLSetter$LWS
  } = ReflectGetOwnPropertyDescriptor$LWS(Element$LWS.prototype, 'innerHTML');
  return function distortionElementInnerHTMLSetter$LWS({
    key: key$LWS,
    sandboxEvaluator: sandboxEvaluator$LWS
  }) {
    return [originalInnerHTMLSetter$LWS, function innerHTML$LWS(value$LWS) {
      const isOwnerXMLDocument$LWS = ReflectApply$LWS$1(NodeProtoOwnerDocumentGetter$LWS, this, []) instanceof XMLDocument$LWS;
      if (!isOwnerXMLDocument$LWS) {
        // istanbul ignore else: needs default platform behavior test
        if (isSharedElement$o$LWS(this)) {
          throw new LockerSecurityError$LWS(`Cannot set innerHTML of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
        }
        if (this instanceof HTMLScriptElement$LWS || this instanceof SVGScriptElement) {
          const scriptWasNotEvaluatedInScriptPropertySetter$LWS = scriptPropertySetters$LWS(this, 'innerHTML', trusted.createScript(value$LWS), originalInnerHTMLGetter$LWS, originalInnerHTMLSetter$LWS, distortions$LWS, sandboxEvaluator$LWS, trusted.createScript(SCRIPT_HOOK_SOURCE_TEXT$LWS));
          if (scriptWasNotEvaluatedInScriptPropertySetter$LWS) {
            return;
          }
        }
        // This must be called to signal to the virtual
        // CustomElementRegistry that the next thing created
        // MAY CONTAIN a custom element, which must be marked for
        // association to this sandbox.
        setCustomElementsRegistry$LWS(document$LWS, key$LWS);
        const contentType$LWS = this instanceof SVGElement$LWS ? ContentType$LWS.SVG : ContentType$LWS.HTML;
        value$LWS = lwsInternalPolicy$LWS.createHTML(value$LWS, key$LWS, contentType$LWS);
      }
      if (isInherentlyUnsecure$2$LWS(value$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot set 'innerHTML' using an unsecure ${toSafeTemplateStringValue$LWS(value$LWS)}.`);
      }
      ReflectApply$LWS$1(originalInnerHTMLSetter$LWS, this, [value$LWS]);
    }];
  };
}
const {
  isSharedElement: isSharedElement$n$LWS,
  isAllowedSharedElementChild: isAllowedSharedElementChild$3$LWS
} = rootValidator$LWS;
function initDistortionElementInsertAdjacentElement$LWS({
  globalObject: {
    Element: {
      prototype: {
        insertAdjacentElement: originalInsertAdjacentElement$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalInsertAdjacentElement$LWS, function insertAdjacentElement$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length > 1) {
      const {
        1: element$LWS
      } = args$LWS;
      // istanbul ignore else: needs default platform behavior test
      if (isSharedElement$n$LWS(this) && !isAllowedSharedElementChild$3$LWS(element$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot insert ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, element$LWS, [])} adjacent to ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
      }
    }
    return ReflectApply$LWS$1(originalInsertAdjacentElement$LWS, this, args$LWS);
  }];
  return function distortionElementInsertAdjacentElement$LWS() {
    return distortionEntry$LWS;
  };
}
const {
  isSharedElement: isSharedElement$m$LWS
} = rootValidator$LWS;
const allowedElementHTMLRegExp$LWS = /^\s*<(link|script|style)/i;
function initDistortionElementInsertAdjacentHTML$LWS({
  document: document$LWS,
  globalObject: {
    Element: {
      prototype: {
        insertAdjacentHTML: originalInsertAdjacentHTML$LWS
      }
    }
  }
}) {
  return function distortionElementInsertAdjacentHTML$LWS({
    key: key$LWS
  }) {
    return [originalInsertAdjacentHTML$LWS, function insertAdjacentHTML$LWS(...args$LWS) {
      // istanbul ignore else: needs default platform behavior test
      if (args$LWS.length > 1) {
        const match$LWS = ReflectApply$LWS$1(StringProtoMatch$LWS, args$LWS[1], [allowedElementHTMLRegExp$LWS]);
        if (isSharedElement$m$LWS(this) && match$LWS === null) {
          throw new LockerSecurityError$LWS(`Cannot insert adjacent HTML to ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}`);
        }
        // This must be called to signal to the virtual
        // CustomElementRegistry that the next thing created
        // MAY CONTAIN a custom element, which must be marked for
        // association to this sandbox.
        setCustomElementsRegistry$LWS(document$LWS, key$LWS);
        const contentType$LWS = this instanceof SVGElement ? ContentType$LWS.SVG : ContentType$LWS.HTML;
        args$LWS[1] = lwsInternalPolicy$LWS.createHTML(args$LWS[1], key$LWS, contentType$LWS);
      }
      ReflectApply$LWS$1(originalInsertAdjacentHTML$LWS, this, args$LWS);
    }];
  };
}
const {
  isSharedElement: isSharedElement$l$LWS
} = rootValidator$LWS;
function initDistortionElementOuterHTMLSetter$LWS({
  document: document$LWS,
  globalObject: {
    Element: Element$LWS
  }
}) {
  const originalOuterHTMLSetter$LWS = ObjectLookupOwnSetter$LWS(Element$LWS.prototype, 'outerHTML');
  return function distortionElementOuterHTMLSetter$LWS({
    key: key$LWS
  }) {
    return [originalOuterHTMLSetter$LWS, function outerHTML$LWS(value$LWS) {
      // istanbul ignore else: needs default platform behavior test
      if (isSharedElement$l$LWS(this)) {
        throw new LockerSecurityError$LWS(`Cannot set outerHTML of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
      }
      // This must be called to signal to the virtual
      // CustomElementRegistry that the next thing created
      // MAY CONTAIN a custom element, which must be marked for
      // association to this sandbox.
      setCustomElementsRegistry$LWS(document$LWS, key$LWS);
      const html$LWS = lwsInternalPolicy$LWS.createHTML(value$LWS, key$LWS, ContentType$LWS.HTML);
      ReflectApply$LWS$1(originalOuterHTMLSetter$LWS, this, [html$LWS]);
    }];
  };
}
const {
  isSharedElement: isSharedElement$k$LWS,
  isAllowedSharedElementChild: isAllowedSharedElementChild$2$LWS
} = rootValidator$LWS;
function initDistortionElementPrepend$LWS({
  globalObject: {
    Element: {
      prototype: {
        prepend: originalPrepend$LWS
      }
    },
    Node: Node$LWS
  }
}) {
  const distortionEntry$LWS = [originalPrepend$LWS, function prepend$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$k$LWS(this)) {
      // Element.prototype.prepend(...args) accepts an arbitrary
      // number of arguments which can be comprised of Nodes and
      // DOMStrings.
      for (let i$LWS = 0, {
          length: length$LWS
        } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const argValue$LWS = args$LWS[i$LWS];
        // ...If any of the provided arguments is NOT a valid shared
        // element child, which is limited to script and link, an
        // exception is thrown.
        if (!isAllowedSharedElementChild$2$LWS(argValue$LWS)) {
          const nodeNameOrString$LWS = argValue$LWS instanceof Node$LWS ? ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, argValue$LWS, []) : /* istanbul ignore next: currently unreachable via tests */toSafeStringValue$LWS(argValue$LWS);
          throw new LockerSecurityError$LWS(`Cannot prepend ${nodeNameOrString$LWS} to ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
        }
      }
    }
    return ReflectApply$LWS$1(originalPrepend$LWS, this, args$LWS);
  }];
  return function distortionElementPrepend$LWS() {
    return distortionEntry$LWS;
  };
}
const {
  isSharedElement: isSharedElement$j$LWS
} = rootValidator$LWS;
function initDistortionElementRemove$LWS({
  globalObject: {
    Element: {
      prototype: {
        remove: originalRemove$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalRemove$LWS, function remove$LWS() {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$j$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot remove ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
    }
    ReflectApply$LWS$1(originalRemove$LWS, this, []);
  }];
  return function distortionElementRemove$LWS() {
    return distortionEntry$LWS;
  };
}
const {
  isSharedElement: isSharedElement$i$LWS
} = rootValidator$LWS;
function initDistortionElementReplaceChildren$LWS({
  globalObject: {
    Element: {
      prototype: {
        replaceChildren: originalReplaceChildren$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalReplaceChildren$LWS, function replaceChildren$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$i$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot replace children of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
    }
    return ReflectApply$LWS$1(originalReplaceChildren$LWS, this, args$LWS);
  }];
  return function distortionElementReplaceChildren$LWS() {
    return distortionEntry$LWS;
  };
}
const {
  isSharedElement: isSharedElement$h$LWS
} = rootValidator$LWS;
function initDistortionElementReplaceWith$LWS({
  globalObject: {
    Element: {
      prototype: {
        replaceWith: originalReplaceWith$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalReplaceWith$LWS, function replaceWith$LWS(...args$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$h$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot replace ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
    }
    return ReflectApply$LWS$1(originalReplaceWith$LWS, this, args$LWS);
  }];
  return function distortionElementReplaceWith$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionElementSetAttribute$LWS({
  globalObject: {
    Element: {
      prototype: {
        setAttribute: originalSetAttribute$LWS
      }
    }
  }
}) {
  return function distortionElementSetAttribute$LWS(record$LWS) {
    return [originalSetAttribute$LWS, function setAttribute$LWS(...args$LWS) {
      if (args$LWS.length > 1) {
        const attrName$LWS = normalizeNamespacedAttributeName$LWS(toSafeStringValue$LWS(args$LWS[0]));
        const attrValue$LWS = toSafeStringValue$LWS(args$LWS[1]);
        const distortion$LWS = getAttributeDistortion$LWS(record$LWS, this, attrName$LWS);
        if (distortion$LWS) {
          ReflectApply$LWS$1(distortion$LWS, this, [attrValue$LWS]);
          return;
        }
        // Cannot use the normalized attrNameDistortionKey because
        // that value has been lowercased, which may cause issues
        // with case-sensitive attribute names such as SVG element's
        // "viewBox".
        args$LWS[0] = attrName$LWS;
        args$LWS[1] = attrValue$LWS;
      }
      ReflectApply$LWS$1(originalSetAttribute$LWS, this, args$LWS);
    }];
  };
}
function initDistortionElementSetAttributeNode$LWS({
  globalObject: {
    Attr: Attr$LWS,
    Element: {
      prototype: {
        setAttributeNode: originalSetAttributeNode$LWS
      }
    }
  }
}) {
  return function distortionElementSetAttributeNode$LWS(record$LWS) {
    return [originalSetAttributeNode$LWS, function setAttributeNode$LWS(...args$LWS) {
      const attr$LWS = args$LWS.length ? args$LWS[0] : undefined;
      if (!(attr$LWS instanceof Attr$LWS)) {
        // Handle non-Attr values using the native API.
        return ReflectApply$LWS$1(originalSetAttributeNode$LWS, this, args$LWS);
      }
      // We can't set an attribute connected to another element.
      // Calling the original getter for property ownerElement
      // validates that we are dealing with an instance of Attr.
      // istanbul ignore if: needs default platform behavior test
      if (ReflectApply$LWS$1(AttrProtoOwnerElementGetter$LWS, attr$LWS, [])) {
        return ReflectApply$LWS$1(originalSetAttributeNode$LWS, this, args$LWS);
      }
      const attrName$LWS = normalizeNamespacedAttributeName$LWS(ReflectApply$LWS$1(AttrProtoNameGetter$LWS, attr$LWS, []));
      const attrNamespace$LWS = ReflectApply$LWS$1(AttrProtoNamespaceURIGetter$LWS, attr$LWS, []);
      const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
      const distortion$LWS = getAttributeDistortion$LWS(record$LWS, this, attrName$LWS, normalizedNamespace$LWS);
      if (distortion$LWS) {
        const oldAttr$LWS = ReflectApply$LWS$1(ElementProtoGetAttributeNode$LWS, this, [attrName$LWS]);
        if (oldAttr$LWS) {
          // Disconnect old attribute.
          ReflectApply$LWS$1(ElementProtoRemoveAttributeNode$LWS, this, [oldAttr$LWS]);
        }
        const attrValue$LWS = ReflectApply$LWS$1(AttrProtoValueGetter$LWS, attr$LWS, []);
        ReflectApply$LWS$1(distortion$LWS, this, [attrValue$LWS]);
        const newAttr$LWS = ReflectApply$LWS$1(ElementProtoGetAttributeNode$LWS, this, [attrName$LWS]);
        if (newAttr$LWS) {
          // Remove distorted attribute.
          ReflectApply$LWS$1(ElementProtoRemoveAttributeNode$LWS, this, [newAttr$LWS]);
        }
        if (oldAttr$LWS) {
          // Re-attach old attribute to maintain identify checks.
          ReflectApply$LWS$1(originalSetAttributeNode$LWS, this, [oldAttr$LWS]);
        }
        if (newAttr$LWS) {
          const newValue$LWS = ReflectApply$LWS$1(AttrProtoValueGetter$LWS, newAttr$LWS, []);
          // Set the distorted attr value.
          ReflectApply$LWS$1(AttrProtoValueSetter$LWS, attr$LWS, [newValue$LWS]);
          // Replace old attr.
          return ReflectApply$LWS$1(originalSetAttributeNode$LWS, this, [attr$LWS]);
        }
        return undefined;
      }
      return ReflectApply$LWS$1(originalSetAttributeNode$LWS, this, args$LWS);
    }];
  };
}
function initDistortionElementSetAttributeNodeNS$LWS({
  globalObject: {
    Attr: Attr$LWS,
    Element: {
      prototype: {
        setAttributeNodeNS: originalSetAttributeNodeNS$LWS
      }
    }
  }
}) {
  return function distortionElementSetAttributeNodeNS$LWS(record$LWS) {
    return [originalSetAttributeNodeNS$LWS, function setAttributeNodeNS$LWS(...args$LWS) {
      const attr$LWS = args$LWS.length ? args$LWS[0] : undefined;
      if (!(attr$LWS instanceof Attr$LWS)) {
        // Handle non-Attr values using the native API.
        return ReflectApply$LWS$1(originalSetAttributeNodeNS$LWS, this, args$LWS);
      }
      // We can't set an attribute connected to another element.
      // Calling the original getter for property ownerElement
      // validates that we are dealing with an instance of Attr.
      // istanbul ignore if: needs default platform behavior test
      if (ReflectApply$LWS$1(AttrProtoOwnerElementGetter$LWS, attr$LWS, [])) {
        return ReflectApply$LWS$1(originalSetAttributeNodeNS$LWS, this, args$LWS);
      }
      const attrName$LWS = normalizeNamespacedAttributeName$LWS(ReflectApply$LWS$1(AttrProtoNameGetter$LWS, attr$LWS, []));
      const attrNamespace$LWS = ReflectApply$LWS$1(AttrProtoNamespaceURIGetter$LWS, attr$LWS, []);
      const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
      const distortion$LWS = getAttributeDistortion$LWS(record$LWS, this, attrName$LWS, normalizedNamespace$LWS);
      if (distortion$LWS) {
        const oldAttr$LWS = ReflectApply$LWS$1(ElementProtoGetAttributeNodeNS$LWS, this, [attrNamespace$LWS, attrName$LWS]);
        if (oldAttr$LWS) {
          // Disconnect the old attribute.
          ReflectApply$LWS$1(ElementProtoRemoveAttributeNode$LWS, this, [oldAttr$LWS]);
        }
        const attrValue$LWS = ReflectApply$LWS$1(AttrProtoValueGetter$LWS, attr$LWS, []);
        ReflectApply$LWS$1(distortion$LWS, this, [attrValue$LWS]);
        const newAttr$LWS = ReflectApply$LWS$1(ElementProtoGetAttributeNodeNS$LWS, this, [attrNamespace$LWS, attrName$LWS]);
        if (newAttr$LWS) {
          // Remove the distorted attribute.
          ReflectApply$LWS$1(ElementProtoRemoveAttributeNode$LWS, this, [newAttr$LWS]);
        }
        if (oldAttr$LWS) {
          // Re-attach old attribute to maintain identify checks.
          ReflectApply$LWS$1(originalSetAttributeNodeNS$LWS, this, [oldAttr$LWS]);
        }
        if (newAttr$LWS) {
          const newValue$LWS = ReflectApply$LWS$1(AttrProtoValueGetter$LWS, newAttr$LWS, []);
          // Set the distorted attr value.
          ReflectApply$LWS$1(AttrProtoValueSetter$LWS, attr$LWS, [newValue$LWS]);
          // Replace old attr.
          return ReflectApply$LWS$1(originalSetAttributeNodeNS$LWS, this, [attr$LWS]);
        }
        return null;
      }
      return ReflectApply$LWS$1(originalSetAttributeNodeNS$LWS, this, [attr$LWS]);
    }];
  };
}
function initDistortionElementSetAttributeNS$LWS({
  globalObject: {
    Element: {
      prototype: {
        setAttributeNS: originalSetAttributeNS$LWS
      }
    }
  }
}) {
  return function distortionElementSetAttributeNS$LWS(record$LWS) {
    return [originalSetAttributeNS$LWS, function setAttributeNS$LWS(...args$LWS) {
      // istanbul ignore next: needs default platform behavior test
      if (args$LWS.length < 3) {
        ReflectApply$LWS$1(originalSetAttributeNS$LWS, this, args$LWS);
        return;
      }
      let {
        0: attrNamespace$LWS
      } = args$LWS;
      if (attrNamespace$LWS !== null && attrNamespace$LWS !== undefined) {
        attrNamespace$LWS = toSafeStringValue$LWS(attrNamespace$LWS);
      }
      const attrName$LWS = normalizeNamespacedAttributeName$LWS(toSafeStringValue$LWS(args$LWS[1]));
      const attrValue$LWS = toSafeStringValue$LWS(args$LWS[2]);
      const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
      const distortion$LWS = getAttributeDistortion$LWS(record$LWS, this, attrName$LWS, normalizedNamespace$LWS);
      // istanbul ignore else: needs default platform behavior test
      if (distortion$LWS) {
        ReflectApply$LWS$1(distortion$LWS, this, [attrValue$LWS]);
        return;
      }
      // istanbul ignore next: needs default platform behavior test
      // eslint-disable-next-line no-lone-blocks
      {
        // This is in a block to avoid requiring an
        // "istanbul ignore next" for all for lines.
        // We could avoid this entirely by testing the default
        // platform behavior.
        args$LWS[0] = attrNamespace$LWS;
        // Cannot use the normalized attrNameDistortionKey because
        // that value has been lowercased, which may cause issues
        // with case-sensitive attribute names such as SVG element's
        // "viewBox".
        args$LWS[1] = attrName$LWS;
        args$LWS[2] = attrValue$LWS;
        ReflectApply$LWS$1(originalSetAttributeNS$LWS, this, args$LWS);
      }
    }];
  };
}
const {
  isInherentlyUnsecure: isInherentlyUnsecure$1$LWS,
  isSharedElement: isSharedElement$g$LWS
} = rootValidator$LWS;
function initDistortionElementSetHTML$LWS({
  document: document$LWS,
  globalObject: {
    Element: {
      prototype: {
        setHTML: originalSetHTML$LWS
      }
    },
    SVGElement: SVGElement$LWS,
    XMLDocument: XMLDocument$LWS
  }
}) {
  if (typeof originalSetHTML$LWS !== 'function') {
    // istanbul ignore next: only runs in browsers without property
    return noop$LWS$1;
  }
  // istanbul ignore next: Element.prototype.setHTML is not supported in any browser yet
  return function distortionElementSetHTML$LWS({
    key: key$LWS
  }) {
    return [originalSetHTML$LWS, function setHTML$LWS(...args$LWS) {
      const isOwnerXMLDocument$LWS = ReflectApply$LWS$1(NodeProtoOwnerDocumentGetter$LWS, this, []) instanceof XMLDocument$LWS;
      if (!isOwnerXMLDocument$LWS) {
        // istanbul ignore else: needs default platform behavior test
        if (isSharedElement$g$LWS(this)) {
          throw new LockerSecurityError$LWS(`Cannot setHTML of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
        }
        // This must be called to signal to the virtual
        // CustomElementRegistry that the next thing created
        // MAY CONTAIN a custom element, which must be marked for
        // association to this sandbox.
        setCustomElementsRegistry$LWS(document$LWS, key$LWS);
        // If options not specified, the default Sanitizer object is used.
        // This will be in addition to the sanitization we have.
        const value$LWS = args$LWS[0];
        const contentType$LWS = this instanceof SVGElement$LWS ? ContentType$LWS.SVG : ContentType$LWS.HTML;
        args$LWS[0] = lwsInternalPolicy$LWS.createHTML(value$LWS, key$LWS, contentType$LWS);
        if (isInherentlyUnsecure$1$LWS(args$LWS[0])) {
          throw new LockerSecurityError$LWS(`Cannot 'setHTML' using an unsecure ${toSafeTemplateStringValue$LWS(args$LWS[0])}.`);
        }
      }
      ReflectApply$LWS$1(originalSetHTML$LWS, this, args$LWS);
    }];
  };
}
const {
  isInherentlyUnsecure: isInherentlyUnsecure$LWS,
  isSharedElement: isSharedElement$f$LWS
} = rootValidator$LWS;
function initDistortionElementSetHTMLUnsafe$LWS({
  document: document$LWS,
  globalObject: {
    Element: Element$LWS,
    Element: {
      prototype: {
        setHTMLUnsafe: originalSetHTMLUnsafe$LWS
      }
    },
    HTMLScriptElement: HTMLScriptElement$LWS,
    SVGElement: SVGElement$LWS,
    XMLDocument: XMLDocument$LWS
  },
  root: {
    distortions: distortions$LWS
  }
}) {
  // istanbul ignore if: currently unreachable via tests
  if (typeof originalSetHTMLUnsafe$LWS !== 'function') {
    return noop$LWS$1;
  }
  return function distortionElementSetHTMLUnsafe$LWS({
    key: key$LWS,
    sandboxEvaluator: sandboxEvaluator$LWS
  }) {
    const {
      get: originalInnerHTMLGetter$LWS,
      set: originalInnerHTMLSetter$LWS
    } = ReflectGetOwnPropertyDescriptor$LWS(Element$LWS.prototype, 'innerHTML');
    return [originalSetHTMLUnsafe$LWS, function innerHTML$LWS(value$LWS) {
      const isOwnerXMLDocument$LWS = ReflectApply$LWS$1(NodeProtoOwnerDocumentGetter$LWS, this, []) instanceof XMLDocument$LWS;
      if (!isOwnerXMLDocument$LWS) {
        // istanbul ignore else: needs default platform behavior test
        if (isSharedElement$f$LWS(this)) {
          throw new LockerSecurityError$LWS(`Cannot 'setHTMLUnsafe' of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
        }
        // This is necessary to support script.setHTMLUnsafe(...)
        if (this instanceof HTMLScriptElement$LWS || this instanceof SVGScriptElement) {
          const scriptWasNotEvaluatedInScriptPropertySetter$LWS = scriptPropertySetters$LWS(this, 'innerHTML', trusted.createScript(value$LWS), originalInnerHTMLGetter$LWS, originalInnerHTMLSetter$LWS, distortions$LWS, sandboxEvaluator$LWS, trusted.createScript(SCRIPT_HOOK_SOURCE_TEXT$LWS));
          if (scriptWasNotEvaluatedInScriptPropertySetter$LWS) {
            return;
          }
        }
        // This must be called to signal to the virtual
        // CustomElementRegistry that the next thing created
        // MAY CONTAIN a custom element, which must be marked for
        // association to this sandbox.
        setCustomElementsRegistry$LWS(document$LWS, key$LWS);
        const contentType$LWS = this instanceof SVGElement$LWS ? ContentType$LWS.SVG : ContentType$LWS.HTML;
        value$LWS = lwsInternalPolicy$LWS.createHTML(value$LWS, key$LWS, contentType$LWS);
      }
      if (isInherentlyUnsecure$LWS(value$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot 'setHTMLUnsafe' using an unsecure ${toSafeTemplateStringValue$LWS(value$LWS)}.`);
      }
      ReflectApply$LWS$1(originalSetHTMLUnsafe$LWS, this, [value$LWS]);
    }];
  };
}
function initDistortionElementShadowRootGetter$LWS({
  globalObject: {
    Element: Element$LWS
  }
}) {
  const originalShadowRootGetter$LWS = ObjectLookupOwnGetter$LWS$1(Element$LWS.prototype, 'shadowRoot');
  return function distortionShadowRootGetter$LWS({
    key: key$LWS
  }) {
    return [originalShadowRootGetter$LWS, function shadowRoot$LWS() {
      const realShadowRoot$LWS = ReflectApply$LWS$1(originalShadowRootGetter$LWS, this, []);
      if (isShadowRootAccessibleInThisSandbox$LWS(key$LWS, realShadowRoot$LWS)) {
        return realShadowRoot$LWS;
      }
      return null;
    }];
  };
}
function initDistortionElementToggleAttribute$LWS({
  globalObject: {
    Element: {
      prototype: {
        hasAttribute: ElementProtoHasAttribute$LWS,
        toggleAttribute: originalToggleAttribute$LWS
      }
    }
  }
}) {
  return function distortionElementToggleAttribute$LWS(record$LWS) {
    return [originalToggleAttribute$LWS, function toggleAttribute$LWS(...args$LWS) {
      const {
        length: length$LWS
      } = args$LWS;
      // istanbul ignore else: needs default platform behavior test
      if (length$LWS > 0) {
        const attrName$LWS = toSafeStringValue$LWS(args$LWS[0]);
        const distortion$LWS = getAttributeDistortion$LWS(record$LWS, this, attrName$LWS);
        // istanbul ignore else: needs default platform behavior test
        if (distortion$LWS) {
          const distortionArgs$LWS = length$LWS > 1 ? [args$LWS[1]] : [];
          // Calling the distortion may end this execution entirely,
          // if the distortion throws.
          ReflectApply$LWS$1(distortion$LWS, this, distortionArgs$LWS);
          // If the distortion does not throw, then we need to
          // return true | false, based on the presence or absence
          // of this attribute.
          return ReflectApply$LWS$1(ElementProtoHasAttribute$LWS, this, [attrName$LWS]);
        }
        // Cannot use the normalized attrNameDistortionKey because
        // that value has been lowercased, which may cause issues
        // with case-sensitive attribute names such as SVG element's
        // "viewBox".
        // istanbul ignore next: needs default platform behavior test
        args$LWS[0] = attrName$LWS;
      }
      // istanbul ignore next: needs default platform behavior test
      return ReflectApply$LWS$1(originalToggleAttribute$LWS, this, args$LWS);
    }];
  };
}
function initDistortionEval$LWS({
  UNCOMPILED_CONTEXT: UNCOMPILED_CONTEXT$LWS,
  globalObject: {
    eval: originalEval$LWS
  }
}) {
  return function distortionEval$LWS({
    sandboxEvaluator: sandboxEvaluator$LWS,
    virtualEnvironmentEvaluator: virtualEnvironmentEvaluator$LWS
  }) {
    return [originalEval$LWS, function (sourceText$LWS) {
      throwIfMarkedAsUnsafeInChildWindow$LWS(virtualEnvironmentEvaluator$LWS, 'eval');
      return sandboxEvaluator$LWS(transformSourceText$LWS(toSafeStringValue$LWS(sourceText$LWS)), UNCOMPILED_CONTEXT$LWS);
    }];
  };
}
function createDistortedComposedPath$LWS(event$LWS, sandboxKey$LWS) {
  const currentTarget$LWS = ReflectApply$LWS$1(EventProtoCurrentTargetGetter$LWS, event$LWS, []);
  const {
    composedPath: originalComposedPath$LWS
  } = Event.prototype;
  const rawComposedPath$LWS = ReflectApply$LWS$1(originalComposedPath$LWS, event$LWS, []);
  const currentTargetIndex$LWS = ReflectApply$LWS$1(ArrayProtoIndexOf$LWS$1, rawComposedPath$LWS, [currentTarget$LWS]);
  let distortedComposedPath$LWS = rawComposedPath$LWS;
  for (let i$LWS = currentTargetIndex$LWS; i$LWS > -1; i$LWS -= 1) {
    const objectThatMightBeAShadowRoot$LWS = rawComposedPath$LWS[i$LWS];
    if (objectThatMightBeAShadowRoot$LWS instanceof ShadowRoot &&
    // Only interfere if this sandbox is not allowed to access this shadowRoot
    !isShadowRootAccessibleInThisSandbox$LWS(sandboxKey$LWS, objectThatMightBeAShadowRoot$LWS)) {
      // If we reach an instance of ShadowRoot, we don't want
      // to include it in the returned path list. This matches
      // the behavior of mode: closed.
      distortedComposedPath$LWS = ReflectApply$LWS$1(ArrayProtoSlice$LWS$1, rawComposedPath$LWS, [i$LWS + 1]);
      break;
    }
  }
  return distortedComposedPath$LWS;
}
function initDistortionEventComposedPath$LWS({
  globalObject: {
    Event: {
      prototype: {
        composedPath: originalComposedPath$LWS
      }
    }
  }
}) {
  return function distortionEventComposedPath$LWS({
    key: key$LWS
  }) {
    return [originalComposedPath$LWS, function composedPath$LWS() {
      return createDistortedComposedPath$LWS(this, key$LWS);
    }];
  };
}
function initDistortionEventPathGetter$LWS({
  globalObject: {
    Event: Event$LWS
  }
}) {
  const originalPathGetter$LWS = ObjectLookupOwnGetter$LWS$1(Event$LWS.prototype, 'path');
  // istanbul ignore else: currently unreachable via tests
  if (typeof originalPathGetter$LWS !== 'function') {
    return noop$LWS$1;
  }
  // istanbul ignore next: currently unreachable via tests
  return function distortionEventPathGetter$LWS({
    key: key$LWS
  }) {
    return [originalPathGetter$LWS,
    // Chromium 109 removed Event.prototype.path
    // https://chromestatus.com/feature/5726124632965120
    // istanbul ignore next: currently unreachable via tests
    function path$LWS() {
      return createDistortedComposedPath$LWS(this, key$LWS);
    }];
  };
}
function initDistortionEventTargetAddEventListener$LWS({
  globalObject: {
    EventTarget: {
      prototype: {
        addEventListener: originalAddEventListener$LWS
      }
    }
  }
}) {
  return function distortionEventTargetAddEventListener$LWS(record$LWS) {
    function addEventListener$LWS(...args$LWS) {
      const {
        length: length$LWS
      } = args$LWS;
      // Ensure that we fallback to the default platform behavior which
      // should fail if less than 2 arguments are provided.
      // istanbul ignore else: needs default platform behavior test
      if (length$LWS > 1) {
        const eventName$LWS = toSafeStringValue$LWS(args$LWS[0]);
        if (isEventTargetRestricted$LWS(record$LWS, this, eventName$LWS)) {
          throw new LockerSecurityError$LWS(createEventListenerExceptionMessage$LWS(this, eventName$LWS));
        }
        args$LWS[0] = eventName$LWS;
      }
      return ReflectApply$LWS$1(originalAddEventListener$LWS, this, args$LWS);
    }
    return [originalAddEventListener$LWS, addEventListener$LWS];
  };
}
function initDistortionFunction$LWS({
  UNCOMPILED_CONTEXT: UNCOMPILED_CONTEXT$LWS,
  globalObject: {
    Function: originalFunction$LWS
  }
}) {
  const funcFooterRegExp$LWS = /\n?}[^}]*$/;
  return function distortionFunction$LWS({
    sandboxEvaluator: sandboxEvaluator$LWS,
    virtualEnvironmentEvaluator: virtualEnvironmentEvaluator$LWS
  }) {
    return [originalFunction$LWS, function Function$LWS(...args$LWS) {
      throwIfMarkedAsUnsafeInChildWindow$LWS(virtualEnvironmentEvaluator$LWS, 'Function');
      // The `arguments` object has `Symbol.iterator` as an own
      // property, not inherited, so it avoids prototype pollution
      // attacks.
      const sandboxFuncCtor$LWS = sandboxEvaluator$LWS('(function() {return Function(...arguments)})');
      const {
        length: length$LWS
      } = args$LWS;
      if (!length$LWS) {
        return ReflectApply$LWS$1(sandboxFuncCtor$LWS, this, []);
      }
      const lastIndex$LWS = length$LWS - 1;
      const funcBody$LWS = toSafeStringValue$LWS(args$LWS[lastIndex$LWS]);
      // Validate parsing the function body.
      ReflectApply$LWS$1(sandboxFuncCtor$LWS, this, [funcBody$LWS]);
      // Make function body empty to create the wire-frame.
      args$LWS[lastIndex$LWS] = '';
      const wireFunc$LWS = ReflectApply$LWS$1(sandboxFuncCtor$LWS, this, args$LWS);
      const prefix$LWS = `${generateContextAssignmentCodeFromContextNames$LWS(UNIVERSAL_CONTEXT_NAMES$LWS)};`;
      const header$LWS = ReflectApply$LWS$1(StringProtoReplace$LWS, `${wireFunc$LWS}`, [funcFooterRegExp$LWS, '']);
      const code$LWS = compileSourceText$LWS(funcBody$LWS);
      // NOTE: Function constructor and eval are controlled by the
      // same CSP rules, which means we can rely on eval to fulfill
      // the behavior of the Function constructor.
      return sandboxEvaluator$LWS(`${prefix$LWS}(${header$LWS}${code$LWS}\n})`, UNCOMPILED_CONTEXT$LWS);
    }];
  };
}
function initDistortionHistoryPushState$LWS({
  globalObject: {
    DOMException: DOMException$LWS,
    History: {
      prototype: {
        pushState: originalPushState$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalPushState$LWS, function pushState$LWS(...args$LWS) {
    try {
      return ReflectApply$LWS$1(originalPushState$LWS, this, args$LWS);
    } catch (error) {
      if (args$LWS.length && error instanceof DOMException$LWS) {
        const state$LWS = args$LWS[0];
        if (isObject$LWS$1(state$LWS)) {
          args$LWS[0] = partialStructuredClone$LWS(state$LWS);
          return ReflectApply$LWS$1(originalPushState$LWS, this, args$LWS);
        }
      }
      throw error;
    }
  }];
  return function distortionHistoryPushState$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionHistoryReplaceState$LWS({
  globalObject: {
    DOMException: DOMException$LWS,
    History: {
      prototype: {
        replaceState: originalReplaceState$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalReplaceState$LWS, function replaceState$LWS(...args$LWS) {
    try {
      return ReflectApply$LWS$1(originalReplaceState$LWS, this, args$LWS);
    } catch (error) {
      if (args$LWS.length && error instanceof DOMException$LWS) {
        const state$LWS = args$LWS[0];
        if (isObject$LWS$1(state$LWS)) {
          args$LWS[0] = partialStructuredClone$LWS(state$LWS);
          return ReflectApply$LWS$1(originalReplaceState$LWS, this, args$LWS);
        }
      }
      throw error;
    }
  }];
  return function distortionHistoryReplaceState$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionHTMLBodyElementOnrejectionhandled$LWS({
  globalObject: {
    HTMLBodyElement: HTMLBodyElement$LWS
  }
}) {
  return createEventDistortionFactory$LWS(HTMLBodyElement$LWS.prototype, HTMLBodyElement$LWS, 'rejectionhandled');
}
function initDistortionHTMLBodyElementOnstorage$LWS({
  globalObject: {
    HTMLBodyElement: HTMLBodyElement$LWS
  }
}) {
  return createEventDistortionFactory$LWS(HTMLBodyElement$LWS.prototype, HTMLBodyElement$LWS, 'storage');
}
function initDistortionHTMLBodyElementOnunhandledrejection$LWS({
  globalObject: {
    HTMLBodyElement: HTMLBodyElement$LWS
  }
}) {
  return createEventDistortionFactory$LWS(HTMLBodyElement$LWS.prototype, HTMLBodyElement$LWS, 'unhandledrejection');
}
function initDistortionHTMLElementCtor$LWS({
  document: document$LWS,
  globalObject: {
    HTMLElement: originalHTMLElementCtor$LWS
  }
}) {
  // We MUST use a reference to the now patched version of this API method,
  // or else we'll end up attempting to distort the wrong definition.
  return function distortionHTMLElementCtor$LWS({
    key: key$LWS
  }) {
    let registry$LWS;
    return [originalHTMLElementCtor$LWS, function HTMLElement$LWS() {
      if (new.target === undefined) {
        throw new TypeErrorCtor$LWS$1(ERR_NO_NEW_OP_HTML_ELEMENT$LWS);
      }
      if (new.target === HTMLElement$LWS) {
        throw new TypeErrorCtor$LWS$1(ERR_ILLEGAL_CONSTRUCTOR$LWS);
      }
      if (registry$LWS === undefined) {
        registry$LWS = getSandboxCustomElementRegistry$LWS(document$LWS, key$LWS);
      }
      return registry$LWS.newCtor(this, new.target, originalHTMLElementCtor$LWS);
    }];
  };
}
function initDistortionHTMLElementDatasetGetter$LWS({
  globalObject: {
    HTMLElement: HTMLElement$LWS
  }
}) {
  const originalDatasetGetter$LWS = ObjectLookupOwnGetter$LWS$1(HTMLElement$LWS.prototype, 'dataset');
  const distortionEntry$LWS = [originalDatasetGetter$LWS, function dataset$LWS() {
    return trackAsLiveTarget$LWS(ReflectApply$LWS$1(originalDatasetGetter$LWS, this, []));
  }];
  return function distortionHTMLElementDatasetGetter$LWS() {
    return distortionEntry$LWS;
  };
}
const {
  isSharedElement: isSharedElement$e$LWS
} = rootValidator$LWS;
function initDistortionHTMLElementInnerTextSetter$LWS({
  globalObject: {
    HTMLElement: HTMLElement$LWS
  }
}) {
  const originalInnerTextSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLElement$LWS.prototype, 'innerText');
  // istanbul ignore if: currently unreachable via tests
  if (typeof originalInnerTextSetter$LWS !== 'function') {
    return noop$LWS$1;
  }
  const distortionEntry$LWS = [originalInnerTextSetter$LWS, function innerText$LWS(value$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$e$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot set innerText of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
    }
    ReflectApply$LWS$1(originalInnerTextSetter$LWS, this, [value$LWS]);
  }];
  return function distortionHTMLElementInnerTextSetter$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionHTMLElementOnsecuritypolicyviolation$LWS({
  globalObject: {
    HTMLElement: {
      prototype: HTMLElementProto$LWS
    },
    HTMLElement: HTMLElement$LWS
  }
}) {
  return createEventDistortionFactory$LWS(HTMLElementProto$LWS, HTMLElement$LWS, 'securitypolicyviolation');
}
const {
  isSharedElement: isSharedElement$d$LWS
} = rootValidator$LWS;
// The outerText property is non-standard, so the descriptor could be undefined,
// like in the case of Firefox.
// https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/outerText#Browser_compatibility
function initDistortionHTMLElementOuterTextSetter$LWS({
  globalObject: {
    HTMLElement: HTMLElement$LWS
  }
}) {
  const originalOuterTextSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLElement$LWS.prototype, 'outerText');
  // istanbul ignore if: currently unreachable via tests
  if (typeof originalOuterTextSetter$LWS !== 'function') {
    return noop$LWS$1;
  }
  const distortionEntry$LWS = [originalOuterTextSetter$LWS, function outerText$LWS(value$LWS) {
    // istanbul ignore else: needs default platform behavior test
    if (isSharedElement$d$LWS(this)) {
      throw new LockerSecurityError$LWS(`Cannot set outerText of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])}.`);
    }
    ReflectApply$LWS$1(originalOuterTextSetter$LWS, this, [value$LWS]);
  }];
  return function distortionHTMLElementOuterTextSetter$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionHTMLElementStyleGetter$LWS({
  globalObject: {
    HTMLElement: HTMLElement$LWS
  }
}) {
  const originalStyleGetter$LWS = ObjectLookupOwnGetter$LWS$1(HTMLElement$LWS.prototype, 'style');
  const distortionEntry$LWS = [originalStyleGetter$LWS, function style$LWS() {
    return trackAsLiveTarget$LWS(ReflectApply$LWS$1(originalStyleGetter$LWS, this, []));
  }];
  return function distortionHTMLElementStyleGetter$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionHTMLFrameSetElementOnrejectionhandled$LWS({
  globalObject: {
    HTMLFrameSetElement: HTMLFrameSetElement$LWS
  }
}) {
  return createEventDistortionFactory$LWS(HTMLFrameSetElement$LWS.prototype, HTMLFrameSetElement$LWS, 'rejectionhandled');
}
function initDistortionHTMLFrameSetElementOnstorage$LWS({
  globalObject: {
    HTMLFrameSetElement: HTMLFrameSetElement$LWS
  }
}) {
  return createEventDistortionFactory$LWS(HTMLFrameSetElement$LWS.prototype, HTMLFrameSetElement$LWS, 'storage');
}
function initDistortionHTMLFrameSetElementOnunhandledrejection$LWS({
  globalObject: {
    HTMLFrameSetElement: HTMLFrameSetElement$LWS
  }
}) {
  return createEventDistortionFactory$LWS(HTMLFrameSetElement$LWS.prototype, HTMLFrameSetElement$LWS, 'unhandledrejection');
}
function initDistortionIFrameElementContentDocumentGetter$LWS({
  globalObject: {
    HTMLIFrameElement: HTMLIFrameElement$LWS
  }
}) {
  const originalContentDocumentGetter$LWS = ObjectLookupOwnGetter$LWS$1(HTMLIFrameElement$LWS.prototype, 'contentDocument');
  const distortionEntry$LWS = [originalContentDocumentGetter$LWS, function get$LWS() {
    // The contentDocument proxy object of a kept alive sandbox iframe is revoked.
    return isRevokedProxy$LWS(this) ? /* istanbul ignore next: currently unreachable via tests */null : ReflectApply$LWS$1(originalContentDocumentGetter$LWS, this, []);
  }];
  return function distortionIFrameElementContentDocument$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionIFrameElementContentWindowGetter$LWS({
  globalObject: {
    HTMLIFrameElement: HTMLIFrameElement$LWS
  }
}) {
  const originalContentWindowGetter$LWS = ObjectLookupOwnGetter$LWS$1(HTMLIFrameElement$LWS.prototype, 'contentWindow');
  const distortionEntry$LWS = [originalContentWindowGetter$LWS, function get$LWS() {
    // The contentWindow proxy object of a kept alive sandbox iframe is revoked.
    return isRevokedProxy$LWS(this) ? /* istanbul ignore next: currently unreachable via tests */null : ReflectApply$LWS$1(originalContentWindowGetter$LWS, this, []);
  }];
  return function distortionIFrameElementContentWindow$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionHTMLIFrameElementSandboxGetter$LWS({
  globalObject: {
    HTMLIFrameElement: HTMLIFrameElement$LWS
  }
}) {
  const originalSandboxGetter$LWS = ObjectLookupOwnGetter$LWS$1(HTMLIFrameElement$LWS.prototype, 'sandbox');
  return function distortionHTMLIFrameElementSandboxGetter$LWS({
    key: key$LWS
  }) {
    return [originalSandboxGetter$LWS, function sandbox$LWS() {
      const sandboxTokenList$LWS = ReflectApply$LWS$1(HTMLIFrameElementProtoSandboxGetter$LWS, this, []);
      if (isGaterEnabledFeature$LWS(ENABLE_SANDBOXED_SAMEORIGIN_IFRAME_GATE$LWS) && isNotAllowedToOverrideGaterEnabledFeature$LWS(key$LWS, ENABLE_SANDBOXED_SAMEORIGIN_IFRAME_GATE$LWS)) {
        // By returning a "copy" of the real "sandbox" DOMTokenList as an array of strings, LWS ensures
        // that the real "sandbox" DOMTokenList is not accessible from code within the LWS sandbox.
        return [...sandboxTokenList$LWS];
      }
      // istanbul ignore next: this line is untested because tests are run with all gates enabled.
      return sandboxTokenList$LWS;
    }];
  };
}
const ABOUT_BLANK_TOKEN$LWS = 'about:blank';
const ALLOW_SAME_ORIGIN_TOKEN$LWS = 'allow-same-origin';
const ALLOW_SCRIPTS_TOKEN$LWS = 'allow-scripts';
const sameOriginSandboxedByLWS$LWS = toSafeWeakSet$LWS$1(new WeakSetCtor$LWS$1());
function enforceSandboxAllowScriptsForSameOriginIframeRealm$LWS(iframe$LWS) {
  const sandboxTokenList$LWS = ReflectApply$LWS$1(HTMLIFrameElementProtoSandboxGetter$LWS, iframe$LWS, []);
  const srcValue$LWS = ReflectApply$LWS$1(HTMLIFrameElementProtoSrcGetter$LWS, iframe$LWS, []);
  // Before adding "allow-scripts", check that "allow-same-origin" isn't present. If it is,
  // throw an exception because LWS cannot allow an iframe created by component code to
  // have sandbox="allow-same-origin allow-scripts", because that would enable access to
  // the top level global object.
  if (ReflectApply$LWS$1(DOMTokenListProtoContains$LWS, sandboxTokenList$LWS, [ALLOW_SAME_ORIGIN_TOKEN$LWS])) {
    // Remove the 'allow-same-origin' sandbox token and throw an exception. This prevents
    // component code from wrapping the operation in a try catch and then exploiting
    // the iframe that may now have "allow-scripts allow-same-origin".
    ReflectApply$LWS$1(DOMTokenListProtoRemove$LWS, sandboxTokenList$LWS, [ALLOW_SAME_ORIGIN_TOKEN$LWS]);
    throw new LockerSecurityError$LWS('HTMLIFrameElement.sandbox cannot be set to "allow-same-origin"');
  }
  if (srcValue$LWS !== '' && srcValue$LWS !== ABOUT_BLANK_TOKEN$LWS) {
    // If there is a valid src value and it is not "about:blank", parse it and
    // compare it to the top level window's location.origin. We don't want to
    // impose the sandbox="allow-scripts" on cross-origin iframes.
    try {
      const srcUrlOrigin$LWS = ReflectApply$LWS$1(URLProtoOriginGetter$LWS, new URLCtor$LWS(srcValue$LWS), []);
      // If this iframe.src is cross-origin, let the browser take care of security.
      if (srcUrlOrigin$LWS && srcUrlOrigin$LWS !== rootWindow$LWS$1.location.origin) {
        return;
      }
    } catch (_unused2$LWS) {
      /* empty */
    }
    if (!ReflectApply$LWS$1(DOMTokenListProtoContains$LWS, sandboxTokenList$LWS, [ALLOW_SCRIPTS_TOKEN$LWS])) {
      // Track that LWS added this token
      sameOriginSandboxedByLWS$LWS.add(iframe$LWS);
      ReflectApply$LWS$1(DOMTokenListProtoAdd$LWS, sandboxTokenList$LWS, [ALLOW_SCRIPTS_TOKEN$LWS]);
    }
  } else {
    if (srcValue$LWS === ABOUT_BLANK_TOKEN$LWS && sameOriginSandboxedByLWS$LWS.has(iframe$LWS)) {
      // If the sandboxed code is navigated away from a same origin url,
      // to "about:blank", and the only token is the one we created,
      // then we can remove the sandbox attribute entirely.
      sameOriginSandboxedByLWS$LWS.delete(iframe$LWS);
      ReflectApply$LWS$1(DOMTokenListProtoRemove$LWS, sandboxTokenList$LWS, [ALLOW_SCRIPTS_TOKEN$LWS]);
      // If after removing ALLOW_SCRIPTS_TOKEN, the sandbox attribute is empty,
      // we can remove it entirely.
      if (ReflectApply$LWS$1(DOMTokenListProtoLengthGetter$LWS, sandboxTokenList$LWS, []) === 0) {
        ReflectApply$LWS$1(ElementProtoRemoveAttribute$LWS, iframe$LWS, ['sandbox']);
      }
    }
  }
}
function initDistortionHTMLIFrameElementSrcSetter$LWS({
  globalObject: {
    HTMLIFrameElement: HTMLIFrameElement$LWS
  }
}) {
  const originalSrcSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLIFrameElement$LWS.prototype, 'src');
  return function distortionHTMLIFrameElementSrcSetter$LWS(record$LWS) {
    function src$LWS(value$LWS) {
      const normalizedSrcValue$LWS = toSafeStringValue$LWS(value$LWS);
      // If the string being set to iframe.src is not an empty string, sanitize it for assignment
      // to iframe.src. If it is an empty string, let it be and proceed.
      // Otherwise, take no action.
      const urlString$LWS = normalizedSrcValue$LWS !== '' ? sanitizeURLForElement$LWS(normalizedSrcValue$LWS) : '';
      if (urlString$LWS && !isValidURLScheme$LWS(urlString$LWS)) {
        throw new LockerSecurityError$LWS('HTMLIFrameElement.src supports http://, https:// schemes, relative urls and about:blank.');
      }
      ReflectApply$LWS$1(HTMLIFrameElementProtoSrcSetter$LWS, this, [urlString$LWS]);
      if (isGaterEnabledFeature$LWS(ENABLE_SANDBOXED_SAMEORIGIN_IFRAME_GATE$LWS) && isNotAllowedToOverrideGaterEnabledFeature$LWS(record$LWS.key, ENABLE_SANDBOXED_SAMEORIGIN_IFRAME_GATE$LWS)) {
        enforceSandboxAllowScriptsForSameOriginIframeRealm$LWS(this);
      }
    }
    registerAttributeDistortion$LWS(record$LWS, HTMLIFrameElement$LWS, 'src', NAMESPACE_DEFAULT$LWS, src$LWS);
    return [originalSrcSetter$LWS, src$LWS];
  };
}
function initDistortionHTMLIFrameElementSandboxSetter$LWS({
  globalObject: {
    HTMLIFrameElement: HTMLIFrameElement$LWS
  }
}) {
  const originalSandboxSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLIFrameElement$LWS.prototype, 'sandbox');
  return function distortionHTMLIFrameElementSandboxSetter$LWS(record$LWS) {
    function sandbox$LWS(value$LWS) {
      ReflectApply$LWS$1(HTMLIFrameElementProtoSandboxSetter$LWS, this, [value$LWS]);
      if (isGaterEnabledFeature$LWS(ENABLE_SANDBOXED_SAMEORIGIN_IFRAME_GATE$LWS) && isNotAllowedToOverrideGaterEnabledFeature$LWS(record$LWS.key, ENABLE_SANDBOXED_SAMEORIGIN_IFRAME_GATE$LWS)) {
        enforceSandboxAllowScriptsForSameOriginIframeRealm$LWS(this);
      }
    }
    registerAttributeDistortion$LWS(record$LWS, HTMLIFrameElement$LWS, 'sandbox', NAMESPACE_DEFAULT$LWS, sandbox$LWS);
    return [originalSandboxSetter$LWS, sandbox$LWS];
  };
}
const importRegExp$LWS = /import/i;
const WARN_MESSAGE$LWS = 'Lightning Web Security: HTMLLinkElement does not allow setting "rel" property to "import" value.';
function isValidRelValue$LWS(value$LWS) {
  return typeof value$LWS !== 'string' || !ReflectApply$LWS$1(RegExpProtoTest$LWS$1, importRegExp$LWS, [value$LWS]);
}
function initDistortionHTMLLinkElementRelSetter$LWS({
  globalObject: {
    HTMLLinkElement: HTMLLinkElement$LWS
  }
}) {
  const originalRelSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLLinkElement$LWS.prototype, 'rel');
  function rel$LWS(value$LWS) {
    const valueAsString$LWS = toSafeStringValue$LWS(value$LWS);
    if (isValidRelValue$LWS(valueAsString$LWS)) {
      ReflectApply$LWS$1(originalRelSetter$LWS, this, [valueAsString$LWS]);
      return;
    }
    consoleWarn$LWS(WARN_MESSAGE$LWS);
  }
  const distortionEntry$LWS = [originalRelSetter$LWS, rel$LWS];
  return function distortionHTMLLinkElementRelSetter$LWS(record$LWS) {
    registerAttributeDistortion$LWS(record$LWS, HTMLLinkElement$LWS, 'rel', NAMESPACE_DEFAULT$LWS, rel$LWS);
    return distortionEntry$LWS;
  };
}
function initDistortionHTMLLinkElementRelListSetter$LWS({
  globalObject: {
    DOMTokenList: DOMTokenList$LWS,
    HTMLLinkElement: HTMLLinkElement$LWS
  }
}) {
  const originalRelListSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLLinkElement$LWS.prototype, 'relList');
  const distortionEntry$LWS = [originalRelListSetter$LWS, function relList$LWS(relListValue$LWS) {
    const string$LWS = relList$LWS instanceof DOMTokenList$LWS ? /* istanbul ignore next: needs default platform behavior test */ReflectApply$LWS$1(DOMTokenListProtoValueGetter$LWS, relListValue$LWS, []) : toSafeStringValue$LWS(relListValue$LWS);
    if (isValidRelValue$LWS(string$LWS)) {
      ReflectApply$LWS$1(originalRelListSetter$LWS, this, [string$LWS]);
      return;
    }
    consoleWarn$LWS(WARN_MESSAGE$LWS);
  }];
  return function distortionHTMLLinkElementRelListSetter$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionHTMLObjectElementDataSetter$LWS({
  globalObject: {
    HTMLObjectElement: HTMLObjectElement$LWS
  }
}) {
  const originalDataSetter$LWS = ObjectLookupOwnSetter$LWS(HTMLObjectElement$LWS.prototype, 'data');
  function data$LWS(value$LWS) {
    const urlString$LWS = sanitizeURLForElement$LWS(value$LWS);
    if (!isValidURLScheme$LWS(urlString$LWS)) {
      throw new LockerSecurityError$LWS('HTMLObjectElement.data supports http://, https:// schemes, relative urls and about:blank.');
    }
    const parsedURL$LWS = parseURL$LWS(urlString$LWS);
    if (!isValidURL$LWS(parsedURL$LWS)) {
      throw new LockerSecurityError$LWS(`Cannot request disallowed endpoint: ${parsedURL$LWS.normalizedURL}`);
    }
    ReflectApply$LWS$1(originalDataSetter$LWS, this, [trusted.createScriptURL(urlString$LWS)]);
  }
  const distortionEntry$LWS = [originalDataSetter$LWS, data$LWS];
  return function distortionHTMLObjectElementDataSetter$LWS(record$LWS) {
    registerAttributeDistortion$LWS(record$LWS, HTMLObjectElement$LWS, 'data', NAMESPACE_DEFAULT$LWS, data$LWS);
    return distortionEntry$LWS;
  };
}
const descriptorCaches$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
function createBlockedAttributeDistortionFactoryInitializer$LWS(Ctor$LWS, ctorName$LWS, attributeName$LWS) {
  return function initDistortionBlockedAttribute$LWS() {
    const enquotedAttributeName$LWS = enquote$LWS(attributeName$LWS);
    const distortionName$LWS = `blocked${capitalizeFirstChar$LWS(attributeName$LWS)}Attribute`;
    // Use a computed property to dynamically set the distortion function
    // name without using `Reflect.defineProperty()`.
    const {
      [distortionName$LWS]: distortion$LWS
    } = {
      [distortionName$LWS]: () => {
        throw new LockerSecurityError$LWS(`Attribute ${enquotedAttributeName$LWS} not allowed on ${ctorName$LWS}.`);
      }
    };
    return function distortionBlockedAttribute$LWS(record$LWS) {
      registerAttributeDistortion$LWS(record$LWS, Ctor$LWS, attributeName$LWS, NAMESPACE_DEFAULT$LWS, distortion$LWS);
    };
  };
}
function createGetThrowerFactoryInitializer$LWS(proto$LWS, key$LWS) {
  const originalGet$LWS = ObjectLookupOwnGetter$LWS$1(proto$LWS, key$LWS);
  const keyAsString$LWS = toSafeTemplateStringValue$LWS(key$LWS);
  const distortionEntry$LWS = [originalGet$LWS,
  // eslint-disable-next-line prefer-arrow-callback
  function get$LWS() {
    throw new LockerSecurityError$LWS(`Cannot access ${keyAsString$LWS}.`);
  }];
  function getThrowerDistortionFactory$LWS() {
    return distortionEntry$LWS;
  }
  return function getThrowerDistortionFactoryInitializer$LWS() {
    return getThrowerDistortionFactory$LWS;
  };
}
function createSetThrowerFactoryInitializer$LWS(proto$LWS, key$LWS) {
  const originalSet$LWS = ObjectLookupOwnSetter$LWS(proto$LWS, key$LWS);
  const keyAsString$LWS = toSafeTemplateStringValue$LWS(key$LWS);
  const distortionEntry$LWS = [originalSet$LWS,
  // eslint-disable-next-line prefer-arrow-callback
  function set$LWS() {
    throw new LockerSecurityError$LWS(`Cannot access ${keyAsString$LWS}.`);
  }];
  function setThrowerDistortionFactory$LWS() {
    return distortionEntry$LWS;
  }
  return function setThrowerDistortionFactoryInitializer$LWS() {
    return setThrowerDistortionFactory$LWS;
  };
}
function createValueThrowerFactoryInitializer$LWS(proto$LWS, key$LWS) {
  const {
    [key$LWS]: originalValue$LWS
  } = proto$LWS;
  const keyAsString$LWS = toSafeTemplateStringValue$LWS(key$LWS);
  const distortionEntry$LWS = [originalValue$LWS,
  // eslint-disable-next-line prefer-arrow-callback
  function value$LWS() {
    throw new LockerSecurityError$LWS(`Cannot access ${keyAsString$LWS}.`);
  }];
  function valueThrowerDistortionFactory$LWS() {
    return distortionEntry$LWS;
  }
  return function valueThrowerDistortionFactoryInitializer$LWS() {
    return valueThrowerDistortionFactory$LWS;
  };
}
function addBlockedAttributeDistortionFactoryInitializers$LWS(Ctor$LWS, ctorName$LWS, attributes$LWS, factoryInitializers$LWS) {
  let {
    length: factoryInitializersOffset$LWS
  } = factoryInitializers$LWS;
  for (let i$LWS = 0, {
      length: length$LWS
    } = attributes$LWS; i$LWS < length$LWS; i$LWS += 1) {
    factoryInitializers$LWS[factoryInitializersOffset$LWS++] = createBlockedAttributeDistortionFactoryInitializer$LWS(Ctor$LWS, ctorName$LWS, attributes$LWS[i$LWS]);
  }
}
function addBlockedPropertyDistortionFactoryInitializers$LWS({
  document: document$LWS
}, proto$LWS, properties$LWS, factoryInitializers$LWS) {
  let {
    length: factoryInitializersOffset$LWS
  } = factoryInitializers$LWS;
  let descsCache$LWS = descriptorCaches$LWS.get(document$LWS);
  // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false
  if (descsCache$LWS === undefined) {
    descsCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
    descriptorCaches$LWS.set(document$LWS, descsCache$LWS);
  }
  let safeDescs$LWS = descsCache$LWS.get(proto$LWS);
  // istanbul ignore else: need a test for this on the same document but different namespace
  if (safeDescs$LWS === undefined) {
    safeDescs$LWS = {
      __proto__: null
    };
    descsCache$LWS.set(proto$LWS, safeDescs$LWS);
  }
  for (let i$LWS = 0, {
      length: length$LWS
    } = properties$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const prop$LWS = properties$LWS[i$LWS];
    let safeDesc$LWS = safeDescs$LWS[prop$LWS];
    if (safeDesc$LWS === undefined) {
      var _ReflectGetOwnPropert$LWS;
      safeDesc$LWS = (_ReflectGetOwnPropert$LWS = ReflectGetOwnPropertyDescriptor$LWS(proto$LWS, prop$LWS)) != null ? _ReflectGetOwnPropert$LWS : null;
      if (safeDesc$LWS) {
        ReflectSetPrototypeOf$LWS$1(safeDesc$LWS, null);
      }
      safeDescs$LWS[prop$LWS] = safeDesc$LWS;
    }
    if (safeDesc$LWS) {
      const {
        value: value$LWS
      } = safeDesc$LWS;
      if ('get' in safeDesc$LWS || 'set' in safeDesc$LWS) {
        const {
          get: getter$LWS,
          set: setter$LWS
        } = safeDesc$LWS;
        // istanbul ignore else
        if (getter$LWS) {
          factoryInitializers$LWS[factoryInitializersOffset$LWS++] = createGetThrowerFactoryInitializer$LWS(proto$LWS, prop$LWS);
        }
        if (setter$LWS) {
          factoryInitializers$LWS[factoryInitializersOffset$LWS++] = createSetThrowerFactoryInitializer$LWS(proto$LWS, prop$LWS);
        }
      } else {
        // The following if statement is enclosed in a dedicated else {}
        // because prettier won't allow a multi-line comment between
        // "else" and "if", which is where the istanbul ignore directive
        // must go to be effective.
        // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false
        if (typeof value$LWS === 'function') {
          factoryInitializers$LWS[factoryInitializersOffset$LWS++] = createValueThrowerFactoryInitializer$LWS(proto$LWS, prop$LWS);
        }
      }
    }
  }
}
const scriptURLs$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
function trackScriptURL$LWS(targetElement$LWS, url$LWS) {
  scriptURLs$LWS.set(targetElement$LWS, url$LWS);
}
function getScriptURL$LWS(targetElement$LWS) {
  return scriptURLs$LWS.get(targetElement$LWS);
}
function createScriptDistortion$LWS({
  sandboxEvaluator: sandboxEvaluator$LWS
}, attributeName$LWS) {
  const distortionName$LWS = `script${capitalizeFirstChar$LWS(attributeName$LWS)}`;
  // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
  // Use a computed property to dynamically set the distortion function name
  // without using `Reflect.defineProperty()`.
  const {
    [distortionName$LWS]: distortion$LWS
  } = {
    [distortionName$LWS](url$LWS) {
      trackScriptURL$LWS(this, resolveURL$LWS(url$LWS));
      const targetElement$LWS = this;
      const evaluator$LWS = function evaluator$LWS(sourceText$LWS) {
        const ownerDoc$LWS = ReflectApply$LWS$1(NodeProtoOwnerDocumentGetter$LWS, targetElement$LWS, []);
        const defaultView$LWS = ReflectApply$LWS$1(DocumentProtoDefaultViewGetter$LWS, ownerDoc$LWS, []);
        const context$LWS = {
          [UNCOMPILED_LOCATION_NAME$LWS]: defaultView$LWS.location,
          [UNCOMPILED_TOP_NAME$LWS]: defaultView$LWS.top
        };
        sourceText$LWS = transformSourceText$LWS(sourceText$LWS);
        return sandboxEvaluator$LWS(sourceText$LWS, context$LWS, defaultView$LWS, ownerDoc$LWS);
      };
      lwsInternalPolicy$LWS.createScriptURL(url$LWS, evaluator$LWS, targetElement$LWS);
    }
  };
  return distortion$LWS;
}
function initDistortionHTMLScriptElementSrcGetter$LWS({
  globalObject: {
    HTMLScriptElement: HTMLScriptElement$LWS
  }
}) {
  const originalSrcGetter$LWS = ObjectLookupOwnGetter$LWS$1(HTMLScriptElement$LWS.prototype, 'src');
  const distortionEntry$LWS = [originalSrcGetter$LWS, function src$LWS() {
    var _getScriptURL$LWS;
    return (_getScriptURL$LWS = getScriptURL$LWS(this)) != null ? _getScriptURL$LWS : ReflectApply$LWS$1(originalSrcGetter$LWS, this, []);
  }];
  return function distortionHTMLScriptElementSrcGetter$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionHTMLScriptElementSrcSetter$LWS({
  globalObject: {
    HTMLScriptElement: HTMLScriptElement$LWS
  }
}) {
  const {
    set: originalSrcSetter$LWS
  } = ReflectGetOwnPropertyDescriptor$LWS(HTMLScriptElement$LWS.prototype, 'src');
  return function distortionHTMLScriptElementSrcSetter$LWS(record$LWS) {
    const src$LWS = createScriptDistortion$LWS(record$LWS, 'src');
    registerAttributeDistortion$LWS(record$LWS, HTMLScriptElement$LWS, 'src', NAMESPACE_DEFAULT$LWS, src$LWS);
    return [originalSrcSetter$LWS, src$LWS];
  };
}
function initDistortionHTMLScriptElementTextSetter$LWS({
  globalObject: {
    HTMLScriptElement: HTMLScriptElement$LWS
  },
  root: {
    distortions: distortions$LWS
  }
}) {
  const {
    get: originalTextGetter$LWS,
    set: originalTextSetter$LWS
  } = ReflectGetOwnPropertyDescriptor$LWS(HTMLScriptElement$LWS.prototype, 'text');
  return function distortionHTMLScriptElementTextSetter$LWS({
    sandboxEvaluator: sandboxEvaluator$LWS
  }) {
    return [originalTextSetter$LWS, function text$LWS(value$LWS) {
      // istanbul ignore else: this will never NOT be instanceof HTMLScriptElement
      if (this instanceof HTMLScriptElement$LWS) {
        const scriptWasNotEvaluatedInScriptPropertySetter$LWS = scriptPropertySetters$LWS(this, 'text', trusted.createScript(value$LWS), originalTextGetter$LWS, originalTextSetter$LWS, distortions$LWS, sandboxEvaluator$LWS, trusted.createScript(SCRIPT_HOOK_SOURCE_TEXT$LWS));
        // istanbul ignore else
        if (scriptWasNotEvaluatedInScriptPropertySetter$LWS) {
          return;
        }
      }
      // istanbul ignore next: currently unreachable via tests (see above)
      ReflectApply$LWS$1(originalTextSetter$LWS, this, [value$LWS]);
    }];
  };
}
function initDistortionIDBObjectStoreAdd$LWS({
  globalObject: {
    DOMException: DOMException$LWS,
    IDBObjectStore: {
      prototype: {
        add: originalAdd$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalAdd$LWS, function add$LWS(...args$LWS) {
    try {
      return ReflectApply$LWS$1(originalAdd$LWS, this, args$LWS);
    } catch (error) {
      if (args$LWS.length && error instanceof DOMException$LWS) {
        const value$LWS = args$LWS[0];
        if (isObject$LWS$1(value$LWS)) {
          args$LWS[0] = partialStructuredClone$LWS(value$LWS);
          return ReflectApply$LWS$1(originalAdd$LWS, this, args$LWS);
        }
      }
      throw error;
    }
  }];
  return function distortionIDBObjectStoreAdd$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionIDBObjectStorePut$LWS({
  globalObject: {
    DOMException: DOMException$LWS,
    IDBObjectStore: {
      prototype: {
        put: originalPut$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalPut$LWS, function put$LWS(...args$LWS) {
    try {
      return ReflectApply$LWS$1(originalPut$LWS, this, args$LWS);
    } catch (error) {
      if (args$LWS.length && error instanceof DOMException$LWS) {
        const value$LWS = args$LWS[0];
        if (isObject$LWS$1(value$LWS)) {
          args$LWS[0] = partialStructuredClone$LWS(value$LWS);
          return ReflectApply$LWS$1(originalPut$LWS, this, args$LWS);
        }
      }
      throw error;
    }
  }];
  return function distortionIDBObjectStorePut$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionMathMLElementOnsecuritypolicyviolation$LWS({
  globalObject: {
    MathMLElement: {
      prototype: MathMLElementProto$LWS
    },
    MathMLElement: MathMLElement$LWS
  }
}) {
  return createEventDistortionFactory$LWS(MathMLElementProto$LWS, MathMLElement$LWS, 'securitypolicyviolation');
}
function initDistortionMessagePortPostMessage$LWS({
  globalObject: {
    DOMException: DOMException$LWS,
    MessagePort: MessagePort$LWS
  }
}) {
  const {
    postMessage: originalPostMessage$LWS
  } = MessagePort$LWS.prototype;
  const distortionEntry$LWS = [originalPostMessage$LWS, function postMessage$LWS(...args$LWS) {
    try {
      return ReflectApply$LWS$1(originalPostMessage$LWS, this, args$LWS);
    } catch (error) {
      const {
        length: length$LWS
      } = args$LWS;
      if (length$LWS && error instanceof DOMException$LWS) {
        const message$LWS = args$LWS[0];
        if (isObject$LWS$1(message$LWS)) {
          if (length$LWS > 1) {
            // MDN document providing a transfer list array
            // while the WHATWG documents providing an options
            // object with a 'transfer' property. To cover both
            // cases we structurally clone the entire `args` array.
            // https://developer.mozilla.org/en-US/docs/Web/API/MessagePort/postMessage#parameters
            // https://html.spec.whatwg.org/multipage/web-messaging.html#dom-structuredserializeoptions-transfer
            args$LWS = partialStructuredClone$LWS(args$LWS);
          } else {
            args$LWS[0] = partialStructuredClone$LWS(message$LWS);
          }
          return ReflectApply$LWS$1(originalPostMessage$LWS, this, args$LWS);
        }
      }
      throw error;
    }
  }];
  return function distortionMessagePortPostMessage$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionNamedNodeMapSetNamedItem$LWS({
  globalObject: {
    Attr: Attr$LWS,
    NamedNodeMap: {
      prototype: {
        setNamedItem: originalSetNamedItem$LWS
      }
    }
  }
}) {
  return function distortionNamedNodeMapSetNamedItem$LWS(record$LWS) {
    return [originalSetNamedItem$LWS, function setNamedItem$LWS(...args$LWS) {
      const attr$LWS = args$LWS.length ? args$LWS[0] : undefined;
      if (attr$LWS && attr$LWS instanceof Attr$LWS) {
        return setNamedItemWithAttr$LWS(record$LWS, originalSetNamedItem$LWS, this, attr$LWS);
      }
      return ReflectApply$LWS$1(originalSetNamedItem$LWS, this, args$LWS);
    }];
  };
}
function initDistortionNamedNodeMapSetNamedItemNS$LWS({
  globalObject: {
    Attr: Attr$LWS,
    NamedNodeMap: {
      prototype: {
        setNamedItemNS: originalSetNamedItemNS$LWS
      }
    }
  }
}) {
  return function distortionNamedNodeMapSetNamedItemNS$LWS(record$LWS) {
    return [originalSetNamedItemNS$LWS, function setNamedItemNS$LWS(...args$LWS) {
      const attr$LWS = args$LWS.length ? args$LWS[0] : undefined;
      if (attr$LWS && attr$LWS instanceof Attr$LWS) {
        return setNamedItemWithAttr$LWS(record$LWS, originalSetNamedItemNS$LWS, this, attr$LWS);
      }
      return ReflectApply$LWS$1(originalSetNamedItemNS$LWS, this, args$LWS);
    }];
  };
}
function initDistortionNavigatorSendBeacon$LWS({
  globalObject: {
    Navigator: {
      prototype: {
        sendBeacon: originalSendBeacon$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalSendBeacon$LWS, function sendBeacon$LWS(...args$LWS) {
    if (args$LWS.length) {
      const parsedURL$LWS = parseURL$LWS(toSafeStringValue$LWS(args$LWS[0]));
      if (!isValidURL$LWS(parsedURL$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot request disallowed endpoint: ${parsedURL$LWS.normalizedURL}`);
      }
      args$LWS[0] = parsedURL$LWS.normalizedURL;
    }
    return ReflectApply$LWS$1(originalSendBeacon$LWS, this, args$LWS);
  }];
  return function distortionNavigatorSendBeacon$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionNavigatorServiceWorkerGetter$LWS({
  globalObject: {
    Navigator: Navigator$LWS
  }
}) {
  const originalServiceWorkerGetter$LWS = ObjectLookupOwnGetter$LWS$1(Navigator$LWS.prototype, 'serviceWorker');
  // istanbul ignore if: needs default platform behavior test
  if (typeof originalServiceWorkerGetter$LWS !== 'function') {
    return noop$LWS$1;
  }
  const distortionEntry$LWS = [originalServiceWorkerGetter$LWS, noop$LWS$1];
  return function distortionNavigatorServiceWorkerGetter$LWS() {
    return distortionEntry$LWS;
  };
}
const {
  isSharedElement: isSharedElement$c$LWS,
  isAllowedSharedElementChild: isAllowedSharedElementChild$1$LWS
} = rootValidator$LWS;
function initDistortionNodeInsertBefore$LWS({
  globalObject: {
    Node: {
      prototype: {
        insertBefore: originalInsertBefore$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalInsertBefore$LWS, function insertBefore$LWS(...args$LWS) {
    // Node.prototype.insertBefore accepts two arguments. The first is the
    // new node to insert, the second is the reference node.
    // If the new node argument is NOT a valid shared element child,
    // which is limited to script and link, an exception is thrown.
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length) {
      const {
        0: node$LWS
      } = args$LWS;
      // istanbul ignore else: needs default platform behavior test
      if (isSharedElement$c$LWS(this) && !isAllowedSharedElementChild$1$LWS(node$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot insert child ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, node$LWS, [])} into ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])},`);
      }
    }
    return ReflectApply$LWS$1(originalInsertBefore$LWS, this, args$LWS);
  }];
  return function distortionNodeInsertBefore$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionNodeValueSetter$LWS({
  globalObject: {
    Attr: Attr$LWS,
    Node: Node$LWS
  }
}) {
  const originalNodeValueSetter$LWS = ObjectLookupOwnSetter$LWS(Node$LWS.prototype, 'nodeValue');
  return function distortionNodeValueSetter$LWS(record$LWS) {
    return [originalNodeValueSetter$LWS, function nodeValue$LWS(value$LWS) {
      // W-10476944 Window access via nodeValue/textContent:
      // This distortion sanitizes the given text to prevent window
      // access from being achieved via the nodeValue property.
      // istanbul ignore else: needs default platform behavior test
      if (this instanceof Attr$LWS) {
        const ownerEl$LWS = ReflectApply$LWS$1(AttrProtoOwnerElementGetter$LWS, this, []);
        if (ownerEl$LWS === null) {
          ReflectApply$LWS$1(originalNodeValueSetter$LWS, this, [value$LWS]);
          return;
        }
        const attrName$LWS = ReflectApply$LWS$1(AttrProtoNameGetter$LWS, this, []);
        const attrNamespace$LWS = ReflectApply$LWS$1(AttrProtoNamespaceURIGetter$LWS, this, []);
        const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
        const distortion$LWS = getAttributeDistortion$LWS(record$LWS, ownerEl$LWS, attrName$LWS, normalizedNamespace$LWS);
        // istanbul ignore next: needs default platform behavior test
        if (distortion$LWS) {
          ReflectApply$LWS$1(distortion$LWS, ownerEl$LWS, [value$LWS]);
          return;
        }
      }
      // istanbul ignore next: needs default platform behavior test
      ReflectApply$LWS$1(originalNodeValueSetter$LWS, this, [value$LWS]);
    }];
  };
}
const {
  isSharedElement: isSharedElement$b$LWS
} = rootValidator$LWS;
function initDistortionNodeRemoveChild$LWS({
  globalObject: {
    Node: {
      prototype: {
        removeChild: originalRemoveChild$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalRemoveChild$LWS, function removeChild$LWS(...args$LWS) {
    // Node.prototype.removeChild only accepts one child argument.
    // If that child argument is a valid shared element, an exception
    // is thrown.
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length) {
      const {
        0: child$LWS
      } = args$LWS;
      // istanbul ignore else: needs default platform behavior test
      if (isSharedElement$b$LWS(child$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot remove ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, child$LWS, [])}.`);
      }
    }
    // istanbul ignore next: needs default platform behavior test
    return ReflectApply$LWS$1(originalRemoveChild$LWS, this, args$LWS);
  }];
  return function distortionNodeRemoveChild$LWS() {
    return distortionEntry$LWS;
  };
}
const {
  isSharedElement: isSharedElement$a$LWS
} = rootValidator$LWS;
function initDistortionNodeReplaceChild$LWS({
  globalObject: {
    Node: {
      prototype: {
        replaceChild: originalReplaceChild$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalReplaceChild$LWS, function replaceChild$LWS(...args$LWS) {
    // Node.prototype.replaceChild accepts two child element arguments.
    // If the "old element" argument is a valid shared element, an
    // exception is thrown.
    const {
      length: length$LWS
    } = args$LWS;
    // istanbul ignore else: needs default platform behavior test
    if (length$LWS > 1) {
      const {
        1: child$LWS
      } = args$LWS;
      // istanbul ignore else: needs default platform behavior test
      if (isSharedElement$a$LWS(child$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot replace ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, child$LWS, [])}.`);
      }
    }
    // istanbul ignore next: needs default platform behavior test
    return ReflectApply$LWS$1(originalReplaceChild$LWS, this, args$LWS);
  }];
  return function distortionNodeReplaceChild$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionNodeTextContentGetter$LWS({
  globalObject: {
    HTMLScriptElement: HTMLScriptElement$LWS,
    Node: Node$LWS,
    SVGScriptElement: SVGScriptElement$LWS
  }
}) {
  const originalTextContentGetter$LWS = ObjectLookupOwnGetter$LWS$1(Node$LWS.prototype, 'textContent');
  const distortionEntry$LWS = [originalTextContentGetter$LWS, function textContent$LWS() {
    if (this instanceof HTMLScriptElement$LWS || this instanceof SVGScriptElement$LWS) {
      var _getOriginalScriptPro$LWS;
      return (_getOriginalScriptPro$LWS = getOriginalScriptProperty$LWS(this)) != null ? _getOriginalScriptPro$LWS : ReflectApply$LWS$1(originalTextContentGetter$LWS, this, []);
    }
    return ReflectApply$LWS$1(originalTextContentGetter$LWS, this, []);
  }];
  return function distortionHTMLScriptElementSrcGetter$LWS() {
    return distortionEntry$LWS;
  };
}

// IMPORTANT! This validator MUST use the top "window" global object, and not
// the provided "globalObject" because magenta objects (arbitrary user-code
// created global objects) must be allowed to interact with their OWN <html>,
// <head> and <body> (within the iframe content window). Using the provided
// "globalObject" here would result in receiving a validator bound to the
// magenta global object, which would erroneously prevent code from interacting
// with that document's <html>, <head> and <body>.
const {
  isSharedElement: isSharedElement$9$LWS
} = rootValidator$LWS;
function initDistortionNodeTextContentSetter$LWS({
  globalObject: {
    Attr: Attr$LWS,
    Node: Node$LWS,
    HTMLScriptElement: HTMLScriptElement$LWS,
    SVGScriptElement: SVGScriptElement$LWS
  },
  root: {
    distortions: distortions$LWS
  }
}) {
  const {
    get: originalTextContentGetter$LWS,
    set: originalTextContentSetter$LWS
  } = ReflectGetOwnPropertyDescriptor$LWS(Node$LWS.prototype, 'textContent');
  return function distortionNodeTextContentSetter$LWS(record$LWS) {
    const {
      sandboxEvaluator: sandboxEvaluator$LWS
    } = record$LWS;
    return [originalTextContentSetter$LWS, function textContent$LWS(value$LWS) {
      const valueAsString$LWS = trusted.createScript(value$LWS);
      // There are two existence of the attribute textContent, one on
      // Attr and one on Node. This first if statement is checking to
      // figure out which distortion should be applied. The instanceof
      // operator tests to see if the current global object, this,
      // is of the type Attr, while also taking inheritance into
      // consideration.
      // W-10476944 Window access via nodeValue/textContent:
      // This distortion sanitizes the given text to prevent window
      // access from being achieved via the textContent property.
      // istanbul ignore else: needs default platform behavior test
      if (this instanceof Attr$LWS) {
        const ownerEl$LWS = ReflectApply$LWS$1(AttrProtoOwnerElementGetter$LWS, this, []);
        if (ownerEl$LWS === null) {
          ReflectApply$LWS$1(originalTextContentSetter$LWS, this, [valueAsString$LWS]);
          return;
        }
        const attrName$LWS = ReflectApply$LWS$1(AttrProtoNameGetter$LWS, this, []);
        const attrNamespace$LWS = ReflectApply$LWS$1(AttrProtoNamespaceURIGetter$LWS, this, []);
        const normalizedNamespace$LWS = normalizeNamespace$LWS(attrNamespace$LWS);
        const distortion$LWS = getAttributeDistortion$LWS(record$LWS, ownerEl$LWS, attrName$LWS, normalizedNamespace$LWS);
        // istanbul ignore next: needs default platform behavior test
        if (distortion$LWS) {
          ReflectApply$LWS$1(distortion$LWS, ownerEl$LWS, [valueAsString$LWS]);
          return;
        }
      } else if (this instanceof HTMLScriptElement$LWS || this instanceof SVGScriptElement$LWS) {
        const scriptWasNotEvaluatedInScriptPropertySetter$LWS = scriptPropertySetters$LWS(this, 'textContent', valueAsString$LWS, originalTextContentGetter$LWS, originalTextContentSetter$LWS, distortions$LWS, sandboxEvaluator$LWS, trusted.createScript(SCRIPT_HOOK_SOURCE_TEXT$LWS));
        if (scriptWasNotEvaluatedInScriptPropertySetter$LWS) {
          return;
        }
      }
      // istanbul ignore else: needs default platform behavior test
      else if (isSharedElement$9$LWS(this)) {
        throw new LockerSecurityError$LWS(`Cannot set textContent of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, this, [])} elements.`);
      }
      ReflectApply$LWS$1(originalTextContentSetter$LWS, this, [valueAsString$LWS]);
    }];
  };
}
function initDistortionNotificationCtor$LWS({
  globalObject: {
    DOMException: DOMException$LWS,
    Notification: originalNotificationCtor$LWS
  }
}) {
  // istanbul ignore if: needs default platform behavior test
  if (typeof originalNotificationCtor$LWS !== 'function') {
    return noop$LWS$1;
  }
  const distortionEntry$LWS = [originalNotificationCtor$LWS, function Notification$LWS(...args$LWS) {
    try {
      return ReflectConstruct$LWS(originalNotificationCtor$LWS, args$LWS);
    } catch (error) {
      if (args$LWS.length > 1 && error instanceof DOMException$LWS) {
        const providedOptions$LWS = args$LWS[1];
        if (isObjectLike$LWS(providedOptions$LWS)) {
          const {
            data: data$LWS
          } = providedOptions$LWS;
          if (isObject$LWS$1(data$LWS)) {
            args$LWS[1] = {
              // The Notification constructor accepts
              // inherited options property values.
              __proto__: providedOptions$LWS,
              // Shadow any inherited value.
              data: partialStructuredClone$LWS(data$LWS)
            };
            return ReflectConstruct$LWS(originalNotificationCtor$LWS, args$LWS);
          }
        }
      }
      throw error;
    }
  }];
  return function distortionNotificationCtor$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionPerformanceMark$LWS({
  globalObject: {
    Performance: {
      prototype: {
        mark: originalMark$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalMark$LWS, function mark$LWS(...args$LWS) {
    try {
      return ReflectApply$LWS$1(originalMark$LWS, this, args$LWS);
    } catch (error) {
      if (args$LWS.length > 1 && error instanceof DOMException) {
        const providedOptions$LWS = args$LWS[1];
        if (isObject$LWS$1(providedOptions$LWS)) {
          args$LWS[1] = partialStructuredClone$LWS(providedOptions$LWS);
          return ReflectApply$LWS$1(originalMark$LWS, this, args$LWS);
        }
      }
      throw error;
    }
  }];
  return function distortionPerformanceMark$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionPerformanceMeasure$LWS({
  globalObject: {
    Performance: {
      prototype: {
        measure: originalMeasure$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalMeasure$LWS, function measure$LWS(...args$LWS) {
    try {
      return ReflectApply$LWS$1(originalMeasure$LWS, this, args$LWS);
    } catch (error) {
      if (args$LWS.length > 1 && error instanceof DOMException) {
        const providedOptions$LWS = args$LWS[1];
        if (isObject$LWS$1(providedOptions$LWS)) {
          args$LWS[1] = partialStructuredClone$LWS(providedOptions$LWS);
          return ReflectApply$LWS$1(originalMeasure$LWS, this, args$LWS);
        }
      }
      throw error;
    }
  }];
  return function distortionPerformanceMeasure$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionPerformanceMarkCtor$LWS({
  globalObject: {
    DOMException: DOMException$LWS,
    PerformanceMark: originalPerformanceMarkCtor$LWS
  }
}) {
  // istanbul ignore if: needs default platform behavior test
  if (typeof originalPerformanceMarkCtor$LWS !== 'function') {
    return noop$LWS$1;
  }
  const distortionEntry$LWS = [originalPerformanceMarkCtor$LWS, function PerformanceMark$LWS(...args$LWS) {
    try {
      return ReflectConstruct$LWS(originalPerformanceMarkCtor$LWS, args$LWS);
    } catch (error) {
      if (args$LWS.length > 1 && error instanceof DOMException$LWS) {
        const providedOptions$LWS = args$LWS[1];
        if (isObject$LWS$1(providedOptions$LWS)) {
          args$LWS[1] = partialStructuredClone$LWS(providedOptions$LWS);
          return ReflectConstruct$LWS(originalPerformanceMarkCtor$LWS, args$LWS);
        }
      }
      throw error;
    }
  }];
  return function distortionPerformanceMarkCtor$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionRangeCreateContextualFragment$LWS({
  document: document$LWS,
  globalObject: {
    Range: {
      prototype: {
        createContextualFragment: originalCreateContextualFragment$LWS
      }
    }
  }
}) {
  return function distortionRangeCreateContextualFragment$LWS({
    key: key$LWS
  }) {
    return [originalCreateContextualFragment$LWS, function createContextualFragment$LWS(...args$LWS) {
      if (args$LWS.length) {
        const {
          0: tagString$LWS
        } = args$LWS;
        if (tagString$LWS !== null && tagString$LWS !== undefined) {
          // This must be called to signal to the virtual
          // CustomElementRegistry that the next thing created
          // MAY CONTAIN a custom element, which must be marked
          // for association to this sandbox.
          setCustomElementsRegistry$LWS(document$LWS, key$LWS);
          args$LWS[0] = lwsInternalPolicy$LWS.createHTML(tagString$LWS, key$LWS, ContentType$LWS.HTML);
        }
      }
      return ReflectApply$LWS$1(originalCreateContextualFragment$LWS, this, args$LWS);
    }];
  };
}
const {
  isSharedElement: isSharedElement$8$LWS
} = rootValidator$LWS;
function initDistortionRangeDeleteContents$LWS({
  globalObject: {
    AbstractRange: AbstractRange$LWS,
    Range: {
      prototype: {
        deleteContents: originalDeleteContents$LWS
      }
    }
  }
}) {
  // Chrome <= 89, Edge <= 89, Safari <= 14, Firefox <= 68, Mobile Safari <= 14.4:
  //      endContainer/startContainer are defined on Range.prototype
  //
  // Chrome >= 90, Edge >= 90, Safari >= 14.1, Firefox >= 69, Mobile Safari >= 14.5:
  //      endContainer/startContainer are defined on AbstractRange.prototype
  // istanbul ignore next: the null path and right side of the expression for this code is not reachable in the version of chrome used to measure coverage.
  const {
    prototype: AbstractRangeProto$LWS
  } = AbstractRange$LWS != null ? AbstractRange$LWS : Range;
  const originalEndContainerGetter$LWS = ObjectLookupOwnGetter$LWS$1(AbstractRangeProto$LWS, 'endContainer');
  const originalStartContainerGetter$LWS = ObjectLookupOwnGetter$LWS$1(AbstractRangeProto$LWS, 'startContainer');
  const distortionEntry$LWS = [originalDeleteContents$LWS, function deleteContents$LWS(...args$LWS) {
    const containers$LWS = [ReflectApply$LWS$1(originalEndContainerGetter$LWS, this, []), ReflectApply$LWS$1(originalStartContainerGetter$LWS, this, [])];
    for (let i$LWS = 0, {
        length: length$LWS
      } = containers$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const container$LWS = containers$LWS[i$LWS];
      if (isSharedElement$8$LWS(container$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot delete contents of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, container$LWS, [])}.`);
      }
    }
    return ReflectApply$LWS$1(originalDeleteContents$LWS, this, args$LWS);
  }];
  return function distortionRangeDeleteContents$LWS() {
    return distortionEntry$LWS;
  };
}
const {
  isSharedElement: isSharedElement$7$LWS
} = rootValidator$LWS;
function initDistortionRangeExtractContents$LWS({
  globalObject: {
    AbstractRange: AbstractRange$LWS,
    Range: {
      prototype: {
        extractContents: originalExtractContents$LWS
      }
    }
  }
}) {
  // Chrome <= 89, Edge <= 89, Safari <= 14, Firefox <= 68, Mobile Safari <= 14.4:
  //      endContainer/startContainer are defined on Range.prototype
  //
  // Chrome >= 90, Edge >= 90, Safari >= 14.1, Firefox >= 69, Mobile Safari >= 14.5:
  //      endContainer/startContainer are defined on AbstractRange.prototype
  // istanbul ignore next: the null path and right side of the expression for this code is not reachable in the version of chrome used to measure coverage.
  const {
    prototype: AbstractRangeProto$LWS
  } = AbstractRange$LWS != null ? AbstractRange$LWS : Range;
  const originalEndContainerGetter$LWS = ObjectLookupOwnGetter$LWS$1(AbstractRangeProto$LWS, 'endContainer');
  const originalStartContainerGetter$LWS = ObjectLookupOwnGetter$LWS$1(AbstractRangeProto$LWS, 'startContainer');
  const distortionEntry$LWS = [originalExtractContents$LWS, function extractContents$LWS(...args$LWS) {
    const containers$LWS = [ReflectApply$LWS$1(originalEndContainerGetter$LWS, this, []), ReflectApply$LWS$1(originalStartContainerGetter$LWS, this, [])];
    for (let i$LWS = 0, {
        length: length$LWS
      } = containers$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const container$LWS = containers$LWS[i$LWS];
      if (isSharedElement$7$LWS(container$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot extract contents of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, container$LWS, [])}.`);
      }
    }
    return ReflectApply$LWS$1(originalExtractContents$LWS, this, args$LWS);
  }];
  return function distortionRangeExtractContents$LWS() {
    return distortionEntry$LWS;
  };
}
const {
  isSharedElement: isSharedElement$6$LWS,
  isAllowedSharedElementChild: isAllowedSharedElementChild$LWS
} = rootValidator$LWS;
function initDistortionRangeInsertNode$LWS({
  globalObject: {
    Range: {
      prototype: {
        insertNode: originalInsertNode$LWS
      }
    }
  }
}) {
  const originalCommonAncestorContainerGetter$LWS = ObjectLookupOwnGetter$LWS$1(Range.prototype, 'commonAncestorContainer');
  const distortionEntry$LWS = [originalInsertNode$LWS, function insertNode$LWS(...args$LWS) {
    // Range.prototype.insertNode only accepts one child argument.
    // If that child argument is NOT a valid shared element child,
    // which is limited to script and link, an exception is thrown.
    // istanbul ignore else: needs default platform behavior test
    if (args$LWS.length) {
      const commonAncestorContainer$LWS = ReflectApply$LWS$1(originalCommonAncestorContainerGetter$LWS, this, []);
      if (commonAncestorContainer$LWS && isSharedElement$6$LWS(commonAncestorContainer$LWS) && !isAllowedSharedElementChild$LWS(args$LWS[0])) {
        throw new LockerSecurityError$LWS(`Cannot insert a new child node of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, commonAncestorContainer$LWS, [])}.`);
      }
    }
    return ReflectApply$LWS$1(originalInsertNode$LWS, this, args$LWS);
  }];
  return function distortionRangeInsertNode$LWS() {
    return distortionEntry$LWS;
  };
}
const {
  isSharedElement: isSharedElement$5$LWS
} = rootValidator$LWS;
function createRangeProtoMethodDistortionFactoryInitializer$LWS(methodName$LWS) {
  return function initDistortionRangeProtoMethod$LWS({
    globalObject: {
      Range: {
        // @ts-ignore: Prevent index type error.
        prototype: {
          [methodName$LWS]: originalMethod$LWS
        }
      }
    }
  }) {
    // Use a computed property to dynamically set the distortion function
    // name without using `Reflect.defineProperty()`.
    const {
      [methodName$LWS]: distortion$LWS
    } = {
      [methodName$LWS](...args$LWS) {
        // istanbul ignore else: needs default platform behavior test
        if (args$LWS.length) {
          const {
            0: node$LWS
          } = args$LWS;
          // istanbul ignore else: needs default platform behavior test
          if (isSharedElement$5$LWS(node$LWS)) {
            throw new LockerSecurityError$LWS(`Cannot call ${methodName$LWS} with ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, node$LWS, [])}.`);
          }
        }
        return ReflectApply$LWS$1(originalMethod$LWS, this, args$LWS);
      }
    };
    const distortionEntry$LWS = [originalMethod$LWS, distortion$LWS];
    return function distortionRangeProtoMethod$LWS() {
      return distortionEntry$LWS;
    };
  };
}
const initDistortionRangeSetEnd$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('setEnd');
const initDistortionRangeSelectNode$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('selectNode');
const initDistortionRangeSelectNodeContents$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('selectNodeContents');
const initDistortionRangeSetEndAfter$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('setEndAfter');
const initDistortionRangeSetEndBefore$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('setEndBefore');
const initDistortionRangeSetStart$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('setStart');
const initDistortionRangeSetStartAfter$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('setStartAfter');
const initDistortionRangeSetStartBefore$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('setStartBefore');
const initDistortionRangeSurroundContents$LWS = createRangeProtoMethodDistortionFactoryInitializer$LWS('surroundContents');
const {
  isSharedElement: isSharedElement$4$LWS
} = rootValidator$LWS;
function initDistortionSelectionCollapse$LWS({
  globalObject: {
    Selection: {
      prototype: {
        collapse: originalSelectionCollapse$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalSelectionCollapse$LWS, function collapse$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: node$LWS
      } = args$LWS;
      // The first arg to Selection.prototype.collapse is "Node | null"
      if (node$LWS && isSharedElement$4$LWS(node$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot collapse selection to ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, node$LWS, [])}`);
      }
    }
    return ReflectApply$LWS$1(originalSelectionCollapse$LWS, this, args$LWS);
  }];
  return function distortionSelectionCollapse$LWS() {
    return distortionEntry$LWS;
  };
}
const {
  isSharedElement: isSharedElement$3$LWS
} = rootValidator$LWS;
function initDistortionSelectionExtend$LWS({
  globalObject: {
    Selection: {
      prototype: {
        extend: originalSelectionExtend$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalSelectionExtend$LWS, function extend$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: node$LWS
      } = args$LWS;
      if (isSharedElement$3$LWS(node$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot extend selection to ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, node$LWS, [])}`);
      }
    }
    return ReflectApply$LWS$1(originalSelectionExtend$LWS, this, args$LWS);
  }];
  return function distortionSelectionExtend$LWS() {
    return distortionEntry$LWS;
  };
}
const {
  isSharedElement: isSharedElement$2$LWS
} = rootValidator$LWS;
function initDistortionSelectionSelectAllChildren$LWS({
  globalObject: {
    Selection: {
      prototype: {
        selectAllChildren: originalSelectionSelectAllChildren$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalSelectionSelectAllChildren$LWS, function selectAllChildren$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: node$LWS
      } = args$LWS;
      if (isSharedElement$2$LWS(node$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot select all children of ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, node$LWS, [])}`);
      }
    }
    return ReflectApply$LWS$1(originalSelectionSelectAllChildren$LWS, this, args$LWS);
  }];
  return function distortionSelectionSelectAllChildren$LWS() {
    return distortionEntry$LWS;
  };
}
const {
  isSharedElement: isSharedElement$1$LWS
} = rootValidator$LWS;
function initDistortionSelectionSetBaseAndExtent$LWS({
  globalObject: {
    Selection: {
      prototype: {
        setBaseAndExtent: originalSelectionSetBaseAndExtent$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalSelectionSetBaseAndExtent$LWS, function setBaseAndExtent$LWS(...args$LWS) {
    // All 4 arguments are required, if any are missing then defer to
    // the platform for error handling.
    if (args$LWS.length === 4) {
      const {
        0: anchorNode$LWS,
        2: focusNode$LWS
      } = args$LWS;
      const anchorNodeIsShared$LWS = isSharedElement$1$LWS(anchorNode$LWS);
      const focusNodeIsShared$LWS = isSharedElement$1$LWS(focusNode$LWS);
      if (anchorNodeIsShared$LWS || focusNodeIsShared$LWS) {
        const subject$LWS = anchorNodeIsShared$LWS ? anchorNode$LWS : focusNode$LWS;
        throw new LockerSecurityError$LWS(`Cannot set selection with ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, subject$LWS, [])}`);
      }
    }
    return ReflectApply$LWS$1(originalSelectionSetBaseAndExtent$LWS, this, args$LWS);
  }];
  return function distortionSelectionSetBaseAndExtent$LWS() {
    return distortionEntry$LWS;
  };
}
const {
  isSharedElement: isSharedElement$LWS
} = rootValidator$LWS;
function initDistortionSelectionSetPosition$LWS({
  globalObject: {
    Selection: {
      prototype: {
        setPosition: originalSelectionSetPosition$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalSelectionSetPosition$LWS, function setPosition$LWS(...args$LWS) {
    if (args$LWS.length) {
      const {
        0: node$LWS
      } = args$LWS;
      // The first arg to Selection.prototype.setPosition is "Node | null"
      if (node$LWS && isSharedElement$LWS(node$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot set position with ${ReflectApply$LWS$1(NodeProtoNodeNameGetter$LWS, node$LWS, [])}`);
      }
    }
    return ReflectApply$LWS$1(originalSelectionSetPosition$LWS, this, args$LWS);
  }];
  return function distortionSelectionSetPosition$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionServiceWorkerContainerProto$LWS({
  globalObject: {
    ServiceWorkerContainer: ServiceWorkerContainer$LWS
  }
}) {
  // istanbul ignore if: this is a safety precaution, but currently unreachable via tests
  if (typeof ServiceWorkerContainer$LWS !== 'function') {
    return noop$LWS$1;
  }
  const {
    prototype: originalPrototype$LWS
  } = ServiceWorkerContainer$LWS;
  const distortionEntry$LWS = [originalPrototype$LWS, createRevokedProxy$LWS(originalPrototype$LWS)];
  return function distortionServiceWorkerContainerProto$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionShadowRootInnerHTMLSetter$LWS({
  document: document$LWS,
  globalObject: {
    ShadowRoot: ShadowRoot$LWS
  }
}) {
  const originalInnerHTMLSetter$LWS = ObjectLookupOwnSetter$LWS(ShadowRoot$LWS.prototype, 'innerHTML');
  return function distortionShadowRootInnerHTMLSetter$LWS({
    key: key$LWS
  }) {
    return [originalInnerHTMLSetter$LWS, function innerHTML$LWS(value$LWS) {
      // This must be called to signal to the virtual
      // CustomElementRegistry that the next thing created
      // MAY CONTAIN a custom element, which must be marked for
      // association to this sandbox.
      setCustomElementsRegistry$LWS(document$LWS, key$LWS);
      ReflectApply$LWS$1(originalInnerHTMLSetter$LWS, this, [lwsInternalPolicy$LWS.createHTML(value$LWS, key$LWS, ContentType$LWS.HTML)]);
    }];
  };
}
function initDistortionShadowRootSetHTMLUnsafe$LWS({
  document: document$LWS,
  globalObject: {
    ShadowRoot: {
      prototype: {
        setHTMLUnsafe: originalSetHTMLUnsafe$LWS
      }
    }
  }
}) {
  // istanbul ignore if: currently unreachable via tests
  if (typeof originalSetHTMLUnsafe$LWS !== 'function') {
    return noop$LWS$1;
  }
  return function distortionShadowRootSetHTMLUnsafe$LWS({
    key: key$LWS
  }) {
    return [originalSetHTMLUnsafe$LWS, function setHTMLUnsafe$LWS(value$LWS) {
      // This must be called to signal to the virtual
      // CustomElementRegistry that the next thing created
      // MAY CONTAIN a custom element, which must be marked for
      // association to this sandbox.
      setCustomElementsRegistry$LWS(document$LWS, key$LWS);
      ReflectApply$LWS$1(originalSetHTMLUnsafe$LWS, this, [lwsInternalPolicy$LWS.createHTML(value$LWS, key$LWS, ContentType$LWS.HTML)]);
    }];
  };
}
function SharedWorker$LWS(scriptURL$LWS) {
  throw new LockerSecurityError$LWS(`Cannot create SharedWorker with ${toSafeTemplateStringValue$LWS(scriptURL$LWS)}.`);
}
function initDistortionSharedWorkerCtor$LWS({
  globalObject: {
    SharedWorker: originalSharedWorkerCtor$LWS
  }
}) {
  // istanbul ignore if: this is a safety precaution, but currently unreachable via tests
  if (typeof originalSharedWorkerCtor$LWS !== 'function') {
    return noop$LWS$1;
  }
  const distortionEntry$LWS = [originalSharedWorkerCtor$LWS, SharedWorker$LWS];
  return function distortionSharedWorkerCtor$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionSharedWorkerProto$LWS({
  globalObject: {
    SharedWorker: SharedWorker$LWS
  }
}) {
  // istanbul ignore if: this is a safety precaution, but currently unreachable via tests
  if (typeof SharedWorker$LWS !== 'function') {
    return noop$LWS$1;
  }
  const {
    prototype: originalPrototype$LWS
  } = SharedWorker$LWS;
  const distortionEntry$LWS = [originalPrototype$LWS, createRevokedProxy$LWS(originalPrototype$LWS)];
  return function distortionSharedWorkerProto$LWS() {
    return distortionEntry$LWS;
  };
}
function getStorageKeysForNamespace$LWS(storage$LWS, namespace$LWS) {
  const storageKeys$LWS = ObjectKeys$LWS$1(storage$LWS);
  const keys$LWS = [];
  let keysOffset$LWS = 0;
  for (let i$LWS = 0, {
      length: length$LWS
    } = storageKeys$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const key$LWS = storageKeys$LWS[i$LWS];
    if (startsWithStorageNamespaceMarker$LWS(key$LWS, namespace$LWS)) {
      keys$LWS[keysOffset$LWS++] = key$LWS;
    }
  }
  return keys$LWS;
}
function processStorageKeysForNamespace$LWS(storageKeysForNamespace$LWS, namespace$LWS) {
  const {
    length: length$LWS
  } = storageKeysForNamespace$LWS;
  const keys$LWS = ArrayCtor$LWS$1(length$LWS);
  for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
    const key$LWS = storageKeysForNamespace$LWS[i$LWS];
    keys$LWS[i$LWS] = removeStorageNamespaceMarker$LWS(key$LWS, namespace$LWS);
  }
  return keys$LWS;
}
const storageToMetaMap$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
function getStorageMetaOrThrowInvalidInvocation$LWS(storage$LWS) {
  const storageMeta$LWS = storageToMetaMap$LWS.get(storage$LWS);
  // istanbul ignore if: currently unreachable via tests
  if (storageMeta$LWS === undefined) {
    throw new LockerSecurityError$LWS(ERR_ILLEGAL_INVOCATION$LWS);
  }
  return storageMeta$LWS;
}
function createStorageProxy$LWS(storageTarget$LWS) {
  const proxy$LWS = new ProxyCtor$LWS(storageTarget$LWS, {
    // istanbul ignore next: currently unreachable via tests, may indicate a dead code path
    get(target$LWS, key$LWS, receiver$LWS) {
      if (typeof key$LWS === 'symbol') {
        return ReflectGet$LWS(target$LWS, key$LWS, receiver$LWS);
      }
      const {
        namespace: namespace$LWS,
        storage: storage$LWS
      } = storageToMetaMap$LWS.get(proxy$LWS);
      const markedKey$LWS = prependStorageNamespaceMarker$LWS(key$LWS, namespace$LWS);
      if (ObjectHasOwn$LWS$1(storage$LWS, markedKey$LWS)) {
        return ReflectGet$LWS(storage$LWS, markedKey$LWS);
      }
      const proto$LWS = ReflectGetPrototypeOf$LWS$1(target$LWS);
      return proto$LWS === null ? undefined : ReflectGet$LWS(proto$LWS, key$LWS, receiver$LWS);
    },
    set(target$LWS, key$LWS, value$LWS) {
      if (typeof key$LWS === 'symbol') {
        return ReflectSet$LWS(target$LWS, key$LWS, value$LWS);
      }
      const {
        namespace: namespace$LWS,
        storage: storage$LWS
      } = storageToMetaMap$LWS.get(proxy$LWS);
      const markedKey$LWS = prependStorageNamespaceMarker$LWS(key$LWS, namespace$LWS);
      ReflectApply$LWS$1(StorageProtoSetItem$LWS, storage$LWS, [markedKey$LWS, value$LWS]);
      return true;
    },
    defineProperty(target$LWS, key$LWS, unsafePartialDesc$LWS) {
      const safeDesc$LWS = unsafePartialDesc$LWS;
      ReflectSetPrototypeOf$LWS$1(safeDesc$LWS, null);
      if (typeof key$LWS === 'symbol') {
        return ReflectDefineProperty$LWS$1(target$LWS, key$LWS, safeDesc$LWS);
      }
      const {
        namespace: namespace$LWS,
        storage: storage$LWS
      } = storageToMetaMap$LWS.get(proxy$LWS);
      const markedKey$LWS = prependStorageNamespaceMarker$LWS(key$LWS, namespace$LWS);
      return ReflectDefineProperty$LWS$1(storage$LWS, markedKey$LWS, safeDesc$LWS);
    },
    deleteProperty(target$LWS, key$LWS) {
      if (typeof key$LWS === 'symbol') {
        return ReflectDeleteProperty$LWS$1(target$LWS, key$LWS);
      }
      const {
        namespace: namespace$LWS,
        storage: storage$LWS
      } = storageToMetaMap$LWS.get(proxy$LWS);
      const markedKey$LWS = prependStorageNamespaceMarker$LWS(key$LWS, namespace$LWS);
      return ReflectDeleteProperty$LWS$1(storage$LWS, markedKey$LWS);
    },
    getOwnPropertyDescriptor(target$LWS, key$LWS) {
      let safeDesc$LWS;
      if (typeof key$LWS === 'symbol') {
        safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(target$LWS, key$LWS);
      } else {
        const {
          namespace: namespace$LWS,
          storage: storage$LWS
        } = storageToMetaMap$LWS.get(proxy$LWS);
        const markedKey$LWS = prependStorageNamespaceMarker$LWS(key$LWS, namespace$LWS);
        safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(storage$LWS, markedKey$LWS);
      }
      if (safeDesc$LWS) {
        ReflectSetPrototypeOf$LWS$1(safeDesc$LWS, null);
      }
      return safeDesc$LWS;
    },
    ownKeys(target$LWS) {
      const {
        namespace: namespace$LWS,
        storage: storage$LWS
      } = storageToMetaMap$LWS.get(proxy$LWS);
      const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, namespace$LWS);
      const storageKeys$LWS = processStorageKeysForNamespace$LWS(storageKeysForNamespace$LWS, namespace$LWS);
      const localSymbolKeys$LWS = ObjectGetOwnPropertySymbols$LWS(target$LWS);
      return ArrayConcat$LWS(storageKeys$LWS, localSymbolKeys$LWS);
    },
    // istanbul ignore next: suspicious gap, currently unreachable via tests
    has(target$LWS, key$LWS) {
      if (typeof key$LWS === 'symbol') {
        return ReflectHas$LWS(target$LWS, key$LWS);
      }
      const {
        namespace: namespace$LWS,
        storage: storage$LWS
      } = storageToMetaMap$LWS.get(proxy$LWS);
      const markedKey$LWS = prependStorageNamespaceMarker$LWS(key$LWS, namespace$LWS);
      if (ObjectHasOwn$LWS$1(storage$LWS, markedKey$LWS)) {
        return true;
      }
      const proto$LWS = ReflectGetPrototypeOf$LWS$1(target$LWS);
      if (proto$LWS === null) {
        return false;
      }
      return ReflectHas$LWS(proto$LWS, key$LWS);
    },
    preventExtensions(_target$LWS) {
      return false;
    }
  });
  return proxy$LWS;
}
class PatchedStorage$LWS {
  // istanbul ignore next: currently unreachable via tests
  constructor() {
    throw new LockerSecurityError$LWS(ERR_ILLEGAL_CONSTRUCTOR$LWS);
  }
  get length() {
    const {
      namespace: namespace$LWS,
      storage: storage$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);
    const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, namespace$LWS);
    return storageKeysForNamespace$LWS.length;
  }
  key(...args$LWS) {
    const {
      namespace: namespace$LWS,
      storage: storage$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);
    if (args$LWS.length) {
      const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, namespace$LWS);
      const index$LWS = args$LWS[0];
      const storageKey$LWS = storageKeysForNamespace$LWS[index$LWS];
      const storageDefaultKey$LWS = storageKeysForNamespace$LWS[0];
      const resolvedKey$LWS = storageKey$LWS || storageDefaultKey$LWS;
      if (typeof resolvedKey$LWS !== 'string') {
        return null;
      }
      return removeStorageNamespaceMarker$LWS(resolvedKey$LWS, namespace$LWS);
    }
    return ReflectApply$LWS$1(StorageProtoKey$LWS, storage$LWS, args$LWS);
  }
  getItem(...args$LWS) {
    const {
      namespace: namespace$LWS,
      storage: storage$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);
    if (args$LWS.length) {
      args$LWS[0] = prependStorageNamespaceMarker$LWS(toSafeStringValue$LWS(args$LWS[0]), namespace$LWS);
    }
    return ReflectApply$LWS$1(StorageProtoGetItem$LWS, storage$LWS, args$LWS);
  }
  setItem(...args$LWS) {
    const {
      namespace: namespace$LWS,
      storage: storage$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);
    if (args$LWS.length > 1) {
      args$LWS[0] = prependStorageNamespaceMarker$LWS(toSafeStringValue$LWS(args$LWS[0]), namespace$LWS);
      args$LWS[1] = toSafeStringValue$LWS(args$LWS[1]);
    }
    ReflectApply$LWS$1(StorageProtoSetItem$LWS, storage$LWS, args$LWS);
  }
  removeItem(...args$LWS) {
    const {
      namespace: namespace$LWS,
      storage: storage$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);
    if (args$LWS.length) {
      args$LWS[0] = prependStorageNamespaceMarker$LWS(toSafeStringValue$LWS(args$LWS[0]), namespace$LWS);
    }
    ReflectApply$LWS$1(StorageProtoRemoveItem$LWS, storage$LWS, args$LWS);
  }
  clear() {
    const {
      namespace: namespace$LWS,
      storage: storage$LWS
    } = getStorageMetaOrThrowInvalidInvocation$LWS(this);
    const storageKeysForNamespace$LWS = getStorageKeysForNamespace$LWS(storage$LWS, namespace$LWS);
    for (let i$LWS = 0, {
        length: length$LWS
      } = storageKeysForNamespace$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const key$LWS = storageKeysForNamespace$LWS[i$LWS];
      ReflectApply$LWS$1(StorageProtoRemoveItem$LWS, storage$LWS, [key$LWS]);
    }
  }
}
function createStorage$LWS(storage$LWS, namespace$LWS) {
  const proxy$LWS = createStorageProxy$LWS({
    __proto__: PatchedStorage$LWS.prototype
  });
  trackAsLiveTarget$LWS(proxy$LWS);
  storageToMetaMap$LWS.set(proxy$LWS, {
    namespace: namespace$LWS,
    storage: storage$LWS
  });
  return proxy$LWS;
}
const {
  prototype: PatchedStorageProto$LWS
} = PatchedStorage$LWS;
const {
  clear: patchedStorageProtoClear$LWS,
  getItem: patchedStorageProtoGetItem$LWS,
  key: patchedStorageProtoKey$LWS,
  removeItem: patchedStorageProtoRemoveItem$LWS,
  setItem: patchedStorageProtoSetItem$LWS
} = PatchedStorageProto$LWS;
const patchedStorageProtoLengthGetter$LWS = ObjectLookupOwnGetter$LWS$1(PatchedStorageProto$LWS, 'length');
function createDistortionStorageFactoryInitializer$LWS(storageName$LWS) {
  return function initDistortionStorageFactory$LWS({
    globalObject: globalObject$LWS
  }) {
    // Depending on browser configuration the storage object may be `null`
    // or throw an exception when its getter is accessed.
    let originalStorageObject$LWS;
    try {
      originalStorageObject$LWS = globalObject$LWS[storageName$LWS];
      // eslint-disable-next-line no-empty
    } catch (_unused3$LWS) {}
    // istanbul ignore if: currently unreachable via tests
    if (!isObject$LWS$1(originalStorageObject$LWS)) {
      return noop$LWS$1;
    }
    return function distortionStorageFactory$LWS({
      key: key$LWS
    }) {
      return [originalStorageObject$LWS, createStorage$LWS(originalStorageObject$LWS, key$LWS)];
    };
  };
}
function initDistortionStorageLength$LWS({
  globalObject: {
    Storage: Storage$LWS
  }
}) {
  const originalLengthGetter$LWS = ObjectLookupOwnGetter$LWS$1(Storage$LWS.prototype, 'length');
  const distortionEntry$LWS = [originalLengthGetter$LWS, patchedStorageProtoLengthGetter$LWS];
  return function distortionStorageLength$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionStorageGetItem$LWS({
  globalObject: {
    Storage: {
      prototype: {
        getItem: originalStorageGetItem$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalStorageGetItem$LWS, patchedStorageProtoGetItem$LWS];
  return function distortionStorageSetItem$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionStorageSetItem$LWS({
  globalObject: {
    Storage: {
      prototype: {
        setItem: originalStorageSetItem$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalStorageSetItem$LWS, patchedStorageProtoSetItem$LWS];
  return function distortionStorageSetItem$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionStorageKey$LWS({
  globalObject: {
    Storage: {
      prototype: {
        key: originalStorageKey$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalStorageKey$LWS, patchedStorageProtoKey$LWS];
  return function distortionStorageKey$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionStorageRemoveItem$LWS({
  globalObject: {
    Storage: {
      prototype: {
        removeItem: originalStorageRemoveItem$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalStorageRemoveItem$LWS, patchedStorageProtoRemoveItem$LWS];
  return function distortionStorageRemoveItem$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionStorageClear$LWS({
  globalObject: {
    Storage: {
      prototype: {
        clear: originalStorageClear$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalStorageClear$LWS, patchedStorageProtoClear$LWS];
  return function distortionStorageClear$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionStorage$LWS({
  globalObject: {
    Storage: Storage$LWS
  }
}) {
  const distortionEntry$LWS = [Storage$LWS, PatchedStorage$LWS];
  return function distortionStorage$LWS() {
    return distortionEntry$LWS;
  };
}
const initDistortionLocalStorage$LWS = createDistortionStorageFactoryInitializer$LWS('localStorage');
const initDistortionSessionStorage$LWS = createDistortionStorageFactoryInitializer$LWS('sessionStorage');
function initDistortionSVGAnimateElementAttributeNameAttribute$LWS({
  globalObject: {
    Element: {
      prototype: {
        setAttribute: originalSetAttribute$LWS
      }
    },
    SVGAnimateElement: SVGAnimateElement$LWS
  }
}) {
  return function distortionSVGAnimateElementAttributeNameAttribute$LWS(record$LWS) {
    function distortAttribute$LWS(el$LWS, attrName$LWS) {
      if (ReflectApply$LWS$1(ElementProtoHasAttribute$LWS, el$LWS, [attrName$LWS])) {
        const originalAttributeValue$LWS = ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, el$LWS, [attrName$LWS]);
        // istanbul ignore else: needs default platform behavior test
        if (originalAttributeValue$LWS) {
          const distortion$LWS = getAttributeDistortion$LWS(record$LWS, el$LWS, attrName$LWS);
          // istanbul ignore else: needs default platform behavior test
          if (distortion$LWS) {
            ReflectApply$LWS$1(distortion$LWS, el$LWS, [originalAttributeValue$LWS]);
          }
        }
      }
    }
    registerAttributeDistortion$LWS(record$LWS, SVGAnimateElement$LWS, 'attributeName', NAMESPACE_DEFAULT$LWS, function attributeName$LWS(value$LWS) {
      ReflectApply$LWS$1(originalSetAttribute$LWS, this, ['attributeName', value$LWS]);
      if (value$LWS === 'href') {
        distortAttribute$LWS(this, 'from');
        distortAttribute$LWS(this, 'to');
        distortAttribute$LWS(this, 'values');
      }
    });
  };
}
function initDistortionSVGAnimateElementFromAttribute$LWS({
  globalObject: {
    Element: {
      prototype: {
        setAttribute: originalSetAttribute$LWS
      }
    },
    SVGAnimateElement: SVGAnimateElement$LWS
  }
}) {
  function from$LWS(value$LWS) {
    if (ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, this, ['attributeName']) === 'href') {
      value$LWS = sanitizeSvgHref$LWS(value$LWS);
    }
    ReflectApply$LWS$1(originalSetAttribute$LWS, this, ['from', value$LWS]);
  }
  return function distortionSVGAnimateElementFromAttribute$LWS(record$LWS) {
    registerAttributeDistortion$LWS(record$LWS, SVGAnimateElement$LWS, 'from', NAMESPACE_DEFAULT$LWS, from$LWS);
  };
}
function initDistortionSVGAnimateElementToAttribute$LWS({
  globalObject: {
    Element: {
      prototype: {
        setAttribute: originalSetAttribute$LWS
      }
    },
    SVGAnimateElement: SVGAnimateElement$LWS
  }
}) {
  function to$LWS(value$LWS) {
    if (ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, this, ['attributeName']) === 'href') {
      value$LWS = sanitizeSvgHref$LWS(value$LWS);
    }
    ReflectApply$LWS$1(originalSetAttribute$LWS, this, ['to', value$LWS]);
  }
  return function distortionSVGAnimateElementToAttribute$LWS(record$LWS) {
    registerAttributeDistortion$LWS(record$LWS, SVGAnimateElement$LWS, 'to', NAMESPACE_DEFAULT$LWS, to$LWS);
  };
}
function initDistortionSVGAnimateElementValuesAttribute$LWS({
  globalObject: {
    Element: {
      prototype: {
        setAttribute: originalSetAttribute$LWS
      }
    },
    SVGAnimateElement: SVGAnimateElement$LWS
  }
}) {
  function values$LWS(value$LWS) {
    let returnValues$LWS = value$LWS;
    if (ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, this, ['attributeName']) === 'href') {
      const valuesSplit$LWS = ReflectApply$LWS$1(StringProtoSplit$LWS, value$LWS, [';']);
      const {
        length: length$LWS
      } = valuesSplit$LWS;
      for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
        valuesSplit$LWS[i$LWS] = sanitizeSvgHref$LWS(valuesSplit$LWS[i$LWS]);
      }
      returnValues$LWS = ReflectApply$LWS$1(ArrayProtoJoin$LWS$1, valuesSplit$LWS, [';']);
    }
    ReflectApply$LWS$1(originalSetAttribute$LWS, this, ['values', returnValues$LWS]);
  }
  return function distortionSVGAnimateElementValuesAttribute$LWS(record$LWS) {
    registerAttributeDistortion$LWS(record$LWS, SVGAnimateElement$LWS, 'values', NAMESPACE_DEFAULT$LWS, values$LWS);
  };
}
function initDistortionSVGElementDatasetGetter$LWS({
  globalObject: {
    SVGElement: SVGElement$LWS
  }
}) {
  const originalDatasetGetter$LWS = ObjectLookupOwnGetter$LWS$1(SVGElement$LWS.prototype, 'dataset');
  const distortionEntry$LWS = [originalDatasetGetter$LWS, function dataset$LWS() {
    return trackAsLiveTarget$LWS(ReflectApply$LWS$1(originalDatasetGetter$LWS, this, []));
  }];
  return function distortionSVGElementDatasetGetter$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionSVGElementOnsecuritypolicyviolation$LWS({
  globalObject: {
    SVGElement: {
      prototype: SVGElementProto$LWS
    },
    SVGElement: SVGElement$LWS
  }
}) {
  return createEventDistortionFactory$LWS(SVGElementProto$LWS, SVGElement$LWS, 'securitypolicyviolation');
}
function initDistortionSVGElementStyleGetter$LWS({
  globalObject: {
    SVGElement: SVGElement$LWS
  }
}) {
  const originalStyleGetter$LWS = ObjectLookupOwnGetter$LWS$1(SVGElement$LWS.prototype, 'style');
  const distortionEntry$LWS = [originalStyleGetter$LWS, function style$LWS() {
    return trackAsLiveTarget$LWS(ReflectApply$LWS$1(originalStyleGetter$LWS, this, []));
  }];
  return function distortionSVGElementStyleGetter$LWS() {
    return distortionEntry$LWS;
  };
}
const script$LWS = ReflectApply$LWS$1(DocumentProtoCreateElementNS$LWS, document, [NAMESPACE_SVG$LWS, 'script']);
function initDistortionSVGScriptElementHrefGetter$LWS({
  globalObject: {
    Element: {
      prototype: {
        setAttribute: originalSetAttribute$LWS
      }
    },
    SVGScriptElement: SVGScriptElement$LWS
  }
}) {
  const originalHrefGetter$LWS = ObjectLookupOwnGetter$LWS$1(SVGScriptElement$LWS.prototype, 'href');
  const distortionEntry$LWS = [originalHrefGetter$LWS, function href$LWS() {
    const url$LWS = getScriptURL$LWS(this);
    // istanbul ignore else: needs default platform behavior test
    if (typeof url$LWS === 'string') {
      ReflectApply$LWS$1(originalSetAttribute$LWS, script$LWS, ['href', trusted.createScriptURL(url$LWS)]);
      return ReflectApply$LWS$1(originalHrefGetter$LWS, script$LWS, []);
    }
    // istanbul ignore next: needs default platform behavior test
    return ReflectApply$LWS$1(originalHrefGetter$LWS, this, []);
  }];
  return function distortionSVGScriptElementHrefGetter$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionSVGScriptElementHrefSetter$LWS({
  globalObject: {
    SVGScriptElement: SVGScriptElement$LWS
  }
}) {
  return function distortionSVGScriptElementHrefSetter$LWS(record$LWS) {
    registerAttributeDistortion$LWS(record$LWS, SVGScriptElement$LWS, 'href', NAMESPACE_XLINK$LWS, createScriptDistortion$LWS(record$LWS, 'href'));
    registerAttributeDistortion$LWS(record$LWS, SVGScriptElement$LWS, 'xlink:href', NAMESPACE_XLINK$LWS, createScriptDistortion$LWS(record$LWS, 'xlink:href'));
    registerAttributeDistortion$LWS(record$LWS, SVGScriptElement$LWS, 'href', NAMESPACE_DEFAULT$LWS, createScriptDistortion$LWS(record$LWS, 'href'));
    registerAttributeDistortion$LWS(record$LWS, SVGScriptElement$LWS, 'xlink:href', NAMESPACE_DEFAULT$LWS, createScriptDistortion$LWS(record$LWS, 'xlink:href'));
  };
}
function initDistortionSVGSetElementAttributeNameAttribute$LWS({
  globalObject: {
    Element: {
      prototype: {
        setAttribute: originalSetAttribute$LWS
      }
    },
    SVGSetElement: SVGSetElement$LWS
  }
}) {
  return function distortionSVGSetElementAttributeNameAttribute$LWS(record$LWS) {
    function distortAttribute$LWS(el$LWS, attrName$LWS) {
      if (ReflectApply$LWS$1(ElementProtoHasAttribute$LWS, el$LWS, [attrName$LWS])) {
        const originalAttributeValue$LWS = ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, el$LWS, [attrName$LWS]);
        // istanbul ignore else: needs default platform behavior test
        if (originalAttributeValue$LWS) {
          const distortion$LWS = getAttributeDistortion$LWS(record$LWS, el$LWS, attrName$LWS);
          // istanbul ignore else: needs default platform behavior test
          if (distortion$LWS) {
            ReflectApply$LWS$1(distortion$LWS, el$LWS, [originalAttributeValue$LWS]);
          }
        }
      }
    }
    function attributeName$LWS(value$LWS) {
      ReflectApply$LWS$1(originalSetAttribute$LWS, this, ['attributeName', value$LWS]);
      if (value$LWS === 'href') {
        distortAttribute$LWS(this, 'to');
      }
    }
    registerAttributeDistortion$LWS(record$LWS, SVGSetElement$LWS, 'attributeName', NAMESPACE_DEFAULT$LWS, attributeName$LWS);
  };
}
function initDistortionSVGSetElementToAttribute$LWS({
  globalObject: {
    Element: {
      prototype: {
        setAttribute: originalSetAttribute$LWS
      }
    },
    SVGSetElement: SVGSetElement$LWS
  }
}) {
  function to$LWS(value$LWS) {
    if (ReflectApply$LWS$1(ElementProtoGetAttribute$LWS, this, ['attributeName']) === 'href') {
      value$LWS = sanitizeSvgHref$LWS(value$LWS);
    }
    ReflectApply$LWS$1(originalSetAttribute$LWS, this, ['to', value$LWS]);
  }
  return function distortionSVGSetElementToAttribute$LWS(record$LWS) {
    registerAttributeDistortion$LWS(record$LWS, SVGSetElement$LWS, 'to', NAMESPACE_DEFAULT$LWS, to$LWS);
  };
}
function createDistortionHrefAttributeFactoryInitializer$LWS(attributeName$LWS) {
  return function distortionHrefAttributeFactoryInitializer$LWS({
    globalObject: {
      Element: {
        prototype: {
          setAttribute: originalSetAttribute$LWS,
          setAttributeNS: originalSetAttributeNS$LWS
        }
      },
      SVGUseElement: SVGUseElement$LWS
    }
  }) {
    function xlinkNamespaceDistortion$LWS(value$LWS) {
      const returnValue$LWS = value$LWS === null || value$LWS === undefined || value$LWS === '' ? /* istanbul ignore next: needs default platform behavior test */value$LWS : sanitizeSvgHref$LWS(value$LWS);
      ReflectApply$LWS$1(originalSetAttributeNS$LWS, this, [NAMESPACE_XLINK$LWS, attributeName$LWS, returnValue$LWS]);
    }
    return function distortionHrefAttributeFactory$LWS(record$LWS) {
      registerAttributeDistortion$LWS(record$LWS, SVGUseElement$LWS, attributeName$LWS, NAMESPACE_XLINK$LWS, xlinkNamespaceDistortion$LWS);
      if (attributeName$LWS === 'href') {
        const defaultNamespaceDistortion$LWS = function defaultNamespaceDistortion$LWS(value$LWS) {
          const returnValue$LWS = value$LWS === null || value$LWS === undefined || value$LWS === '' ? /* istanbul ignore next: needs default platform behavior test */value$LWS : sanitizeSvgHref$LWS(value$LWS);
          ReflectApply$LWS$1(originalSetAttribute$LWS, this, [attributeName$LWS, returnValue$LWS]);
        };
        registerAttributeDistortion$LWS(record$LWS, SVGUseElement$LWS, attributeName$LWS, NAMESPACE_DEFAULT$LWS, defaultNamespaceDistortion$LWS);
      }
    };
  };
}
const initDistortionSVGUseElementHrefAttribute$LWS = createDistortionHrefAttributeFactoryInitializer$LWS('href');
const initDistortionSVGUseElementXlinkHrefAttribute$LWS = createDistortionHrefAttributeFactoryInitializer$LWS('xlink:href');
function createTrustedTypesExceptionMessage$LWS(name$LWS) {
  return `Cannot create TrustedTypePolicy with '${name$LWS}' policy name.`;
}
function initDistortionTrustedTypePolicyFactoryCreatePolicy$LWS({
  globalObject: {
    TrustedTypePolicyFactory: TrustedTypePolicyFactory$LWS
  }
}) {
  var _TrustedTypePolicyFac$LWS;
  // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
  const originalCreatePolicy$LWS = TrustedTypePolicyFactory$LWS == null || (_TrustedTypePolicyFac$LWS = TrustedTypePolicyFactory$LWS.prototype) == null ? void 0 : _TrustedTypePolicyFac$LWS.createPolicy;
  // istanbul ignore if: this is a safety precaution, but currently unreachable via tests
  if (typeof originalCreatePolicy$LWS !== 'function') {
    return noop$LWS$1;
  }
  const distortionEntry$LWS = [originalCreatePolicy$LWS, function createPolicy$LWS(...args$LWS) {
    const name$LWS = args$LWS.length ? args$LWS[0] : /* istanbul ignore next: needs default platform behavior test */undefined;
    // istanbul ignore else: needs default platform behavior test
    if (name$LWS === 'default') {
      throw new LockerSecurityError$LWS(createTrustedTypesExceptionMessage$LWS(name$LWS));
    }
    // If the policy is one of the CSP policies, it should be allowed
    try {
      // istanbul ignore next: needs default platform behavior test
      return ReflectApply$LWS$1(originalCreatePolicy$LWS, this, args$LWS);
    } catch (_unused4$LWS) {
      // istanbul ignore next: this is tested, but currently cannot be tested in the coverage environment
      consoleWarn$LWS(`${createTrustedTypesExceptionMessage$LWS(name$LWS)} Substituting with Lightning Web Security policy.`);
    }
    // istanbul ignore next: this is tested, but currently cannot be tested in the coverage environment
    return trusted;
  }];
  return function distortionTrustedTypePolicyFactoryCreatePolicy$LWS() {
    return distortionEntry$LWS;
  };
}
const HTML_MIME_TYPES_LIST$LWS = toSafeArray$LWS$1(['text/html', 'image/svg+xml', 'text/xml']);
const createInsecureBlobErrorMessage$LWS = input$LWS => `Cannot 'createObjectURL' using an unsecure ${toSafeTemplateStringValue$LWS(input$LWS)}.`;
function initDistortionURLCreateObjectURL$LWS({
  document: document$LWS,
  globalObject: globalObject$LWS,
  globalObject: {
    MediaSource: MediaSource$LWS,
    URL: {
      createObjectURL: originalCreateObjectURL$LWS
    }
  }
}) {
  // IMPORTANT! This validator MUST use the record's global object to create
  // a validator and not rely on the `rootValidator` because the validator
  // needs to be bound to the global object of the magenta object (arbitrary
  // user-code created global objects).
  const {
    isEqualDomString: isEqualDomString$LWS,
    isInherentlyUnsecure: isInherentlyUnsecure$LWS
  } = getValidator$LWS(document$LWS, globalObject$LWS);
  return function distortionURLCreateObjectURL$LWS({
    key: key$LWS
  }) {
    const sanitizer$LWS = blobSanitizer$LWS(key$LWS);
    return [originalCreateObjectURL$LWS, function createObjectURL$LWS(blobObject$LWS) {
      // Create a URL object first using the native APIs.
      // This will ensure native validation against undefined and other
      // non-accepted types.
      let outURL$LWS = ReflectApply$LWS$1(originalCreateObjectURL$LWS, this, [blobObject$LWS]);
      if (
      // MediaSource may not be defined in some browsers.
      // https://caniuse.com/mdn-api_mediasource
      MediaSource$LWS &&
      // MediaSource does not share the same prototype as Blob or File.
      // It can still be used with `createObjectURL()` however we need
      // to treat it separately. MediaSource does not accept plain text
      // input as Blob or File and does not have a MIME type.
      blobObject$LWS instanceof MediaSource$LWS) {
        return outURL$LWS;
      }
      const blobType$LWS = ReflectApply$LWS$1(BlobProtoTypeGetter$LWS, blobObject$LWS, []);
      if (blobType$LWS === '') {
        // Browsers interpret the empty MIME type differently.
        // Chrome makes it text/plain.
        // Firefox attempts to guess the content.
        // Safari makes it application/octet-stream effectively forcing a download of the content.
        // We need to normalize the behavior here.
        const plainTextBlob$LWS = ReflectApply$LWS$1(BlobProtoSlice$LWS, blobObject$LWS, [0, undefined, 'text/plain']);
        return ReflectApply$LWS$1(originalCreateObjectURL$LWS, this, [plainTextBlob$LWS]);
      }
      const loweredBlobType$LWS = ReflectApply$LWS$1(StringProtoToLowerCase$LWS, blobType$LWS, []);
      if (HTML_MIME_TYPES_LIST$LWS.includes(loweredBlobType$LWS)) {
        const blobSize$LWS = ReflectApply$LWS$1(BlobProtoSizeGetter$LWS, blobObject$LWS, []);
        const normalizedBlob$LWS = ReflectApply$LWS$1(BlobProtoSlice$LWS, blobObject$LWS, [0, blobSize$LWS, `${loweredBlobType$LWS};charset=utf-8`]);
        URLRevokeObjectURL$LWS(outURL$LWS);
        outURL$LWS = ReflectApply$LWS$1(originalCreateObjectURL$LWS, this, [normalizedBlob$LWS]);
        const xhr$LWS = new XhrCtor$LWS();
        ReflectApply$LWS$1(XhrProtoOpen$LWS, xhr$LWS, ['GET', outURL$LWS, false]);
        try {
          ReflectApply$LWS$1(XhrProtoSend$LWS, xhr$LWS, []);
        } catch (_unused5$LWS) {
          throw new LockerSecurityError$LWS(`Unable to verify ${toSafeTemplateStringValue$LWS(blobObject$LWS)} is secure.`);
        }
        const responseText$LWS = ReflectApply$LWS$1(XhrProtoResponseTextGetter$LWS, xhr$LWS, []);
        const sanitized$LWS = sanitizer$LWS.sanitize(responseText$LWS);
        if (!isEqualDomString$LWS(trusted.createHTML(responseText$LWS), trusted.createHTML(sanitized$LWS)) || isInherentlyUnsecure$LWS(responseText$LWS)) {
          URLRevokeObjectURL$LWS(outURL$LWS);
          throw new LockerSecurityError$LWS(createInsecureBlobErrorMessage$LWS(blobObject$LWS));
        }
        return outURL$LWS;
      }
      if (isMIMETypeAllowed$LWS(loweredBlobType$LWS)) {
        return outURL$LWS;
      }
      URLRevokeObjectURL$LWS(outURL$LWS);
      throw new LockerSecurityError$LWS('Unsupported MIME type.');
    }];
  };
}
function initDistortionWindowFetch$LWS({
  globalObject: {
    fetch: originalFetch$LWS
  }
}) {
  const distortionEntry$LWS = [originalFetch$LWS, function fetch$LWS(...args$LWS) {
    // Let the native method handle missing parameters error or null/undefined URL case.
    let {
      0: url$LWS
    } = args$LWS;
    if (url$LWS !== null && url$LWS !== undefined) {
      let parsedURL$LWS;
      if (url$LWS instanceof Request) {
        // Request will also normalize the url (partial to absolute url)
        // similar to link element's href.
        parsedURL$LWS = parseURL$LWS(ReflectApply$LWS$1(RequestProtoURLGetter$LWS, url$LWS, []));
      } else {
        parsedURL$LWS = parseURL$LWS(toSafeStringValue$LWS(url$LWS));
        url$LWS = parsedURL$LWS.normalizedURL;
        args$LWS[0] = url$LWS;
      }
      if (!isValidURL$LWS(parsedURL$LWS)) {
        const {
          normalizedURL: normalizedURL$LWS
        } = parsedURL$LWS;
        return PromiseReject$LWS(new LockerSecurityError$LWS(`Cannot request disallowed endpoint: ${toSafeTemplateStringValue$LWS(normalizedURL$LWS)}`));
      }
    }
    return ReflectApply$LWS$1(originalFetch$LWS, this, args$LWS);
  }];
  return function distortionWindowFetch$LWS() {
    return distortionEntry$LWS;
  };
}

// The rules for this proxy are as follows:
//
// If the key is a string...
//      ...And the key is a valid index that matches an existing
//      index in the frame list or matches the value of a name
//      property of a frame in the frame list, then return the
//      appropriate frame from the frame list.
//
//      ...Or the key's value is "length", then return the number of
//      frames in the in the frame list.
//  Else,
//      ...Return the value of the key from the shadow target
class BaseFrameHandler$LWS {
  defineProperty(_target$LWS, _key$LWS, _descriptor$LWS) {
    return true;
  }
  deleteProperty(_target$LWS, _key$LWS) {
    return true;
  }
  getOwnPropertyDescriptor(_target$LWS, _key$LWS) {
    return undefined;
  }
  isExtensible(_target$LWS) {
    return true;
  }
  ownKeys(_target$LWS) {
    return [];
  }
  preventExtensions(_target$LWS) {
    return true;
  }
  set(_target$LWS, _key$LWS, _value$LWS, _receiver$LWS) {
    return true;
  }
  setPrototypeOf(_target$LWS) {
    return false;
  }
}
ReflectSetPrototypeOf$LWS$1(BaseFrameHandler$LWS.prototype, null);
class ShadowFramesPrototypeHandler$LWS extends BaseFrameHandler$LWS {}
function initDistortionWindowFramesGetter$LWS({
  globalObject: globalObject$LWS
}) {
  const originalWindowFramesGetter$LWS = ObjectLookupOwnGetter$LWS$1(globalObject$LWS, 'frames');
  // istanbul ignore if: this is a safety precaution, but currently unreachable via tests
  if (typeof originalWindowFramesGetter$LWS !== 'function') {
    return noop$LWS$1;
  }
  const createFramesProxy$LWS = () => {
    const WindowPrototype$LWS = ReflectGetPrototypeOf$LWS$1(globalObject$LWS);
    const WindowProperties$LWS = ReflectGetPrototypeOf$LWS$1(WindowPrototype$LWS);
    // Wrap `WindowLengthGetter` in bound function to obscure the getter
    // source as "[native code]".
    const framesLengthGetter$LWS = ReflectApply$LWS$1(FunctionProtoBind$LWS, WindowLengthGetter$LWS, [globalObject$LWS]);
    // Wrap `noop` in bound function to obscure the setter source as
    // "[native code]".
    const framesLengthSetter$LWS = ReflectApply$LWS$1(FunctionProtoBind$LWS, noop$LWS$1, []);
    const getFrameByIndexKey$LWS = key$LWS => {
      const possibleIndex$LWS = typeof key$LWS === 'string' ? +key$LWS : -1;
      if (possibleIndex$LWS > -1 && NumberIsInteger$LWS$1(possibleIndex$LWS) && possibleIndex$LWS < ReflectApply$LWS$1(WindowLengthGetter$LWS, globalObject$LWS, [])) {
        const value$LWS = ObjectLookupOwnValue$LWS(globalObject$LWS, key$LWS);
        // istanbul ignore else: needs default platform behavior test
        if (isWindow$LWS(value$LWS)) {
          return value$LWS;
        }
      }
      return undefined;
    };
    const getFrameByNameKey$LWS = key$LWS => {
      if (typeof key$LWS === 'string' &&
      // Don't shadow properties on the global object...
      !ObjectHasOwn$LWS$1(globalObject$LWS, key$LWS) &&
      // ...Or its prototype.
      !ObjectHasOwn$LWS$1(WindowPrototype$LWS, key$LWS)) {
        const value$LWS = ObjectLookupOwnValue$LWS(WindowProperties$LWS, key$LWS);
        if (isWindow$LWS(value$LWS)) {
          return value$LWS;
        }
      }
      return undefined;
    };
    const getValueByKey$LWS = key$LWS => key$LWS === 'length' ? ReflectApply$LWS$1(WindowLengthGetter$LWS, globalObject$LWS, []) : getFrameByIndexKey$LWS(key$LWS);
    class ShadowFrameHandler$LWS extends BaseFrameHandler$LWS {
      get(target$LWS, key$LWS, receiver$LWS) {
        const value$LWS = getValueByKey$LWS(key$LWS);
        return value$LWS === undefined ?
        // window.frames.foo when iframe.name is 'foo'
        ReflectGet$LWS(target$LWS, key$LWS, receiver$LWS) :
        // window.frames.length
        // window.frames[n]
        // window.frames['n']
        value$LWS;
      }
      getOwnPropertyDescriptor(_target$LWS, key$LWS) {
        if (key$LWS === 'length') {
          return {
            __proto__: null,
            configurable: true,
            enumerable: true,
            get: framesLengthGetter$LWS,
            set: framesLengthSetter$LWS
          };
        }
        const value$LWS = getFrameByIndexKey$LWS(key$LWS);
        if (value$LWS) {
          return {
            __proto__: null,
            configurable: true,
            enumerable: true,
            value: value$LWS,
            writable: false
          };
        }
        return undefined;
      }
      // istanbul ignore next: suspicious gap, currently unreachable via tests
      has(target$LWS, key$LWS) {
        return ReflectHas$LWS(target$LWS, key$LWS) || getValueByKey$LWS(key$LWS) !== undefined;
      }
      ownKeys() {
        const {
          length: length$LWS
        } = globalObject$LWS;
        const keys$LWS = ArrayCtor$LWS$1(length$LWS + 1);
        for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
          keys$LWS[i$LWS] = `${i$LWS}`;
        }
        keys$LWS[length$LWS] = 'length';
        return keys$LWS;
      }
    }
    class ShadowWindowPropertiesHandler$LWS extends ShadowFramesPrototypeHandler$LWS {
      get(target$LWS, key$LWS, receiver$LWS) {
        const value$LWS = getFrameByNameKey$LWS(key$LWS);
        return value$LWS === undefined ?
        // window.frames.foo when iframe.name is 'foo'
        ReflectGet$LWS(target$LWS, key$LWS, receiver$LWS) : /* istanbul ignore next: needs default platform behavior test */value$LWS;
      }
      getOwnPropertyDescriptor(_target$LWS, key$LWS) {
        const value$LWS = getFrameByNameKey$LWS(key$LWS);
        if (value$LWS === undefined) {
          return value$LWS;
        }
        return {
          __proto__: null,
          configurable: true,
          enumerable: true,
          value: value$LWS,
          writable: false
        };
      }
      // istanbul ignore next: suspicious gap, currently unreachable via tests
      has(target$LWS, key$LWS) {
        return ReflectHas$LWS(target$LWS, key$LWS) || getFrameByNameKey$LWS(key$LWS) !== undefined;
      }
      ownKeys() {
        const keys$LWS = [];
        let keysOffset$LWS = 0;
        const unsafeDescs$LWS = ObjectGetOwnPropertyDescriptors$LWS(WindowProperties$LWS);
        ReflectSetPrototypeOf$LWS$1(unsafeDescs$LWS, null);
        for (const key$LWS in unsafeDescs$LWS) {
          // istanbul ignore next: currently unreachable via tests, may indicate a dead code path
          if (typeof key$LWS === 'string') {
            const unsafeDesc$LWS = unsafeDescs$LWS[key$LWS];
            if (ObjectHasOwn$LWS$1(unsafeDesc$LWS, 'value') && isWindow$LWS(unsafeDesc$LWS.value)) {
              keys$LWS[keysOffset$LWS++] = key$LWS;
            }
          }
        }
        return keys$LWS;
      }
    }
    // In order to preserve window.frames === window.frames, create a
    // shadow target object, to be used with the proxy object that is
    // returned by accesses to window.frames.
    const shadowFrames$LWS = {};
    const shadowFramesPrototype$LWS = {};
    const shadowWindowProperties$LWS = {};
    const shadowFramesHandler$LWS = new ShadowFrameHandler$LWS();
    const shadowFramesPrototypeHandler$LWS = new ShadowFramesPrototypeHandler$LWS();
    const shadowWindowPropertiesHandler$LWS = new ShadowWindowPropertiesHandler$LWS();
    const framesPrototypeProxy$LWS = new ProxyCtor$LWS(shadowFramesPrototype$LWS, shadowFramesPrototypeHandler$LWS);
    const windowPropertiesProxy$LWS = new ProxyCtor$LWS(shadowWindowProperties$LWS, shadowWindowPropertiesHandler$LWS);
    ReflectSetPrototypeOf$LWS$1(shadowFrames$LWS, framesPrototypeProxy$LWS);
    ReflectSetPrototypeOf$LWS$1(shadowFramesPrototype$LWS, windowPropertiesProxy$LWS);
    return new ProxyCtor$LWS(shadowFrames$LWS, shadowFramesHandler$LWS);
  };
  let framesProxy$LWS;
  const distortionEntry$LWS = [originalWindowFramesGetter$LWS,
  // eslint-disable-next-line prefer-arrow-callback
  function frames$LWS() {
    if (framesProxy$LWS === undefined) {
      framesProxy$LWS = createFramesProxy$LWS();
    }
    return framesProxy$LWS;
  }];
  return function distortionWindowFramesGetter$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionWindowGetComputedStyle$LWS({
  globalObject: {
    getComputedStyle: originalGetComputedStyle$LWS
  }
}) {
  const distortionEntry$LWS = [originalGetComputedStyle$LWS, function getComputedStyle$LWS(...args$LWS) {
    return trackAsLiveTarget$LWS(ReflectApply$LWS$1(originalGetComputedStyle$LWS, this, args$LWS));
  }];
  return function distortionWindowGetComputedStyle$LWS() {
    return distortionEntry$LWS;
  };
}
function length$LWS() {
  return 0;
}
function initDistortionWindowLengthGetter$LWS({
  globalObject: globalObject$LWS
}) {
  const originalLengthGetter$LWS = ObjectLookupOwnGetter$LWS$1(globalObject$LWS, 'length');
  // istanbul ignore if: currently unreachable via tests
  if (typeof originalLengthGetter$LWS !== 'function') {
    return noop$LWS$1;
  }
  const distortionEntry$LWS = [originalLengthGetter$LWS, length$LWS];
  return function distortionWindowLengthGetter$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionWindowOnrejectionhandled$LWS({
  globalObject: globalObject$LWS,
  globalObject: {
    Window: Window$LWS
  }
}) {
  return createEventDistortionFactory$LWS(globalObject$LWS, Window$LWS, 'rejectionhandled');
}
function initDistortionWindowOnsecuritypolicyviolation$LWS({
  globalObject: globalObject$LWS,
  globalObject: {
    Window: Window$LWS
  }
}) {
  return createEventDistortionFactory$LWS(globalObject$LWS, Window$LWS, 'securitypolicyviolation');
}
function initDistortionWindowOnstorage$LWS({
  globalObject: globalObject$LWS,
  globalObject: {
    Window: Window$LWS
  }
}) {
  return createEventDistortionFactory$LWS(globalObject$LWS, Window$LWS, 'storage');
}
function initDistortionWindowOnunhandledrejection$LWS({
  globalObject: globalObject$LWS,
  globalObject: {
    Window: Window$LWS
  }
}) {
  return createEventDistortionFactory$LWS(globalObject$LWS, Window$LWS, 'unhandledrejection');
}
function initDistortionWindowOpen$LWS({
  globalObject: {
    open: originalWindowOpen$LWS
  }
}) {
  const distortionEntry$LWS = [originalWindowOpen$LWS, function open$LWS(...args$LWS) {
    const normalizedArgs$LWS = normalizeWindowOpenArguments$LWS(args$LWS);
    const childWindow$LWS = ReflectApply$LWS$1(originalWindowOpen$LWS, this, normalizedArgs$LWS);
    // W-16032332
    // Block access to unsafe child window properties
    markForUnsafePropertyBlocking$LWS(childWindow$LWS);
    // W-14218118
    // If the target is '_self', '_parent', or '_top', only makes one request
    if (normalizedArgs$LWS.length > 1) {
      const {
        1: target$LWS
      } = normalizedArgs$LWS;
      const willOpenInSameBrowsingContext$LWS = target$LWS === '_self' || target$LWS === '_parent' || target$LWS === '_top';
      if (willOpenInSameBrowsingContext$LWS) {
        return childWindow$LWS;
      }
    }
    // W-13552831
    // If the target is anything else, two requests are made
    if (childWindow$LWS && normalizedArgs$LWS.length) {
      initWindowOpenChildWindow$LWS(childWindow$LWS, normalizedArgs$LWS[0]);
    }
    return childWindow$LWS;
  }];
  return function distortionWindowOpen$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionWindowPostMessage$LWS({
  globalObject: {
    postMessage: originalPostMessage$LWS
  }
}) {
  const distortionEntry$LWS = [originalPostMessage$LWS, function postMessage$LWS(...args$LWS) {
    try {
      return ReflectApply$LWS$1(originalPostMessage$LWS, this, args$LWS);
    } catch (error) {
      // We don't check if `error instance of DOMException` because
      // accessing `DOMException` of the `globalObject` will throw
      // an error for opaque windows.
      const {
        length: length$LWS
      } = args$LWS;
      if (length$LWS) {
        const message$LWS = args$LWS[0];
        if (isObject$LWS$1(message$LWS)) {
          // Calling `window.postMessage(message, target, transfer)`
          // is equivalent to `window.postMessage(message, { targetOrigin, transfer })`.
          const providedOptions$LWS = length$LWS > 1 ? args$LWS[1] : /* istanbul ignore next: currently unreachable via tests */undefined;
          if (isObjectLike$LWS(providedOptions$LWS)) {
            // Structured clone all arguments so that `transfer`
            // is referenced correctly within `message`.
            args$LWS = partialStructuredClone$LWS(args$LWS);
          } else {
            args$LWS[0] = partialStructuredClone$LWS(message$LWS);
          }
          return ReflectApply$LWS$1(originalPostMessage$LWS, this, args$LWS);
        }
      }
      throw error;
    }
  }];
  return function distortionWindowPostMessage$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionWindowSetInterval$LWS({
  UNCOMPILED_CONTEXT: UNCOMPILED_CONTEXT$LWS,
  globalObject: {
    setInterval: originalSetInterval$LWS
  }
}) {
  return function distortionWndowSetInterval$LWS({
    sandboxEvaluator: sandboxEvaluator$LWS,
    virtualEnvironmentEvaluator: virtualEnvironmentEvaluator$LWS
  }) {
    return [originalSetInterval$LWS, function setInterval$LWS(...args$LWS) {
      throwIfMarkedAsUnsafeInChildWindow$LWS(virtualEnvironmentEvaluator$LWS, 'setInterval');
      if (args$LWS.length) {
        const {
          0: callback$LWS
        } = args$LWS;
        if (callback$LWS !== null && callback$LWS !== undefined && typeof callback$LWS !== 'function') {
          // Snapshot callback source to prevent shapeshifting.
          const sourceText$LWS = toSafeStringValue$LWS(callback$LWS);
          // Defer transforming source text asynchronously.
          let transformedSourceText$LWS;
          // Replace callback parameter.
          args$LWS[0] = () => {
            // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false
            if (transformedSourceText$LWS === undefined) {
              transformedSourceText$LWS = transformSourceText$LWS(sourceText$LWS);
            }
            sandboxEvaluator$LWS(transformedSourceText$LWS, UNCOMPILED_CONTEXT$LWS);
          };
        }
      }
      return ReflectApply$LWS$1(originalSetInterval$LWS, this, args$LWS);
    }];
  };
}
function initDistortionWindowSetTimeout$LWS({
  UNCOMPILED_CONTEXT: UNCOMPILED_CONTEXT$LWS,
  globalObject: {
    setTimeout: originalSetTimeout$LWS
  }
}) {
  return function distortionWindowSetTimeout$LWS({
    sandboxEvaluator: sandboxEvaluator$LWS,
    virtualEnvironmentEvaluator: virtualEnvironmentEvaluator$LWS
  }) {
    return [originalSetTimeout$LWS, function setTimeout$LWS(...args$LWS) {
      throwIfMarkedAsUnsafeInChildWindow$LWS(virtualEnvironmentEvaluator$LWS, 'setTimeout');
      if (args$LWS.length) {
        const {
          0: callback$LWS
        } = args$LWS;
        if (callback$LWS !== null && callback$LWS !== undefined && typeof callback$LWS !== 'function') {
          // Snapshot callback source to prevent shapeshifting.
          const sourceText$LWS = toSafeStringValue$LWS(callback$LWS);
          // Replace callback parameter.
          args$LWS[0] = () => {
            // Defer transforming source text asynchronously.
            sandboxEvaluator$LWS(transformSourceText$LWS(sourceText$LWS), UNCOMPILED_CONTEXT$LWS);
          };
        }
      }
      return ReflectApply$LWS$1(originalSetTimeout$LWS, this, args$LWS);
    }];
  };
}
function initDistortionWindowStructuredClone$LWS({
  // @ts-ignore: Prevent property existence error.
  globalObject: {
    DOMException: DOMException$LWS,
    structuredClone: originalStructuredClone$LWS
  }
}) {
  // istanbul ignore if: currently unreachable via tests
  if (typeof originalStructuredClone$LWS !== 'function') {
    return noop$LWS$1;
  }
  const distortionEntry$LWS = [originalStructuredClone$LWS, function structuredClone$LWS(...args$LWS) {
    try {
      return ReflectApply$LWS$1(originalStructuredClone$LWS, this, args$LWS);
    } catch (error) {
      const {
        length: length$LWS
      } = args$LWS;
      if (length$LWS && error instanceof DOMException$LWS) {
        const message$LWS = args$LWS[0];
        if (isObject$LWS$1(message$LWS)) {
          const providedOptions$LWS = length$LWS > 1 ? args$LWS[1] : undefined;
          if (isObjectLike$LWS(providedOptions$LWS)) {
            const {
              transfer: transfer$LWS
            } = providedOptions$LWS;
            args$LWS[1] = {
              // The structuredClone function accepts inherited
              // options property values.
              __proto__: providedOptions$LWS,
              // Shadow any inherited value.
              transfer: transfer$LWS
            };
            // Structured clone all arguments so that `options.transfer`
            // is referenced correctly within `value`.
            args$LWS = partialStructuredClone$LWS(args$LWS);
          } else {
            args$LWS[0] = partialStructuredClone$LWS(message$LWS);
          }
          return ReflectApply$LWS$1(originalStructuredClone$LWS, this, args$LWS);
        }
      }
      throw error;
    }
  }];
  return function distortionWindowStructuredClone$LWS() {
    return distortionEntry$LWS;
  };
}
function Worker$LWS(scriptURL$LWS) {
  throw new LockerSecurityError$LWS(`Cannot create Worker with ${toSafeTemplateStringValue$LWS(scriptURL$LWS)}.`);
}
function initDistortionWorkerCtor$LWS({
  globalObject: {
    Worker: originalWorkerCtor$LWS
  }
}) {
  const distortionEntry$LWS = [originalWorkerCtor$LWS, Worker$LWS];
  return function distortionWorkerCtor$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionWorkerProto$LWS({
  globalObject: {
    Worker: {
      prototype: originalPrototype$LWS
    }
  }
}) {
  const distortionEntry$LWS = [originalPrototype$LWS, createRevokedProxy$LWS(originalPrototype$LWS)];
  return function distortionWorkerProto$LWS() {
    return distortionEntry$LWS;
  };
}
function initDistortionXMLHttpRequestOpen$LWS({
  globalObject: {
    XMLHttpRequest: {
      prototype: {
        open: originalOpen$LWS
      }
    }
  }
}) {
  const distortionEntry$LWS = [originalOpen$LWS, function open$LWS(...args$LWS) {
    // Let the native method handle missing parameters error or null/undefined URL case.
    const url$LWS = args$LWS.length > 1 ? args$LWS[1] : undefined;
    if (url$LWS !== null && url$LWS !== undefined) {
      const parsedURL$LWS = parseURL$LWS(toSafeStringValue$LWS(url$LWS));
      if (!isValidURL$LWS(parsedURL$LWS)) {
        throw new LockerSecurityError$LWS(`Cannot request disallowed endpoint: ${parsedURL$LWS.normalizedURL}`);
      }
      args$LWS[1] = parsedURL$LWS.normalizedURL;
    }
    ReflectApply$LWS$1(originalOpen$LWS, this, args$LWS);
  }];
  return function distortionXMLHttpRequestOpen$LWS() {
    return distortionEntry$LWS;
  };
}
function replaceDocumentContent$LWS(doc$LWS, content$LWS) {
  const docImpl$LWS = ReflectApply$LWS$1(DocumentProtoImplementationGetter$LWS, doc$LWS, []);
  const newDoc$LWS = ReflectApply$LWS$1(DOMImplementationProtoCreateDocument$LWS, docImpl$LWS, [NAMESPACE_XHTML$LWS, 'html']);
  const newDocEl$LWS = ReflectApply$LWS$1(DocumentProtoDocumentElementGetter$LWS, newDoc$LWS, []);
  ReflectApply$LWS$1(ElementProtoInnerHTMLSetter$LWS, newDocEl$LWS, [content$LWS]);
  return newDoc$LWS;
}
function initDistortionXMLHttpRequestResponseGetter$LWS({
  document: document$LWS,
  globalObject: {
    Document: Document$LWS,
    XMLHttpRequest: XMLHttpRequest$LWS
  }
}) {
  const originalResponseGetter$LWS = ObjectLookupOwnGetter$LWS$1(XMLHttpRequest$LWS.prototype, 'response');
  return function distortionXMLHttpRequestResponseGetter$LWS({
    key: key$LWS
  }) {
    return [originalResponseGetter$LWS, function response$LWS() {
      const rawResponse$LWS = ReflectApply$LWS$1(originalResponseGetter$LWS, this, []);
      // This must be called to signal to the virtual
      // CustomElementRegistry that the next thing created
      // MAY CONTAIN a custom element, which must be marked for
      // association to this sandbox.
      setCustomElementsRegistry$LWS(document$LWS, key$LWS);
      if (rawResponse$LWS instanceof Document$LWS) {
        const docEl$LWS = ReflectApply$LWS$1(DocumentProtoDocumentElementGetter$LWS, rawResponse$LWS, []);
        const content$LWS = ReflectApply$LWS$1(ElementProtoOuterHTMLGetter$LWS, docEl$LWS, []);
        return replaceDocumentContent$LWS(rawResponse$LWS, lwsInternalPolicy$LWS.createHTML(content$LWS, key$LWS, ContentType$LWS.HTML));
      }
      return rawResponse$LWS;
    }];
  };
}
function initDistortionXMLHttpRequestResponseXMLGetter$LWS({
  document: document$LWS,
  globalObject: {
    XMLHttpRequest: XMLHttpRequest$LWS
  }
}) {
  const originalResponseXMLGetter$LWS = ObjectLookupOwnGetter$LWS$1(XMLHttpRequest$LWS.prototype, 'responseXML');
  return function distortionXMLHttpRequestResponseXMLGetter$LWS({
    key: key$LWS
  }) {
    return [originalResponseXMLGetter$LWS, function responseXML$LWS() {
      const rawResponseXML$LWS = ReflectApply$LWS$1(originalResponseXMLGetter$LWS, this, []);
      // This must be called to signal to the virtual
      // CustomElementRegistry that the next thing created
      // MAY CONTAIN a custom element, which must be marked for
      // association to this sandbox.
      setCustomElementsRegistry$LWS(document$LWS, key$LWS);
      const docEl$LWS = ReflectApply$LWS$1(DocumentProtoDocumentElementGetter$LWS, rawResponseXML$LWS, []);
      const content$LWS = ReflectApply$LWS$1(ElementProtoOuterHTMLGetter$LWS, docEl$LWS, []);
      return replaceDocumentContent$LWS(rawResponseXML$LWS, lwsInternalPolicy$LWS.createHTML(content$LWS, key$LWS, ContentType$LWS.HTML));
    }];
  };
}

/*
Naming convention for DistortionFactory function types:
    distortion[ObjectName][PropertyName] : used for property values
    distortion[ObjectName][PropertyName]Getter : used for property getters
    distortion[ObjectName][PropertyName]Setter : used for property setters
    distortion[ObjectName]Ctor : used for object constructors
    distortion[ObjectName]Proto : used for the object prototype itself
*/
const internalDistortionFactoryInitializers$LWS = [
// BroadcastChannel
initDistortionBroadcastChannelPostMessage$LWS,
// CSSStyleRule
initDistortionCSSStyleRuleStyleGetter$LWS,
// Document
initDistortionDocumentDomainSetter$LWS, initDistortionDocumentOnsecuritypolicyviolation$LWS, initDistortionDocumentOpen$LWS,
// Element
initDistortionElementAttributesGetter$LWS, initDistortionElementGetInnerHTML$LWS, initDistortionElementRemove$LWS, initDistortionElementReplaceChildren$LWS, initDistortionElementReplaceWith$LWS,
// Function
initDistortionFunction$LWS,
// History
initDistortionHistoryPushState$LWS, initDistortionHistoryReplaceState$LWS,
// HTMLElement
initDistortionHTMLElementDatasetGetter$LWS, initDistortionHTMLElementInnerTextSetter$LWS, initDistortionHTMLElementOuterTextSetter$LWS, initDistortionHTMLElementStyleGetter$LWS,
// HTMLIFrameElement
initDistortionIFrameElementContentDocumentGetter$LWS, initDistortionIFrameElementContentWindowGetter$LWS, initDistortionHTMLIFrameElementSandboxGetter$LWS, initDistortionHTMLIFrameElementSandboxSetter$LWS, initDistortionHTMLIFrameElementSrcSetter$LWS,
// HTMLLinkElement
initDistortionHTMLLinkElementRelSetter$LWS, initDistortionHTMLLinkElementRelListSetter$LWS,
// HTMLObjectElement
initDistortionHTMLObjectElementDataSetter$LWS,
// HTMLScriptElement
initDistortionHTMLScriptElementSrcGetter$LWS, initDistortionHTMLScriptElementTextSetter$LWS,
// IDBObjectStore
initDistortionIDBObjectStoreAdd$LWS, initDistortionIDBObjectStorePut$LWS,
// MessagePort
initDistortionMessagePortPostMessage$LWS,
// Navigator
initDistortionNavigatorSendBeacon$LWS, initDistortionNavigatorServiceWorkerGetter$LWS,
// Node
initDistortionNodeRemoveChild$LWS, initDistortionNodeReplaceChild$LWS,
// Performance
initDistortionPerformanceMark$LWS, initDistortionPerformanceMeasure$LWS,
// PerformanceMark
initDistortionPerformanceMarkCtor$LWS,
// Notification
initDistortionNotificationCtor$LWS,
// Range
initDistortionRangeDeleteContents$LWS, initDistortionRangeExtractContents$LWS, initDistortionRangeInsertNode$LWS, initDistortionRangeSelectNode$LWS, initDistortionRangeSelectNodeContents$LWS, initDistortionRangeSetEnd$LWS, initDistortionRangeSetEndAfter$LWS, initDistortionRangeSetEndBefore$LWS, initDistortionRangeSetStart$LWS, initDistortionRangeSetStartAfter$LWS, initDistortionRangeSetStartBefore$LWS, initDistortionRangeSurroundContents$LWS,
// Selection
initDistortionSelectionCollapse$LWS, initDistortionSelectionExtend$LWS, initDistortionSelectionSelectAllChildren$LWS, initDistortionSelectionSetBaseAndExtent$LWS, initDistortionSelectionSetPosition$LWS,
// ServiceWorkerContainer
initDistortionServiceWorkerContainerProto$LWS,
// SharedWorker
initDistortionSharedWorkerCtor$LWS, initDistortionSharedWorkerProto$LWS,
// Storage
initDistortionStorage$LWS, initDistortionStorageClear$LWS, initDistortionStorageGetItem$LWS, initDistortionStorageKey$LWS, initDistortionStorageLength$LWS, initDistortionStorageRemoveItem$LWS, initDistortionStorageSetItem$LWS,
// SVGAnimateElement
initDistortionSVGAnimateElementFromAttribute$LWS, initDistortionSVGAnimateElementToAttribute$LWS, initDistortionSVGAnimateElementValuesAttribute$LWS,
// SVGElement
initDistortionSVGElementDatasetGetter$LWS, initDistortionSVGElementStyleGetter$LWS,
// SVGSetElement
initDistortionSVGSetElementToAttribute$LWS,
// SVGUseElement
initDistortionSVGUseElementHrefAttribute$LWS, initDistortionSVGUseElementXlinkHrefAttribute$LWS,
// TrustedTypePolicyFactory
initDistortionTrustedTypePolicyFactoryCreatePolicy$LWS,
// Window
initDistortionWindowFetch$LWS, initDistortionWindowFramesGetter$LWS, initDistortionWindowGetComputedStyle$LWS, initDistortionWindowLengthGetter$LWS, initDistortionWindowOpen$LWS, initDistortionWindowPostMessage$LWS, initDistortionWindowStructuredClone$LWS,
// Worker
initDistortionWorkerCtor$LWS, initDistortionWorkerProto$LWS,
// XHR
initDistortionXMLHttpRequestOpen$LWS];
const internalKeyedDistortionFactoryInitializers$LWS = [
// AbstractRange
initDistortionAbstractRangeEndContainerGetter$LWS, initDistortionAbstractRangeStartContainerGetter$LWS,
// Attr
initDistortionAttrValueSetter$LWS,
// Aura
initDistortionAuraUtilGlobalEval$LWS,
// CacheStorage
initDistortionCacheStorageDelete$LWS, initDistortionCacheStorageHas$LWS, initDistortionCacheStorageKeys$LWS, initDistortionCacheStorageMatch$LWS, initDistortionCacheStorageOpen$LWS,
// CookieStore
initDistortionCookieStoreDelete$LWS, initDistortionCookieStoreGet$LWS, initDistortionCookieStoreGetAll$LWS, initDistortionCookieStoreOnChange$LWS, initDistortionCookieStoreSet$LWS,
// CustomElementRegistry
initDistortionCustomElementRegistryDefine$LWS, initDistortionCustomElementRegistryGet$LWS, initDistortionCustomElementRegistryUpgrade$LWS, initDistortionCustomElementRegistryWhenDefined$LWS,
// Document
initDistortionDocumentCookieGetter$LWS, initDistortionDocumentCookieSetter$LWS, initDistortionDocumentCreateElement$LWS, initDistortionDocumentCreateElementNS$LWS, initDistortionDocumentExecCommand$LWS, initDistortionDocumentReplaceChildren$LWS,
// DOMParser
initDistortionDOMParserParseFromString$LWS,
// Element
initDistortionElementAttachShadow$LWS, initDistortionElementInnerHTMLSetter$LWS, initDistortionElementInsertAdjacentHTML$LWS, initDistortionElementOuterHTMLSetter$LWS, initDistortionElementSetAttribute$LWS, initDistortionElementSetAttributeNode$LWS, initDistortionElementSetAttributeNodeNS$LWS, initDistortionElementSetAttributeNS$LWS, initDistortionElementSetHTML$LWS, initDistortionElementSetHTMLUnsafe$LWS, initDistortionElementShadowRootGetter$LWS, initDistortionElementToggleAttribute$LWS,
// Eval
initDistortionEval$LWS,
// Event
initDistortionEventComposedPath$LWS, initDistortionEventPathGetter$LWS,
// EventTarget
initDistortionEventTargetAddEventListener$LWS,
// HTMLBodyElement
initDistortionHTMLBodyElementOnrejectionhandled$LWS, initDistortionHTMLBodyElementOnstorage$LWS, initDistortionHTMLBodyElementOnunhandledrejection$LWS,
// HTMLElement
initDistortionHTMLElementCtor$LWS, initDistortionHTMLElementOnsecuritypolicyviolation$LWS,
// HTMLFrameSetElement
initDistortionHTMLFrameSetElementOnrejectionhandled$LWS, initDistortionHTMLFrameSetElementOnstorage$LWS, initDistortionHTMLFrameSetElementOnunhandledrejection$LWS,
// HTMLScriptElement,
initDistortionHTMLScriptElementSrcSetter$LWS, initDistortionHTMLScriptElementTextSetter$LWS,
// MathMLElement
initDistortionMathMLElementOnsecuritypolicyviolation$LWS,
// NamedNodeMap
initDistortionNamedNodeMapSetNamedItem$LWS, initDistortionNamedNodeMapSetNamedItemNS$LWS,
// Node
initDistortionNodeValueSetter$LWS, initDistortionNodeTextContentGetter$LWS, initDistortionNodeTextContentSetter$LWS,
// Range
initDistortionRangeCreateContextualFragment$LWS,
// ShadowRoot
initDistortionShadowRootInnerHTMLSetter$LWS, initDistortionShadowRootSetHTMLUnsafe$LWS,
// Storage
initDistortionLocalStorage$LWS, initDistortionSessionStorage$LWS,
// SVGAnimationElement
initDistortionSVGAnimateElementAttributeNameAttribute$LWS,
// SVGScriptElement
initDistortionSVGScriptElementHrefGetter$LWS, initDistortionSVGScriptElementHrefSetter$LWS,
// SVGSetElement
initDistortionSVGSetElementAttributeNameAttribute$LWS, initDistortionSVGElementOnsecuritypolicyviolation$LWS,
// URL
initDistortionURLCreateObjectURL$LWS,
// Window
initDistortionWindowOnrejectionhandled$LWS, initDistortionWindowOnsecuritypolicyviolation$LWS, initDistortionWindowOnstorage$LWS, initDistortionWindowOnunhandledrejection$LWS, initDistortionWindowSetInterval$LWS, initDistortionWindowSetTimeout$LWS,
// XHR
initDistortionXMLHttpRequestResponseGetter$LWS, initDistortionXMLHttpRequestResponseXMLGetter$LWS];
const externalDistortionFactoryInitializers$LWS = ArrayConcat$LWS(internalDistortionFactoryInitializers$LWS, [
// Element
initDistortionElementAfter$LWS, initDistortionElementAppend$LWS, initDistortionElementBefore$LWS, initDistortionElementInsertAdjacentElement$LWS, initDistortionElementPrepend$LWS,
// Node
// The initDistortionNodeAppendChild distortion is temporarily disabled
// until W-10409618 is resolved..
// initDistortionNodeAppendChild,
initDistortionNodeInsertBefore$LWS]);
const externalKeyedDistortionFactoryInitializers$LWS = internalKeyedDistortionFactoryInitializers$LWS;
const distortionFactoryInitializerToggleSwitches$LWS = toSafeMap$LWS$1(new MapCtor$LWS$1([[initDistortionCacheStorageDelete$LWS, 'caches'], [initDistortionCacheStorageHas$LWS, 'caches'], [initDistortionCacheStorageKeys$LWS, 'caches'], [initDistortionCacheStorageMatch$LWS, 'caches'], [initDistortionCacheStorageOpen$LWS, 'caches'], [initDistortionCookieStoreDelete$LWS, 'cookieStore'], [initDistortionCookieStoreGet$LWS, 'cookieStore'], [initDistortionCookieStoreGetAll$LWS, 'cookieStore'], [initDistortionCookieStoreOnChange$LWS, 'cookieStore'], [initDistortionCookieStoreSet$LWS, 'cookieStore'], [initDistortionCSSStyleRuleStyleGetter$LWS, 'style'], [initDistortionCustomElementRegistryDefine$LWS, 'customElements'], [initDistortionCustomElementRegistryGet$LWS, 'customElements'], [initDistortionCustomElementRegistryUpgrade$LWS, 'customElements'], [initDistortionCustomElementRegistryWhenDefined$LWS, 'customElements'], [initDistortionDocumentCookieGetter$LWS, 'documentCookie'], [initDistortionDocumentCookieSetter$LWS, 'documentCookie'], [initDistortionDocumentDomainSetter$LWS, 'documentDomain'], [initDistortionDocumentExecCommand$LWS, 'documentExecCommand'], [initDistortionDOMParserParseFromString$LWS, 'domParserParseFromString'], [initDistortionElementAfter$LWS, 'element'], [initDistortionElementAppend$LWS, 'element'], [initDistortionElementAttributesGetter$LWS, 'attributes'], [initDistortionElementBefore$LWS, 'element'], [initDistortionElementGetInnerHTML$LWS, 'innerHTML'], [initDistortionElementInnerHTMLSetter$LWS, 'innerHTML'], [initDistortionElementInsertAdjacentElement$LWS, 'element'], [initDistortionElementInsertAdjacentHTML$LWS, 'element'], [initDistortionElementOuterHTMLSetter$LWS, 'element'], [initDistortionElementPrepend$LWS, 'element'], [initDistortionElementRemove$LWS, 'element'], [initDistortionElementReplaceChildren$LWS, 'element'], [initDistortionElementReplaceWith$LWS, 'element'], [initDistortionElementSetAttribute$LWS, 'attributes'], [initDistortionElementSetAttributeNode$LWS, 'attributes'], [initDistortionElementSetAttributeNodeNS$LWS, 'attributes'], [initDistortionElementSetAttributeNS$LWS, 'attributes'], [initDistortionElementSetHTML$LWS, 'element'], [initDistortionElementToggleAttribute$LWS, 'attributes'], [initDistortionHistoryPushState$LWS, 'history'], [initDistortionHistoryReplaceState$LWS, 'history'], [initDistortionHTMLElementDatasetGetter$LWS, 'dataset'], [initDistortionHTMLElementStyleGetter$LWS, 'style'], [initDistortionHTMLScriptElementSrcGetter$LWS, 'script'], [initDistortionHTMLScriptElementSrcSetter$LWS, 'script'], [initDistortionHTMLScriptElementTextSetter$LWS, 'script'], [initDistortionIDBObjectStoreAdd$LWS, 'indexedDB'], [initDistortionIDBObjectStorePut$LWS, 'indexedDB'], [initDistortionLocalStorage$LWS, 'storage'], [initDistortionMessagePortPostMessage$LWS, 'postMessage'], [initDistortionNamedNodeMapSetNamedItem$LWS, 'attributes'], [initDistortionNamedNodeMapSetNamedItemNS$LWS, 'attributes'], [initDistortionNavigatorSendBeacon$LWS, 'navigatorSendBeacon'], [initDistortionNodeInsertBefore$LWS, 'node'], [initDistortionNodeRemoveChild$LWS, 'node'], [initDistortionNodeReplaceChild$LWS, 'node'], [initDistortionNodeTextContentGetter$LWS, 'node'], [initDistortionNodeTextContentSetter$LWS, 'node'], [initDistortionNodeValueSetter$LWS, 'node'], [initDistortionNotificationCtor$LWS, 'notification'], [initDistortionPerformanceMark$LWS, 'performance'], [initDistortionPerformanceMarkCtor$LWS, 'performance'], [initDistortionPerformanceMeasure$LWS, 'performance'], [initDistortionRangeCreateContextualFragment$LWS, 'range'], [initDistortionRangeDeleteContents$LWS, 'range'], [initDistortionRangeExtractContents$LWS, 'range'], [initDistortionRangeInsertNode$LWS, 'range'], [initDistortionRangeSelectNode$LWS, 'range'], [initDistortionRangeSelectNodeContents$LWS, 'range'], [initDistortionRangeSetEnd$LWS, 'range'], [initDistortionRangeSetEndAfter$LWS, 'range'], [initDistortionRangeSetEndBefore$LWS, 'range'], [initDistortionRangeSetStart$LWS, 'range'], [initDistortionRangeSetStartAfter$LWS, 'range'], [initDistortionRangeSetStartBefore$LWS, 'range'], [initDistortionRangeSurroundContents$LWS, 'range'], [initDistortionSelectionCollapse$LWS, 'selection'], [initDistortionSelectionExtend$LWS, 'selection'], [initDistortionSelectionSelectAllChildren$LWS, 'selection'], [initDistortionSelectionSetBaseAndExtent$LWS, 'selection'], [initDistortionSelectionSetPosition$LWS, 'selection'], [initDistortionSessionStorage$LWS, 'storage'], [initDistortionShadowRootInnerHTMLSetter$LWS, 'innerHTML'], [initDistortionStorage$LWS, 'storage'], [initDistortionStorageClear$LWS, 'storage'], [initDistortionStorageGetItem$LWS, 'storage'], [initDistortionStorageKey$LWS, 'storage'], [initDistortionStorageLength$LWS, 'storage'], [initDistortionStorageRemoveItem$LWS, 'storage'], [initDistortionStorageSetItem$LWS, 'storage'], [initDistortionSVGElementDatasetGetter$LWS, 'dataset'], [initDistortionSVGElementStyleGetter$LWS, 'style'], [initDistortionSVGScriptElementHrefGetter$LWS, 'script'], [initDistortionSVGScriptElementHrefSetter$LWS, 'script'], [initDistortionWindowFetch$LWS, 'windowFetch'], [initDistortionWindowFramesGetter$LWS, 'windowFrames'], [initDistortionWindowGetComputedStyle$LWS, 'style'], [initDistortionWindowLengthGetter$LWS, 'windowFrames'], [initDistortionWindowPostMessage$LWS, 'postMessage'], [initDistortionWindowSetInterval$LWS, 'setInterval'], [initDistortionWindowSetTimeout$LWS, 'setTimeout'], [initDistortionXMLHttpRequestResponseGetter$LWS, 'xhr'], [initDistortionXMLHttpRequestResponseXMLGetter$LWS, 'xhr']]));
const DocumentBlockedProperties$LWS = ['createProcessingInstruction', 'exitFullscreen', 'fullscreen', 'fullscreenElement', 'fullscreenEnabled', 'mozCancelFullScreen', 'mozFullScreen', 'mozFullScreenElement', 'mozFullScreenEnabled', 'onfullscreenchange', 'onfullscreenerror', 'onmozfullscreenchange', 'onmozfullscreenerror', 'onrejectionhandled', 'onunhandledrejection', 'parseHTMLUnsafe', 'releaseCapture', 'releaseEvents', 'requestStorageAccess', 'webkitFullScreenKeyboardInputAllowed', 'write', 'writeln'];
const ElementBlockedProperties$LWS = ['mozRequestFullScreen', 'onfullscreenchange', 'onfullscreenerror', 'requestFullscreen', 'webkitRequestFullScreen', 'webkitRequestFullscreen'];
const EventBlockedProperties$LWS = ['originalTarget', 'explicitOriginalTarget'];
const HTMLElementBlockedAttributes$LWS = ['nonce'];
const HTMLElementBlockedProperties$LWS = ['nonce', 'onrejectionhandled', 'onunhandledrejection'];
const HTMLEmbedElementBlockedProperties$LWS = ['getSVGDocument'];

// https://www.w3schools.com/tags/tag_iframe.asp
const HTMLIFrameElementBlockedAttributes$LWS = ['srcdoc'];
const HTMLIFrameElementBlockedProperties$LWS = ['getSVGDocument', 'srcdoc'];
const HTMLObjectElementBlockedProperties$LWS = ['getSVGDocument'];
const HTMLScriptElementBlockedAttributes$LWS = ['nonce'];
const HTMLScriptElementBlockedProperties$LWS = ['nonce'];
const SVGElementBlockedAttributes$LWS = ['nonce'];
const SVGElementBlockedProperties$LWS = ['nonce'];
const UIEventBlockedProperties$LWS = ['rangeParent'];
const WindowBlockedProperties$LWS = ['find', 'requestFileSystem', 'webkitRequestFileSystem'];
const XSLTProcessorBlockedProperties$LWS = ['transformToDocument', 'transformToFragment'];
/*! version: 0.23.6 */

/*!
 * Copyright (C) 2019 salesforce.com, inc.
 */
const rootSandboxRegistry$LWS = {
  __proto__: null
};
const documentSandboxRegistryCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1([[rootDocument$LWS, rootSandboxRegistry$LWS]]));
const opaqueWindowSandboxRegistryCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
function getOpaqueSandboxRegistry$LWS(globalObject$LWS) {
  // Use the `document` as the key because a window object maintains its
  // identity continuity when its location changes and while the
  // non-configurable document property does not.
  let sandboxRegistry$LWS = opaqueWindowSandboxRegistryCache$LWS.get(globalObject$LWS);
  // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false
  if (sandboxRegistry$LWS === undefined) {
    sandboxRegistry$LWS = {
      __proto__: null
    };
    opaqueWindowSandboxRegistryCache$LWS.set(globalObject$LWS, sandboxRegistry$LWS);
  }
  return sandboxRegistry$LWS;
}
function getSandboxRegistry$LWS(document$LWS) {
  // Use the `document` as the key because a window object maintains its
  // identity continuity when its location changes and while the
  // non-configurable document property does not.
  let sandboxRegistry$LWS = documentSandboxRegistryCache$LWS.get(document$LWS);
  if (sandboxRegistry$LWS === undefined) {
    sandboxRegistry$LWS = {
      __proto__: null
    };
    documentSandboxRegistryCache$LWS.set(document$LWS, sandboxRegistry$LWS);
  }
  return sandboxRegistry$LWS;
}
const LightningWebSecurity$LWS = {
  __proto__: null
};
// Flag to allow distortions to be "toggle-able".
const ENABLE_DISTORTION_TOGGLE_SWITCHES$LWS = LOCKER_UNMINIFIED_FLAG$LWS$1 || /* istanbul ignore next */false || /* istanbul ignore next */false;
const distortionFactoryToToggleSwitch$LWS = ENABLE_DISTORTION_TOGGLE_SWITCHES$LWS ? toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1()) : /* istanbul ignore next */null;
const sandboxToDistortionEntryToToggleSwitchRegistry$LWS = ENABLE_DISTORTION_TOGGLE_SWITCHES$LWS ? toSafeWeakMap$LWS$1(
// The value must be a Map because its entries are iterated over in lws.ts
new WeakMapCtor$LWS$1()) : /* istanbul ignore next */null;
const sandboxToDisabledDistortionToggleSwitches$LWS = toSafeMap$LWS$1(new MapCtor$LWS$1());
function setSandboxDistortionToggleState$LWS(record$LWS, toggleSwitchName$LWS, state$LWS) {
  const disabledDistortionToggleSwitches$LWS = sandboxToDisabledDistortionToggleSwitches$LWS.get(record$LWS);
  if (state$LWS) {
    disabledDistortionToggleSwitches$LWS == null || disabledDistortionToggleSwitches$LWS.delete(toggleSwitchName$LWS);
  } else {
    disabledDistortionToggleSwitches$LWS == null || disabledDistortionToggleSwitches$LWS.add(toggleSwitchName$LWS);
  }
}
function getSandboxDistortionToggleState$LWS(record$LWS, toggleSwitchName$LWS) {
  const disabledDistortionToggleSwitches$LWS = sandboxToDisabledDistortionToggleSwitches$LWS.get(record$LWS);
  // If there are active toggle switches, check for the presense of the specific
  // toggle switch name in question. If the toggle switch name is present, then
  // the distortion is disabled:
  //
  // Distortion is enabled? Return true
  // Distortion is disabled? Return false
  return !disabledDistortionToggleSwitches$LWS.has(toggleSwitchName$LWS);
}
// Will be assigned the composed object value as:
//
// namespaces = {
//      ...ns = {
//          distortions: {
//              ...distortion toggle switch flag: true | false
//          }
//      }
// }
//
// This is created once and only upon the first access of $LWS.namespaces
let namespaces$LWS = null;
// This should only be created in DEBUG/COVERAGE mode
if (ENABLE_DISTORTION_TOGGLE_SWITCHES$LWS) {
  ReflectDefineProperty$LWS$1(LightningWebSecurity$LWS, 'namespaces', {
    __proto__: null,
    enumerable: true,
    configurable: false,
    get() {
      // Ensure that the above described namespaces object is only createed once.
      if (!namespaces$LWS) {
        namespaces$LWS = {
          __proto__: null
        };
        // Use the current document to get the sandbox registry to derive a list
        // of all sandbox keys corresponding to all created sandboxes.
        const registry$LWS = getSandboxRegistry$LWS(document);
        const sandboxKeys$LWS = ReflectApply$LWS$1(ObjectKeys$LWS$1, null, [registry$LWS]);
        // Construct a list of distortion flags (as object accessors) for each sandbox,
        // accessible by sandbox key.
        for (const sandboxKey$LWS of sandboxKeys$LWS) {
          const record$LWS = registry$LWS[sandboxKey$LWS];
          // istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
          const distortionToggleSwitchRegistry$LWS = sandboxToDistortionEntryToToggleSwitchRegistry$LWS == null ? void 0 : sandboxToDistortionEntryToToggleSwitchRegistry$LWS.get(record$LWS);
          const seenFlags$LWS = toSafeSet$LWS(new SetCtor$LWS$1());
          const distortions$LWS = {
            __proto__: null
          };
          namespaces$LWS[sandboxKey$LWS] = {
            __proto__: null,
            distortions: distortions$LWS
          };
          for (const {
            1: flag$LWS
          } of distortionToggleSwitchRegistry$LWS) {
            if (!seenFlags$LWS.has(flag$LWS)) {
              seenFlags$LWS.add(flag$LWS);
              ReflectDefineProperty$LWS$1(namespaces$LWS[sandboxKey$LWS].distortions, flag$LWS, {
                __proto__: null,
                enumerable: true,
                configurable: false,
                get() {
                  return getSandboxDistortionToggleState$LWS(record$LWS, flag$LWS);
                },
                set(flagValue$LWS) {
                  return setSandboxDistortionToggleState$LWS(record$LWS, flag$LWS, flagValue$LWS);
                }
              });
            }
          }
          ObjectPreventExtensions$LWS(distortions$LWS);
        }
        ObjectPreventExtensions$LWS(namespaces$LWS);
      }
      return namespaces$LWS;
    }
  });
  ReflectDefineProperty$LWS$1(window, '$LWS', {
    __proto__: null,
    enumerable: false,
    configurable: false,
    writable: false,
    value: LightningWebSecurity$LWS
  });
}
ObjectFreeze$LWS$1(LightningWebSecurity$LWS);
function createDistortionToggleSwitchWrapper$LWS(sandboxKey$LWS, toggleSwitchName$LWS, proxyMaskedFunctionDistortion$LWS, originalValue$LWS) {
  // The distortion function value wrapper is necessary because these switches can only be activated _after_
  // the sandbox is created, which means the distortion registry has already been processed, with redefined
  // descriptors already set. Once that is done, there is no way to affect the behavior of a distortion
  // during runtime without wrapping the distortion function value with a function that side channel communicates
  // with the exposed flags interface.
  // eslint-disable-next-line @typescript-eslint/no-loop-func
  return function (...args$LWS) {
    var _root$LWS$namespaces$LWS;
    const {
      $LWS: root$LWS
    } = rootWindow$LWS$1;
    // If no toggleSwitchName is defined, then always use the distorted value
    // If a toggleSwitchName exists and the corresponding flag in this sandbox
    // has been set to false, then the distortion is toggled off and we need to
    // use the undistorted value
    let useDistortedValue$LWS = root$LWS == null || (_root$LWS$namespaces$LWS = root$LWS.namespaces) == null || (_root$LWS$namespaces$LWS = _root$LWS$namespaces$LWS[sandboxKey$LWS]) == null ? void 0 : _root$LWS$namespaces$LWS.distortions[toggleSwitchName$LWS];
    // If there is a toggleSwitchName, but there is currently no
    // boolean value for that toggleSwitchName, then use the distorted value.
    if (useDistortedValue$LWS === undefined) {
      useDistortedValue$LWS = true;
    }
    const constructOrApplyTarget$LWS = useDistortedValue$LWS ? proxyMaskedFunctionDistortion$LWS : originalValue$LWS;
    if (new.target) {
      return ReflectConstruct$LWS(constructOrApplyTarget$LWS, args$LWS, new.target);
    }
    return ReflectApply$LWS$1(constructOrApplyTarget$LWS, this, args$LWS);
  };
}
const distortionFactoriesCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
const opaqueWindowPostMessageDistortionFactoryCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
// WebKit based browsers have a bug that prematurely removes distortion entries
// from the distortions weak map.
const SUPPORTS_DISTORTIONS_WEAK_MAP$LWS = !IS_WEBKIT_BROWSER$LWS;
function createDistortionEntries$LWS(record$LWS, factories$LWS) {
  const distortionEntryToToggleSwitch$LWS = toSafeMap$LWS$1(new MapCtor$LWS$1());
  const entries$LWS = [];
  for (let i$LWS = 0, {
      length: length$LWS
    } = factories$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const factory$LWS = factories$LWS[i$LWS];
    const entry$LWS = factory$LWS(record$LWS);
    if (entry$LWS) {
      const {
        0: originalValue$LWS,
        1: distortedValue$LWS
      } = entry$LWS;
      if (typeof originalValue$LWS === 'function') {
        const proxyMaskedFunctionDistortion$LWS = proxyMaskFunctionDistortion$LWS(record$LWS, factory$LWS, distortedValue$LWS, originalValue$LWS);
        const toggleSwitchName$LWS = ENABLE_DISTORTION_TOGGLE_SWITCHES$LWS && ( /* istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator */distortionFactoryToToggleSwitch$LWS == null ? void 0 : distortionFactoryToToggleSwitch$LWS.get(factory$LWS));
        let distortionToggleSwitchWrapperOrProxyMaskedFunction$LWS = proxyMaskedFunctionDistortion$LWS;
        if (ENABLE_DISTORTION_TOGGLE_SWITCHES$LWS && toggleSwitchName$LWS) {
          distortionToggleSwitchWrapperOrProxyMaskedFunction$LWS = createDistortionToggleSwitchWrapper$LWS(record$LWS.key, toggleSwitchName$LWS, proxyMaskedFunctionDistortion$LWS, originalValue$LWS);
          // If the distorted API originated in a window created via window.open or
          // document.open, it may be marked as an unsafe property. If so, we need
          // to transfer the original value's marker to the wrapped toggle switch
          // function to ensure that the distortion itself can find the marker when
          // checking if it needs to be blocked.
          if (originalValue$LWS[CHILD_WINDOW_BLOCKED_PROPERTY_SYMBOL$LWS]) {
            const descriptor$LWS = ReflectGetOwnPropertyDescriptor$LWS(originalValue$LWS, CHILD_WINDOW_BLOCKED_PROPERTY_SYMBOL$LWS);
            ReflectDefineProperty$LWS$1(distortionToggleSwitchWrapperOrProxyMaskedFunction$LWS, CHILD_WINDOW_BLOCKED_PROPERTY_SYMBOL$LWS, descriptor$LWS);
          }
        }
        entries$LWS[entries$LWS.length] = [originalValue$LWS, toggleSwitchName$LWS ? distortionToggleSwitchWrapperOrProxyMaskedFunction$LWS : proxyMaskedFunctionDistortion$LWS];
      } else {
        // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false
        if (typeof originalValue$LWS === 'object' && originalValue$LWS !== null) {
          // TODO: we may need to make this assigned value a proxy when ENABLE_DISTORTION_TOGGLE_SWITCHES is true,
          // allowing us to change which value is provided for the distortion.
          entries$LWS[entries$LWS.length] = entry$LWS;
        }
      }
      if (ENABLE_DISTORTION_TOGGLE_SWITCHES$LWS) {
        /* istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator */
        const toggleSwitchName$LWS = distortionFactoryToToggleSwitch$LWS == null ? void 0 : distortionFactoryToToggleSwitch$LWS.get(factory$LWS);
        if (toggleSwitchName$LWS) {
          // Map the just added distortion entry to this toggle switch name
          distortionEntryToToggleSwitch$LWS.set(entries$LWS[entries$LWS.length - 1], toggleSwitchName$LWS);
        }
      }
    }
  }
  if (ENABLE_DISTORTION_TOGGLE_SWITCHES$LWS) {
    sandboxToDistortionEntryToToggleSwitchRegistry$LWS == null || sandboxToDistortionEntryToToggleSwitchRegistry$LWS.set(record$LWS, distortionEntryToToggleSwitch$LWS);
    sandboxToDisabledDistortionToggleSwitches$LWS.set(record$LWS, toSafeSet$LWS(new SetCtor$LWS$1()));
  }
  return entries$LWS;
}
function createDistortionMap$LWS(entries$LWS) {
  return SUPPORTS_DISTORTIONS_WEAK_MAP$LWS ? toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1(entries$LWS)) :
  // istanbul ignore next: this code is not reachable in the coverage run.
  toSafeMap$LWS$1(new MapCtor$LWS$1(entries$LWS));
}
function getDistortionFactories$LWS(record$LWS) {
  const {
    document: document$LWS,
    globalObject: globalObject$LWS,
    type: type$LWS
  } = record$LWS;
  let factories$LWS = distortionFactoriesCache$LWS.get(document$LWS);
  if (factories$LWS) {
    return factories$LWS;
  }
  const {
    Document: Document$LWS,
    Element: Element$LWS,
    Event: Event$LWS,
    HTMLElement: HTMLElement$LWS,
    HTMLIFrameElement: HTMLIFrameElement$LWS,
    HTMLScriptElement: HTMLScriptElement$LWS,
    SVGElement: SVGElement$LWS,
    UIEvent: UIEvent$LWS,
    XSLTProcessor: XSLTProcessor$LWS
  } = globalObject$LWS;
  const initializers$LWS = type$LWS === 1 /* SandboxType.Internal */ ?
  // instanbul ignore next: coverage is collected on the external sandbox test run
  ArrayConcat$LWS(internalDistortionFactoryInitializers$LWS, internalKeyedDistortionFactoryInitializers$LWS) : ArrayConcat$LWS(externalDistortionFactoryInitializers$LWS, externalKeyedDistortionFactoryInitializers$LWS);
  addBlockedAttributeDistortionFactoryInitializers$LWS(HTMLElement$LWS, 'HTMLElement', HTMLElementBlockedAttributes$LWS, initializers$LWS);
  addBlockedAttributeDistortionFactoryInitializers$LWS(HTMLIFrameElement$LWS, 'HTMLIFrameElement', HTMLIFrameElementBlockedAttributes$LWS, initializers$LWS);
  addBlockedAttributeDistortionFactoryInitializers$LWS(HTMLScriptElement$LWS, 'HTMLScriptElement', HTMLScriptElementBlockedAttributes$LWS, initializers$LWS);
  addBlockedAttributeDistortionFactoryInitializers$LWS(SVGElement$LWS, 'SVGElement', SVGElementBlockedAttributes$LWS, initializers$LWS);
  addBlockedPropertyDistortionFactoryInitializers$LWS(record$LWS, DataTransfer.prototype, DataTransferBlockedProperties$LWS, initializers$LWS);
  addBlockedPropertyDistortionFactoryInitializers$LWS(record$LWS, Document$LWS.prototype, DocumentBlockedProperties$LWS, initializers$LWS);
  addBlockedPropertyDistortionFactoryInitializers$LWS(record$LWS, Element$LWS.prototype, ElementBlockedProperties$LWS, initializers$LWS);
  addBlockedPropertyDistortionFactoryInitializers$LWS(record$LWS, Event$LWS.prototype, EventBlockedProperties$LWS, initializers$LWS);
  addBlockedPropertyDistortionFactoryInitializers$LWS(record$LWS, HTMLElement$LWS.prototype, HTMLElementBlockedProperties$LWS, initializers$LWS);
  addBlockedPropertyDistortionFactoryInitializers$LWS(record$LWS, HTMLIFrameElement$LWS.prototype, HTMLIFrameElementBlockedProperties$LWS, initializers$LWS);
  addBlockedPropertyDistortionFactoryInitializers$LWS(record$LWS, HTMLEmbedElement.prototype, HTMLEmbedElementBlockedProperties$LWS, initializers$LWS);
  addBlockedPropertyDistortionFactoryInitializers$LWS(record$LWS, HTMLObjectElement.prototype, HTMLObjectElementBlockedProperties$LWS, initializers$LWS);
  addBlockedPropertyDistortionFactoryInitializers$LWS(record$LWS, HTMLScriptElement$LWS.prototype, HTMLScriptElementBlockedProperties$LWS, initializers$LWS);
  addBlockedPropertyDistortionFactoryInitializers$LWS(record$LWS, SVGElement$LWS.prototype, SVGElementBlockedProperties$LWS, initializers$LWS);
  addBlockedPropertyDistortionFactoryInitializers$LWS(record$LWS, UIEvent$LWS.prototype, UIEventBlockedProperties$LWS, initializers$LWS);
  addBlockedPropertyDistortionFactoryInitializers$LWS(record$LWS, globalObject$LWS, WindowBlockedProperties$LWS, initializers$LWS);
  // istanbul ignore else: this is a safety precaution that is unreachable via tests
  if (typeof XSLTProcessor$LWS === 'function') {
    addBlockedPropertyDistortionFactoryInitializers$LWS(record$LWS, XSLTProcessor$LWS.prototype, XSLTProcessorBlockedProperties$LWS, initializers$LWS);
  }
  patchGlobalObject$LWS(globalObject$LWS, document$LWS);
  // Reuse the `initializers` array as the `factories` array.
  factories$LWS = initializers$LWS;
  for (let i$LWS = 0, {
      length: length$LWS
    } = factories$LWS; i$LWS < length$LWS; i$LWS += 1) {
    let toggleSwitchName$LWS;
    // Restrict this operation to debug/development/coverage mode only
    if (ENABLE_DISTORTION_TOGGLE_SWITCHES$LWS) {
      toggleSwitchName$LWS = distortionFactoryInitializerToggleSwitches$LWS.get(initializers$LWS[i$LWS]);
    }
    factories$LWS[i$LWS] = initializers$LWS[i$LWS](record$LWS);
    // Restrict this operation to debug/development/coverage mode only.
    // Since we actually need the _factory_ to when creating the toggle-able
    // distortion wrapper, map the factory provided by the initializer to the
    // toggle switch name.
    if (ENABLE_DISTORTION_TOGGLE_SWITCHES$LWS && toggleSwitchName$LWS) {
      distortionFactoryToToggleSwitch$LWS == null || distortionFactoryToToggleSwitch$LWS.set(factories$LWS[i$LWS], toggleSwitchName$LWS);
    }
  }
  // Finalize attribute distortions last because the attribute registry is
  // populated by the other distortion factories.
  factories$LWS[factories$LWS.length] = finalizeAttributeDistortions$LWS;
  distortionFactoriesCache$LWS.set(document$LWS, factories$LWS);
  return factories$LWS;
}
function getOpaqueWindowPostMessageDistortionFactory$LWS(record$LWS) {
  const {
    globalObject: globalObject$LWS
  } = record$LWS;
  let opaqueWindowPostMessageDistortionFactory$LWS = opaqueWindowPostMessageDistortionFactoryCache$LWS.get(globalObject$LWS);
  // istanbul ignore next: this is a safety precaution that is unreachable via tests
  if (opaqueWindowPostMessageDistortionFactory$LWS) {
    return opaqueWindowPostMessageDistortionFactory$LWS;
  }
  opaqueWindowPostMessageDistortionFactory$LWS = initDistortionWindowPostMessage$LWS(record$LWS);
  opaqueWindowPostMessageDistortionFactoryCache$LWS.set(globalObject$LWS, opaqueWindowPostMessageDistortionFactory$LWS);
  return opaqueWindowPostMessageDistortionFactory$LWS;
}
function proxyMaskFunctionDistortion$LWS({
  LOCKER_VERBOSE_INSTRUMENTATION_FLAG: LOCKER_VERBOSE_INSTRUMENTATION_FLAG$LWS,
  instrumentation: instrumentation$LWS,
  key: sandboxKey$LWS
}, distortionFactory$LWS, distortionFunc$LWS, maskFunc$LWS) {
  return maskFunction$LWS(distortionFunc$LWS, maskFunc$LWS, {
    apply: function (target$LWS, thisArg$LWS, args$LWS) {
      try {
        return ReflectApply$LWS$1(target$LWS, thisArg$LWS, args$LWS);
      } catch (error) {
        throw error;
      } finally {
      }
    },
    construct: function (target$LWS, args$LWS, newTarget$LWS) {
      try {
        return ReflectConstruct$LWS(target$LWS, args$LWS, newTarget$LWS);
      } catch (error) {
        throw error;
      } finally {
      }
    }
  });
}
let lockerEvalContextValue$LWS;
let lockerEvalHelpersValue$LWS;
function clearEvalContext$LWS() {
  const evalContext$LWS = lockerEvalContextValue$LWS;
  lockerEvalContextValue$LWS = undefined;
  return evalContext$LWS;
}
function clearEvalHelpers$LWS() {
  const evalHelpers$LWS = lockerEvalHelpersValue$LWS;
  lockerEvalHelpersValue$LWS = undefined;
  return evalHelpers$LWS;
}
function setEvalContext$LWS(evalContext$LWS) {
  lockerEvalContextValue$LWS = evalContext$LWS;
}
function setEvalHelpers$LWS(evalHelpers$LWS) {
  lockerEvalHelpersValue$LWS = evalHelpers$LWS;
}
const CORE_SANDBOX_KEY$LWS = 'lws-core-sandbox';
const DEFAULT_ENDOWMENTS_DESCRIPTOR_MAP$LWS = {
  [SANDBOX_EVAL_CONTEXT_NAME$LWS]: {
    __proto__: null,
    get() {
      return clearEvalContext$LWS();
    }
  },
  [SANDBOX_EVAL_HELPERS_NAME$LWS]: {
    __proto__: null,
    get() {
      return clearEvalHelpers$LWS();
    }
  }
};
const EMPTY_DISTORTIONS_MAP$LWS = createDistortionMap$LWS();
const EMPTY_OBJECT$LWS = {};
const ROOT_UNCOMPILED_CONTEXT$LWS = {
  [UNCOMPILED_LOCATION_NAME$LWS]: rootWindowLocation$LWS,
  [UNCOMPILED_TOP_NAME$LWS]: rootWindowTop$LWS,
  // The following context entries are explicitly added because the
  // UNCOMPILED_*_NAME entries will only be added to the contextNames
  // via transforms when the fully qualified member expression is detected
  // in the code, eg. window.location, or window.top.
  // See complete explanation in packages/@locker/shared-dom/src/source-transformations.ts.
  location: rootWindowLocation$LWS,
  top: rootWindowTop$LWS
};
const {
  apply: ReflectApply$LWS,
  defineProperty: ReflectDefineProperty$LWS,
  deleteProperty: ReflectDeleteProperty$LWS,
  getPrototypeOf: ReflectGetPrototypeOf$LWS,
  ownKeys: ReflectOwnKeys$LWS,
  setPrototypeOf: ReflectSetPrototypeOf$LWS
} = Reflect;
const ObjectCtor$LWS = Object;
const {
  assign: ObjectAssign$LWS,
  freeze: ObjectFreeze$LWS,
  keys: ObjectKeys$LWS,
  prototype: ObjectProto$LWS
} = ObjectCtor$LWS;
const {
  hasOwn: OriginalObjectHasOwn$LWS
} = ObjectCtor$LWS;
const {
  __lookupGetter__: ObjectProtoLookupGetter$LWS,
  __lookupSetter__: ObjectProtoLookupSetter$LWS,
  hasOwnProperty: ObjectProtoHasOwnProperty$LWS
} = ObjectProto$LWS;
const ObjectHasOwn$LWS = typeof OriginalObjectHasOwn$LWS === 'function' ? OriginalObjectHasOwn$LWS : /* istanbul ignore next: currently unreachable via tests */function ObjectHasOwn$LWS(object$LWS, key$LWS) {
  return ReflectApply$LWS(ObjectProtoHasOwnProperty$LWS, object$LWS, [key$LWS]);
};
const {
  toString: ObjectProtoToString$LWS
} = ObjectProto$LWS;
function isObject$LWS(value$LWS) {
  return typeof value$LWS === 'object' && value$LWS !== null;
}
function ObjectLookupOwnGetter$LWS(object$LWS, key$LWS) {
  return object$LWS === null || object$LWS === undefined || !ObjectHasOwn$LWS(object$LWS, key$LWS) ? undefined : ReflectApply$LWS(ObjectProtoLookupGetter$LWS, object$LWS, [key$LWS]);
}
const SymbolCtor$LWS = Symbol;
const {
  for: SymbolFor$LWS,
  iterator: SymbolIterator$LWS,
  toStringTag: SymbolToStringTag$LWS,
  unscopables: SymbolUnscopables$LWS
} = SymbolCtor$LWS;
const ArrayCtor$LWS = Array;
const {
  prototype: ArrayProto$LWS
} = ArrayCtor$LWS;
const {
  at: ArrayProtoAt$LWS,
  concat: ArrayProtoConcat$LWS,
  copyWithin: ArrayProtoCopyWithin$LWS,
  entries: ArrayProtoEntries$LWS,
  every: ArrayProtoEvery$LWS,
  fill: ArrayProtoFill$LWS,
  findIndex: ArrayProtoFindIndex$LWS,
  flat: ArrayProtoFlat$LWS,
  flatMap: ArrayProtoFlatMap$LWS,
  forEach: ArrayProtoForEach$LWS,
  join: ArrayProtoJoin$LWS,
  keys: ArrayProtoKeys$LWS,
  lastIndexOf: ArrayProtoLastIndexOf$LWS,
  pop: ArrayProtoPop$LWS,
  reduce: ArrayProtoReduce$LWS,
  reduceRight: ArrayProtoReduceRight$LWS,
  reverse: ArrayProtoReverse$LWS,
  slice: ArrayProtoSlice$LWS,
  some: ArrayProtoSome$LWS,
  toLocaleString: ArrayProtoToLocaleString$LWS,
  toString: ArrayProtoToString$LWS,
  values: ArrayProtoValues$LWS,
  [SymbolIterator$LWS]: ArrayProtoSymbolIterator$LWS
} = ArrayProto$LWS;
const ArrayUnscopables$LWS = ObjectFreeze$LWS(ObjectAssign$LWS({
  __proto__: null
}, ArrayProto$LWS[SymbolUnscopables$LWS]));
const {
  filter: ArrayProtoFilter$LWS,
  find: ArrayProtoFind$LWS,
  includes: ArrayProtoIncludes$LWS,
  indexOf: ArrayProtoIndexOf$LWS,
  map: ArrayProtoMap$LWS,
  push: ArrayProtoPush$LWS,
  shift: ArrayProtoShift$LWS,
  splice: ArrayProtoSplice$LWS,
  sort: ArrayProtoSort$LWS,
  unshift: ArrayProtoUnshift$LWS
} = ArrayProto$LWS;
const {
  isArray: ArrayIsArray$LWS
} = ArrayCtor$LWS;
function toSafeArray$LWS(array$LWS) {
  ReflectSetPrototypeOf$LWS(array$LWS, null);
  array$LWS.at = ArrayProtoAt$LWS;
  array$LWS.concat = ArrayProtoConcat$LWS;
  // *** DO NOT SET THE ARRAY CONSTRUCTOR PROPERTY ***
  // https://bugs.chromium.org/p/v8/issues/detail?id=13202
  // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/lookup.cc;l=196-215?q=IsArraySpeciesLookupChainIntact
  //
  // In V8 setting the constructor property of an array, promise, regexp, or
  // typed array triggers a de-opt because it could change an instance's
  // @@species. This de-opt affects at least `Array#splice` and occurs even
  // if the prototype of the array is change or nulled beforehand. Further,
  // the de-opt persists after a page refresh. It is not until navigating to
  // a different page that the performance of `Array#splice` is restored.
  array$LWS.copyWithin = ArrayProtoCopyWithin$LWS;
  array$LWS.entries = ArrayProtoEntries$LWS;
  array$LWS.every = ArrayProtoEvery$LWS;
  array$LWS.fill = ArrayProtoFill$LWS;
  array$LWS.filter = ArrayProtoFilter$LWS;
  array$LWS.find = ArrayProtoFind$LWS;
  array$LWS.findIndex = ArrayProtoFindIndex$LWS;
  array$LWS.flat = ArrayProtoFlat$LWS;
  array$LWS.flatMap = ArrayProtoFlatMap$LWS;
  array$LWS.forEach = ArrayProtoForEach$LWS;
  array$LWS.includes = ArrayProtoIncludes$LWS;
  array$LWS.indexOf = ArrayProtoIndexOf$LWS;
  array$LWS.join = ArrayProtoJoin$LWS;
  array$LWS.keys = ArrayProtoKeys$LWS;
  array$LWS.lastIndexOf = ArrayProtoLastIndexOf$LWS;
  array$LWS.map = ArrayProtoMap$LWS;
  array$LWS.pop = ArrayProtoPop$LWS;
  array$LWS.push = ArrayProtoPush$LWS;
  array$LWS.reduce = ArrayProtoReduce$LWS;
  array$LWS.reduceRight = ArrayProtoReduceRight$LWS;
  array$LWS.reverse = ArrayProtoReverse$LWS;
  array$LWS.shift = ArrayProtoShift$LWS;
  array$LWS.slice = ArrayProtoSlice$LWS;
  array$LWS.some = ArrayProtoSome$LWS;
  array$LWS.sort = ArrayProtoSort$LWS;
  array$LWS.splice = ArrayProtoSplice$LWS;
  array$LWS.toLocaleString = ArrayProtoToLocaleString$LWS;
  array$LWS.toString = ArrayProtoToString$LWS;
  array$LWS.unshift = ArrayProtoUnshift$LWS;
  array$LWS.values = ArrayProtoValues$LWS;
  array$LWS[SymbolIterator$LWS] = ArrayProtoSymbolIterator$LWS;
  array$LWS[SymbolUnscopables$LWS] = ArrayUnscopables$LWS;
  ReflectSetPrototypeOf$LWS(array$LWS, ArrayProto$LWS);
  return array$LWS;
}
ObjectLookupOwnGetter$LWS(ArrayBuffer.prototype, 'byteLength');
// This package is bundled by third-parties that have their own build time
// replacement logic. Instead of customizing each build system to be aware
// of this package we implement a two phase debug mode by performing small
// runtime checks to determine phase one, our code is unminified, and
// phase two, the user opted-in to custom devtools formatters. Phase one
// is used for light weight initialization time debug while phase two is
// reserved for post initialization runtime
const LOCKER_UNMINIFIED_FLAG$LWS =
// eslint-disable-next-line @typescript-eslint/naming-convention
/* istanbul ignore next */
`${function LOCKER_UNMINIFIED_FLAG$LWS() {
  return LOCKER_UNMINIFIED_FLAG$LWS.name;
}()}`.includes('LOCKER_UNMINIFIED_FLAG');
// Character constants.
const CHAR_ELLIPSIS$LWS = '\u2026';
// Near-membrane constants.
const LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS = SymbolFor$LWS('@@lockerNearMembraneSerializedValue');
const LOCKER_NEAR_MEMBRANE_SYMBOL$LWS = SymbolFor$LWS('@@lockerNearMembrane');
SymbolFor$LWS('@@lockerLiveValue');
const TO_STRING_BRAND_BIG_INT$LWS = '[object BigInt]';
const TO_STRING_BRAND_BOOLEAN$LWS = '[object Boolean]';
const TO_STRING_BRAND_NUMBER$LWS = '[object Number]';
const TO_STRING_BRAND_STRING$LWS = '[object String]';
const TO_STRING_BRAND_SYMBOL$LWS = '[object Symbol]';
const MapCtor$LWS = Map;
const {
  prototype: MapProto$LWS
} = MapCtor$LWS;
const {
  clear: MapProtoClear$LWS,
  delete: MapProtoDelete$LWS,
  forEach: MapProtoForEach$LWS,
  get: MapProtoGet$LWS,
  has: MapProtoHas$LWS,
  keys: MapProtoKeys$LWS,
  values: MapProtoValues$LWS,
  [SymbolIterator$LWS]: MapProtoSymbolIterator$LWS,
  [SymbolToStringTag$LWS]: MapProtoSymbolToStringTag$LWS
} = MapProto$LWS;
const {
  entries: MapProtoEntries$LWS,
  set: MapProtoSet$LWS
} = MapProto$LWS;
const MapProtoSizeGetter$LWS = ObjectLookupOwnGetter$LWS(MapProto$LWS, 'size');
function toSafeMap$LWS(map$LWS) {
  ReflectSetPrototypeOf$LWS(map$LWS, null);
  map$LWS.clear = MapProtoClear$LWS;
  map$LWS.delete = MapProtoDelete$LWS;
  map$LWS.entries = MapProtoEntries$LWS;
  map$LWS.forEach = MapProtoForEach$LWS;
  map$LWS.get = MapProtoGet$LWS;
  map$LWS.has = MapProtoHas$LWS;
  map$LWS.keys = MapProtoKeys$LWS;
  map$LWS.set = MapProtoSet$LWS;
  ReflectDefineProperty$LWS(map$LWS, 'size', {
    __proto__: null,
    configurable: true,
    enumerable: true,
    get: MapProtoSizeGetter$LWS,
    set: undefined
  });
  map$LWS.values = MapProtoValues$LWS;
  map$LWS[SymbolIterator$LWS] = MapProtoSymbolIterator$LWS;
  map$LWS[SymbolToStringTag$LWS] = MapProtoSymbolToStringTag$LWS;
  ReflectSetPrototypeOf$LWS(map$LWS, MapProto$LWS);
  return map$LWS;
}
const NumberCtor$LWS = Number;
const {
  isFinite: NumberIsFinite$LWS,
  isInteger: NumberIsInteger$LWS,
  isNaN: NumberIsNaN$LWS
} = NumberCtor$LWS;
const RegExpCtor$LWS = RegExp;
const {
  prototype: RegExpProto$LWS
} = RegExpCtor$LWS;
const {
  test: RegExpProtoTest$LWS
} = RegExpProto$LWS;
ObjectLookupOwnGetter$LWS(RegExpProto$LWS, 'source');
const SetCtor$LWS = Set;
const {
  prototype: SetProto$LWS
} = SetCtor$LWS;
const {
  add: SetProtoAdd$LWS,
  has: SetProtoHas$LWS,
  values: SetProtoValues$LWS
} = SetProto$LWS;
ObjectLookupOwnGetter$LWS(SetProto$LWS, 'size');
const StringCtor$LWS = String;
const {
  prototype: StringProto$LWS
} = StringCtor$LWS;
const {
  slice: StringProtoSlice$LWS,
  valueOf: StringProtoValueOf$LWS
} = StringProto$LWS;
const WeakMapCtor$LWS = WeakMap;
const {
  prototype: WeakMapProto$LWS
} = WeakMapCtor$LWS;
const {
  has: WeakMapProtoHas$LWS
} = WeakMapProto$LWS;
const {
  delete: WeakMapProtoDelete$LWS,
  get: WeakMapProtoGet$LWS,
  set: WeakMapProtoSet$LWS,
  [SymbolToStringTag$LWS]: WeakMapProtoSymbolToStringTag$LWS
} = WeakMapProto$LWS;
function toSafeWeakMap$LWS(weakMap$LWS) {
  ReflectSetPrototypeOf$LWS(weakMap$LWS, null);
  weakMap$LWS.delete = WeakMapProtoDelete$LWS;
  weakMap$LWS.get = WeakMapProtoGet$LWS;
  weakMap$LWS.has = WeakMapProtoHas$LWS;
  weakMap$LWS.set = WeakMapProtoSet$LWS;
  weakMap$LWS[SymbolToStringTag$LWS] = WeakMapProtoSymbolToStringTag$LWS;
  ReflectSetPrototypeOf$LWS(weakMap$LWS, WeakMapProto$LWS);
  return weakMap$LWS;
}
const WeakSetCtor$LWS = WeakSet;
const {
  prototype: WeakSetProto$LWS
} = WeakSetCtor$LWS;
const {
  has: WeakSetProtoHas$LWS
} = WeakSetProto$LWS;
const {
  add: WeakSetProtoAdd$LWS,
  delete: WeakSetProtoDelete$LWS,
  [SymbolToStringTag$LWS]: WeakSetProtoSymbolToStringTag$LWS
} = WeakSetProto$LWS;
function toSafeWeakSet$LWS(weakSet$LWS) {
  ReflectSetPrototypeOf$LWS(weakSet$LWS, null);
  weakSet$LWS.add = WeakSetProtoAdd$LWS;
  weakSet$LWS.delete = WeakSetProtoDelete$LWS;
  weakSet$LWS.has = WeakSetProtoHas$LWS;
  weakSet$LWS[SymbolToStringTag$LWS] = WeakSetProtoSymbolToStringTag$LWS;
  ReflectSetPrototypeOf$LWS(weakSet$LWS, WeakSetProto$LWS);
  return weakSet$LWS;
}
// Used by '@locker/near-membrane-dom'.
const {
  stringify: JSONStringify$LWS
} = JSON;
function getNearMembraneProxySerializedValue$LWS(object$LWS) {
  if (typeof object$LWS === 'object' && object$LWS !== null || typeof object$LWS === 'function') {
    // To extract the serialized value of a blue near-membrane proxy we must
    // perform a two step handshake. First, we trigger the "has" trap for
    // the `LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL` property which
    // must report `false`. Second, we trigger the "get" trap to return the
    // serialized value.
    return LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS in object$LWS ? undefined : object$LWS[LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS];
  }
  return undefined;
}
function isNearMembraneProxy$LWS(value$LWS) {
  if (typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function') {
    // To extract the flag value of a blue near-membrane proxy we must
    // perform a two step handshake. First, we trigger the "has" trap for
    // the `LOCKER_NEAR_MEMBRANE_SYMBOL` property which must report `false`.
    // Second, we trigger the "get" trap to return the flag value.
    return !(LOCKER_NEAR_MEMBRANE_SYMBOL$LWS in value$LWS) && value$LWS[LOCKER_NEAR_MEMBRANE_SYMBOL$LWS] === true;
  }
  return false;
}
toSafeMap$LWS(new MapCtor$LWS());
const ErrorCtor$LWS = Error;
const TypeErrorCtor$LWS = TypeError;
function noop$LWS() {
  // No operation performed.
}

// Used by '@locker/near-membrane-dom'.
const {
  min: MathMin$LWS
} = Math;
const rootWindow$LWS = window;
const {
  // We don't cherry-pick the 'userAgent' property from `navigator` here
  // to avoid triggering its getter.
  navigator: navigator$LWS,
  navigator: {
    userAgentData: userAgentData$LWS
  }
} = rootWindow$LWS;
// The user-agent client hints API is experimental and subject to change.
// https://caniuse.com/mdn-api_navigator_useragentdata
// istanbul ignore next: optional chaining and nullish coalescing results in an expansion that contains an unreachable "void 0" branch for every occurrence of the operator
const brands$LWS = userAgentData$LWS == null ? void 0 : userAgentData$LWS.brands;
// Note: Chromium identifies itself as Chrome in its user-agent string.
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent
const chromiumUserAgentRegExp$LWS = / (?:Headless)?Chrome\/\d+/;
let userAgent$LWS;
function getUserAgent$LWS() {
  if (userAgent$LWS === undefined) {
    userAgent$LWS = navigator$LWS.userAgent;
  }
  return userAgent$LWS;
}
const IS_CHROMIUM_BROWSER$LWS =
// While experimental, `navigator.userAgentData.brands` may be defined as an
// empty array in headless Chromium based browsers.
ArrayIsArray$LWS(brands$LWS) && brands$LWS.length ?
// Use user-agent client hints API if available to avoid deprecation
// warnings.
// https://developer.mozilla.org/en-US/docs/Web/API/User-Agent_Client_Hints_API
// istanbul ignore next: this code is not reachable in the coverage run.
ReflectApply$LWS(ArrayProtoFind$LWS, brands$LWS, [
// prettier-ignore
item$LWS => (item$LWS == null ? void 0 : item$LWS.brand) === 'Chromium']) !== undefined :
// Fallback to a standard user-agent string sniff.
ReflectApply$LWS(RegExpProtoTest$LWS, chromiumUserAgentRegExp$LWS, [getUserAgent$LWS()]);
const IS_OLD_CHROMIUM_BROWSER$LWS = IS_CHROMIUM_BROWSER$LWS &&
// Chromium added support for `navigator.userAgentData` in v90.
// https://caniuse.com/mdn-api_navigator_useragentdata
userAgentData$LWS === undefined;
const {
  prototype: DocumentProto$LWS
} = Document;
const {
  close: DocumentProtoClose$LWS,
  createElement: DocumentProtoCreateElement$LWS,
  open: DocumentProtoOpen$LWS
} = DocumentProto$LWS;
const DocumentProtoBodyGetter$LWS = ObjectLookupOwnGetter$LWS(DocumentProto$LWS, 'body');

// The DOMException constructor was exposed in Edge 12 but wasn't invocable
// until Edge 79. As long as this is used for instanceof checks it should be fine.
// https://developer.mozilla.org/en-US/docs/Web/API/DOMException#browser_compatibility
const DOMExceptionCtor$LWS = DOMException;
ObjectLookupOwnGetter$LWS(DOMExceptionCtor$LWS.prototype, 'code');
const {
  remove: ElementProtoRemove$LWS,
  setAttribute: ElementProtoSetAttribute$LWS
} = Element.prototype;
const HTMLElementProtoStyleGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLElement.prototype, 'style');
const HTMLIFrameElementProtoContentWindowGetter$LWS = ObjectLookupOwnGetter$LWS(HTMLIFrameElement.prototype, 'contentWindow');
const {
  prototype: NodeProto$LWS
} = Node;
const {
  appendChild: NodeProtoAppendChild$LWS
} = NodeProto$LWS;
const NodeProtoLastChildGetter$LWS = ObjectLookupOwnGetter$LWS(NodeProto$LWS, 'lastChild');

// This package is bundled by third-parties that have their own build time
// replacement logic. Instead of customizing each build system to be aware
// of this package we implement a two phase debug mode by performing small
// runtime checks to determine phase one, our code is unminified, and
// phase two, the user opted-in to custom devtools formatters. Phase one
// is used for light weight initialization time debug while phase two is
// reserved for post initialization runtime.
// istanbul ignore else: not avoidable via tests
if (LOCKER_UNMINIFIED_FLAG$LWS) {
  // We passed the phase one gate so we know our code is unminified and we can
  // install Locker's custom devtools formatter.
  let lockerDebugModeSymbolFlag$LWS = true;
  const LOCKER_DEBUG_MODE_SYMBOL$LWS = SymbolFor$LWS('@@lockerDebugMode');
  const MAX_ARRAY_DISPLAY$LWS = 100;
  const MAX_OBJECT_DISPLAY$LWS = 5;
  const MAX_STRING_DISPLAY$LWS = 100;
  const MID_STRING_DISPLAY$LWS = MAX_STRING_DISPLAY$LWS / 2;
  const headerCSSText$LWS = 'display: inline-block; margin-bottom: 3px; margin-left: -3px; word-break: break-all; word-wrap: wrap;';
  const bodyItemStyleObject$LWS = {
    style: 'margin-left:15px; margin-bottom: 3px;'
  };
  const bodyStyleObject$LWS = {
    style: 'display: inline-block; margin-left:12px; word-break: break-all; word-wrap: wrap;'
  };
  const keyEnumerableStringStyleObject$LWS = {
    style: 'color: #9d288c; font-weight: bold'
  };
  const keyNonEnumerableOrSymbolStyleObject$LWS = {
    style: 'color: #b17ab0'
  };
  const primitiveBlueColorStyleObject$LWS = {
    style: 'color: #16239f'
  };
  const primitiveGreenColorStyleObject$LWS = {
    style: 'color: #236d25'
  };
  const primitiveGreyColorStyleObject$LWS = {
    style: 'color: #606367'
  };
  const primitiveOrangeColorStyleObject$LWS = {
    style: 'color: #b82619'
  };
  // istanbul ignore next: currently unreachable via tests
  const formatValue$LWS = function formatValue$LWS(value$LWS) {
    if (value$LWS === null || value$LWS === undefined) {
      return ['span', primitiveGreyColorStyleObject$LWS, `${value$LWS}`];
    }
    if (typeof value$LWS === 'boolean') {
      return ['span', primitiveBlueColorStyleObject$LWS, value$LWS];
    }
    if (typeof value$LWS === 'number') {
      return NumberIsFinite$LWS(value$LWS) ? ['span', primitiveBlueColorStyleObject$LWS, value$LWS] : ['span', primitiveBlueColorStyleObject$LWS, `${value$LWS >= 0 ? '' : '-'}Infinity`];
    }
    if (typeof value$LWS === 'bigint') {
      return ['span', primitiveGreenColorStyleObject$LWS, `${value$LWS}n`];
    }
    if (typeof value$LWS === 'string') {
      let string$LWS = value$LWS;
      const {
        length: length$LWS
      } = string$LWS;
      if (length$LWS > MAX_STRING_DISPLAY$LWS) {
        const firstChunk$LWS = ReflectApply$LWS(StringProtoSlice$LWS, string$LWS, [0, MID_STRING_DISPLAY$LWS]);
        const lastChunk$LWS = ReflectApply$LWS(StringProtoSlice$LWS, string$LWS, [length$LWS - MID_STRING_DISPLAY$LWS - 1, length$LWS]);
        string$LWS = firstChunk$LWS + CHAR_ELLIPSIS$LWS + lastChunk$LWS;
      }
      // @TODO: Default to using single quotes on main header and double
      // quotes on body.
      return ['span', primitiveOrangeColorStyleObject$LWS, JSONStringify$LWS(string$LWS)];
    }
    if (ArrayIsArray$LWS(value$LWS)) {
      return ['span', {}, `Array(${value$LWS.length})`];
    }
    if (isObject$LWS(value$LWS)) {
      return ['span', {}, `{${CHAR_ELLIPSIS$LWS}}`];
    }
    // Symbol will be coerced to a string.
    return ['span', primitiveOrangeColorStyleObject$LWS, StringCtor$LWS(value$LWS)];
  };
  // istanbul ignore next: currently unreachable via tests
  const formatHeader$LWS = function formatHeader$LWS(object$LWS, config$LWS) {
    const isChildElement$LWS = config$LWS == null ? void 0 : config$LWS.isChildElement;
    const formattedHeader$LWS = [];
    let formattedHeaderOffset$LWS = 0;
    if (isChildElement$LWS) {
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', keyEnumerableStringStyleObject$LWS, config$LWS.childKey];
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, ': '];
    }
    const brand$LWS = ReflectApply$LWS(ObjectProtoToString$LWS, object$LWS, []);
    let keys$LWS = ObjectKeys$LWS(object$LWS);
    if (brand$LWS === TO_STRING_BRAND_SYMBOL$LWS) {
      if (!ReflectApply$LWS(ArrayProtoIncludes$LWS, keys$LWS, ['description'])) {
        ReflectApply$LWS(ArrayProtoUnshift$LWS, keys$LWS, ['description']);
      }
    } else if (brand$LWS === TO_STRING_BRAND_STRING$LWS) {
      const {
        length: length$LWS
      } = object$LWS;
      keys$LWS = ReflectApply$LWS(ArrayProtoFilter$LWS, keys$LWS, [key$LWS => {
        const possibleIndex$LWS = typeof key$LWS === 'string' ? +key$LWS : -1;
        return possibleIndex$LWS < 0 || possibleIndex$LWS >= length$LWS || !NumberIsInteger$LWS(possibleIndex$LWS);
      }]);
    }
    const ownKeysRaw$LWS = ReflectOwnKeys$LWS(object$LWS);
    const ownKeys$LWS = ReflectApply$LWS(ArrayProtoMap$LWS, ownKeysRaw$LWS, [StringCtor$LWS]);
    const {
      length: ownKeysLength$LWS
    } = ownKeys$LWS;
    if (ArrayIsArray$LWS(object$LWS)) {
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, `(${object$LWS.length}) [`];
      for (let i$LWS = 0, length$LWS = MathMin$LWS(ownKeysLength$LWS, MAX_ARRAY_DISPLAY$LWS); i$LWS < length$LWS; i$LWS += 1) {
        const ownKeyRaw$LWS = ownKeysRaw$LWS[i$LWS];
        const ownKey$LWS = ownKeys$LWS[i$LWS];
        const value$LWS = object$LWS[ownKeyRaw$LWS];
        if (ownKey$LWS !== 'length') {
          if (!NumberIsNaN$LWS(NumberCtor$LWS(ownKey$LWS))) {
            formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, i$LWS ? ', ' : ''];
            formattedHeader$LWS[formattedHeaderOffset$LWS++] = formatValue$LWS(value$LWS);
          } else {
            formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, i$LWS ? ', ' : ''];
            formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', primitiveGreyColorStyleObject$LWS, StringCtor$LWS(ownKey$LWS)];
            formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, ': '];
            formattedHeader$LWS[formattedHeaderOffset$LWS++] = formatValue$LWS(value$LWS);
          }
        }
      }
      if (ownKeysLength$LWS > MAX_ARRAY_DISPLAY$LWS) {
        formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', null, ['span', {}, `, ${CHAR_ELLIPSIS$LWS}`]];
      }
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, ']'];
      return formattedHeader$LWS;
    }
    let boxedHeaderEntry$LWS;
    let headerOpening$LWS = '{';
    // eslint-disable-next-line default-case
    switch (brand$LWS) {
      case TO_STRING_BRAND_BIG_INT$LWS:
      case TO_STRING_BRAND_BOOLEAN$LWS:
      case TO_STRING_BRAND_NUMBER$LWS:
      case TO_STRING_BRAND_STRING$LWS:
      case TO_STRING_BRAND_SYMBOL$LWS:
        {
          let colorStyleObject$LWS = primitiveBlueColorStyleObject$LWS;
          if (brand$LWS === TO_STRING_BRAND_BIG_INT$LWS) {
            colorStyleObject$LWS = primitiveGreenColorStyleObject$LWS;
          } else if (brand$LWS === TO_STRING_BRAND_SYMBOL$LWS) {
            colorStyleObject$LWS = primitiveOrangeColorStyleObject$LWS;
          }
          headerOpening$LWS = `${ReflectApply$LWS(StringProtoSlice$LWS, brand$LWS, [8, -1])} {`;
          boxedHeaderEntry$LWS = ['span', colorStyleObject$LWS, `${StringCtor$LWS(getNearMembraneProxySerializedValue$LWS(object$LWS))}`];
          break;
        }
    }
    formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, headerOpening$LWS];
    if (boxedHeaderEntry$LWS) {
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = boxedHeaderEntry$LWS;
      if (ownKeysLength$LWS) {
        formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, ', '];
      }
    }
    for (let i$LWS = 0, length$LWS = MathMin$LWS(ownKeysLength$LWS, MAX_OBJECT_DISPLAY$LWS); i$LWS < length$LWS; i$LWS += 1) {
      const ownKeyRaw$LWS = ownKeysRaw$LWS[i$LWS];
      const ownKey$LWS = ownKeys$LWS[i$LWS];
      const value$LWS = object$LWS[ownKeyRaw$LWS];
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, i$LWS ? ', ' : ''];
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', primitiveGreyColorStyleObject$LWS, ownKey$LWS];
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, ': '];
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = formatValue$LWS(value$LWS);
    }
    if (ownKeysLength$LWS > MAX_OBJECT_DISPLAY$LWS) {
      formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', null, ['span', {}, `, ${CHAR_ELLIPSIS$LWS}`]];
    }
    formattedHeader$LWS[formattedHeaderOffset$LWS++] = ['span', {}, '}'];
    return formattedHeader$LWS;
  };
  // istanbul ignore next: currently unreachable via tests
  const formatBody$LWS = function formatBody$LWS(object$LWS) {
    // @TODO: Arrays are broken into groups of 100.
    const ownKeysRaw$LWS = ReflectOwnKeys$LWS(object$LWS);
    const ownKeys$LWS = ReflectApply$LWS(ArrayProtoMap$LWS, ownKeysRaw$LWS, [StringCtor$LWS]);
    // Put 'length' at the end of array.
    const isArray$LWS = ArrayIsArray$LWS(object$LWS);
    if (isArray$LWS) {
      const lengthIndex$LWS = ReflectApply$LWS(ArrayProtoIndexOf$LWS, ownKeys$LWS, ['length']);
      const lengthKeyRaw$LWS = ReflectApply$LWS(ArrayProtoSplice$LWS, ownKeysRaw$LWS, [lengthIndex$LWS, 1])[0];
      ReflectApply$LWS(ArrayProtoPush$LWS, ownKeysRaw$LWS, [lengthKeyRaw$LWS]);
      const lengthKey$LWS = ReflectApply$LWS(ArrayProtoSplice$LWS, ownKeys$LWS, [lengthIndex$LWS, 1])[0];
      ReflectApply$LWS(ArrayProtoPush$LWS, ownKeys$LWS, [lengthKey$LWS]);
    }
    const formattedBody$LWS = [];
    let formattedBodyOffset$LWS = 0;
    for (let i$LWS = 0, {
        length: length$LWS
      } = ownKeys$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const ownKeyRaw$LWS = ownKeysRaw$LWS[i$LWS];
      const ownKey$LWS = ownKeys$LWS[i$LWS];
      const value$LWS = object$LWS[ownKeyRaw$LWS];
      if (isObject$LWS(value$LWS)) {
        formattedBody$LWS[formattedBodyOffset$LWS++] = ['div', {}, ['object', {
          object: value$LWS,
          config: {
            childKey: StringCtor$LWS(ownKey$LWS),
            isChildElement: true
          }
        }]];
      } else {
        let currentKeyStyle$LWS = keyEnumerableStringStyleObject$LWS;
        if (isArray$LWS && ownKey$LWS === 'length') {
          currentKeyStyle$LWS = keyNonEnumerableOrSymbolStyleObject$LWS;
        }
        formattedBody$LWS[formattedBodyOffset$LWS++] = ['div', bodyItemStyleObject$LWS, ['span', currentKeyStyle$LWS, ownKey$LWS], ['span', {}, ': '], formatValue$LWS(value$LWS)];
      }
    }
    return formattedBody$LWS;
  };
  let {
    devtoolsFormatters: devtoolsFormatters$LWS
  } = rootWindow$LWS;
  if (!ArrayIsArray$LWS(devtoolsFormatters$LWS)) {
    devtoolsFormatters$LWS = [];
    ReflectDefineProperty$LWS(rootWindow$LWS, 'devtoolsFormatters', {
      __proto__: null,
      configurable: true,
      value: devtoolsFormatters$LWS,
      writable: true
    });
  }
  // Append our custom formatter to the array of devtools formatters.
  // istanbul ignore next: currently unreachable via tests
  devtoolsFormatters$LWS[devtoolsFormatters$LWS.length] = {
    // istanbul ignore next: currently unreachable via tests
    header(object$LWS, config$LWS) {
      if (lockerDebugModeSymbolFlag$LWS) {
        // We passed the second phase gate so we know that the user has
        // opted-in to custom devtools formatters. Close the gate and
        // define the @@lockerDebugMode symbol on window.
        lockerDebugModeSymbolFlag$LWS = false;
        ReflectDefineProperty$LWS(rootWindow$LWS, LOCKER_DEBUG_MODE_SYMBOL$LWS, {
          __proto__: null,
          configurable: true,
          value: true,
          writable: true
        });
      }
      if (!isNearMembraneProxy$LWS(object$LWS)) {
        return null;
      }
      const headerDiv$LWS = ['div', {
        style: `${headerCSSText$LWS}${config$LWS != null && config$LWS.isChildElement ? '' : 'font-style: italic;'}`
      }];
      ReflectApply$LWS(ArrayProtoPush$LWS, headerDiv$LWS, formatHeader$LWS(object$LWS, config$LWS));
      return ['div', {}, headerDiv$LWS];
    },
    // istanbul ignore next: currently unreachable via tests
    hasBody() {
      return true;
    },
    // istanbul ignore next: currently unreachable via tests
    body(object$LWS) {
      const bodyDiv$LWS = ['div', bodyStyleObject$LWS];
      ReflectApply$LWS(ArrayProtoPush$LWS, bodyDiv$LWS, formatBody$LWS(object$LWS));
      return bodyDiv$LWS;
    }
  };
}

/**
 * This file contains an exportable (portable) function `init()` used to initialize
 * one side of a membrane on any realm. The only prerequisite is the ability to
 * evaluate the sourceText of the `init()` function there. Once evaluated, the
 * function will return a set of values that can be used to wire up the side of
 * the membrane with another existing `init()` function from another realm, in
 * which case they will exchange callable functions that are required to connect
 * the two realms via the membrane.
 *
 * About the mechanics of the membrane, there are few important considerations:
 *
 * 1. Pointers are the way to pass reference to object and functions.
 * 2. A dedicated symbol (LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL) is needed
 *    to represent the absence of a value.
 * 3. The realm that owns the object or function is responsible for projecting
 *    the proxy onto the other side (via callablePushTarget), which returns a
 *    Pointer that can be used by the realm to pass the reference to the same
 *    proxy over and over again.
 * 4. The realm that owns the proxy (after the other side projects it into it)
 *    will hold a Pointer alongside the proxy to signal what original object or
 *    function should the foreign operation operates, it is always the first
 *    argument of the foreign callable for proxies, and the other side can use
 *    it via `selectedTarget!`.
 */
const proxyTargetToLazyPropertyDescriptorStateMap$LWS = toSafeWeakMap$LWS(new WeakMapCtor$LWS());
// istanbul ignore next
function createMembraneMarshall$LWS(globalObject$LWS) {
  var _ref$LWS, _ref2$LWS, _ReflectApply$LWS, _globalThisRef$BigInt$LWS, _globalThisRef$BigUin$LWS;
  /* eslint-disable prefer-object-spread */
  const ArrayCtor$LWS = Array;
  const ArrayBufferCtor$LWS = ArrayBuffer;
  const ErrorCtor$LWS = Error;
  const NumberCtor$LWS = Number;
  const ObjectCtor$LWS = Object;
  const ProxyCtor$LWS = Proxy;
  const ReflectRef$LWS = Reflect;
  const RegExpCtor$LWS = RegExp;
  const StringCtor$LWS = String;
  const SymbolCtor$LWS = Symbol;
  const TypeErrorCtor$LWS = TypeError;
  // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow
  const WeakMapCtor$LWS = WeakMap;
  const WeakSetCtor$LWS = WeakSet;
  const {
    for: SymbolFor$LWS,
    toStringTag: SymbolToStringTag$LWS
  } = SymbolCtor$LWS;
  const {
    // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow
    apply: ReflectApply$LWS,
    construct: ReflectConstruct$LWS,
    defineProperty: ReflectDefineProperty$LWS,
    deleteProperty: ReflectDeleteProperty$LWS,
    get: ReflectGet$LWS,
    getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor$LWS,
    getPrototypeOf: ReflectGetPrototypeOf$LWS,
    has: ReflectHas$LWS,
    isExtensible: ReflectIsExtensible$LWS,
    ownKeys: ReflectOwnKeys$LWS,
    preventExtensions: ReflectPreventExtensions$LWS,
    set: ReflectSet$LWS,
    // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow
    setPrototypeOf: ReflectSetPrototypeOf$LWS
  } = ReflectRef$LWS;
  const {
    assign: ObjectAssign$LWS,
    defineProperties: ObjectDefineProperties$LWS,
    freeze: ObjectFreeze$LWS,
    getOwnPropertyDescriptor: ObjectGetOwnPropertyDescriptor$LWS,
    getOwnPropertyDescriptors: ObjectGetOwnPropertyDescriptors$LWS,
    isFrozen: ObjectIsFrozen$LWS,
    isSealed: ObjectIsSealed$LWS,
    keys: ObjectKeys$LWS,
    prototype: ObjectProto$LWS,
    seal: ObjectSeal$LWS
  } = ObjectCtor$LWS;
  const {
    hasOwnProperty: ObjectProtoHasOwnProperty$LWS,
    propertyIsEnumerable: ObjectProtoPropertyIsEnumerable$LWS,
    toString: ObjectProtoToString$LWS
  } = ObjectProto$LWS;
  const {
    hasOwn: OriginalObjectHasOwn$LWS
  } = ObjectCtor$LWS;
  const {
    __defineGetter__: ObjectProtoDefineGetter$LWS,
    __defineSetter__: ObjectProtoDefineSetter$LWS,
    __lookupGetter__: ObjectProtoLookupGetter$LWS,
    __lookupSetter__: ObjectProtoLookupSetter$LWS
  } = ObjectProto$LWS;
  const ObjectHasOwn$LWS = typeof OriginalObjectHasOwn$LWS === 'function' ? OriginalObjectHasOwn$LWS : (object$LWS, key$LWS) => ReflectApply$LWS(ObjectProtoHasOwnProperty$LWS, object$LWS, [key$LWS]);
  const globalThisRef$LWS = (_ref$LWS = (_ref2$LWS = globalObject$LWS != null ? globalObject$LWS :
  // Support for globalThis was added in Chrome 71.
  // https://caniuse.com/mdn-javascript_builtins_globalthisfor
  typeof globalThis !== 'undefined' ? globalThis : undefined) != null ? _ref2$LWS :
  // However, environments like Android emulators are running Chrome 69.
  // eslint-disable-next-line no-restricted-globals
  typeof self !== 'undefined' ? self : undefined) != null ? _ref$LWS : (
  // See https://mathiasbynens.be/notes/globalthis for more details.
  ReflectDefineProperty$LWS(ObjectProto$LWS, 'globalThis', {
    __proto__: null,
    configurable: true,
    get() {
      ReflectDeleteProperty$LWS(ObjectProto$LWS, 'globalThis');
      // Safari 12 on iOS 12.1 has a `this` of `undefined` so we
      // fallback to `self`.
      // eslint-disable-next-line no-restricted-globals
      return this != null ? this : self;
    }
  }), globalThis);
  const IS_IN_SHADOW_REALM$LWS = typeof globalObject$LWS !== 'object' || globalObject$LWS === null;
  const IS_NOT_IN_SHADOW_REALM$LWS = !IS_IN_SHADOW_REALM$LWS;
  const LOCKER_DEBUG_MODE_SYMBOL$LWS = IS_NOT_IN_SHADOW_REALM$LWS ? SymbolFor$LWS('@@lockerDebugMode') : undefined;
  const LOCKER_IDENTIFIER_MARKER$LWS = '$LWS';
  const LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS = IS_NOT_IN_SHADOW_REALM$LWS ? SymbolFor$LWS('@@lockerNearMembraneSerializedValue') : undefined;
  const LOCKER_NEAR_MEMBRANE_SYMBOL$LWS = IS_NOT_IN_SHADOW_REALM$LWS ? SymbolFor$LWS('@@lockerNearMembrane') : undefined;
  const LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS = SymbolFor$LWS('@@lockerNearMembraneUndefinedValue');
  // The default stack trace limit in Chrome is 10.
  // Set to 20 to account for stack trace filtering.
  const LOCKER_STACK_TRACE_LIMIT$LWS = 20;
  // This package is bundled by third-parties that have their own build time
  // replacement logic. Instead of customizing each build system to be aware
  // of this package we implement a two phase debug mode by performing small
  // runtime checks to determine phase one, our code is unminified, and
  // phase two, the user opted-in to custom devtools formatters. Phase one
  // is used for light weight initialization time debug while phase two is
  // reserved for post initialization runtime.
  // eslint-disable-next-line @typescript-eslint/naming-convention
  const LOCKER_UNMINIFIED_FLAG$LWS = `${function LOCKER_UNMINIFIED_FLAG$LWS() {
    return LOCKER_UNMINIFIED_FLAG$LWS.name;
  }()}`.includes('LOCKER_UNMINIFIED_FLAG');
  // Indicate whether debug support is available.
  const LOCKER_DEBUGGABLE_FLAG$LWS = LOCKER_UNMINIFIED_FLAG$LWS && IS_NOT_IN_SHADOW_REALM$LWS;
  const ERR_ILLEGAL_PROPERTY_ACCESS$LWS = 'Illegal property access.';
  // BigInt is not supported in Safari 13.1.
  // https://caniuse.com/bigint
  const FLAGS_REG_EXP$LWS = IS_IN_SHADOW_REALM$LWS ? /\w*$/ : undefined;
  // Minification safe references to the private `BoundaryProxyHandler`
  // 'apply' and 'construct' trap variant's property names.
  let MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS;
  const SUPPORTS_BIG_INT$LWS = typeof BigInt === 'function';
  const {
    isArray: isArrayOrThrowForRevoked$LWS
  } = ArrayCtor$LWS;
  const {
    includes: ArrayProtoIncludes$LWS,
    indexOf: ArrayProtoIndexOf$LWS,
    slice: ArrayProtoSlice$LWS
  } = ArrayCtor$LWS.prototype;
  const {
    isView: ArrayBufferIsView$LWS
  } = ArrayBufferCtor$LWS;
  const BigIntProtoValueOf$LWS = SUPPORTS_BIG_INT$LWS ? BigInt.prototype.valueOf : undefined;
  const {
    valueOf: BooleanProtoValueOf$LWS
  } = Boolean.prototype;
  const {
    toString: ErrorProtoToString$LWS
  } = ErrorCtor$LWS.prototype;
  const {
    bind: FunctionProtoBind$LWS,
    toString: FunctionProtoToString$LWS
  } = Function.prototype;
  const {
    stringify: JSONStringify$LWS
  } = JSON;
  const {
    isInteger: NumberIsInteger$LWS
  } = NumberCtor$LWS;
  const {
    valueOf: NumberProtoValueOf$LWS
  } = NumberCtor$LWS.prototype;
  const {
    revocable: ProxyRevocable$LWS
  } = ProxyCtor$LWS;
  const {
    prototype: RegExpProto$LWS
  } = RegExpCtor$LWS;
  const {
    exec: RegExpProtoExec$LWS,
    test: RegExpProtoTest$LWS,
    toString: RegExProtoToString$LWS
  } = RegExpProto$LWS;
  // Edge 15 does not support RegExp.prototype.flags.
  // https://caniuse.com/mdn-javascript_builtins_regexp_flags
  const RegExpProtoFlagsGetter$LWS = IS_IN_SHADOW_REALM$LWS ? (_ReflectApply$LWS = ReflectApply$LWS(ObjectProtoLookupGetter$LWS, RegExpProto$LWS, ['flags'])) != null ? _ReflectApply$LWS : function flags$LWS() {
    const string$LWS = ReflectApply$LWS(RegExProtoToString$LWS, this, []);
    return ReflectApply$LWS(RegExpProtoExec$LWS, FLAGS_REG_EXP$LWS, [string$LWS])[0];
  } : undefined;
  const RegExpProtoSourceGetter$LWS = ReflectApply$LWS(ObjectProtoLookupGetter$LWS, RegExpProto$LWS, ['source']);
  const {
    replace: StringProtoReplace$LWS,
    slice: StringProtoSlice$LWS,
    valueOf: StringProtoValueOf$LWS
  } = StringCtor$LWS.prototype;
  const {
    toString: SymbolProtoToString$LWS,
    valueOf: SymbolProtoValueOf$LWS
  } = SymbolCtor$LWS.prototype;
  const BigInt64ArrayProto$LWS = (_globalThisRef$BigInt$LWS = globalThisRef$LWS.BigInt64Array) == null ? void 0 : _globalThisRef$BigInt$LWS.prototype;
  const BigUint64ArrayProto$LWS = (_globalThisRef$BigUin$LWS = globalThisRef$LWS.BigUint64Array) == null ? void 0 : _globalThisRef$BigUin$LWS.prototype;
  const {
    prototype: Float32ArrayProto$LWS
  } = Float32Array;
  const {
    prototype: Float64ArrayProto$LWS
  } = Float64Array;
  const {
    prototype: Int8ArrayProto$LWS
  } = Int8Array;
  const {
    prototype: Int16ArrayProto$LWS
  } = Int16Array;
  const {
    prototype: Int32ArrayProto$LWS
  } = Int32Array;
  const {
    prototype: Uint8ArrayProto$LWS
  } = Uint8Array;
  const {
    prototype: Uint16ArrayProto$LWS
  } = Uint16Array;
  const {
    prototype: Uint32ArrayProto$LWS
  } = Uint32Array;
  // eslint-disable-next-line no-proto
  const TypedArrayProto$LWS = Uint8ArrayProto$LWS.__proto__;
  const TypedArrayProtoLengthGetter$LWS = ReflectApply$LWS(ObjectProtoLookupGetter$LWS, TypedArrayProto$LWS, ['length']);
  const {
    prototype: WeakMapProto$LWS
  } = WeakMapCtor$LWS;
  const {
    delete: WeakMapProtoDelete$LWS,
    has: WeakMapProtoHas$LWS,
    set: WeakMapProtoSet$LWS,
    [SymbolToStringTag$LWS]: WeakMapProtoSymbolToStringTag$LWS
  } = WeakMapProto$LWS;
  const {
    prototype: WeakSetProto$LWS
  } = WeakSetCtor$LWS;
  const {
    add: WeakSetProtoAdd$LWS,
    has: WeakSetProtoHas$LWS,
    delete: WeakSetProtoDelete$LWS,
    [SymbolToStringTag$LWS]: WeakSetProtoSymbolToStringTag$LWS
  } = WeakSetProto$LWS;
  const consoleObject$LWS = IS_NOT_IN_SHADOW_REALM$LWS && typeof console === 'object' && console !== null ? console : undefined;
  const consoleInfo$LWS = consoleObject$LWS == null ? void 0 : consoleObject$LWS.info;
  const localEval$LWS = IS_IN_SHADOW_REALM$LWS ? eval : undefined;
  // Install flags to ensure things are installed once per realm.
  let installedErrorPrepareStackTraceFlag$LWS = false;
  let installedPropertyDescriptorMethodWrappersFlag$LWS = false;
  function alwaysFalse$LWS() {
    return false;
  }
  const installErrorPrepareStackTrace$LWS = LOCKER_UNMINIFIED_FLAG$LWS ? () => {
    if (installedErrorPrepareStackTraceFlag$LWS) {
      return;
    }
    installedErrorPrepareStackTraceFlag$LWS = true;
    // Feature detect the V8 stack trace API.
    // https://v8.dev/docs/stack-trace-api
    const CallSite$LWS = (() => {
      try {
        var _callSites$$LWS;
        ErrorCtor$LWS.prepareStackTrace = (_error$LWS, callSites) => callSites;
        const callSites = new ErrorCtor$LWS().stack;
        ReflectDeleteProperty$LWS(ErrorCtor$LWS, 'prepareStackTrace');
        return isArrayOrThrowForRevoked$LWS(callSites) && callSites.length > 0 ? (_callSites$$LWS = callSites[0]) == null ? void 0 : _callSites$$LWS.constructor : undefined;
        // eslint-disable-next-line no-empty
      } catch (_unused$LWS) {}
      return undefined;
    })();
    if (typeof CallSite$LWS !== 'function') {
      return;
    }
    const {
      getEvalOrigin: CallSiteProtoGetEvalOrigin$LWS,
      getFunctionName: CallSiteProtoGetFunctionName$LWS,
      toString: CallSiteProtoToString$LWS
    } = CallSite$LWS.prototype;
    // A regexp to detect call sites containing LOCKER_IDENTIFIER_MARKER.
    const lockerFunctionNameMarkerRegExp$LWS = new RegExpCtor$LWS(`${
    // Escape regexp special characters in LOCKER_IDENTIFIER_MARKER.
    ReflectApply$LWS(StringProtoReplace$LWS, LOCKER_IDENTIFIER_MARKER$LWS, [/[\\^$.*+?()[\]{}|]/g, '\\$&'])
    // Function name references in call sites also contain
    // the name of the class they belong to,
    // e.g. myClassName.myFunctionName.
    }(?=\\.|$)`);
    const formatStackTrace = function formatStackTrace(error, callSites) {
      // Based on V8's default stack trace formatting:
      // https://chromium.googlesource.com/v8/v8.git/+/refs/heads/main/src/execution/messages.cc#371
      let stackTrace$LWS = '';
      try {
        stackTrace$LWS = ReflectApply$LWS(ErrorProtoToString$LWS, error, []);
      } catch (_unused2$LWS) {
        stackTrace$LWS = '<error>';
      }
      let consecutive$LWS = false;
      for (let i$LWS = 0, {
          length: length$LWS
        } = callSites; i$LWS < length$LWS; i$LWS += 1) {
        const callSite$LWS = callSites[i$LWS];
        const funcName$LWS = ReflectApply$LWS(CallSiteProtoGetFunctionName$LWS, callSite$LWS, []);
        let isMarked$LWS = false;
        if (typeof funcName$LWS === 'string' && funcName$LWS !== 'eval' && ReflectApply$LWS(RegExpProtoTest$LWS, lockerFunctionNameMarkerRegExp$LWS, [funcName$LWS])) {
          isMarked$LWS = true;
        }
        if (!isMarked$LWS) {
          const evalOrigin$LWS = ReflectApply$LWS(CallSiteProtoGetEvalOrigin$LWS, callSite$LWS, []);
          if (typeof evalOrigin$LWS === 'string' && ReflectApply$LWS(RegExpProtoTest$LWS, lockerFunctionNameMarkerRegExp$LWS, [evalOrigin$LWS])) {
            isMarked$LWS = true;
          }
        }
        // Only write a single LWS entry per consecutive LWS stacks.
        if (isMarked$LWS) {
          if (!consecutive$LWS) {
            consecutive$LWS = true;
            stackTrace$LWS += '\n    at LWS';
          }
          continue;
        } else {
          consecutive$LWS = false;
        }
        try {
          stackTrace$LWS += `\n    at ${ReflectApply$LWS(CallSiteProtoToString$LWS, callSite$LWS, [])}`;
          // eslint-disable-next-line no-empty
        } catch (_unused3$LWS) {}
      }
      return stackTrace$LWS;
    };
    try {
      // Error.prepareStackTrace cannot be a bound or proxy wrapped
      // function, so to obscure its source we wrap the call to
      // formatStackTrace().
      ErrorCtor$LWS.prepareStackTrace = function prepareStackTrace(error, callSites) {
        return formatStackTrace(error, callSites);
      };
      // eslint-disable-next-line no-empty
    } catch (_unused4$LWS) {}
    try {
      const {
        stackTraceLimit: stackTraceLimit$LWS
      } = ErrorCtor$LWS;
      if (typeof stackTraceLimit$LWS !== 'number' || stackTraceLimit$LWS < LOCKER_STACK_TRACE_LIMIT$LWS) {
        ErrorCtor$LWS.stackTraceLimit = LOCKER_STACK_TRACE_LIMIT$LWS;
      }
      // eslint-disable-next-line no-empty
    } catch (_unused5$LWS) {}
  } : noop$LWS;
  function noop$LWS() {
    // No-operation.
  }
  const serializeBigIntObject$LWS = IS_IN_SHADOW_REALM$LWS ? bigIntObject$LWS =>
  // Section 21.2.3 Properties of the BigInt Prototype Object
  // https://tc39.es/ecma262/#thisbigintvalue
  // Step 2: If Type(value) is Object and value has a [[BigIntData]] internal slot, then
  //     a. Assert: Type(value.[[BigIntData]]) is BigInt.
  ReflectApply$LWS(BigIntProtoValueOf$LWS, bigIntObject$LWS, []) : noop$LWS;
  const serializeBooleanObject$LWS = IS_IN_SHADOW_REALM$LWS ? booleanObject$LWS =>
  // Section 20.3.3 Properties of the Boolean Prototype Object
  // https://tc39.es/ecma262/#thisbooleanvalue
  // Step 2: If Type(value) is Object and value has a [[BooleanData]] internal slot, then
  //     a. Let b be value.[[BooleanData]].
  //     b. Assert: Type(b) is Boolean.
  ReflectApply$LWS(BooleanProtoValueOf$LWS, booleanObject$LWS, []) : noop$LWS;
  const serializeNumberObject$LWS = IS_IN_SHADOW_REALM$LWS ? numberObject$LWS =>
  // 21.1.3 Properties of the Number Prototype Object
  // https://tc39.es/ecma262/#thisnumbervalue
  // Step 2: If Type(value) is Object and value has a [[NumberData]] internal slot, then
  //     a. Let n be value.[[NumberData]].
  //     b. Assert: Type(n) is Number.
  ReflectApply$LWS(NumberProtoValueOf$LWS, numberObject$LWS, []) : noop$LWS;
  const serializeRegExp$LWS = IS_IN_SHADOW_REALM$LWS ? value$LWS => {
    // 22.2.5.12 get RegExp.prototype.source
    // https://tc39.es/ecma262/#sec-get-regexp.prototype.source
    // Step 3: If R does not have an [[OriginalSource]] internal slot, then
    //     a. If SameValue(R, %RegExp.prototype%) is true, return "(?:)".
    //     b. Otherwise, throw a TypeError exception.
    if (value$LWS !== RegExpProto$LWS) {
      const source$LWS = ReflectApply$LWS(RegExpProtoSourceGetter$LWS, value$LWS, []);
      return JSONStringify$LWS({
        __proto__: null,
        flags: ReflectApply$LWS(RegExpProtoFlagsGetter$LWS, value$LWS, []),
        source: source$LWS
      });
    }
    return undefined;
  } : noop$LWS;
  const serializeStringObject$LWS = IS_IN_SHADOW_REALM$LWS ? stringObject$LWS =>
  // 22.1.3 Properties of the String Prototype Object
  // https://tc39.es/ecma262/#thisstringvalue
  // Step 2: If Type(value) is Object and value has a [[StringData]] internal slot, then
  //     a. Let s be value.[[StringData]].
  //     b. Assert: Type(s) is String.
  ReflectApply$LWS(StringProtoValueOf$LWS, stringObject$LWS, []) : noop$LWS;
  const serializeSymbolObject$LWS = IS_IN_SHADOW_REALM$LWS ? symbolObject$LWS =>
  // 20.4.3 Properties of the Symbol Prototype Object
  // https://tc39.es/ecma262/#thissymbolvalue
  // Step 2: If Type(value) is Object and value has a [[SymbolData]] internal slot, then
  //     a. Let s be value.[[SymbolData]].
  //     b. Assert: Type(s) is Symbol.
  ReflectApply$LWS(SymbolProtoValueOf$LWS, symbolObject$LWS, []) : noop$LWS;
  const serializeTargetByBrand$LWS = IS_IN_SHADOW_REALM$LWS ? target$LWS => {
    const brand$LWS = ReflectApply$LWS(ObjectProtoToString$LWS, target$LWS, []);
    switch (brand$LWS) {
      // The brand checks below represent boxed primitives of
      // `ESGlobalKeys` in packages/near-membrane-base/src/intrinsics.ts
      // which are not remapped or reflective.
      case '[object Boolean]':
        return serializeBooleanObject$LWS(target$LWS);
      case '[object Number]':
        return serializeNumberObject$LWS(target$LWS);
      case '[object RegExp]':
        return serializeRegExp$LWS(target$LWS);
      case '[object String]':
        return serializeStringObject$LWS(target$LWS);
      case '[object Object]':
        try {
          // Symbol.prototype[@@toStringTag] is defined by default so
          // must have been removed.
          // https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
          return serializeSymbolObject$LWS(target$LWS);
          // eslint-disable-next-line no-empty
        } catch (_unused6$LWS) {}
        if (SUPPORTS_BIG_INT$LWS) {
          // BigInt.prototype[@@toStringTag] is defined by default so
          // must have been removed.
          // https://tc39.es/ecma262/#sec-bigint.prototype-@@tostringtag
          try {
            return serializeBigIntObject$LWS(target$LWS);
            // eslint-disable-next-line no-empty
          } catch (_unused7$LWS) {}
        }
      // eslint-disable-next-line no-fallthrough
      default:
        return undefined;
    }
  } : noop$LWS;
  const serializeTargetByTrialAndError$LWS = IS_IN_SHADOW_REALM$LWS ? target$LWS => {
    // The serialization attempts below represent boxed primitives of
    // `ESGlobalKeys` in packages/near-membrane-base/src/intrinsics.ts
    // which are not remapped or reflective.
    try {
      // Symbol.prototype[@@toStringTag] is defined by default so
      // attempted before others.
      // https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
      return serializeSymbolObject$LWS(target$LWS);
      // eslint-disable-next-line no-empty
    } catch (_unused8$LWS) {}
    if (SUPPORTS_BIG_INT$LWS) {
      // BigInt.prototype[@@toStringTag] is defined by default so
      // attempted before others.
      // https://tc39.es/ecma262/#sec-bigint.prototype-@@tostringtag
      try {
        return serializeBigIntObject$LWS(target$LWS);
        // eslint-disable-next-line no-empty
      } catch (_unused9$LWS) {}
    }
    try {
      return serializeBooleanObject$LWS(target$LWS);
      // eslint-disable-next-line no-empty
    } catch (_unused10$LWS) {}
    try {
      return serializeNumberObject$LWS(target$LWS);
      // eslint-disable-next-line no-empty
    } catch (_unused11$LWS) {}
    try {
      return serializeRegExp$LWS(target$LWS);
      // eslint-disable-next-line no-empty
    } catch (_unused12$LWS) {}
    try {
      return serializeStringObject$LWS(target$LWS);
      // eslint-disable-next-line no-empty
    } catch (_unused13$LWS) {}
    return undefined;
  } : noop$LWS;
  function toSafeTemplateStringValue$LWS(value$LWS) {
    if (typeof value$LWS === 'string') {
      return value$LWS;
    }
    try {
      if (typeof value$LWS === 'object' && value$LWS !== null) {
        const result$LWS = ReflectApply$LWS(ObjectProtoToString$LWS, value$LWS, []);
        return result$LWS === '[object Symbol]' ? ReflectApply$LWS(SymbolProtoToString$LWS, value$LWS, []) : result$LWS;
      }
      if (typeof value$LWS === 'function') {
        return ReflectApply$LWS(FunctionProtoToString$LWS, value$LWS, []);
      }
      // Attempt to coerce `value` to a string with the String() constructor.
      // Section 22.1.1.1 String ( value )
      // https://tc39.es/ecma262/#sec-string-constructor-string-value
      return StringCtor$LWS(value$LWS);
      // eslint-disable-next-line no-empty
    } catch (_unused14$LWS) {}
    return '[Object Unknown]';
  }
  // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow
  function toSafeWeakMap$LWS(weakMap$LWS) {
    ReflectSetPrototypeOf$LWS(weakMap$LWS, null);
    weakMap$LWS.delete = WeakMapProtoDelete$LWS;
    weakMap$LWS.has = WeakMapProtoHas$LWS;
    weakMap$LWS.set = WeakMapProtoSet$LWS;
    weakMap$LWS[SymbolToStringTag$LWS] = WeakMapProtoSymbolToStringTag$LWS;
    ReflectSetPrototypeOf$LWS(weakMap$LWS, WeakMapProto$LWS);
    return weakMap$LWS;
  }
  function toSafeWeakSet$LWS(weakSet$LWS) {
    ReflectSetPrototypeOf$LWS(weakSet$LWS, null);
    weakSet$LWS.add = WeakSetProtoAdd$LWS;
    weakSet$LWS.delete = WeakSetProtoDelete$LWS;
    weakSet$LWS.has = WeakSetProtoHas$LWS;
    weakSet$LWS[SymbolToStringTag$LWS] = WeakSetProtoSymbolToStringTag$LWS;
    ReflectSetPrototypeOf$LWS(weakSet$LWS, WeakSetProto$LWS);
    return weakSet$LWS;
  }
  return function createHooksCallback$LWS(color$LWS, foreignCallableHooksCallback$LWS, options$LWS) {
    if (IS_IN_SHADOW_REALM$LWS) {
      options$LWS = undefined;
    }
    const {
      distortionCallback: distortionCallback$LWS,
      liveTargetCallback: liveTargetCallback$LWS,
      revokedProxyCallback: revokedProxyCallback$LWS
      // eslint-disable-next-line prefer-object-spread
    } = ObjectAssign$LWS({
      __proto__: null
    }, options$LWS);
    const applyTrapNameRegistry$LWS = {
      // Populated in the returned connector function below.
      __proto__: null,
      0: undefined,
      1: undefined,
      2: undefined,
      3: undefined,
      4: undefined,
      n: undefined
    };
    const constructTrapNameRegistry$LWS = {
      // Populated in the returned connector function below.
      __proto__: null,
      0: undefined,
      1: undefined,
      2: undefined,
      3: undefined,
      4: undefined,
      n: undefined
    };
    const lazyPropertyDescriptorStateCache$LWS = toSafeWeakMap$LWS(new WeakMapCtor$LWS());
    const proxyPointerCache$LWS = toSafeWeakMap$LWS(new WeakMapCtor$LWS());
    let foreignCallablePushErrorTarget$LWS;
    let foreignCallablePushTarget$LWS;
    let foreignCallableApply$LWS;
    let foreignCallableConstruct$LWS;
    let foreignCallableDefineProperty$LWS;
    let foreignCallableDeleteProperty$LWS;
    let foreignCallableGet$LWS;
    let foreignCallableGetOwnPropertyDescriptor$LWS;
    let foreignCallableGetPrototypeOf$LWS;
    let foreignCallableHas$LWS;
    let foreignCallableIsExtensible$LWS;
    let foreignCallableOwnKeys$LWS;
    let foreignCallablePreventExtensions$LWS;
    let foreignCallableSet$LWS;
    let foreignCallableSetPrototypeOf$LWS;
    let foreignCallableDebugInfo$LWS;
    let foreignCallableGetPropertyValue$LWS;
    let foreignCallableGetLazyPropertyDescriptorStateByTarget$LWS;
    let foreignCallableGetTargetIntegrityTraits$LWS;
    let foreignCallableGetToStringTagOfTarget$LWS;
    let foreignCallableInstallErrorPrepareStackTrace$LWS;
    let foreignCallableIsTargetLive$LWS;
    let foreignCallableIsTargetRevoked$LWS;
    let foreignCallableSerializeTarget$LWS;
    let foreignCallableSetLazyPropertyDescriptorStateByTarget$LWS;
    let foreignCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS;
    let foreignCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS;
    let foreignCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS;
    let fastForeignTargetPointers$LWS;
    let foreignPointerBigInt64ArrayProto$LWS;
    let foreignPointerBigUint64ArrayProto$LWS;
    let foreignPointerFloat32ArrayProto$LWS;
    let foreignPointerFloat64ArrayProto$LWS;
    let foreignPointerInt8ArrayProto$LWS;
    let foreignPointerInt16ArrayProto$LWS;
    let foreignPointerInt32ArrayProto$LWS;
    let foreignPointerObjectProto$LWS;
    let foreignPointerTypedArrayProto$LWS;
    let foreignPointerUint8ArrayProto$LWS;
    let foreignPointerUint16ArrayProto$LWS;
    let foreignPointerUint32ArrayProto$LWS;
    let selectedTarget$LWS;
    let lastProxyTrapCalled$LWS = 0 /* ProxyHandlerTraps.None */;
    let handshakePropertyFlag$LWS = false;
    let useFastForeignTargetPath$LWS = IS_IN_SHADOW_REALM$LWS;
    let useFastForeignTargetPathForTypedArrays$LWS = IS_IN_SHADOW_REALM$LWS;
    const activateLazyOwnPropertyDefinition$LWS = IS_IN_SHADOW_REALM$LWS ? (target$LWS, key$LWS, state$LWS) => {
      state$LWS[key$LWS] = false;
      const foreignTargetPointer$LWS = getTransferablePointer$LWS(target$LWS);
      let safeDesc$LWS;
      try {
        foreignCallableGetOwnPropertyDescriptor$LWS(foreignTargetPointer$LWS, key$LWS, (_key$LWS, configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS) => {
          safeDesc$LWS = createDescriptorFromMeta$LWS(configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS);
        });
      } catch (error) {
        var _selectedTarget$LWS;
        const errorToThrow$LWS = (_selectedTarget$LWS = selectedTarget$LWS) != null ? _selectedTarget$LWS : error;
        selectedTarget$LWS = undefined;
        throw errorToThrow$LWS;
      }
      if (safeDesc$LWS) {
        ReflectDefineProperty$LWS(target$LWS, key$LWS, safeDesc$LWS);
      } else {
        ReflectDeleteProperty$LWS(target$LWS, key$LWS);
      }
    } : noop$LWS;
    let checkDebugMode$LWS = LOCKER_DEBUGGABLE_FLAG$LWS ? () => {
      try {
        if (ObjectHasOwn$LWS(globalThisRef$LWS, LOCKER_DEBUG_MODE_SYMBOL$LWS)) {
          checkDebugMode$LWS = () => true;
          installErrorPrepareStackTrace$LWS();
          foreignCallableInstallErrorPrepareStackTrace$LWS();
        }
      } catch (_unused15$LWS) {
        checkDebugMode$LWS = alwaysFalse$LWS;
      }
      return false;
    } : alwaysFalse$LWS;
    const clearFastForeignTargetPointers$LWS = IS_IN_SHADOW_REALM$LWS ? () => {
      fastForeignTargetPointers$LWS = toSafeWeakSet$LWS(new WeakSetCtor$LWS());
    } : noop$LWS;
    function copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget$LWS(foreignTargetPointer$LWS, shadowTarget$LWS) {
      let protoPointerOrNull$LWS;
      try {
        protoPointerOrNull$LWS = foreignCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS(foreignTargetPointer$LWS, (...descriptorTuples$LWS) => {
          const descriptors$LWS = {};
          for (let i$LWS = 0, {
              length: length$LWS
            } = descriptorTuples$LWS; i$LWS < length$LWS; i$LWS += 7) {
            const key$LWS = descriptorTuples$LWS[i$LWS];
            descriptors$LWS[key$LWS] = createDescriptorFromMeta$LWS(descriptorTuples$LWS[i$LWS + 1],
            // configurable
            descriptorTuples$LWS[i$LWS + 2],
            // enumerable
            descriptorTuples$LWS[i$LWS + 3],
            // writable
            descriptorTuples$LWS[i$LWS + 4],
            // valuePointer
            descriptorTuples$LWS[i$LWS + 5],
            // getterPointer
            descriptorTuples$LWS[i$LWS + 6] // setterPointer
            );
          }
          // Use `ObjectDefineProperties()` instead of individual
          // `ReflectDefineProperty()` calls for better performance.
          ObjectDefineProperties$LWS(shadowTarget$LWS, descriptors$LWS);
        });
      } catch (error) {
        var _selectedTarget2$LWS;
        const errorToThrow$LWS = (_selectedTarget2$LWS = selectedTarget$LWS) != null ? _selectedTarget2$LWS : error;
        selectedTarget$LWS = undefined;
        throw errorToThrow$LWS;
      }
      let proto$LWS;
      if (typeof protoPointerOrNull$LWS === 'function') {
        protoPointerOrNull$LWS();
        proto$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
      } else {
        proto$LWS = null;
      }
      ReflectSetPrototypeOf$LWS(shadowTarget$LWS, proto$LWS);
    }
    function createApplyOrConstructTrapForZeroOrMoreArgs$LWS(proxyTrapEnum$LWS) {
      const isApplyTrap$LWS = proxyTrapEnum$LWS & 1 /* ProxyHandlerTraps.Apply */;
      const arityToApplyOrConstructTrapNameRegistry$LWS = isApplyTrap$LWS ? applyTrapNameRegistry$LWS : constructTrapNameRegistry$LWS;
      const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
      return function applyOrConstructTrap$LWS(_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
        lastProxyTrapCalled$LWS = proxyTrapEnum$LWS;
        const args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
        const {
          length: length$LWS
        } = args$LWS;
        if (length$LWS !== 0) {
          var _arityToApplyOrConstr$LWS;
          return this[(_arityToApplyOrConstr$LWS = arityToApplyOrConstructTrapNameRegistry$LWS[length$LWS]) != null ? _arityToApplyOrConstr$LWS : arityToApplyOrConstructTrapNameRegistry$LWS.n](_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS);
        }
        // @ts-ignore: Prevent private property access error.
        const {
          foreignTargetPointer: foreignTargetPointer$LWS
        } = this;
        const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
        let pointerOrPrimitive$LWS;
        try {
          pointerOrPrimitive$LWS = foreignCallableApplyOrConstruct$LWS(foreignTargetPointer$LWS,
          // Inline getTransferableValue().
          typeof thisArgOrNewTarget$LWS === 'object' && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === 'function' ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof thisArgOrNewTarget$LWS === 'undefined' ? undefined : thisArgOrNewTarget$LWS);
        } catch (error) {
          var _selectedTarget3$LWS;
          const errorToThrow$LWS = (_selectedTarget3$LWS = selectedTarget$LWS) != null ? _selectedTarget3$LWS : error;
          selectedTarget$LWS = undefined;
          throw errorToThrow$LWS;
        }
        let result$LWS;
        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          result$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          result$LWS = pointerOrPrimitive$LWS;
        }
        return result$LWS;
      };
    }
    function createApplyOrConstructTrapForOneOrMoreArgs$LWS(proxyTrapEnum$LWS) {
      const isApplyTrap$LWS = proxyTrapEnum$LWS & 1 /* ProxyHandlerTraps.Apply */;
      const arityToApplyOrConstructTrapNameRegistry$LWS = isApplyTrap$LWS ? applyTrapNameRegistry$LWS : constructTrapNameRegistry$LWS;
      const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
      return function applyOrConstructTrapForOneOrMoreArgs$LWS(_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
        lastProxyTrapCalled$LWS = proxyTrapEnum$LWS;
        const args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
        const {
          length: length$LWS
        } = args$LWS;
        if (length$LWS !== 1) {
          var _arityToApplyOrConstr2$LWS;
          return this[(_arityToApplyOrConstr2$LWS = arityToApplyOrConstructTrapNameRegistry$LWS[length$LWS]) != null ? _arityToApplyOrConstr2$LWS : arityToApplyOrConstructTrapNameRegistry$LWS.n](_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS);
        }
        // @ts-ignore: Prevent private property access error.
        const {
          foreignTargetPointer: foreignTargetPointer$LWS
        } = this;
        const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
        let pointerOrPrimitive$LWS;
        try {
          const {
            0: arg0$LWS
          } = args$LWS;
          pointerOrPrimitive$LWS = foreignCallableApplyOrConstruct$LWS(foreignTargetPointer$LWS,
          // Inline getTransferableValue().
          typeof thisArgOrNewTarget$LWS === 'object' && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === 'function' ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof thisArgOrNewTarget$LWS === 'undefined' ? undefined : thisArgOrNewTarget$LWS,
          // Inline getTransferableValue().
          typeof arg0$LWS === 'object' && arg0$LWS !== null || typeof arg0$LWS === 'function' ? getTransferablePointer$LWS(arg0$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg0$LWS === 'undefined' ? undefined : arg0$LWS);
        } catch (error) {
          var _selectedTarget4$LWS;
          const errorToThrow$LWS = (_selectedTarget4$LWS = selectedTarget$LWS) != null ? _selectedTarget4$LWS : error;
          selectedTarget$LWS = undefined;
          throw errorToThrow$LWS;
        }
        let result$LWS;
        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          result$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          result$LWS = pointerOrPrimitive$LWS;
        }
        return result$LWS;
      };
    }
    function createApplyOrConstructTrapForTwoOrMoreArgs$LWS(proxyTrapEnum$LWS) {
      const isApplyTrap$LWS = proxyTrapEnum$LWS & 1 /* ProxyHandlerTraps.Apply */;
      const arityToApplyOrConstructTrapNameRegistry$LWS = isApplyTrap$LWS ? applyTrapNameRegistry$LWS : constructTrapNameRegistry$LWS;
      const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
      return function applyOrConstructTrapForTwoOrMoreArgs$LWS(_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
        lastProxyTrapCalled$LWS = proxyTrapEnum$LWS;
        const args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
        const {
          length: length$LWS
        } = args$LWS;
        if (length$LWS !== 2) {
          var _arityToApplyOrConstr3$LWS;
          return this[(_arityToApplyOrConstr3$LWS = arityToApplyOrConstructTrapNameRegistry$LWS[length$LWS]) != null ? _arityToApplyOrConstr3$LWS : arityToApplyOrConstructTrapNameRegistry$LWS.n](_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS);
        }
        // @ts-ignore: Prevent private property access error.
        const {
          foreignTargetPointer: foreignTargetPointer$LWS
        } = this;
        const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
        let pointerOrPrimitive$LWS;
        try {
          const {
            0: arg0$LWS,
            1: arg1$LWS
          } = args$LWS;
          pointerOrPrimitive$LWS = foreignCallableApplyOrConstruct$LWS(foreignTargetPointer$LWS,
          // Inline getTransferableValue().
          typeof thisArgOrNewTarget$LWS === 'object' && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === 'function' ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof thisArgOrNewTarget$LWS === 'undefined' ? undefined : thisArgOrNewTarget$LWS,
          // Inline getTransferableValue().
          typeof arg0$LWS === 'object' && arg0$LWS !== null || typeof arg0$LWS === 'function' ? getTransferablePointer$LWS(arg0$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg0$LWS === 'undefined' ? undefined : arg0$LWS,
          // Inline getTransferableValue().
          typeof arg1$LWS === 'object' && arg1$LWS !== null || typeof arg1$LWS === 'function' ? getTransferablePointer$LWS(arg1$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg1$LWS === 'undefined' ? undefined : arg1$LWS);
        } catch (error) {
          var _selectedTarget5$LWS;
          const errorToThrow$LWS = (_selectedTarget5$LWS = selectedTarget$LWS) != null ? _selectedTarget5$LWS : error;
          selectedTarget$LWS = undefined;
          throw errorToThrow$LWS;
        }
        let result$LWS;
        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          result$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          result$LWS = pointerOrPrimitive$LWS;
        }
        return result$LWS;
      };
    }
    function createApplyOrConstructTrapForThreeOrMoreArgs$LWS(proxyTrapEnum$LWS) {
      const isApplyTrap$LWS = proxyTrapEnum$LWS & 1 /* ProxyHandlerTraps.Apply */;
      const arityToApplyOrConstructTrapNameRegistry$LWS = isApplyTrap$LWS ? applyTrapNameRegistry$LWS : constructTrapNameRegistry$LWS;
      const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
      return function applyOrConstructTrapForTwoOrMoreArgs$LWS(_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
        lastProxyTrapCalled$LWS = proxyTrapEnum$LWS;
        const args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
        const {
          length: length$LWS
        } = args$LWS;
        if (length$LWS !== 3) {
          var _arityToApplyOrConstr4$LWS;
          return this[(_arityToApplyOrConstr4$LWS = arityToApplyOrConstructTrapNameRegistry$LWS[length$LWS]) != null ? _arityToApplyOrConstr4$LWS : arityToApplyOrConstructTrapNameRegistry$LWS.n](_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS);
        }
        // @ts-ignore: Prevent private property access error.
        const {
          foreignTargetPointer: foreignTargetPointer$LWS
        } = this;
        const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
        let pointerOrPrimitive$LWS;
        try {
          const {
            0: arg0$LWS,
            1: arg1$LWS,
            2: arg2$LWS
          } = args$LWS;
          pointerOrPrimitive$LWS = foreignCallableApplyOrConstruct$LWS(foreignTargetPointer$LWS,
          // Inline getTransferableValue().
          typeof thisArgOrNewTarget$LWS === 'object' && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === 'function' ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof thisArgOrNewTarget$LWS === 'undefined' ? undefined : thisArgOrNewTarget$LWS,
          // Inline getTransferableValue().
          typeof arg0$LWS === 'object' && arg0$LWS !== null || typeof arg0$LWS === 'function' ? getTransferablePointer$LWS(arg0$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg0$LWS === 'undefined' ? undefined : arg0$LWS,
          // Inline getTransferableValue().
          typeof arg1$LWS === 'object' && arg1$LWS !== null || typeof arg1$LWS === 'function' ? getTransferablePointer$LWS(arg1$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg1$LWS === 'undefined' ? undefined : arg1$LWS,
          // Inline getTransferableValue().
          typeof arg2$LWS === 'object' && arg2$LWS !== null || typeof arg2$LWS === 'function' ? getTransferablePointer$LWS(arg2$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg2$LWS === 'undefined' ? undefined : arg2$LWS);
        } catch (error) {
          var _selectedTarget6$LWS;
          const errorToThrow$LWS = (_selectedTarget6$LWS = selectedTarget$LWS) != null ? _selectedTarget6$LWS : error;
          selectedTarget$LWS = undefined;
          throw errorToThrow$LWS;
        }
        let result$LWS;
        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          result$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          result$LWS = pointerOrPrimitive$LWS;
        }
        return result$LWS;
      };
    }
    function createApplyOrConstructTrapForFourOrMoreArgs$LWS(proxyTrapEnum$LWS) {
      const isApplyTrap$LWS = proxyTrapEnum$LWS & 1 /* ProxyHandlerTraps.Apply */;
      const arityToApplyOrConstructTrapNameRegistry$LWS = isApplyTrap$LWS ? applyTrapNameRegistry$LWS : constructTrapNameRegistry$LWS;
      const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
      return function applyOrConstructTrapForTwoOrMoreArgs$LWS(_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
        lastProxyTrapCalled$LWS = proxyTrapEnum$LWS;
        const args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
        const {
          length: length$LWS
        } = args$LWS;
        if (length$LWS !== 4) {
          var _arityToApplyOrConstr5$LWS;
          return this[(_arityToApplyOrConstr5$LWS = arityToApplyOrConstructTrapNameRegistry$LWS[length$LWS]) != null ? _arityToApplyOrConstr5$LWS : arityToApplyOrConstructTrapNameRegistry$LWS.n](_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS);
        }
        // @ts-ignore: Prevent private property access error.
        const {
          foreignTargetPointer: foreignTargetPointer$LWS
        } = this;
        const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
        let pointerOrPrimitive$LWS;
        try {
          const {
            0: arg0$LWS,
            1: arg1$LWS,
            2: arg2$LWS,
            3: arg3$LWS
          } = args$LWS;
          pointerOrPrimitive$LWS = foreignCallableApplyOrConstruct$LWS(foreignTargetPointer$LWS,
          // Inline getTransferableValue().
          typeof thisArgOrNewTarget$LWS === 'object' && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === 'function' ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof thisArgOrNewTarget$LWS === 'undefined' ? undefined : thisArgOrNewTarget$LWS,
          // Inline getTransferableValue().
          typeof arg0$LWS === 'object' && arg0$LWS !== null || typeof arg0$LWS === 'function' ? getTransferablePointer$LWS(arg0$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg0$LWS === 'undefined' ? undefined : arg0$LWS,
          // Inline getTransferableValue().
          typeof arg1$LWS === 'object' && arg1$LWS !== null || typeof arg1$LWS === 'function' ? getTransferablePointer$LWS(arg1$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg1$LWS === 'undefined' ? undefined : arg1$LWS,
          // Inline getTransferableValue().
          typeof arg2$LWS === 'object' && arg2$LWS !== null || typeof arg2$LWS === 'function' ? getTransferablePointer$LWS(arg2$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg2$LWS === 'undefined' ? undefined : arg2$LWS,
          // Inline getTransferableValue().
          typeof arg3$LWS === 'object' && arg3$LWS !== null || typeof arg3$LWS === 'function' ? getTransferablePointer$LWS(arg3$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg3$LWS === 'undefined' ? undefined : arg3$LWS);
        } catch (error) {
          var _selectedTarget7$LWS;
          const errorToThrow$LWS = (_selectedTarget7$LWS = selectedTarget$LWS) != null ? _selectedTarget7$LWS : error;
          selectedTarget$LWS = undefined;
          throw errorToThrow$LWS;
        }
        let result$LWS;
        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          result$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          result$LWS = pointerOrPrimitive$LWS;
        }
        return result$LWS;
      };
    }
    function createApplyOrConstructTrapForFiveOrMoreArgs$LWS(proxyTrapEnum$LWS) {
      const isApplyTrap$LWS = proxyTrapEnum$LWS & 1 /* ProxyHandlerTraps.Apply */;
      const arityToApplyOrConstructTrapNameRegistry$LWS = isApplyTrap$LWS ? applyTrapNameRegistry$LWS : constructTrapNameRegistry$LWS;
      const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
      return function applyOrConstructTrapForTwoOrMoreArgs$LWS(_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
        lastProxyTrapCalled$LWS = proxyTrapEnum$LWS;
        const args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
        const {
          length: length$LWS
        } = args$LWS;
        if (length$LWS !== 5) {
          var _arityToApplyOrConstr6$LWS;
          return this[(_arityToApplyOrConstr6$LWS = arityToApplyOrConstructTrapNameRegistry$LWS[length$LWS]) != null ? _arityToApplyOrConstr6$LWS : arityToApplyOrConstructTrapNameRegistry$LWS.n](_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS);
        }
        // @ts-ignore: Prevent private property access error.
        const {
          foreignTargetPointer: foreignTargetPointer$LWS
        } = this;
        const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
        let pointerOrPrimitive$LWS;
        try {
          const {
            0: arg0$LWS,
            1: arg1$LWS,
            2: arg2$LWS,
            3: arg3$LWS,
            4: arg4$LWS
          } = args$LWS;
          pointerOrPrimitive$LWS = foreignCallableApplyOrConstruct$LWS(foreignTargetPointer$LWS,
          // Inline getTransferableValue().
          typeof thisArgOrNewTarget$LWS === 'object' && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === 'function' ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof thisArgOrNewTarget$LWS === 'undefined' ? undefined : thisArgOrNewTarget$LWS,
          // Inline getTransferableValue().
          typeof arg0$LWS === 'object' && arg0$LWS !== null || typeof arg0$LWS === 'function' ? getTransferablePointer$LWS(arg0$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg0$LWS === 'undefined' ? undefined : arg0$LWS,
          // Inline getTransferableValue().
          typeof arg1$LWS === 'object' && arg1$LWS !== null || typeof arg1$LWS === 'function' ? getTransferablePointer$LWS(arg1$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg1$LWS === 'undefined' ? undefined : arg1$LWS,
          // Inline getTransferableValue().
          typeof arg2$LWS === 'object' && arg2$LWS !== null || typeof arg2$LWS === 'function' ? getTransferablePointer$LWS(arg2$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg2$LWS === 'undefined' ? undefined : arg2$LWS,
          // Inline getTransferableValue().
          typeof arg3$LWS === 'object' && arg3$LWS !== null || typeof arg3$LWS === 'function' ? getTransferablePointer$LWS(arg3$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg3$LWS === 'undefined' ? undefined : arg3$LWS,
          // Inline getTransferableValue().
          typeof arg4$LWS === 'object' && arg4$LWS !== null || typeof arg4$LWS === 'function' ? getTransferablePointer$LWS(arg4$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof arg4$LWS === 'undefined' ? undefined : arg4$LWS);
        } catch (error) {
          var _selectedTarget8$LWS;
          const errorToThrow$LWS = (_selectedTarget8$LWS = selectedTarget$LWS) != null ? _selectedTarget8$LWS : error;
          selectedTarget$LWS = undefined;
          throw errorToThrow$LWS;
        }
        let result$LWS;
        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          result$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          result$LWS = pointerOrPrimitive$LWS;
        }
        return result$LWS;
      };
    }
    function createApplyOrConstructTrapForAnyNumberOfArgs$LWS(proxyTrapEnum$LWS) {
      const isApplyTrap$LWS = proxyTrapEnum$LWS & 1 /* ProxyHandlerTraps.Apply */;
      const foreignCallableApplyOrConstruct$LWS = isApplyTrap$LWS ? foreignCallableApply$LWS : foreignCallableConstruct$LWS;
      return function applyOrConstructTrapForAnyNumberOfArgs$LWS(_shadowTarget$LWS, thisArgOrArgs$LWS, argsOrNewTarget$LWS) {
        lastProxyTrapCalled$LWS = proxyTrapEnum$LWS;
        // @ts-ignore: Prevent private property access error.
        const {
          foreignTargetPointer: foreignTargetPointer$LWS
        } = this;
        const args$LWS = isApplyTrap$LWS ? argsOrNewTarget$LWS : thisArgOrArgs$LWS;
        const {
          length: length$LWS
        } = args$LWS;
        const thisArgOrNewTarget$LWS = isApplyTrap$LWS ? thisArgOrArgs$LWS : argsOrNewTarget$LWS;
        let combinedOffset$LWS = 2;
        const combinedArgs$LWS = new ArrayCtor$LWS(length$LWS + combinedOffset$LWS);
        combinedArgs$LWS[0] = foreignTargetPointer$LWS;
        let pointerOrPrimitive$LWS;
        try {
          combinedArgs$LWS[1] = typeof thisArgOrNewTarget$LWS === 'object' && thisArgOrNewTarget$LWS !== null || typeof thisArgOrNewTarget$LWS === 'function' ? getTransferablePointer$LWS(thisArgOrNewTarget$LWS) :
          // Intentionally ignoring `document.all`.
          // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
          // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
          typeof thisArgOrNewTarget$LWS === 'undefined' ? undefined : thisArgOrNewTarget$LWS;
          for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
            const arg$LWS = args$LWS[i$LWS];
            // Inlining `getTransferableValue()`.
            combinedArgs$LWS[combinedOffset$LWS++] = typeof arg$LWS === 'object' && arg$LWS !== null || typeof arg$LWS === 'function' ? getTransferablePointer$LWS(arg$LWS) :
            // Intentionally ignoring `document.all`.
            // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
            // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
            typeof arg$LWS === 'undefined' ? undefined : arg$LWS;
          }
          pointerOrPrimitive$LWS = ReflectApply$LWS(foreignCallableApplyOrConstruct$LWS, undefined, combinedArgs$LWS);
        } catch (error) {
          var _selectedTarget9$LWS;
          const errorToThrow$LWS = (_selectedTarget9$LWS = selectedTarget$LWS) != null ? _selectedTarget9$LWS : error;
          selectedTarget$LWS = undefined;
          throw errorToThrow$LWS;
        }
        let result$LWS;
        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          result$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          result$LWS = pointerOrPrimitive$LWS;
        }
        return result$LWS;
      };
    }
    function createDescriptorFromMeta$LWS(configurable$LWS, enumerable$LWS, writable$LWS, valuePointerOrPrimitive$LWS, getterPointerOrPrimitive$LWS, setterPointerOrPrimitive$LWS) {
      const safeDesc$LWS = {
        __proto__: null
      };
      if (configurable$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
        safeDesc$LWS.configurable = configurable$LWS;
      }
      if (enumerable$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
        safeDesc$LWS.enumerable = enumerable$LWS;
      }
      if (writable$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
        safeDesc$LWS.writable = writable$LWS;
      }
      if (getterPointerOrPrimitive$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
        if (typeof getterPointerOrPrimitive$LWS === 'function') {
          getterPointerOrPrimitive$LWS();
          safeDesc$LWS.get = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          safeDesc$LWS.get = undefined;
        }
      }
      if (setterPointerOrPrimitive$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
        if (typeof setterPointerOrPrimitive$LWS === 'function') {
          setterPointerOrPrimitive$LWS();
          safeDesc$LWS.set = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          safeDesc$LWS.set = undefined;
        }
      }
      if (valuePointerOrPrimitive$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
        if (typeof valuePointerOrPrimitive$LWS === 'function') {
          valuePointerOrPrimitive$LWS();
          safeDesc$LWS.value = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          safeDesc$LWS.value = valuePointerOrPrimitive$LWS;
        }
      }
      return safeDesc$LWS;
    }
    function createPointer$LWS(originalTarget$LWS) {
      const pointer$LWS = () => {
        // assert: selectedTarget is undefined
        selectedTarget$LWS = originalTarget$LWS;
      };
      return pointer$LWS;
    }
    const disableFastForeignTargetPointers$LWS = IS_IN_SHADOW_REALM$LWS ? () => {
      useFastForeignTargetPath$LWS = false;
      useFastForeignTargetPathForTypedArrays$LWS = false;
      clearFastForeignTargetPointers$LWS();
    } : noop$LWS;
    const getLazyPropertyDescriptorStateByTarget$LWS = IS_IN_SHADOW_REALM$LWS ? target$LWS => {
      let state$LWS = lazyPropertyDescriptorStateCache$LWS.get(target$LWS);
      if (state$LWS === undefined) {
        const statePointerOrUndefined$LWS = foreignCallableGetLazyPropertyDescriptorStateByTarget$LWS(getTransferablePointer$LWS(target$LWS));
        if (typeof statePointerOrUndefined$LWS === 'function') {
          statePointerOrUndefined$LWS();
          state$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
          if (state$LWS) {
            lazyPropertyDescriptorStateCache$LWS.set(target$LWS, state$LWS);
          }
        }
      }
      return state$LWS;
    } : noop$LWS;
    const isForeignPointerOfObjectProto$LWS = IS_IN_SHADOW_REALM$LWS ?
    // eslint-disable-next-line no-return-assign
    foreignTargetPointer$LWS => foreignTargetPointer$LWS === (foreignPointerObjectProto$LWS === undefined ? foreignPointerObjectProto$LWS = getTransferablePointer$LWS(ObjectProto$LWS) : foreignPointerObjectProto$LWS) : alwaysFalse$LWS;
    const isForeignPointerOfTypedArrayProto$LWS = IS_IN_SHADOW_REALM$LWS ?
    // eslint-disable-next-line no-return-assign
    foreignTargetPointer$LWS => foreignTargetPointer$LWS === (foreignPointerFloat32ArrayProto$LWS === undefined ? foreignPointerFloat32ArrayProto$LWS = getTransferablePointer$LWS(Float32ArrayProto$LWS) : foreignPointerFloat32ArrayProto$LWS) || foreignTargetPointer$LWS === (foreignPointerFloat64ArrayProto$LWS === undefined ? foreignPointerFloat64ArrayProto$LWS = getTransferablePointer$LWS(Float64ArrayProto$LWS) : foreignPointerFloat64ArrayProto$LWS) || foreignTargetPointer$LWS === (foreignPointerInt8ArrayProto$LWS === undefined ? foreignPointerInt8ArrayProto$LWS = getTransferablePointer$LWS(Int8ArrayProto$LWS) : foreignPointerInt8ArrayProto$LWS) || foreignTargetPointer$LWS === (foreignPointerInt16ArrayProto$LWS === undefined ? foreignPointerInt16ArrayProto$LWS = getTransferablePointer$LWS(Int16ArrayProto$LWS) : foreignPointerInt16ArrayProto$LWS) || foreignTargetPointer$LWS === (foreignPointerInt32ArrayProto$LWS === undefined ? foreignPointerInt32ArrayProto$LWS = getTransferablePointer$LWS(Int32ArrayProto$LWS) : foreignPointerInt32ArrayProto$LWS) || foreignTargetPointer$LWS === (foreignPointerUint8ArrayProto$LWS === undefined ? foreignPointerUint8ArrayProto$LWS = getTransferablePointer$LWS(Uint8ArrayProto$LWS) : foreignPointerUint8ArrayProto$LWS) || foreignTargetPointer$LWS === (foreignPointerUint16ArrayProto$LWS === undefined ? foreignPointerUint16ArrayProto$LWS = getTransferablePointer$LWS(Uint16ArrayProto$LWS) : foreignPointerUint16ArrayProto$LWS) || foreignTargetPointer$LWS === (foreignPointerUint32ArrayProto$LWS === undefined ? foreignPointerUint32ArrayProto$LWS = getTransferablePointer$LWS(Uint32ArrayProto$LWS) : foreignPointerUint32ArrayProto$LWS) || foreignTargetPointer$LWS === (foreignPointerTypedArrayProto$LWS === undefined ? foreignPointerTypedArrayProto$LWS = getTransferablePointer$LWS(TypedArrayProto$LWS) : foreignPointerTypedArrayProto$LWS) || foreignTargetPointer$LWS === (foreignPointerBigInt64ArrayProto$LWS === undefined ? foreignPointerBigInt64ArrayProto$LWS = BigInt64ArrayProto$LWS ? getTransferablePointer$LWS(BigInt64ArrayProto$LWS) : noop$LWS : foreignPointerBigInt64ArrayProto$LWS) || foreignTargetPointer$LWS === (foreignPointerBigUint64ArrayProto$LWS === undefined ? foreignPointerBigUint64ArrayProto$LWS = BigUint64ArrayProto$LWS ? getTransferablePointer$LWS(BigUint64ArrayProto$LWS) : noop$LWS : foreignPointerBigUint64ArrayProto$LWS) : alwaysFalse$LWS;
    function getTransferablePointer$LWS(originalTarget$LWS, foreignCallablePusher$LWS = foreignCallablePushTarget$LWS) {
      let proxyPointer$LWS = proxyPointerCache$LWS.get(originalTarget$LWS);
      if (proxyPointer$LWS) {
        return proxyPointer$LWS;
      }
      let targetFunctionArity$LWS = 0;
      let targetFunctionName$LWS = '';
      let targetTypedArrayLength$LWS = 0;
      if (revokedProxyCallback$LWS && revokedProxyCallback$LWS(originalTarget$LWS)) {
        proxyPointer$LWS = foreignCallablePusher$LWS(createPointer$LWS(originalTarget$LWS), 64 /* TargetTraits.Revoked */, targetFunctionArity$LWS, targetFunctionName$LWS, targetTypedArrayLength$LWS);
        proxyPointerCache$LWS.set(originalTarget$LWS, proxyPointer$LWS);
        return proxyPointer$LWS;
      }
      let distortionTarget$LWS;
      let targetTraits$LWS = 16 /* TargetTraits.IsObject */;
      if (distortionCallback$LWS) {
        distortionTarget$LWS = distortionCallback$LWS(originalTarget$LWS);
        // If a distortion entry is found, it must be a valid proxy target.
        if (distortionTarget$LWS !== originalTarget$LWS && typeof distortionTarget$LWS !== typeof originalTarget$LWS) {
          throw new TypeErrorCtor$LWS(`Invalid distortion ${toSafeTemplateStringValue$LWS(originalTarget$LWS)}.`);
        }
      } else {
        distortionTarget$LWS = originalTarget$LWS;
      }
      let isPossiblyRevoked$LWS = true;
      if (typeof distortionTarget$LWS === 'function') {
        isPossiblyRevoked$LWS = false;
        targetFunctionArity$LWS = 0;
        targetTraits$LWS = 4 /* TargetTraits.IsFunction */;
        try {
          // Detect arrow functions.
          if (!('prototype' in distortionTarget$LWS)) {
            targetTraits$LWS |= 8 /* TargetTraits.IsArrowFunction */;
          }
          const safeLengthDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(originalTarget$LWS, 'length');
          if (safeLengthDesc$LWS) {
            ReflectSetPrototypeOf$LWS(safeLengthDesc$LWS, null);
            const {
              value: safeLengthDescValue$LWS
            } = safeLengthDesc$LWS;
            if (typeof safeLengthDescValue$LWS === 'number') {
              targetFunctionArity$LWS = safeLengthDescValue$LWS;
            }
          }
          const safeNameDesc$LWS = false ? ReflectGetOwnPropertyDescriptor$LWS(originalTarget$LWS, 'name') : undefined;
          if (safeNameDesc$LWS) ;
        } catch (_unused16$LWS) {
          isPossiblyRevoked$LWS = true;
        }
      } else if (ArrayBufferIsView$LWS(distortionTarget$LWS)) {
        isPossiblyRevoked$LWS = false;
        targetTraits$LWS = 2 /* TargetTraits.IsArrayBufferView */;
        try {
          targetTypedArrayLength$LWS = ReflectApply$LWS(TypedArrayProtoLengthGetter$LWS, distortionTarget$LWS, []);
          targetTraits$LWS |= 32 /* TargetTraits.IsTypedArray */;
          // eslint-disable-next-line no-empty
        } catch (_unused17$LWS) {
          // Could be a DataView object or a revoked proxy.
          isPossiblyRevoked$LWS = true;
        }
      }
      if (isPossiblyRevoked$LWS) {
        try {
          if (isArrayOrThrowForRevoked$LWS(distortionTarget$LWS)) {
            targetTraits$LWS = 1 /* TargetTraits.IsArray */;
          }
        } catch (_unused18$LWS) {
          targetTraits$LWS = 64 /* TargetTraits.Revoked */;
        }
      }
      proxyPointer$LWS = foreignCallablePusher$LWS(createPointer$LWS(distortionTarget$LWS), targetTraits$LWS, targetFunctionArity$LWS, targetFunctionName$LWS, targetTypedArrayLength$LWS);
      proxyPointerCache$LWS.set(originalTarget$LWS, proxyPointer$LWS);
      return proxyPointer$LWS;
    }
    const installPropertyDescriptorMethodWrappers$LWS = IS_IN_SHADOW_REALM$LWS ? unforgeableGlobalThisKeys$LWS => {
      if (installedPropertyDescriptorMethodWrappersFlag$LWS) {
        return;
      }
      installedPropertyDescriptorMethodWrappersFlag$LWS = true;
      // We wrap property descriptor methods to activate lazy
      // descriptors and/or workaround browser bugs. The following
      // methods are wrapped:
      //   Object.getOwnPropertyDescriptors()
      //   Object.getOwnPropertyDescriptor()
      //   Reflect.defineProperty()
      //   Reflect.getOwnPropertyDescriptor()
      //   Object.prototype.__defineGetter__()
      //   Object.prototype.__defineSetter__()
      //   Object.prototype.__lookupGetter__()
      //   Object.prototype.__lookupSetter__()
      //
      // Chromium based browsers have a bug that nulls the result
      // of `window` getters in detached iframes when the property
      // descriptor of `window.window` is retrieved.
      // https://bugs.chromium.org/p/chromium/issues/detail?id=1305302
      //
      // Methods may be poisoned when they interact with the `window`
      // object and retrieve property descriptors, like 'window',
      // that contain the `window` object itself. The following
      // built-in methods are susceptible to this issue:
      //     console.log(window);
      //     Object.getOwnPropertyDescriptors(window);
      //     Object.getOwnPropertyDescriptor(window, 'window');
      //     Reflect.getOwnPropertyDescriptor(window, 'window');
      //     window.__lookupGetter__('window');
      //     window.__lookupSetter__('window');
      //
      // We side step issues with `console` by mapping it to the
      // primary realm's `console`. Since we're already wrapping
      // property descriptor methods to activate lazy descriptors
      // we use the wrapper to workaround the `window` getter
      // nulling bug.
      const shouldFixChromeBug$LWS = isArrayOrThrowForRevoked$LWS(unforgeableGlobalThisKeys$LWS) && unforgeableGlobalThisKeys$LWS.length > 0;
      // Lazily populated by `getUnforgeableGlobalThisGetter()`;
      const keyToGlobalThisGetterRegistry$LWS = shouldFixChromeBug$LWS ? {
        __proto__: null
      } : undefined;
      const getFixedDescriptor$LWS = shouldFixChromeBug$LWS ? (target$LWS, key$LWS) => ReflectApply$LWS(ArrayProtoIncludes$LWS, unforgeableGlobalThisKeys$LWS, [key$LWS]) ? {
        configurable: false,
        enumerable: ReflectApply$LWS(ObjectProtoPropertyIsEnumerable$LWS, target$LWS, [key$LWS]),
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        get: getUnforgeableGlobalThisGetter$LWS(key$LWS),
        set: undefined
      } : ReflectGetOwnPropertyDescriptor$LWS(target$LWS, key$LWS) : undefined;
      const getUnforgeableGlobalThisGetter$LWS = shouldFixChromeBug$LWS ? key$LWS => {
        let globalThisGetter$LWS = keyToGlobalThisGetterRegistry$LWS[key$LWS];
        if (globalThisGetter$LWS === undefined) {
          // We can't access the original getter to mask
          // with `proxyMaskFunction()`, so instead we wrap
          // `unboundGlobalThisGetter` in bound function
          // to obscure the getter source as "[native code]".
          globalThisGetter$LWS = ReflectApply$LWS(FunctionProtoBind$LWS,
          // eslint-disable-next-line @typescript-eslint/no-use-before-define
          unboundGlobalThisGetter$LWS, []);
          // Preserve identity continuity of getters.
          keyToGlobalThisGetterRegistry$LWS[key$LWS] = globalThisGetter$LWS;
        }
        return globalThisGetter$LWS;
      } : undefined;
      const lookupFixedGetter$LWS = shouldFixChromeBug$LWS ? (target$LWS, key$LWS) => ReflectApply$LWS(ArrayProtoIncludes$LWS, unforgeableGlobalThisKeys$LWS, [key$LWS]) ? getUnforgeableGlobalThisGetter$LWS(key$LWS) : ReflectApply$LWS(ObjectProtoLookupGetter$LWS, target$LWS, [key$LWS]) : undefined;
      const lookupFixedSetter$LWS = shouldFixChromeBug$LWS ? (target$LWS, key$LWS) => ReflectApply$LWS(ArrayProtoIncludes$LWS, unforgeableGlobalThisKeys$LWS, [key$LWS]) ? undefined : ReflectApply$LWS(ObjectProtoLookupSetter$LWS, target$LWS, [key$LWS]) : undefined;
      const unboundGlobalThisGetter$LWS = shouldFixChromeBug$LWS ? () => globalThisRef$LWS : undefined;
      const wrapDefineAccessOrProperty$LWS = originalFunc$LWS => {
        const {
          length: originalFuncLength$LWS
        } = originalFunc$LWS;
        // `__defineGetter__()` and `__defineSetter__()` have
        // function lengths of 2 while `Reflect.defineProperty()`
        // has a function length of 3.
        const useThisArgAsTarget$LWS = originalFuncLength$LWS === 2;
        return new ProxyCtor$LWS(originalFunc$LWS, {
          apply(_originalFunc$LWS, thisArg$LWS, args$LWS) {
            if (args$LWS.length >= originalFuncLength$LWS) {
              const target$LWS = useThisArgAsTarget$LWS ? thisArg$LWS : args$LWS[0];
              if (typeof target$LWS === 'object' && target$LWS !== null || typeof target$LWS === 'function') {
                const key$LWS = useThisArgAsTarget$LWS ? args$LWS[0] : args$LWS[1];
                const state$LWS = getLazyPropertyDescriptorStateByTarget$LWS(target$LWS);
                if (state$LWS != null && state$LWS[key$LWS]) {
                  // Activate the descriptor by triggering
                  // its getter.
                  // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                  target$LWS[key$LWS];
                }
              }
            }
            return ReflectApply$LWS(originalFunc$LWS, thisArg$LWS, args$LWS);
          }
        });
      };
      const wrapLookupAccessor$LWS = (originalFunc$LWS, lookupFixedAccessor$LWS) => new ProxyCtor$LWS(originalFunc$LWS, {
        apply(_originalFunc$LWS, thisArg$LWS, args$LWS) {
          if (args$LWS.length && (typeof thisArg$LWS === 'object' && thisArg$LWS !== null || typeof thisArg$LWS === 'function')) {
            const {
              0: key$LWS
            } = args$LWS;
            const state$LWS = getLazyPropertyDescriptorStateByTarget$LWS(thisArg$LWS);
            if (state$LWS != null && state$LWS[key$LWS]) {
              // Activate the descriptor by triggering
              // its getter.
              // eslint-disable-next-line @typescript-eslint/no-unused-expressions
              thisArg$LWS[key$LWS];
            }
            if (shouldFixChromeBug$LWS && thisArg$LWS === globalThisRef$LWS) {
              return lookupFixedAccessor$LWS(thisArg$LWS, key$LWS);
            }
          }
          return ReflectApply$LWS(originalFunc$LWS, thisArg$LWS, args$LWS);
        }
      });
      const wrapGetOwnPropertyDescriptor$LWS = originalFunc$LWS => new ProxyCtor$LWS(originalFunc$LWS, {
        apply(_originalFunc$LWS, thisArg$LWS, args$LWS) {
          if (args$LWS.length > 1) {
            const {
              0: target$LWS,
              1: key$LWS
            } = args$LWS;
            if (typeof target$LWS === 'object' && target$LWS !== null || typeof target$LWS === 'function') {
              const state$LWS = getLazyPropertyDescriptorStateByTarget$LWS(target$LWS);
              if (state$LWS != null && state$LWS[key$LWS]) {
                // Activate the descriptor by triggering
                // its getter.
                // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                target$LWS[key$LWS];
              }
              if (shouldFixChromeBug$LWS && target$LWS === globalThisRef$LWS) {
                return getFixedDescriptor$LWS(target$LWS, key$LWS);
              }
            }
          }
          return ReflectApply$LWS(originalFunc$LWS, thisArg$LWS, args$LWS);
        }
      });
      const wrapGetOwnPropertyDescriptors$LWS = originalFunc$LWS => new ProxyCtor$LWS(originalFunc$LWS, {
        apply(_originalFunc$LWS, thisArg$LWS, args$LWS) {
          const target$LWS = args$LWS.length ? args$LWS[0] : undefined;
          if (!(typeof target$LWS === 'object' && target$LWS !== null || typeof target$LWS === 'function')) {
            // Defer to native method to throw exception.
            return ReflectApply$LWS(originalFunc$LWS, thisArg$LWS, args$LWS);
          }
          const state$LWS = getLazyPropertyDescriptorStateByTarget$LWS(target$LWS);
          const isFixingChromeBug$LWS = target$LWS === globalThisRef$LWS && shouldFixChromeBug$LWS;
          const unsafeDescs$LWS = isFixingChromeBug$LWS ?
          // Create an empty property descriptor map
          // to populate with curated descriptors.
          {} :
          // Since this is not a global object it is
          // safe to use the native method.
          ReflectApply$LWS(originalFunc$LWS, thisArg$LWS, args$LWS);
          if (!isFixingChromeBug$LWS && state$LWS === undefined) {
            // Exit early if the target is not a global
            // object and there are no lazy descriptors.
            return unsafeDescs$LWS;
          }
          const ownKeys$LWS = ReflectOwnKeys$LWS(isFixingChromeBug$LWS ? target$LWS : unsafeDescs$LWS);
          for (let i$LWS = 0, {
              length: length$LWS
            } = ownKeys$LWS; i$LWS < length$LWS; i$LWS += 1) {
            const ownKey$LWS = ownKeys$LWS[i$LWS];
            const isLazyProp$LWS = !!(state$LWS != null && state$LWS[ownKey$LWS]);
            if (isLazyProp$LWS) {
              // Activate the descriptor by triggering
              // its getter.
              // eslint-disable-next-line @typescript-eslint/no-unused-expressions
              target$LWS[ownKey$LWS];
            }
            if (isLazyProp$LWS || isFixingChromeBug$LWS) {
              const unsafeDesc$LWS = isFixingChromeBug$LWS ? getFixedDescriptor$LWS(target$LWS, ownKey$LWS) : ReflectGetOwnPropertyDescriptor$LWS(target$LWS, ownKey$LWS);
              // Update the descriptor map entry.
              if (unsafeDesc$LWS) {
                unsafeDescs$LWS[ownKey$LWS] = unsafeDesc$LWS;
              } else if (!isFixingChromeBug$LWS) {
                ReflectDeleteProperty$LWS(unsafeDescs$LWS, ownKey$LWS);
              }
            }
          }
          return unsafeDescs$LWS;
        }
      });
      try {
        ReflectRef$LWS.defineProperty = wrapDefineAccessOrProperty$LWS(ReflectDefineProperty$LWS);
        // eslint-disable-next-line no-empty
      } catch (_unused19$LWS) {}
      try {
        ReflectRef$LWS.getOwnPropertyDescriptor = wrapGetOwnPropertyDescriptor$LWS(ReflectGetOwnPropertyDescriptor$LWS);
        // eslint-disable-next-line no-empty
      } catch (_unused20$LWS) {}
      try {
        ObjectCtor$LWS.getOwnPropertyDescriptor = wrapGetOwnPropertyDescriptor$LWS(ObjectGetOwnPropertyDescriptor$LWS);
        // eslint-disable-next-line no-empty
      } catch (_unused21$LWS) {}
      try {
        ObjectCtor$LWS.getOwnPropertyDescriptors = wrapGetOwnPropertyDescriptors$LWS(ObjectGetOwnPropertyDescriptors$LWS);
        // eslint-disable-next-line no-empty
      } catch (_unused22$LWS) {}
      try {
        // eslint-disable-next-line @typescript-eslint/naming-convention, no-restricted-properties, no-underscore-dangle
        ObjectProto$LWS.__defineGetter__ = wrapDefineAccessOrProperty$LWS(ObjectProtoDefineGetter$LWS);
        // eslint-disable-next-line no-empty
      } catch (_unused23$LWS) {}
      try {
        // eslint-disable-next-line @typescript-eslint/naming-convention, no-restricted-properties, no-underscore-dangle
        ObjectProto$LWS.__defineSetter__ = wrapDefineAccessOrProperty$LWS(ObjectProtoDefineSetter$LWS);
        // eslint-disable-next-line no-empty
      } catch (_unused24$LWS) {}
      try {
        // eslint-disable-next-line @typescript-eslint/naming-convention, no-underscore-dangle
        ObjectProto$LWS.__lookupGetter__ = wrapLookupAccessor$LWS(ObjectProtoLookupGetter$LWS, lookupFixedGetter$LWS);
        // eslint-disable-next-line no-empty
      } catch (_unused25$LWS) {}
      try {
        // eslint-disable-next-line @typescript-eslint/naming-convention, no-underscore-dangle
        ObjectProto$LWS.__lookupSetter__ = wrapLookupAccessor$LWS(ObjectProtoLookupSetter$LWS, lookupFixedSetter$LWS);
        // eslint-disable-next-line no-empty
      } catch (_unused26$LWS) {}
    } : noop$LWS;
    function lookupForeignDescriptor$LWS(foreignTargetPointer$LWS, shadowTarget$LWS, key$LWS) {
      let protoPointerOrNull$LWS;
      let safeDesc$LWS;
      try {
        protoPointerOrNull$LWS = foreignCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS(foreignTargetPointer$LWS, key$LWS, (_key$LWS, configurable$LWS, enumerable$LWS, writable$LWS, valuePointerOrPrimitive$LWS, getterPointerOrPrimitive$LWS, setterPointerOrPrimitive$LWS) => {
          safeDesc$LWS = {
            __proto__: null,
            foreign: true
          };
          if (configurable$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
            safeDesc$LWS.configurable = configurable$LWS;
          }
          if (enumerable$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
            safeDesc$LWS.enumerable = enumerable$LWS;
          }
          if (writable$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
            safeDesc$LWS.writable = writable$LWS;
          }
          if (getterPointerOrPrimitive$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
            if (typeof getterPointerOrPrimitive$LWS === 'function') {
              getterPointerOrPrimitive$LWS();
              safeDesc$LWS.get = selectedTarget$LWS;
              selectedTarget$LWS = undefined;
            } else {
              safeDesc$LWS.get = undefined;
            }
          }
          if (setterPointerOrPrimitive$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
            if (typeof setterPointerOrPrimitive$LWS === 'function') {
              setterPointerOrPrimitive$LWS();
              safeDesc$LWS.set = selectedTarget$LWS;
              selectedTarget$LWS = undefined;
            } else {
              safeDesc$LWS.set = undefined;
            }
          }
          if (valuePointerOrPrimitive$LWS !== LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
            if (typeof valuePointerOrPrimitive$LWS === 'function') {
              valuePointerOrPrimitive$LWS();
              safeDesc$LWS.value = selectedTarget$LWS;
              selectedTarget$LWS = undefined;
            } else {
              safeDesc$LWS.value = valuePointerOrPrimitive$LWS;
            }
          }
          if (configurable$LWS === false) {
            // Update the descriptor to non-configurable on
            // the shadow target.
            ReflectDefineProperty$LWS(shadowTarget$LWS, key$LWS, safeDesc$LWS);
          }
        });
      } catch (error) {
        var _selectedTarget10$LWS;
        const errorToThrow$LWS = (_selectedTarget10$LWS = selectedTarget$LWS) != null ? _selectedTarget10$LWS : error;
        selectedTarget$LWS = undefined;
        throw errorToThrow$LWS;
      }
      if (safeDesc$LWS === undefined) {
        // Avoiding calling the has trap for any proto chain operation,
        // instead we implement the regular logic here in this trap.
        let currentObject$LWS;
        if (typeof protoPointerOrNull$LWS === 'function') {
          protoPointerOrNull$LWS();
          currentObject$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          currentObject$LWS = null;
        }
        while (currentObject$LWS) {
          safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(currentObject$LWS, key$LWS);
          if (safeDesc$LWS) {
            ReflectSetPrototypeOf$LWS(safeDesc$LWS, null);
            break;
          }
          currentObject$LWS = ReflectGetPrototypeOf$LWS(currentObject$LWS);
        }
        if (safeDesc$LWS) {
          var _ref3$LWS;
          const {
            get: getter$LWS,
            set: setter$LWS,
            value: localValue$LWS
          } = safeDesc$LWS;
          const possibleProxy$LWS = (_ref3$LWS = getter$LWS != null ? getter$LWS : setter$LWS) != null ? _ref3$LWS : localValue$LWS;
          safeDesc$LWS.foreign = (typeof possibleProxy$LWS === 'object' && possibleProxy$LWS !== null || typeof possibleProxy$LWS === 'function') && proxyPointerCache$LWS.get(possibleProxy$LWS) !== undefined;
        }
      }
      return safeDesc$LWS;
    }
    function passthruForeignTraversedSet$LWS(foreignTargetPointer$LWS, shadowTarget$LWS, key$LWS, value$LWS, receiver$LWS) {
      const safeDesc$LWS = lookupForeignDescriptor$LWS(foreignTargetPointer$LWS, shadowTarget$LWS, key$LWS);
      // Following the specification steps for
      // OrdinarySetWithOwnDescriptor ( O, P, V, Receiver, ownDesc ).
      // https://tc39.es/ecma262/#sec-ordinarysetwithowndescriptor
      if (safeDesc$LWS) {
        if ('get' in safeDesc$LWS || 'set' in safeDesc$LWS) {
          const {
            set: setter$LWS
          } = safeDesc$LWS;
          if (setter$LWS) {
            if (safeDesc$LWS.foreign) {
              foreignCallableApply$LWS(getTransferablePointer$LWS(setter$LWS),
              // Inline getTransferableValue().
              typeof receiver$LWS === 'object' && receiver$LWS !== null || typeof receiver$LWS === 'function' ? getTransferablePointer$LWS(receiver$LWS) :
              // Intentionally ignoring `document.all`.
              // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
              // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
              typeof receiver$LWS === 'undefined' ? undefined : receiver$LWS,
              // Inline getTransferableValue().
              typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function' ? getTransferablePointer$LWS(value$LWS) :
              // Intentionally ignoring `document.all`.
              // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
              // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
              typeof value$LWS === 'undefined' ? undefined : value$LWS);
            } else {
              // Even though the setter function exists, we can't
              // use `ReflectSet()` because there might be a
              // distortion for that setter function, in which
              // case we must resolve the local setter and call
              // it instead.
              ReflectApply$LWS(setter$LWS, receiver$LWS, [value$LWS]);
            }
            // If there is a setter, it either throw or we can assume
            // the value was set.
            return true;
          }
          return false;
        }
        if (safeDesc$LWS.writable === false) {
          return false;
        }
      }
      // Exit early if receiver is not object like.
      if (!(typeof receiver$LWS === 'object' && receiver$LWS !== null || typeof receiver$LWS === 'function')) {
        return false;
      }
      const safeReceiverDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(receiver$LWS, key$LWS);
      if (safeReceiverDesc$LWS) {
        ReflectSetPrototypeOf$LWS(safeReceiverDesc$LWS, null);
        // Exit early for accessor descriptors or non-writable data
        // descriptors.
        if ('get' in safeReceiverDesc$LWS || 'set' in safeReceiverDesc$LWS || safeReceiverDesc$LWS.writable === false) {
          return false;
        }
        // Setting the descriptor with only a value entry should not
        // affect existing descriptor traits.
        ReflectDefineProperty$LWS(receiver$LWS, key$LWS, {
          __proto__: null,
          value: value$LWS
        });
        return true;
      }
      // `ReflectDefineProperty()` and `ReflectSet()` both are expected
      // to return `false` when attempting to add a new property if the
      // receiver is not extensible.
      return ReflectDefineProperty$LWS(receiver$LWS, key$LWS, {
        __proto__: null,
        configurable: true,
        enumerable: true,
        value: value$LWS,
        writable: true
      });
    }
    function pushErrorAcrossBoundary$LWS(error) {
      if (LOCKER_DEBUGGABLE_FLAG$LWS) {
        checkDebugMode$LWS();
      }
      // Inline getTransferableValue().
      if (typeof error === 'object' && error !== null || typeof error === 'function') {
        const foreignErrorPointer$LWS = getTransferablePointer$LWS(error, foreignCallablePushErrorTarget$LWS);
        foreignErrorPointer$LWS();
      }
      return error;
    }
    function pushTarget$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS, foreignTargetFunctionArity$LWS, foreignTargetFunctionName$LWS, foreignTargetTypedArrayLength$LWS) {
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      const {
        proxy: proxy$LWS
      } = new BoundaryProxyHandler$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS, foreignTargetFunctionArity$LWS, foreignTargetFunctionName$LWS, foreignTargetTypedArrayLength$LWS);
      proxyPointerCache$LWS.set(proxy$LWS, foreignTargetPointer$LWS);
      return createPointer$LWS(proxy$LWS);
    }
    const setLazyPropertyDescriptorStateByTarget$LWS = IS_IN_SHADOW_REALM$LWS ? (target$LWS, state$LWS) => {
      lazyPropertyDescriptorStateCache$LWS.set(target$LWS, state$LWS);
      foreignCallableSetLazyPropertyDescriptorStateByTarget$LWS(getTransferablePointer$LWS(target$LWS), getTransferablePointer$LWS(state$LWS));
    } : noop$LWS;
    class BoundaryProxyHandler$LWS {
      constructor(foreignTargetPointer$LWS, foreignTargetTraits$LWS, foreignTargetFunctionArity$LWS, foreignTargetFunctionName$LWS, foreignTargetTypedArrayLength$LWS) {
        // Internal red/shadow realm side utilities:
        this.makeProxyLive = IS_IN_SHADOW_REALM$LWS ? function () {
          // Replace pending traps with live traps that can work with the
          // target without taking snapshots.
          this.deleteProperty = BoundaryProxyHandler$LWS.passthruDeletePropertyTrap;
          this.defineProperty = BoundaryProxyHandler$LWS.passthruDefinePropertyTrap;
          this.preventExtensions = BoundaryProxyHandler$LWS.passthruPreventExtensionsTrap;
          this.set = BoundaryProxyHandler$LWS.passthruSetTrap;
          this.setPrototypeOf = BoundaryProxyHandler$LWS.passthruSetPrototypeOfTrap;
        } : noop$LWS;
        this.makeProxyStatic = IS_IN_SHADOW_REALM$LWS ? function () {
          // Reset all traps except apply and construct for static proxies
          // since the proxy target is the shadow target and all operations
          // are going to be applied to it rather than the real target.
          this.defineProperty = BoundaryProxyHandler$LWS.staticDefinePropertyTrap;
          this.deleteProperty = BoundaryProxyHandler$LWS.staticDeletePropertyTrap;
          this.get = BoundaryProxyHandler$LWS.staticGetTrap;
          this.getOwnPropertyDescriptor = BoundaryProxyHandler$LWS.staticGetOwnPropertyDescriptorTrap;
          this.getPrototypeOf = BoundaryProxyHandler$LWS.staticGetPrototypeOfTrap;
          this.has = BoundaryProxyHandler$LWS.staticHasTrap;
          this.isExtensible = BoundaryProxyHandler$LWS.staticIsExtensibleTrap;
          this.ownKeys = BoundaryProxyHandler$LWS.staticOwnKeysTrap;
          this.preventExtensions = BoundaryProxyHandler$LWS.staticPreventExtensionsTrap;
          this.set = BoundaryProxyHandler$LWS.staticSetTrap;
          this.setPrototypeOf = BoundaryProxyHandler$LWS.staticSetPrototypeOfTrap;
          const {
            foreignTargetPointer: foreignTargetPointer$LWS,
            foreignTargetTraits: foreignTargetTraits$LWS,
            shadowTarget: shadowTarget$LWS
          } = this;
          if (useFastForeignTargetPath$LWS) {
            fastForeignTargetPointers$LWS.delete(foreignTargetPointer$LWS);
          }
          // We don't wrap `foreignCallableGetTargetIntegrityTraits()`
          // in a try-catch because it cannot throw.
          const targetIntegrityTraits$LWS = foreignCallableGetTargetIntegrityTraits$LWS(foreignTargetPointer$LWS);
          if (targetIntegrityTraits$LWS & 8 /* TargetIntegrityTraits.Revoked */) {
            // the target is a revoked proxy, in which case we revoke
            // this proxy as well.
            this.revoke();
            return;
          }
          // A proxy can revoke itself when traps are triggered and break
          // the membrane, therefore we need protection.
          try {
            copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget$LWS(foreignTargetPointer$LWS, shadowTarget$LWS);
          } catch (_unused27$LWS) {
            // We don't wrap `foreignCallableIsTargetRevoked()` in a
            // try-catch because it cannot throw.
            if (foreignCallableIsTargetRevoked$LWS(foreignTargetPointer$LWS)) {
              this.revoke();
              return;
            }
          }
          if (foreignTargetTraits$LWS & 16 /* TargetTraits.IsObject */ && !(SymbolToStringTag$LWS in shadowTarget$LWS)) {
            let toStringTag$LWS = 'Object';
            try {
              toStringTag$LWS = foreignCallableGetToStringTagOfTarget$LWS(foreignTargetPointer$LWS);
              // eslint-disable-next-line no-empty
            } catch (_unused28$LWS) {}
            this.staticToStringTag = toStringTag$LWS;
          }
          // Preserve the semantics of the target.
          if (targetIntegrityTraits$LWS & 4 /* TargetIntegrityTraits.IsFrozen */) {
            ObjectFreeze$LWS(shadowTarget$LWS);
          } else {
            if (targetIntegrityTraits$LWS & 2 /* TargetIntegrityTraits.IsSealed */) {
              ObjectSeal$LWS(shadowTarget$LWS);
            } else if (targetIntegrityTraits$LWS & 1 /* TargetIntegrityTraits.IsNotExtensible */) {
              ReflectPreventExtensions$LWS(shadowTarget$LWS);
            }
            if (LOCKER_UNMINIFIED_FLAG$LWS) {
              // We don't wrap `foreignCallableDebugInfo()` in a try-catch
              // because it cannot throw.
              foreignCallableDebugInfo$LWS('Mutations on the membrane of an object originating ' + 'outside of the sandbox will not be reflected on ' + 'the object itself:', foreignTargetPointer$LWS);
            }
          }
        } : noop$LWS;
        let shadowTarget$LWS;
        const isForeignTargetArray$LWS = foreignTargetTraits$LWS & 1 /* TargetTraits.IsArray */;
        const isForeignTargetFunction$LWS = foreignTargetTraits$LWS & 4 /* TargetTraits.IsFunction */;
        if (isForeignTargetFunction$LWS) {
          // This shadow target is never invoked. It's needed to avoid
          // proxy trap invariants. Because it's not invoked the code
          // does not need to be instrumented for code coverage.
          //
          // istanbul ignore next
          shadowTarget$LWS = foreignTargetTraits$LWS & 8 /* TargetTraits.IsArrowFunction */ ? () => {} : function () {};
        } else if (isForeignTargetArray$LWS) {
          shadowTarget$LWS = [];
        } else {
          shadowTarget$LWS = {};
        }
        const {
          proxy: proxy$LWS,
          revoke: revoke$LWS
        } = ProxyRevocable$LWS(shadowTarget$LWS, this);
        this.foreignTargetPointer = foreignTargetPointer$LWS;
        this.foreignTargetTraits = foreignTargetTraits$LWS;
        this.foreignTargetTypedArrayLength = foreignTargetTypedArrayLength$LWS;
        // Define in the BoundaryProxyHandler constructor so it is bound
        // to the BoundaryProxyHandler instance.
        this.nonConfigurableDescriptorCallback = (key$LWS, configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS) => {
          // Update the descriptor to non-configurable on the shadow
          // target.
          ReflectDefineProperty$LWS(this.shadowTarget, key$LWS, createDescriptorFromMeta$LWS(configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS));
        };
        this.proxy = proxy$LWS;
        this.revoke = revoke$LWS;
        this.serialize = noop$LWS;
        this.shadowTarget = shadowTarget$LWS;
        this.staticToStringTag = 'Object';
        // Define traps.
        if (isForeignTargetFunction$LWS) {
          var _applyTrapNameRegistr$LWS, _constructTrapNameReg$LWS;
          this.apply = this[(_applyTrapNameRegistr$LWS = applyTrapNameRegistry$LWS[foreignTargetFunctionArity$LWS]) != null ? _applyTrapNameRegistr$LWS : applyTrapNameRegistry$LWS.n];
          this.construct = this[(_constructTrapNameReg$LWS = constructTrapNameRegistry$LWS[foreignTargetFunctionArity$LWS]) != null ? _constructTrapNameReg$LWS : constructTrapNameRegistry$LWS.n];
        }
        this.defineProperty = BoundaryProxyHandler$LWS.defaultDefinePropertyTrap;
        this.deleteProperty = BoundaryProxyHandler$LWS.defaultDeletePropertyTrap;
        this.isExtensible = BoundaryProxyHandler$LWS.defaultIsExtensibleTrap;
        this.getOwnPropertyDescriptor = BoundaryProxyHandler$LWS.defaultGetOwnPropertyDescriptorTrap;
        this.getPrototypeOf = BoundaryProxyHandler$LWS.defaultGetPrototypeOfTrap;
        this.get = foreignTargetTraits$LWS & 32 /* TargetTraits.IsTypedArray */ ? BoundaryProxyHandler$LWS.hybridGetTrapForTypedArray : BoundaryProxyHandler$LWS.defaultGetTrap;
        this.has = BoundaryProxyHandler$LWS.defaultHasTrap;
        this.ownKeys = BoundaryProxyHandler$LWS.defaultOwnKeysTrap;
        this.preventExtensions = BoundaryProxyHandler$LWS.defaultPreventExtensionsTrap;
        this.setPrototypeOf = BoundaryProxyHandler$LWS.defaultSetPrototypeOfTrap;
        this.set = BoundaryProxyHandler$LWS.defaultSetTrap;
        if (foreignTargetTraits$LWS & 64 /* TargetTraits.Revoked */) {
          this.revoke();
        } else if (IS_IN_SHADOW_REALM$LWS) {
          if (isForeignTargetArray$LWS || foreignTargetTraits$LWS & 2 /* TargetTraits.IsArrayBufferView */) {
            this.makeProxyLive();
          }
        } else {
          if (foreignTargetTraits$LWS & 16 /* TargetTraits.IsObject */) {
            // Lazily define serialize method.
            let cachedSerializedValue$LWS = LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
            this.serialize = () => {
              if (cachedSerializedValue$LWS === LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS) {
                cachedSerializedValue$LWS = foreignCallableSerializeTarget$LWS(this.foreignTargetPointer);
              }
              return cachedSerializedValue$LWS;
            };
          }
        }
      }
      // Passthru traps:
      static passthruDefinePropertyTrap(_shadowTarget$LWS, key$LWS, unsafePartialDesc$LWS) {
        lastProxyTrapCalled$LWS = 4 /* ProxyHandlerTraps.DefineProperty */;
        const {
          foreignTargetPointer: foreignTargetPointer$LWS,
          nonConfigurableDescriptorCallback: nonConfigurableDescriptorCallback$LWS
        } = this;
        const safePartialDesc$LWS = unsafePartialDesc$LWS;
        ReflectSetPrototypeOf$LWS(safePartialDesc$LWS, null);
        const {
          get: getter$LWS,
          set: setter$LWS,
          value: value$LWS
        } = safePartialDesc$LWS;
        const valuePointerOrPrimitive$LWS = 'value' in safePartialDesc$LWS ?
        // Inline getTransferableValue().
        typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function' ? getTransferablePointer$LWS(value$LWS) :
        // Intentionally ignoring `document.all`.
        // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
        // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
        typeof value$LWS === 'undefined' ? undefined : value$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        const getterPointerOrUndefinedSymbol$LWS = 'get' in safePartialDesc$LWS ?
        // Inline getTransferableValue().
        typeof getter$LWS === 'function' ? getTransferablePointer$LWS(getter$LWS) : getter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        const setterPointerOrUndefinedSymbol$LWS = 'set' in safePartialDesc$LWS ?
        // Inline getTransferableValue().
        typeof setter$LWS === 'function' ? getTransferablePointer$LWS(setter$LWS) : setter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        let result$LWS = false;
        try {
          result$LWS = foreignCallableDefineProperty$LWS(foreignTargetPointer$LWS, key$LWS, 'configurable' in safePartialDesc$LWS ? !!safePartialDesc$LWS.configurable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'enumerable' in safePartialDesc$LWS ? !!safePartialDesc$LWS.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'writable' in safePartialDesc$LWS ? !!safePartialDesc$LWS.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, valuePointerOrPrimitive$LWS, getterPointerOrUndefinedSymbol$LWS, setterPointerOrUndefinedSymbol$LWS, nonConfigurableDescriptorCallback$LWS);
        } catch (error) {
          var _selectedTarget11$LWS;
          const errorToThrow$LWS = (_selectedTarget11$LWS = selectedTarget$LWS) != null ? _selectedTarget11$LWS : error;
          selectedTarget$LWS = undefined;
          throw errorToThrow$LWS;
        }
        if (useFastForeignTargetPath$LWS && result$LWS && (typeof getterPointerOrUndefinedSymbol$LWS === 'function' || typeof setterPointerOrUndefinedSymbol$LWS === 'function')) {
          fastForeignTargetPointers$LWS.delete(foreignTargetPointer$LWS);
        }
        return result$LWS;
      }
      static passthruDeletePropertyTrap(_shadowTarget$LWS, key$LWS) {
        lastProxyTrapCalled$LWS = 8 /* ProxyHandlerTraps.DeleteProperty */;
        let result$LWS = false;
        try {
          result$LWS = foreignCallableDeleteProperty$LWS(this.foreignTargetPointer, key$LWS);
        } catch (error) {
          var _selectedTarget12$LWS;
          const errorToThrow$LWS = (_selectedTarget12$LWS = selectedTarget$LWS) != null ? _selectedTarget12$LWS : error;
          selectedTarget$LWS = undefined;
          throw errorToThrow$LWS;
        }
        return result$LWS;
      }
      static passthruGetPrototypeOfTrap(_shadowTarget$LWS) {
        lastProxyTrapCalled$LWS = 64 /* ProxyHandlerTraps.GetPrototypeOf */;
        let protoPointerOrNull$LWS;
        try {
          protoPointerOrNull$LWS = foreignCallableGetPrototypeOf$LWS(this.foreignTargetPointer);
        } catch (error) {
          var _selectedTarget13$LWS;
          const errorToThrow$LWS = (_selectedTarget13$LWS = selectedTarget$LWS) != null ? _selectedTarget13$LWS : error;
          selectedTarget$LWS = undefined;
          throw errorToThrow$LWS;
        }
        let proto$LWS;
        if (typeof protoPointerOrNull$LWS === 'function') {
          protoPointerOrNull$LWS();
          proto$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          proto$LWS = null;
        }
        return proto$LWS;
      }
      static passthruIsExtensibleTrap(_shadowTarget$LWS) {
        lastProxyTrapCalled$LWS = 256 /* ProxyHandlerTraps.IsExtensible */;
        const {
          shadowTarget: shadowTarget$LWS
        } = this;
        let result$LWS = false;
        // Check if already locked.
        if (ReflectIsExtensible$LWS(shadowTarget$LWS)) {
          const {
            foreignTargetPointer: foreignTargetPointer$LWS
          } = this;
          try {
            result$LWS = foreignCallableIsExtensible$LWS(foreignTargetPointer$LWS);
          } catch (error) {
            var _selectedTarget14$LWS;
            const errorToThrow$LWS = (_selectedTarget14$LWS = selectedTarget$LWS) != null ? _selectedTarget14$LWS : error;
            selectedTarget$LWS = undefined;
            throw errorToThrow$LWS;
          }
          if (!result$LWS) {
            copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget$LWS(foreignTargetPointer$LWS, shadowTarget$LWS);
            ReflectPreventExtensions$LWS(shadowTarget$LWS);
          }
        }
        return result$LWS;
      }
      static passthruOwnKeysTrap(_shadowTarget$LWS) {
        lastProxyTrapCalled$LWS = 512 /* ProxyHandlerTraps.OwnKeys */;
        let ownKeys$LWS;
        try {
          foreignCallableOwnKeys$LWS(this.foreignTargetPointer, (...args$LWS) => {
            ownKeys$LWS = args$LWS;
          });
        } catch (error) {
          var _selectedTarget15$LWS;
          const errorToThrow$LWS = (_selectedTarget15$LWS = selectedTarget$LWS) != null ? _selectedTarget15$LWS : error;
          selectedTarget$LWS = undefined;
          throw errorToThrow$LWS;
        }
        return ownKeys$LWS || [];
      }
      static passthruGetOwnPropertyDescriptorTrap(_shadowTarget$LWS, key$LWS) {
        lastProxyTrapCalled$LWS = 32 /* ProxyHandlerTraps.GetOwnPropertyDescriptor */;
        const {
          foreignTargetPointer: foreignTargetPointer$LWS,
          shadowTarget: shadowTarget$LWS
        } = this;
        let safeDesc$LWS;
        try {
          foreignCallableGetOwnPropertyDescriptor$LWS(foreignTargetPointer$LWS, key$LWS, (_key$LWS, configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS) => {
            safeDesc$LWS = createDescriptorFromMeta$LWS(configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS);
            if (safeDesc$LWS.configurable === false) {
              // Update the descriptor to non-configurable on
              // the shadow target.
              ReflectDefineProperty$LWS(shadowTarget$LWS, key$LWS, safeDesc$LWS);
            }
          });
        } catch (error) {
          var _selectedTarget16$LWS;
          const errorToThrow$LWS = (_selectedTarget16$LWS = selectedTarget$LWS) != null ? _selectedTarget16$LWS : error;
          selectedTarget$LWS = undefined;
          throw errorToThrow$LWS;
        }
        // Getting forged descriptors of handshake properties is not allowed.
        if (IS_NOT_IN_SHADOW_REALM$LWS && safeDesc$LWS && (key$LWS === LOCKER_NEAR_MEMBRANE_SYMBOL$LWS || key$LWS === LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS)) {
          throw new TypeErrorCtor$LWS(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
        }
        return safeDesc$LWS;
      }
      static passthruPreventExtensionsTrap(_shadowTarget$LWS) {
        lastProxyTrapCalled$LWS = 1024 /* ProxyHandlerTraps.PreventExtensions */;
        const {
          foreignTargetPointer: foreignTargetPointer$LWS,
          shadowTarget: shadowTarget$LWS
        } = this;
        let result$LWS = true;
        if (ReflectIsExtensible$LWS(shadowTarget$LWS)) {
          let resultEnum$LWS = 0 /* PreventExtensionsResult.None */;
          try {
            resultEnum$LWS = foreignCallablePreventExtensions$LWS(foreignTargetPointer$LWS);
          } catch (error) {
            var _selectedTarget17$LWS;
            const errorToThrow$LWS = (_selectedTarget17$LWS = selectedTarget$LWS) != null ? _selectedTarget17$LWS : error;
            selectedTarget$LWS = undefined;
            throw errorToThrow$LWS;
          }
          // If the target is a proxy it might reject the
          // preventExtension call, in which case we should not
          // attempt to lock down the shadow target.
          if (!(resultEnum$LWS & 1 /* PreventExtensionsResult.Extensible */)) {
            copyForeignOwnPropertyDescriptorsAndPrototypeToShadowTarget$LWS(foreignTargetPointer$LWS, shadowTarget$LWS);
            ReflectPreventExtensions$LWS(shadowTarget$LWS);
          }
          result$LWS = !(resultEnum$LWS & 2 /* PreventExtensionsResult.False */);
        }
        return result$LWS;
      }
      static passthruSetPrototypeOfTrap(_shadowTarget$LWS, proto$LWS) {
        lastProxyTrapCalled$LWS = 4096 /* ProxyHandlerTraps.SetPrototypeOf */;
        const {
          foreignTargetPointer: foreignTargetPointer$LWS
        } = this;
        const transferableProto$LWS = proto$LWS ? getTransferablePointer$LWS(proto$LWS) : proto$LWS;
        let result$LWS = false;
        try {
          result$LWS = foreignCallableSetPrototypeOf$LWS(foreignTargetPointer$LWS, transferableProto$LWS);
        } catch (error) {
          var _selectedTarget18$LWS;
          const errorToThrow$LWS = (_selectedTarget18$LWS = selectedTarget$LWS) != null ? _selectedTarget18$LWS : error;
          selectedTarget$LWS = undefined;
          throw errorToThrow$LWS;
        }
        if (useFastForeignTargetPath$LWS && result$LWS) {
          fastForeignTargetPointers$LWS.delete(foreignTargetPointer$LWS);
        }
        return result$LWS;
      }
      static passthruSetTrap(_shadowTarget$LWS, key$LWS, value$LWS, receiver$LWS) {
        lastProxyTrapCalled$LWS = 2048 /* ProxyHandlerTraps.Set */;
        const {
          foreignTargetPointer: foreignTargetPointer$LWS,
          proxy: proxy$LWS,
          shadowTarget: shadowTarget$LWS
        } = this;
        // Intentionally ignoring `document.all`.
        // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
        // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
        if (typeof value$LWS === 'undefined') {
          value$LWS = undefined;
        }
        if (typeof receiver$LWS === 'undefined') {
          receiver$LWS = proxy$LWS;
        }
        // Setting forged values of handshake properties is not allowed.
        if (IS_NOT_IN_SHADOW_REALM$LWS && (key$LWS === LOCKER_NEAR_MEMBRANE_SYMBOL$LWS || key$LWS === LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS)) {
          throw new TypeErrorCtor$LWS(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
        }
        const isFastPath$LWS = proxy$LWS === receiver$LWS;
        let result$LWS = false;
        try {
          result$LWS = isFastPath$LWS ? foreignCallableSet$LWS(foreignTargetPointer$LWS, key$LWS,
          // Inline getTransferableValue().
          typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function' ? getTransferablePointer$LWS(value$LWS) : value$LWS) : passthruForeignTraversedSet$LWS(foreignTargetPointer$LWS, shadowTarget$LWS, key$LWS, value$LWS, receiver$LWS);
        } catch (error) {
          var _selectedTarget19$LWS;
          const errorToThrow$LWS = (_selectedTarget19$LWS = selectedTarget$LWS) != null ? _selectedTarget19$LWS : error;
          selectedTarget$LWS = undefined;
          throw errorToThrow$LWS;
        }
        return result$LWS;
      }
    }
    // Logic implementation of all traps.
    // Hybrid traps:
    // (traps that operate on their shadowTarget, proxy, and foreignTargetPointer):
    BoundaryProxyHandler$LWS.hybridGetTrap = IS_IN_SHADOW_REALM$LWS ? function (_shadowTarget$LWS, key$LWS, receiver$LWS) {
      const {
        foreignTargetPointer: foreignTargetPointer$LWS,
        foreignTargetTraits: foreignTargetTraits$LWS,
        proxy: proxy$LWS,
        shadowTarget: shadowTarget$LWS
      } = this;
      let safeDesc$LWS;
      let result$LWS;
      if (useFastForeignTargetPath$LWS && fastForeignTargetPointers$LWS.has(foreignTargetPointer$LWS)) {
        let pointerOrPrimitive$LWS;
        try {
          pointerOrPrimitive$LWS = foreignCallableGetPropertyValue$LWS(foreignTargetPointer$LWS, key$LWS);
        } catch (error) {
          var _selectedTarget20$LWS;
          const errorToThrow$LWS = (_selectedTarget20$LWS = selectedTarget$LWS) != null ? _selectedTarget20$LWS : error;
          selectedTarget$LWS = undefined;
          throw errorToThrow$LWS;
        }
        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          result$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          result$LWS = pointerOrPrimitive$LWS;
        }
      } else {
        safeDesc$LWS = lookupForeignDescriptor$LWS(foreignTargetPointer$LWS, shadowTarget$LWS, key$LWS);
        if (safeDesc$LWS) {
          const {
            get: getter$LWS,
            value: localValue$LWS
          } = safeDesc$LWS;
          if (getter$LWS) {
            if (safeDesc$LWS.foreign) {
              const foreignGetterPointer$LWS = getTransferablePointer$LWS(getter$LWS);
              const transferableReceiver$LWS = proxy$LWS === receiver$LWS ? foreignTargetPointer$LWS :
              // Inline getTransferableValue().
              typeof receiver$LWS === 'object' && receiver$LWS !== null || typeof receiver$LWS === 'function' ? getTransferablePointer$LWS(receiver$LWS) : receiver$LWS;
              let pointerOrPrimitive$LWS;
              try {
                pointerOrPrimitive$LWS = foreignCallableApply$LWS(foreignGetterPointer$LWS, transferableReceiver$LWS);
              } catch (error) {
                var _selectedTarget21$LWS;
                const errorToThrow$LWS = (_selectedTarget21$LWS = selectedTarget$LWS) != null ? _selectedTarget21$LWS : error;
                selectedTarget$LWS = undefined;
                throw errorToThrow$LWS;
              }
              if (typeof pointerOrPrimitive$LWS === 'function') {
                pointerOrPrimitive$LWS();
                result$LWS = selectedTarget$LWS;
                selectedTarget$LWS = undefined;
              } else {
                result$LWS = pointerOrPrimitive$LWS;
              }
            } else {
              // Even though the getter function exists,
              // we can't use `ReflectGet()` because there
              // might be a distortion for that getter function,
              // in which case we must resolve the local getter
              // and call it instead.
              result$LWS = ReflectApply$LWS(getter$LWS, receiver$LWS, []);
            }
          } else {
            result$LWS = localValue$LWS;
          }
        } else {
          const transferableReceiver$LWS = proxy$LWS === receiver$LWS ? foreignTargetPointer$LWS :
          // Inline getTransferableValue().
          typeof receiver$LWS === 'object' && receiver$LWS !== null || typeof receiver$LWS === 'function' ? getTransferablePointer$LWS(receiver$LWS) : receiver$LWS;
          let pointerOrPrimitive$LWS;
          try {
            pointerOrPrimitive$LWS = foreignCallableGet$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS, key$LWS, transferableReceiver$LWS);
          } catch (error) {
            var _selectedTarget22$LWS;
            const errorToThrow$LWS = (_selectedTarget22$LWS = selectedTarget$LWS) != null ? _selectedTarget22$LWS : error;
            selectedTarget$LWS = undefined;
            throw errorToThrow$LWS;
          }
          if (typeof pointerOrPrimitive$LWS === 'function') {
            pointerOrPrimitive$LWS();
            result$LWS = selectedTarget$LWS;
            selectedTarget$LWS = undefined;
          } else {
            result$LWS = pointerOrPrimitive$LWS;
          }
        }
      }
      if (safeDesc$LWS === undefined && result$LWS === undefined && key$LWS === SymbolToStringTag$LWS && foreignTargetTraits$LWS & 16 /* TargetTraits.IsObject */) {
        let toStringTag$LWS;
        try {
          toStringTag$LWS = foreignCallableGetToStringTagOfTarget$LWS(foreignTargetPointer$LWS);
        } catch (error) {
          var _selectedTarget23$LWS;
          const errorToThrow$LWS = (_selectedTarget23$LWS = selectedTarget$LWS) != null ? _selectedTarget23$LWS : error;
          selectedTarget$LWS = undefined;
          throw errorToThrow$LWS;
        }
        // The default language toStringTag is "Object". If we
        // receive "Object" we return `undefined` to let the
        // language resolve it naturally without projecting a
        // value.
        if (toStringTag$LWS !== 'Object') {
          result$LWS = toStringTag$LWS;
        }
      }
      return result$LWS;
    } : noop$LWS;
    BoundaryProxyHandler$LWS.hybridGetTrapForTypedArray = IS_IN_SHADOW_REALM$LWS ? function (_shadowTarget$LWS, key$LWS, receiver$LWS) {
      const {
        foreignTargetPointer: foreignTargetPointer$LWS,
        foreignTargetTypedArrayLength: foreignTargetTypedArrayLength$LWS,
        proxy: proxy$LWS,
        shadowTarget: shadowTarget$LWS
      } = this;
      let useFastPath$LWS = useFastForeignTargetPathForTypedArrays$LWS;
      if (!useFastPath$LWS && typeof key$LWS === 'string') {
        const possibleIndex$LWS = +key$LWS;
        useFastPath$LWS = possibleIndex$LWS > -1 && possibleIndex$LWS < foreignTargetTypedArrayLength$LWS && NumberIsInteger$LWS(possibleIndex$LWS);
      }
      let result$LWS;
      if (useFastPath$LWS) {
        let pointerOrPrimitive$LWS;
        try {
          pointerOrPrimitive$LWS = foreignCallableGetPropertyValue$LWS(foreignTargetPointer$LWS, key$LWS);
        } catch (error) {
          var _selectedTarget24$LWS;
          const errorToThrow$LWS = (_selectedTarget24$LWS = selectedTarget$LWS) != null ? _selectedTarget24$LWS : error;
          selectedTarget$LWS = undefined;
          throw errorToThrow$LWS;
        }
        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          result$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          result$LWS = pointerOrPrimitive$LWS;
        }
      } else {
        const safeDesc$LWS = lookupForeignDescriptor$LWS(foreignTargetPointer$LWS, shadowTarget$LWS, key$LWS);
        if (safeDesc$LWS) {
          const {
            get: getter$LWS,
            value: localValue$LWS
          } = safeDesc$LWS;
          if (getter$LWS) {
            if (safeDesc$LWS.foreign) {
              const foreignGetterPointer$LWS = getTransferablePointer$LWS(getter$LWS);
              const transferableReceiver$LWS = proxy$LWS === receiver$LWS ? foreignTargetPointer$LWS :
              // Inline getTransferableValue().
              typeof receiver$LWS === 'object' && receiver$LWS !== null || typeof receiver$LWS === 'function' ? getTransferablePointer$LWS(receiver$LWS) : receiver$LWS;
              let pointerOrPrimitive$LWS;
              try {
                pointerOrPrimitive$LWS = foreignCallableApply$LWS(foreignGetterPointer$LWS, transferableReceiver$LWS);
              } catch (error) {
                var _selectedTarget25$LWS;
                const errorToThrow$LWS = (_selectedTarget25$LWS = selectedTarget$LWS) != null ? _selectedTarget25$LWS : error;
                selectedTarget$LWS = undefined;
                throw errorToThrow$LWS;
              }
              if (typeof pointerOrPrimitive$LWS === 'function') {
                pointerOrPrimitive$LWS();
                result$LWS = selectedTarget$LWS;
                selectedTarget$LWS = undefined;
              } else {
                result$LWS = pointerOrPrimitive$LWS;
              }
            } else {
              // Even though the getter function exists,
              // we can't use `ReflectGet()` because there
              // might be a distortion for that getter function,
              // in which case we must resolve the local getter
              // and call it instead.
              result$LWS = ReflectApply$LWS(getter$LWS, receiver$LWS, []);
            }
          } else {
            result$LWS = localValue$LWS;
          }
        }
      }
      return result$LWS;
    } : noop$LWS;
    BoundaryProxyHandler$LWS.hybridHasTrap = IS_IN_SHADOW_REALM$LWS ? function (_shadowTarget$LWS, key$LWS) {
      let trueOrProtoPointerOrNull$LWS;
      try {
        trueOrProtoPointerOrNull$LWS = foreignCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS(this.foreignTargetPointer, key$LWS);
      } catch (error) {
        var _selectedTarget26$LWS;
        const errorToThrow$LWS = (_selectedTarget26$LWS = selectedTarget$LWS) != null ? _selectedTarget26$LWS : error;
        selectedTarget$LWS = undefined;
        throw errorToThrow$LWS;
      }
      let result$LWS = false;
      if (trueOrProtoPointerOrNull$LWS === true) {
        result$LWS = true;
      } else {
        // Avoiding calling the has trap for any proto chain operation,
        // instead we implement the regular logic here in this trap.
        let currentObject$LWS;
        if (typeof trueOrProtoPointerOrNull$LWS === 'function') {
          trueOrProtoPointerOrNull$LWS();
          currentObject$LWS = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        } else {
          currentObject$LWS = null;
        }
        while (currentObject$LWS) {
          if (ObjectHasOwn$LWS(currentObject$LWS, key$LWS)) {
            result$LWS = true;
            break;
          }
          currentObject$LWS = ReflectGetPrototypeOf$LWS(currentObject$LWS);
        }
      }
      return result$LWS;
    } : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.passthruGetTrap = IS_NOT_IN_SHADOW_REALM$LWS ? function (_shadowTarget$LWS, key$LWS, receiver$LWS) {
      // Only allow accessing handshake property values if the
      // "has" trap has been triggered immediately BEFORE and
      // the property does NOT exist.
      handshakePropertyFlag$LWS && (handshakePropertyFlag$LWS = lastProxyTrapCalled$LWS === 128 /* ProxyHandlerTraps.Has */);
      lastProxyTrapCalled$LWS = 16 /* ProxyHandlerTraps.Get */;
      const isNearMembraneSymbol$LWS = key$LWS === LOCKER_NEAR_MEMBRANE_SYMBOL$LWS;
      const isNearMembraneSerializedValueSymbol$LWS = key$LWS === LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS;
      if (handshakePropertyFlag$LWS) {
        // Exit without performing a [[Get]] for handshake
        // properties because we know that when the
        // `handshakePropertyFlag` is ON that there are NO
        // shadowed values.
        if (isNearMembraneSymbol$LWS) {
          return true;
        }
        if (isNearMembraneSerializedValueSymbol$LWS) {
          return this.serialize();
        }
      }
      const {
        foreignTargetPointer: foreignTargetPointer$LWS,
        foreignTargetTraits: foreignTargetTraits$LWS,
        proxy: proxy$LWS
      } = this;
      if (typeof receiver$LWS === 'undefined') {
        receiver$LWS = proxy$LWS;
      }
      const transferableReceiver$LWS = proxy$LWS === receiver$LWS ? LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS :
      // Inline getTransferableValue().
      typeof receiver$LWS === 'object' && receiver$LWS !== null || typeof receiver$LWS === 'function' ? getTransferablePointer$LWS(receiver$LWS) : receiver$LWS;
      let pointerOrPrimitive$LWS;
      try {
        pointerOrPrimitive$LWS = foreignCallableGet$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS, key$LWS, transferableReceiver$LWS);
      } catch (error) {
        var _selectedTarget27$LWS;
        const errorToThrow$LWS = (_selectedTarget27$LWS = selectedTarget$LWS) != null ? _selectedTarget27$LWS : error;
        selectedTarget$LWS = undefined;
        throw errorToThrow$LWS;
      }
      let result$LWS;
      if (typeof pointerOrPrimitive$LWS === 'function') {
        pointerOrPrimitive$LWS();
        result$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
      } else {
        result$LWS = pointerOrPrimitive$LWS;
      }
      // Getting forged values of handshake properties is not allowed.
      if (result$LWS !== undefined && (isNearMembraneSymbol$LWS || isNearMembraneSerializedValueSymbol$LWS)) {
        throw new TypeErrorCtor$LWS(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
      }
      return result$LWS;
    } : noop$LWS;
    BoundaryProxyHandler$LWS.passthruHasTrap = IS_NOT_IN_SHADOW_REALM$LWS ? function (_shadowTarget$LWS, key$LWS) {
      lastProxyTrapCalled$LWS = 128 /* ProxyHandlerTraps.Has */;
      let result$LWS;
      try {
        result$LWS = foreignCallableHas$LWS(this.foreignTargetPointer, key$LWS);
      } catch (error) {
        var _selectedTarget28$LWS;
        const errorToThrow$LWS = (_selectedTarget28$LWS = selectedTarget$LWS) != null ? _selectedTarget28$LWS : error;
        selectedTarget$LWS = undefined;
        throw errorToThrow$LWS;
      }
      const isNearMembraneSymbol$LWS = key$LWS === LOCKER_NEAR_MEMBRANE_SYMBOL$LWS;
      const isNearMembraneSerializedValueSymbol$LWS = key$LWS === LOCKER_NEAR_MEMBRANE_SERIALIZED_VALUE_SYMBOL$LWS;
      if (result$LWS) {
        handshakePropertyFlag$LWS = false;
        // Checking the existence of forged handshake properties
        // is not allowed.
        if (isNearMembraneSymbol$LWS || isNearMembraneSerializedValueSymbol$LWS) {
          throw new TypeErrorCtor$LWS(ERR_ILLEGAL_PROPERTY_ACCESS$LWS);
        }
      } else {
        // The `handshakePropertyFlag` is ON if the handshake
        // property does NOT exist on the object or its [[Prototype]].
        handshakePropertyFlag$LWS = isNearMembraneSymbol$LWS || isNearMembraneSerializedValueSymbol$LWS;
      }
      return result$LWS;
    } : alwaysFalse$LWS;
    // Pending traps:
    BoundaryProxyHandler$LWS.pendingDefinePropertyTrap = IS_IN_SHADOW_REALM$LWS ? function (shadowTarget$LWS, key$LWS, unsafePartialDesc$LWS) {
      const {
        foreignTargetPointer: foreignTargetPointer$LWS,
        foreignTargetTraits: foreignTargetTraits$LWS
      } = this;
      // We don't wrap `foreignCallableIsTargetLive()` in a
      // try-catch because it cannot throw.
      if (foreignCallableIsTargetLive$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS)) {
        this.makeProxyLive();
      } else {
        if (useFastForeignTargetPath$LWS) {
          if (isForeignPointerOfObjectProto$LWS(foreignTargetPointer$LWS)) {
            disableFastForeignTargetPointers$LWS();
          } else if (isForeignPointerOfTypedArrayProto$LWS(foreignTargetPointer$LWS)) {
            useFastForeignTargetPathForTypedArrays$LWS = false;
          }
        }
        this.makeProxyStatic();
      }
      return this.defineProperty(shadowTarget$LWS, key$LWS, unsafePartialDesc$LWS);
    } : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.pendingDeletePropertyTrap = IS_IN_SHADOW_REALM$LWS ? function (shadowTarget$LWS, key$LWS) {
      // We don't wrap `foreignCallableIsTargetLive()` in a
      // try-catch because it cannot throw.
      if (foreignCallableIsTargetLive$LWS(this.foreignTargetPointer, this.foreignTargetTraits)) {
        this.makeProxyLive();
      } else {
        this.makeProxyStatic();
      }
      return this.deleteProperty(shadowTarget$LWS, key$LWS);
    } : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.pendingPreventExtensionsTrap = IS_IN_SHADOW_REALM$LWS ? function (shadowTarget$LWS) {
      // We don't wrap `foreignCallableIsTargetLive()` in a
      // try-catch because it cannot throw.
      if (foreignCallableIsTargetLive$LWS(this.foreignTargetPointer, this.foreignTargetTraits)) {
        this.makeProxyLive();
      } else {
        this.makeProxyStatic();
      }
      return this.preventExtensions(shadowTarget$LWS);
    } : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.pendingSetPrototypeOfTrap = IS_IN_SHADOW_REALM$LWS ? function (shadowTarget$LWS, proto$LWS) {
      const {
        foreignTargetPointer: foreignTargetPointer$LWS,
        foreignTargetTraits: foreignTargetTraits$LWS
      } = this;
      // We don't wrap `foreignCallableIsTargetLive()` in a
      // try-catch because it cannot throw.
      if (foreignCallableIsTargetLive$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS)) {
        this.makeProxyLive();
      } else {
        if (useFastForeignTargetPath$LWS) {
          if (isForeignPointerOfObjectProto$LWS(foreignTargetPointer$LWS)) {
            disableFastForeignTargetPointers$LWS();
          } else if (isForeignPointerOfTypedArrayProto$LWS(foreignTargetPointer$LWS)) {
            useFastForeignTargetPathForTypedArrays$LWS = false;
          }
        }
        this.makeProxyStatic();
      }
      return this.setPrototypeOf(shadowTarget$LWS, proto$LWS);
    } : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.pendingSetTrap = IS_IN_SHADOW_REALM$LWS ? function (shadowTarget$LWS, key$LWS, value$LWS, receiver$LWS) {
      const {
        foreignTargetPointer: foreignTargetPointer$LWS,
        foreignTargetTraits: foreignTargetTraits$LWS
      } = this;
      // We don't wrap `foreignCallableIsTargetLive()` in a
      // try-catch because it cannot throw.
      if (foreignCallableIsTargetLive$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS)) {
        this.makeProxyLive();
      } else {
        if (useFastForeignTargetPath$LWS) {
          if (isForeignPointerOfObjectProto$LWS(foreignTargetPointer$LWS)) {
            disableFastForeignTargetPointers$LWS();
          } else if (isForeignPointerOfTypedArrayProto$LWS(foreignTargetPointer$LWS)) {
            useFastForeignTargetPathForTypedArrays$LWS = false;
          }
        }
        this.makeProxyStatic();
      }
      return this.set(shadowTarget$LWS, key$LWS, value$LWS, receiver$LWS);
    } : alwaysFalse$LWS;
    //  Static traps:
    BoundaryProxyHandler$LWS.staticDefinePropertyTrap = IS_IN_SHADOW_REALM$LWS ? ReflectDefineProperty$LWS : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.staticDeletePropertyTrap = IS_IN_SHADOW_REALM$LWS ? ReflectDeleteProperty$LWS : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.staticGetOwnPropertyDescriptorTrap = IS_IN_SHADOW_REALM$LWS ? ReflectGetOwnPropertyDescriptor$LWS : noop$LWS;
    BoundaryProxyHandler$LWS.staticGetPrototypeOfTrap = IS_IN_SHADOW_REALM$LWS ? ReflectGetPrototypeOf$LWS : () => null;
    BoundaryProxyHandler$LWS.staticGetTrap = IS_IN_SHADOW_REALM$LWS ? function (shadowTarget$LWS, key$LWS, receiver$LWS) {
      const {
        foreignTargetTraits: foreignTargetTraits$LWS,
        staticToStringTag: staticToStringTag$LWS
      } = this;
      const result$LWS = ReflectGet$LWS(shadowTarget$LWS, key$LWS, receiver$LWS);
      if (result$LWS === undefined && key$LWS === SymbolToStringTag$LWS && foreignTargetTraits$LWS & 16 /* TargetTraits.IsObject */ &&
      // The default language toStringTag is "Object". If we
      // receive "Object" we return `undefined` to let the
      // language resolve it naturally without projecting a
      // value.
      staticToStringTag$LWS !== 'Object' && !(key$LWS in shadowTarget$LWS)) {
        return staticToStringTag$LWS;
      }
      return result$LWS;
    } : noop$LWS;
    BoundaryProxyHandler$LWS.staticHasTrap = IS_IN_SHADOW_REALM$LWS ? ReflectHas$LWS : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.staticIsExtensibleTrap = IS_IN_SHADOW_REALM$LWS ? ReflectIsExtensible$LWS : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.staticOwnKeysTrap = IS_IN_SHADOW_REALM$LWS ? ReflectOwnKeys$LWS : () => [];
    BoundaryProxyHandler$LWS.staticPreventExtensionsTrap = IS_IN_SHADOW_REALM$LWS ? ReflectPreventExtensions$LWS : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.staticSetPrototypeOfTrap = IS_IN_SHADOW_REALM$LWS ? ReflectSetPrototypeOf$LWS : alwaysFalse$LWS;
    BoundaryProxyHandler$LWS.staticSetTrap = IS_IN_SHADOW_REALM$LWS ? ReflectSet$LWS : alwaysFalse$LWS;
    // Default traps:
    // Pending traps are needed for the shadow realm side of the membrane
    // to avoid leaking mutation operations on the primary realm side.
    BoundaryProxyHandler$LWS.defaultDefinePropertyTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.pendingDefinePropertyTrap : BoundaryProxyHandler$LWS.passthruDefinePropertyTrap;
    BoundaryProxyHandler$LWS.defaultDeletePropertyTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.pendingDeletePropertyTrap : BoundaryProxyHandler$LWS.passthruDeletePropertyTrap;
    BoundaryProxyHandler$LWS.defaultGetOwnPropertyDescriptorTrap = BoundaryProxyHandler$LWS.passthruGetOwnPropertyDescriptorTrap;
    BoundaryProxyHandler$LWS.defaultGetPrototypeOfTrap = BoundaryProxyHandler$LWS.passthruGetPrototypeOfTrap;
    BoundaryProxyHandler$LWS.defaultGetTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.hybridGetTrap : BoundaryProxyHandler$LWS.passthruGetTrap;
    BoundaryProxyHandler$LWS.defaultHasTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.hybridHasTrap : BoundaryProxyHandler$LWS.passthruHasTrap;
    BoundaryProxyHandler$LWS.defaultIsExtensibleTrap = BoundaryProxyHandler$LWS.passthruIsExtensibleTrap;
    BoundaryProxyHandler$LWS.defaultOwnKeysTrap = BoundaryProxyHandler$LWS.passthruOwnKeysTrap;
    BoundaryProxyHandler$LWS.defaultPreventExtensionsTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.pendingPreventExtensionsTrap : BoundaryProxyHandler$LWS.passthruPreventExtensionsTrap;
    BoundaryProxyHandler$LWS.defaultSetTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.pendingSetTrap : BoundaryProxyHandler$LWS.passthruSetTrap;
    BoundaryProxyHandler$LWS.defaultSetPrototypeOfTrap = IS_IN_SHADOW_REALM$LWS ? BoundaryProxyHandler$LWS.pendingSetPrototypeOfTrap : BoundaryProxyHandler$LWS.passthruSetPrototypeOfTrap;
    if (IS_IN_SHADOW_REALM$LWS) {
      // Initialize `fastForeignTargetPointers` weak map.
      clearFastForeignTargetPointers$LWS();
    }
    // Export callable hooks to a foreign realm.
    foreignCallableHooksCallback$LWS(
    // globalThisPointer
    // When crossing, should be mapped to the foreign globalThis
    createPointer$LWS(globalThisRef$LWS),
    // getSelectedTarget
    IS_NOT_IN_SHADOW_REALM$LWS ? () => {
      const result$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      return result$LWS;
    } : noop$LWS,
    // getTransferableValue
    value$LWS => {
      if (typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function') {
        return getTransferablePointer$LWS(value$LWS);
      }
      // Intentionally ignoring `document.all`.
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
      return typeof value$LWS === 'undefined' ? undefined : value$LWS;
    },
    // callableGetPropertyValuePointer: this callable function allows
    // the foreign realm to access a linkable pointer for a property value.
    // In order to do that, the foreign side must provide a pointer and
    // a key access the value in order to produce a pointer
    (targetPointer$LWS, key$LWS) => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      const value$LWS = target$LWS == null ? void 0 : target$LWS[key$LWS];
      // Intentionally ignoring `document.all`.
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
      return createPointer$LWS(typeof value$LWS === 'undefined' ? undefined : value$LWS);
    },
    // callableEvaluate
    IS_IN_SHADOW_REALM$LWS ? sourceText$LWS => {
      let result$LWS;
      try {
        result$LWS = localEval$LWS(sourceText$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
      // Inline getTransferableValue().
      return typeof result$LWS === 'object' && result$LWS !== null || typeof result$LWS === 'function' ? getTransferablePointer$LWS(result$LWS) : result$LWS;
    } : noop$LWS,
    // callableLinkPointers: this callable function allows the foreign
    // realm to define a linkage between two values across the membrane.
    (targetPointer$LWS, newPointer$LWS) => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      if (typeof target$LWS === 'object' && target$LWS !== null || typeof target$LWS === 'function') {
        proxyPointerCache$LWS.set(target$LWS, newPointer$LWS);
      }
    },
    // callablePushErrorTarget
    LOCKER_DEBUGGABLE_FLAG$LWS ? (foreignTargetPointer$LWS, foreignTargetTraits$LWS, foreignTargetFunctionArity$LWS, foreignTargetFunctionName$LWS, foreignTargetTypedArrayLength$LWS) => {
      const pointer$LWS = pushTarget$LWS(foreignTargetPointer$LWS, foreignTargetTraits$LWS, foreignTargetFunctionArity$LWS, foreignTargetFunctionName$LWS, foreignTargetTypedArrayLength$LWS);
      const pointerWrapper$LWS = () => {
        checkDebugMode$LWS();
        return pointer$LWS();
      };
      return pointerWrapper$LWS;
    } : pushTarget$LWS,
    // callablePushTarget: This function can be used by a foreign realm
    // to install a proxy into this realm that correspond to an object
    // from the foreign realm. It returns a Pointer that can be used by
    // the foreign realm to pass back a reference to this realm when
    // passing arguments or returning from a foreign callable invocation.
    // This function is extremely important to understand the mechanics
    // of this membrane.
    pushTarget$LWS,
    // callableApply
    (targetPointer$LWS, thisArgPointerOrUndefined$LWS, ...args$LWS) => {
      targetPointer$LWS();
      const func$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let thisArg$LWS;
      if (typeof thisArgPointerOrUndefined$LWS === 'function') {
        thisArgPointerOrUndefined$LWS();
        thisArg$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
      }
      for (let i$LWS = 0, {
          length: length$LWS
        } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const pointerOrPrimitive$LWS = args$LWS[i$LWS];
        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          args$LWS[i$LWS] = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        }
      }
      let result$LWS;
      try {
        result$LWS = ReflectApply$LWS(func$LWS, thisArg$LWS, args$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
      // Inline getTransferableValue().
      return typeof result$LWS === 'object' && result$LWS !== null || typeof result$LWS === 'function' ? getTransferablePointer$LWS(result$LWS) :
      // Intentionally ignoring `document.all`.
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
      typeof result$LWS === 'undefined' ? undefined : result$LWS;
    },
    // callableConstruct
    (targetPointer$LWS, newTargetPointerOrUndefined$LWS, ...args$LWS) => {
      targetPointer$LWS();
      const constructor$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let newTarget$LWS;
      if (typeof newTargetPointerOrUndefined$LWS === 'function') {
        newTargetPointerOrUndefined$LWS();
        newTarget$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
      }
      for (let i$LWS = 0, {
          length: length$LWS
        } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const pointerOrPrimitive$LWS = args$LWS[i$LWS];
        if (typeof pointerOrPrimitive$LWS === 'function') {
          pointerOrPrimitive$LWS();
          args$LWS[i$LWS] = selectedTarget$LWS;
          selectedTarget$LWS = undefined;
        }
      }
      let result$LWS;
      try {
        result$LWS = ReflectConstruct$LWS(constructor$LWS, args$LWS, newTarget$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
      // Inline getTransferableValue().
      return typeof result$LWS === 'object' && result$LWS !== null || typeof result$LWS === 'function' ? getTransferablePointer$LWS(result$LWS) :
      // Intentionally ignoring `document.all`.
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
      typeof result$LWS === 'undefined' ? undefined : result$LWS;
    },
    // callableDefineProperty
    (targetPointer$LWS, key$LWS, configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS, foreignCallableNonConfigurableDescriptorCallback$LWS) => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      const safePartialDesc$LWS = createDescriptorFromMeta$LWS(configurable$LWS, enumerable$LWS, writable$LWS, valuePointer$LWS, getterPointer$LWS, setterPointer$LWS);
      let result$LWS = false;
      try {
        result$LWS = ReflectDefineProperty$LWS(target$LWS, key$LWS, safePartialDesc$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
      if (result$LWS && configurable$LWS === false) {
        let safeDesc$LWS;
        try {
          safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(target$LWS, key$LWS);
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
        if (safeDesc$LWS) {
          ReflectSetPrototypeOf$LWS(safeDesc$LWS, null);
          if (safeDesc$LWS.configurable === false) {
            const {
              get: getter$LWS,
              set: setter$LWS,
              value: value$LWS
            } = safeDesc$LWS;
            foreignCallableNonConfigurableDescriptorCallback$LWS(key$LWS, false,
            // configurable
            'enumerable' in safeDesc$LWS ? safeDesc$LWS.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'writable' in safeDesc$LWS ? safeDesc$LWS.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'value' in safeDesc$LWS ?
            // Inline getTransferableValue().
            typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function' ? getTransferablePointer$LWS(value$LWS) : value$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'get' in safeDesc$LWS ?
            // Inline getTransferableValue().
            typeof getter$LWS === 'function' ? getTransferablePointer$LWS(getter$LWS) : getter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'set' in safeDesc$LWS ?
            // Inline getTransferableValue().
            typeof setter$LWS === 'function' ? getTransferablePointer$LWS(setter$LWS) : setter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS);
          }
        }
      }
      return result$LWS;
    },
    // callableDeleteProperty
    (targetPointer$LWS, key$LWS) => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      try {
        return ReflectDeleteProperty$LWS(target$LWS, key$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
    },
    // callableGet
    (targetPointer$LWS, targetTraits$LWS, key$LWS, receiverPointerOrPrimitive$LWS) => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let receiver$LWS;
      if (typeof receiverPointerOrPrimitive$LWS === 'function') {
        receiverPointerOrPrimitive$LWS();
        receiver$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
      } else {
        receiver$LWS = receiverPointerOrPrimitive$LWS === LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS ? target$LWS : receiverPointerOrPrimitive$LWS;
      }
      let result$LWS;
      try {
        result$LWS = ReflectGet$LWS(target$LWS, key$LWS, receiver$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
      // Inline getTransferableValue().
      if (typeof result$LWS === 'object' && result$LWS !== null || typeof result$LWS === 'function') {
        return getTransferablePointer$LWS(result$LWS);
      }
      if (result$LWS === undefined && key$LWS === SymbolToStringTag$LWS && targetTraits$LWS & 16 /* TargetTraits.IsObject */) {
        try {
          if (!(key$LWS in target$LWS)) {
            // Section 19.1.3.6 Object.prototype.toString()
            // https://tc39.github.io/ecma262/#sec-object.prototype.tostring
            const brand$LWS = ReflectApply$LWS(ObjectProtoToString$LWS, target$LWS, []);
            // The default language toStringTag is "Object". If
            // we receive "[object Object]" we return `undefined`
            // to let the language resolve it naturally without
            // projecting a value.
            if (brand$LWS !== '[object Object]') {
              result$LWS = ReflectApply$LWS(StringProtoSlice$LWS, brand$LWS, [8, -1]);
            }
          }
        } catch (error) {
          throw pushErrorAcrossBoundary$LWS(error);
        }
      }
      // Intentionally ignoring `document.all`.
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
      return typeof result$LWS === 'undefined' ? undefined : result$LWS;
    },
    // callableGetOwnPropertyDescriptor
    (targetPointer$LWS, key$LWS, foreignCallableDescriptorCallback$LWS) => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let safeDesc$LWS;
      try {
        safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(target$LWS, key$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
      if (safeDesc$LWS) {
        ReflectSetPrototypeOf$LWS(safeDesc$LWS, null);
        const {
          get: getter$LWS,
          set: setter$LWS,
          value: value$LWS
        } = safeDesc$LWS;
        foreignCallableDescriptorCallback$LWS(key$LWS, 'configurable' in safeDesc$LWS ? safeDesc$LWS.configurable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'enumerable' in safeDesc$LWS ? safeDesc$LWS.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'writable' in safeDesc$LWS ? safeDesc$LWS.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'value' in safeDesc$LWS ?
        // Inline getTransferableValue().
        typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function' ? getTransferablePointer$LWS(value$LWS) :
        // Intentionally ignoring `document.all`.
        // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
        // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
        typeof value$LWS === 'undefined' ? undefined : value$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'get' in safeDesc$LWS ?
        // Inline getTransferableValue().
        typeof getter$LWS === 'function' ? getTransferablePointer$LWS(getter$LWS) : getter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'set' in safeDesc$LWS ?
        // Inline getTransferableValue().
        typeof setter$LWS === 'function' ? getTransferablePointer$LWS(setter$LWS) : setter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS);
      }
    },
    // callableGetPrototypeOf
    targetPointer$LWS => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let proto$LWS;
      try {
        proto$LWS = ReflectGetPrototypeOf$LWS(target$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
      // Intentionally ignoring `document.all`.
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
      if (typeof proto$LWS === 'undefined') {
        return null;
      }
      return proto$LWS ? getTransferablePointer$LWS(proto$LWS) : proto$LWS;
    },
    // callableHas
    (targetPointer$LWS, key$LWS) => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      try {
        return key$LWS in target$LWS;
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
    },
    // callableIsExtensible
    targetPointer$LWS => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      try {
        return ReflectIsExtensible$LWS(target$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
    },
    // callableOwnKeys
    (targetPointer$LWS, foreignCallableKeysCallback$LWS) => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let ownKeys$LWS;
      try {
        ownKeys$LWS = ReflectOwnKeys$LWS(target$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
      ReflectApply$LWS(foreignCallableKeysCallback$LWS, undefined, ownKeys$LWS);
    },
    // callablePreventExtensions
    targetPointer$LWS => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let result$LWS = 2 /* PreventExtensionsResult.False */;
      try {
        if (ReflectPreventExtensions$LWS(target$LWS)) {
          result$LWS = 4 /* PreventExtensionsResult.True */;
        } else if (ReflectIsExtensible$LWS(target$LWS)) {
          result$LWS |= 1 /* PreventExtensionsResult.Extensible */;
        }
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
      return result$LWS;
    },
    // callableSet
    (targetPointer$LWS, key$LWS, valuePointerOrPrimitive$LWS) => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let value$LWS;
      if (typeof valuePointerOrPrimitive$LWS === 'function') {
        valuePointerOrPrimitive$LWS();
        value$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
      } else {
        value$LWS = valuePointerOrPrimitive$LWS;
      }
      try {
        return ReflectSet$LWS(target$LWS, key$LWS, value$LWS, target$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
    },
    // callableSetPrototypeOf
    (targetPointer$LWS, protoPointerOrNull$LWS = null) => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let proto$LWS;
      if (typeof protoPointerOrNull$LWS === 'function') {
        // Instead of calling `protoPointerOrNull()` directly we use
        // `ReflectApply` to avoid a Maglev (https://v8.dev/blog/maglev)
        // optimizing JIT bug in Chrome >= 117:
        // https://bugs.chromium.org/p/chromium/issues/detail?id=1494060
        ReflectApply$LWS(protoPointerOrNull$LWS, undefined, []);
        proto$LWS = selectedTarget$LWS;
        selectedTarget$LWS = undefined;
      } else {
        proto$LWS = null;
      }
      try {
        return ReflectSetPrototypeOf$LWS(target$LWS, proto$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
    },
    // callableDebugInfo
    LOCKER_DEBUGGABLE_FLAG$LWS ? (...args$LWS) => {
      if (checkDebugMode$LWS()) {
        for (let i$LWS = 0, {
            length: length$LWS
          } = args$LWS; i$LWS < length$LWS; i$LWS += 1) {
          const pointerOrPrimitive$LWS = args$LWS[i$LWS];
          if (typeof pointerOrPrimitive$LWS === 'function') {
            pointerOrPrimitive$LWS();
            args$LWS[i$LWS] = selectedTarget$LWS;
            selectedTarget$LWS = undefined;
          }
        }
        try {
          ReflectApply$LWS(consoleInfo$LWS, consoleObject$LWS, args$LWS);
          // eslint-disable-next-line no-empty
        } catch (_unused29$LWS) {}
      }
    } : noop$LWS,
    // callableDefineProperties
    IS_IN_SHADOW_REALM$LWS ? (targetPointer$LWS, ...descriptorTuples$LWS) => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      for (let i$LWS = 0, {
          length: length$LWS
        } = descriptorTuples$LWS; i$LWS < length$LWS; i$LWS += 7) {
        // We don't use `ObjectDefineProperties()` here because it
        // will throw an exception if it fails to define one of its
        // properties.
        ReflectDefineProperty$LWS(target$LWS, descriptorTuples$LWS[i$LWS], createDescriptorFromMeta$LWS(descriptorTuples$LWS[i$LWS + 1],
        // configurable
        descriptorTuples$LWS[i$LWS + 2],
        // enumerable
        descriptorTuples$LWS[i$LWS + 3],
        // writable
        descriptorTuples$LWS[i$LWS + 4],
        // valuePointer
        descriptorTuples$LWS[i$LWS + 5],
        // getterPointer
        descriptorTuples$LWS[i$LWS + 6] // setterPointer
        ));
      }
    } : noop$LWS,
    // callableGetLazyPropertyDescriptorStateByTarget
    IS_NOT_IN_SHADOW_REALM$LWS ? targetPointer$LWS => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      // We don't wrap the weak map `get()` call in a try-catch
      // because we know `target` is an object.
      const state$LWS = proxyTargetToLazyPropertyDescriptorStateMap$LWS.get(target$LWS);
      return state$LWS ? getTransferablePointer$LWS(state$LWS) : state$LWS;
    } : noop$LWS,
    // callableGetPropertyValue
    IS_NOT_IN_SHADOW_REALM$LWS ? (targetPointer$LWS, key$LWS) => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let value$LWS;
      try {
        value$LWS = target$LWS[key$LWS];
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
      return typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function' ? getTransferablePointer$LWS(value$LWS) : value$LWS;
    } : noop$LWS,
    // callableGetTargetIntegrityTraits
    IS_NOT_IN_SHADOW_REALM$LWS ? targetPointer$LWS => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      // A target may be a proxy that is revoked or throws in its
      // "isExtensible" trap.
      try {
        if (!ReflectIsExtensible$LWS(target$LWS)) {
          if (ObjectIsFrozen$LWS(target$LWS)) {
            return 4 /* TargetIntegrityTraits.IsFrozen */ & 2 /* TargetIntegrityTraits.IsSealed */ & 1 /* TargetIntegrityTraits.IsNotExtensible */;
          }
          if (ObjectIsSealed$LWS(target$LWS)) {
            return 2 /* TargetIntegrityTraits.IsSealed */ & 1 /* TargetIntegrityTraits.IsNotExtensible */;
          }
          return 1 /* TargetIntegrityTraits.IsNotExtensible */;
        }
      } catch (_unused30$LWS) {
        try {
          isArrayOrThrowForRevoked$LWS(target$LWS);
        } catch (_unused31$LWS) {
          return 8 /* TargetIntegrityTraits.Revoked */;
        }
      }
      return 0 /* TargetIntegrityTraits.None */;
    } : () => 0 /* TargetIntegrityTraits.None */,
    // callableGetToStringTagOfTarget
    targetPointer$LWS => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      try {
        // Section 19.1.3.6 Object.prototype.toString()
        // https://tc39.github.io/ecma262/#sec-object.prototype.tostring
        const brand$LWS = ReflectApply$LWS(ObjectProtoToString$LWS, target$LWS, []);
        return brand$LWS === '[object Object]' ? 'Object' : ReflectApply$LWS(StringProtoSlice$LWS, brand$LWS, [8, -1]);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
    },
    // callableInstallErrorPrepareStackTrace
    installErrorPrepareStackTrace$LWS,
    // callableInstallLazyPropertyDescriptors
    IS_IN_SHADOW_REALM$LWS ? (targetPointer$LWS, ...ownKeysAndUnforgeableGlobalThisKeys$LWS) => {
      const sliceIndex$LWS = ReflectApply$LWS(ArrayProtoIndexOf$LWS, ownKeysAndUnforgeableGlobalThisKeys$LWS, [LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS]);
      let ownKeys$LWS;
      let unforgeableGlobalThisKeys$LWS;
      if (sliceIndex$LWS === -1) {
        ownKeys$LWS = ownKeysAndUnforgeableGlobalThisKeys$LWS;
      } else {
        ownKeys$LWS = ReflectApply$LWS(ArrayProtoSlice$LWS, ownKeysAndUnforgeableGlobalThisKeys$LWS, [0, sliceIndex$LWS]);
        unforgeableGlobalThisKeys$LWS = ReflectApply$LWS(ArrayProtoSlice$LWS, ownKeysAndUnforgeableGlobalThisKeys$LWS, [sliceIndex$LWS + 1]);
      }
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let state$LWS = getLazyPropertyDescriptorStateByTarget$LWS(target$LWS);
      if (state$LWS === undefined) {
        state$LWS = {
          __proto__: null
        };
        setLazyPropertyDescriptorStateByTarget$LWS(target$LWS, state$LWS);
      }
      for (let i$LWS = 0, {
          length: length$LWS
        } = ownKeys$LWS; i$LWS < length$LWS; i$LWS += 1) {
        const ownKey$LWS = ownKeys$LWS[i$LWS];
        state$LWS[ownKey$LWS] = true;
        ReflectDefineProperty$LWS(target$LWS, ownKey$LWS,
        // The role of this descriptor is to serve as a
        // bouncer. When either a getter or a setter is
        // invoked the descriptor will be replaced with
        // the descriptor from the foreign side and the
        // get/set operation will carry on from there.
        {
          __proto__: null,
          // We DO explicitly set configurability in the
          // off chance that the property doesn't exist.
          configurable: true,
          // We DON'T explicitly set enumerability to
          // defer to the enumerability of the existing
          // property. In the off chance the property
          // doesn't exist the property will be defined
          // as non-enumerable.
          get() {
            activateLazyOwnPropertyDefinition$LWS(target$LWS, ownKey$LWS, state$LWS);
            return target$LWS[ownKey$LWS];
          },
          set(value$LWS) {
            activateLazyOwnPropertyDefinition$LWS(target$LWS, ownKey$LWS, state$LWS);
            ReflectSet$LWS(target$LWS, ownKey$LWS, value$LWS);
          }
        });
      }
      installPropertyDescriptorMethodWrappers$LWS(unforgeableGlobalThisKeys$LWS);
    } : noop$LWS,
    // callableIsTargetLive
    IS_NOT_IN_SHADOW_REALM$LWS && liveTargetCallback$LWS ? (targetPointer$LWS, targetTraits$LWS) => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      if (target$LWS !== ObjectProto$LWS && target$LWS !== RegExpProto$LWS) {
        try {
          return liveTargetCallback$LWS(target$LWS, targetTraits$LWS);
          // eslint-disable-next-line no-empty
        } catch (_unused32$LWS) {}
      }
      return false;
    } : alwaysFalse$LWS,
    // callableIsTargetRevoked
    IS_NOT_IN_SHADOW_REALM$LWS ? targetPointer$LWS => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      try {
        isArrayOrThrowForRevoked$LWS(target$LWS);
        return false;
        //  eslint-disable-next-line no-empty
      } catch (_unused33$LWS) {}
      return true;
    } : alwaysFalse$LWS,
    // callableSerializeTarget
    IS_IN_SHADOW_REALM$LWS ? targetPointer$LWS => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      try {
        return SymbolToStringTag$LWS in target$LWS ? serializeTargetByTrialAndError$LWS(target$LWS) :
        // Fast path.
        serializeTargetByBrand$LWS(target$LWS);
        // eslint-disable-next-line no-empty
      } catch (_unused34$LWS) {}
      return undefined;
    } : noop$LWS,
    // callableSetLazyPropertyDescriptorStateByTarget
    IS_NOT_IN_SHADOW_REALM$LWS ? (targetPointer$LWS, statePointer$LWS) => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      statePointer$LWS();
      const state$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      // We don't wrap the weak map `set()` call in a try-catch
      // because we know `target` is an object.
      proxyTargetToLazyPropertyDescriptorStateMap$LWS.set(target$LWS, state$LWS);
    } : noop$LWS,
    // callableTrackAsFastTarget
    IS_IN_SHADOW_REALM$LWS ? targetPointer$LWS => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      if (useFastForeignTargetPath$LWS) {
        fastForeignTargetPointers$LWS.add(getTransferablePointer$LWS(target$LWS));
      }
    } : noop$LWS,
    // callableBatchGetPrototypeOfAndGetOwnPropertyDescriptors
    (targetPointer$LWS, foreignCallableDescriptorsCallback$LWS) => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let unsafeDescs$LWS;
      try {
        unsafeDescs$LWS = ObjectGetOwnPropertyDescriptors$LWS(target$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
      const ownKeys$LWS = ReflectOwnKeys$LWS(unsafeDescs$LWS);
      const {
        length: length$LWS
      } = ownKeys$LWS;
      const descriptorTuples$LWS = new ArrayCtor$LWS(length$LWS * 7);
      for (let i$LWS = 0, j$LWS = 0; i$LWS < length$LWS; i$LWS += 1, j$LWS += 7) {
        const ownKey$LWS = ownKeys$LWS[i$LWS];
        const safeDesc$LWS = unsafeDescs$LWS[ownKey$LWS];
        ReflectSetPrototypeOf$LWS(safeDesc$LWS, null);
        const {
          get: getter$LWS,
          set: setter$LWS,
          value: value$LWS
        } = safeDesc$LWS;
        descriptorTuples$LWS[j$LWS] = ownKey$LWS;
        descriptorTuples$LWS[j$LWS + 1] = 'configurable' in safeDesc$LWS ? safeDesc$LWS.configurable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        descriptorTuples$LWS[j$LWS + 2] = 'enumerable' in safeDesc$LWS ? safeDesc$LWS.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        descriptorTuples$LWS[j$LWS + 3] = 'writable' in safeDesc$LWS ? safeDesc$LWS.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        descriptorTuples$LWS[j$LWS + 4] = 'value' in safeDesc$LWS ?
        // Inline getTransferableValue().
        typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function' ? getTransferablePointer$LWS(value$LWS) : value$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        descriptorTuples$LWS[j$LWS + 5] = 'get' in safeDesc$LWS ?
        // Inline getTransferableValue().
        typeof getter$LWS === 'function' ? getTransferablePointer$LWS(getter$LWS) : getter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        descriptorTuples$LWS[j$LWS + 6] = 'set' in safeDesc$LWS ?
        // Inline getTransferableValue().
        typeof setter$LWS === 'function' ? getTransferablePointer$LWS(setter$LWS) : setter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
      }
      ReflectApply$LWS(foreignCallableDescriptorsCallback$LWS, undefined, descriptorTuples$LWS);
      let proto$LWS;
      try {
        proto$LWS = ReflectGetPrototypeOf$LWS(target$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
      // Intentionally ignoring `document.all`.
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
      if (typeof proto$LWS === 'undefined') {
        return null;
      }
      return proto$LWS ? getTransferablePointer$LWS(proto$LWS) : proto$LWS;
    },
    // callableBatchGetPrototypeOfWhenHasNoOwnProperty
    (targetPointer$LWS, key$LWS) => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let proto$LWS;
      try {
        if (ObjectHasOwn$LWS(target$LWS, key$LWS)) {
          return true;
        }
        proto$LWS = ReflectGetPrototypeOf$LWS(target$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
      // Intentionally ignoring `document.all`.
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
      if (typeof proto$LWS === 'undefined') {
        return null;
      }
      return proto$LWS ? getTransferablePointer$LWS(proto$LWS) : proto$LWS;
    },
    // callableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor
    (targetPointer$LWS, key$LWS, foreignCallableDescriptorCallback$LWS) => {
      targetPointer$LWS();
      const target$LWS = selectedTarget$LWS;
      selectedTarget$LWS = undefined;
      let safeDesc$LWS;
      try {
        safeDesc$LWS = ReflectGetOwnPropertyDescriptor$LWS(target$LWS, key$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
      if (safeDesc$LWS) {
        ReflectSetPrototypeOf$LWS(safeDesc$LWS, null);
        const {
          get: getter$LWS,
          set: setter$LWS,
          value: value$LWS
        } = safeDesc$LWS;
        foreignCallableDescriptorCallback$LWS(key$LWS, 'configurable' in safeDesc$LWS ? safeDesc$LWS.configurable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'enumerable' in safeDesc$LWS ? safeDesc$LWS.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'writable' in safeDesc$LWS ? safeDesc$LWS.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'value' in safeDesc$LWS ?
        // Inline getTransferableValue().
        typeof value$LWS === 'object' && value$LWS !== null || typeof value$LWS === 'function' ? getTransferablePointer$LWS(value$LWS) :
        // Intentionally ignoring `document.all`.
        // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
        // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
        typeof value$LWS === 'undefined' ? undefined : value$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'get' in safeDesc$LWS ?
        // Inline getTransferableValue().
        typeof getter$LWS === 'function' ? getTransferablePointer$LWS(getter$LWS) : getter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS, 'set' in safeDesc$LWS ?
        // Inline getTransferableValue().
        typeof setter$LWS === 'function' ? getTransferablePointer$LWS(setter$LWS) : setter$LWS : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS);
        return undefined;
      }
      let proto$LWS;
      try {
        proto$LWS = ReflectGetPrototypeOf$LWS(target$LWS);
      } catch (error) {
        throw pushErrorAcrossBoundary$LWS(error);
      }
      // Intentionally ignoring `document.all`.
      // https://developer.mozilla.org/en-US/docs/Web/API/Document/all
      // https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
      if (typeof proto$LWS === 'undefined') {
        return null;
      }
      return proto$LWS ? getTransferablePointer$LWS(proto$LWS) : proto$LWS;
    });
    let foreignCallablesHooked$LWS = false;
    return (...hooks$LWS) => {
      if (foreignCallablesHooked$LWS) {
        return;
      }
      foreignCallablesHooked$LWS = true;
      ({
        // 0: globalThisPointer,
        // 1: getSelectedTarget,
        // 2: getTransferableValue,
        // 3: callableGetPropertyValuePointer,
        // 4: callableEvaluate,
        // 5: callableLinkPointers,
        6: foreignCallablePushErrorTarget$LWS,
        7: foreignCallablePushTarget$LWS,
        8: foreignCallableApply$LWS,
        9: foreignCallableConstruct$LWS,
        10: foreignCallableDefineProperty$LWS,
        11: foreignCallableDeleteProperty$LWS,
        12: foreignCallableGet$LWS,
        13: foreignCallableGetOwnPropertyDescriptor$LWS,
        14: foreignCallableGetPrototypeOf$LWS,
        15: foreignCallableHas$LWS,
        16: foreignCallableIsExtensible$LWS,
        17: foreignCallableOwnKeys$LWS,
        18: foreignCallablePreventExtensions$LWS,
        19: foreignCallableSet$LWS,
        20: foreignCallableSetPrototypeOf$LWS,
        21: foreignCallableDebugInfo$LWS,
        // 22: callableDefineProperties,
        23: foreignCallableGetLazyPropertyDescriptorStateByTarget$LWS,
        24: foreignCallableGetPropertyValue$LWS,
        25: foreignCallableGetTargetIntegrityTraits$LWS,
        26: foreignCallableGetToStringTagOfTarget$LWS,
        27: foreignCallableInstallErrorPrepareStackTrace$LWS,
        // 28: callableInstallLazyPropertyDescriptors,
        29: foreignCallableIsTargetLive$LWS,
        30: foreignCallableIsTargetRevoked$LWS,
        31: foreignCallableSerializeTarget$LWS,
        32: foreignCallableSetLazyPropertyDescriptorStateByTarget$LWS,
        // 33: callableTrackAsFastTarget,
        34: foreignCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS,
        35: foreignCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS,
        36: foreignCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS
      } = hooks$LWS);
      const applyTrapForZeroOrMoreArgs$LWS = createApplyOrConstructTrapForZeroOrMoreArgs$LWS(1 /* ProxyHandlerTraps.Apply */);
      const applyTrapForOneOrMoreArgs$LWS = createApplyOrConstructTrapForOneOrMoreArgs$LWS(1 /* ProxyHandlerTraps.Apply */);
      const applyTrapForTwoOrMoreArgs$LWS = createApplyOrConstructTrapForTwoOrMoreArgs$LWS(1 /* ProxyHandlerTraps.Apply */);
      const applyTrapForThreeOrMoreArgs$LWS = createApplyOrConstructTrapForThreeOrMoreArgs$LWS(1 /* ProxyHandlerTraps.Apply */);
      const applyTrapForFourOrMoreArgs$LWS = createApplyOrConstructTrapForFourOrMoreArgs$LWS(1 /* ProxyHandlerTraps.Apply */);
      const applyTrapForFiveOrMoreArgs$LWS = createApplyOrConstructTrapForFiveOrMoreArgs$LWS(1 /* ProxyHandlerTraps.Apply */);
      const applyTrapForAnyNumberOfArgs$LWS = createApplyOrConstructTrapForAnyNumberOfArgs$LWS(1 /* ProxyHandlerTraps.Apply */);
      const constructTrapForZeroOrMoreArgs$LWS = createApplyOrConstructTrapForZeroOrMoreArgs$LWS(2 /* ProxyHandlerTraps.Construct */);
      const constructTrapForOneOrMoreArgs$LWS = createApplyOrConstructTrapForOneOrMoreArgs$LWS(2 /* ProxyHandlerTraps.Construct */);
      const constructTrapForTwoOrMoreArgs$LWS = createApplyOrConstructTrapForTwoOrMoreArgs$LWS(2 /* ProxyHandlerTraps.Construct */);
      const constructTrapForThreeOrMoreArgs$LWS = createApplyOrConstructTrapForThreeOrMoreArgs$LWS(2 /* ProxyHandlerTraps.Construct */);
      const constructTrapForFourOrMoreArgs$LWS = createApplyOrConstructTrapForFourOrMoreArgs$LWS(2 /* ProxyHandlerTraps.Construct */);
      const constructTrapForFiveOrMoreArgs$LWS = createApplyOrConstructTrapForFiveOrMoreArgs$LWS(2 /* ProxyHandlerTraps.Construct */);
      const constructTrapForAnyNumberOfArgs$LWS = createApplyOrConstructTrapForAnyNumberOfArgs$LWS(2 /* ProxyHandlerTraps.Construct */);
      if (MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS === undefined) {
        // A minification safe way to get the 'apply' and 'construct'
        // trap property names.
        MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS = ObjectKeys$LWS({
          applyTrapForZeroOrMoreArgs: applyTrapForZeroOrMoreArgs$LWS,
          applyTrapForOneOrMoreArgs: applyTrapForOneOrMoreArgs$LWS,
          applyTrapForTwoOrMoreArgs: applyTrapForTwoOrMoreArgs$LWS,
          applyTrapForThreeOrMoreArgs: applyTrapForThreeOrMoreArgs$LWS,
          applyTrapForFourOrMoreArgs: applyTrapForFourOrMoreArgs$LWS,
          applyTrapForFiveOrMoreArgs: applyTrapForFiveOrMoreArgs$LWS,
          applyTrapForAnyNumberOfArgs: applyTrapForAnyNumberOfArgs$LWS,
          constructTrapForZeroOrMoreArgs: constructTrapForZeroOrMoreArgs$LWS,
          constructTrapForOneOrMoreArgs: constructTrapForOneOrMoreArgs$LWS,
          constructTrapForTwoOrMoreArgs: constructTrapForTwoOrMoreArgs$LWS,
          constructTrapForThreeOrMoreArgs: constructTrapForThreeOrMoreArgs$LWS,
          constructTrapForFourOrMoreArgs: constructTrapForFourOrMoreArgs$LWS,
          constructTrapForFiveOrMoreArgs: constructTrapForFiveOrMoreArgs$LWS,
          constructTrapForAnyNumberOfArgs: constructTrapForAnyNumberOfArgs$LWS
        });
      }
      applyTrapNameRegistry$LWS[0] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[0];
      applyTrapNameRegistry$LWS[1] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[1];
      applyTrapNameRegistry$LWS[2] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[2];
      applyTrapNameRegistry$LWS[3] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[3];
      applyTrapNameRegistry$LWS[4] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[4];
      applyTrapNameRegistry$LWS[5] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[5];
      applyTrapNameRegistry$LWS.n = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[6];
      constructTrapNameRegistry$LWS[0] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[7];
      constructTrapNameRegistry$LWS[1] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[8];
      constructTrapNameRegistry$LWS[2] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[9];
      constructTrapNameRegistry$LWS[3] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[10];
      constructTrapNameRegistry$LWS[4] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[11];
      constructTrapNameRegistry$LWS[5] = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[12];
      constructTrapNameRegistry$LWS.n = MINIFICATION_SAFE_TRAP_PROPERTY_NAMES$LWS[13];
      const {
        prototype: BoundaryProxyHandlerProto$LWS
      } = BoundaryProxyHandler$LWS;
      BoundaryProxyHandlerProto$LWS[applyTrapNameRegistry$LWS[0]] = applyTrapForZeroOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[applyTrapNameRegistry$LWS[1]] = applyTrapForOneOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[applyTrapNameRegistry$LWS[2]] = applyTrapForTwoOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[applyTrapNameRegistry$LWS[3]] = applyTrapForThreeOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[applyTrapNameRegistry$LWS[4]] = applyTrapForFourOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[applyTrapNameRegistry$LWS[5]] = applyTrapForFiveOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[applyTrapNameRegistry$LWS.n] = applyTrapForAnyNumberOfArgs$LWS;
      BoundaryProxyHandlerProto$LWS[constructTrapNameRegistry$LWS[0]] = constructTrapForZeroOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[constructTrapNameRegistry$LWS[1]] = constructTrapForOneOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[constructTrapNameRegistry$LWS[2]] = constructTrapForTwoOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[constructTrapNameRegistry$LWS[3]] = constructTrapForThreeOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[constructTrapNameRegistry$LWS[4]] = constructTrapForFourOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[constructTrapNameRegistry$LWS[5]] = constructTrapForFiveOrMoreArgs$LWS;
      BoundaryProxyHandlerProto$LWS[constructTrapNameRegistry$LWS.n] = constructTrapForAnyNumberOfArgs$LWS;
      ReflectSetPrototypeOf$LWS(BoundaryProxyHandlerProto$LWS, null);
    };
  };
  /* eslint-enable prefer-object-spread */
}
const createMembraneMarshallSourceInStrictMode$LWS = `
'use strict';
(${createMembraneMarshall$LWS})`;
function createBlueConnector$LWS(globalObject$LWS) {
  if (typeof globalObject$LWS !== 'object' || globalObject$LWS === null) {
    throw new TypeErrorCtor$LWS('Missing globalObject.');
  }
  return createMembraneMarshall$LWS(globalObject$LWS);
}
function createRedConnector$LWS(evaluator$LWS) {
  if (typeof evaluator$LWS !== 'function') {
    throw new TypeErrorCtor$LWS('Missing evaluator function.');
  }
  return evaluator$LWS(createMembraneMarshallSourceInStrictMode$LWS)();
}
const LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS = SymbolFor$LWS('@@lockerNearMembraneUndefinedValue');
class VirtualEnvironment$LWS {
  constructor(options$LWS) {
    if (options$LWS === undefined) {
      throw new ErrorCtor$LWS('Missing required VirtualEnvironment options.');
    }
    // prettier-ignore
    const {
      blueConnector: blueConnector$LWS,
      redConnector: redConnector$LWS,
      distortionCallback: distortionCallback$LWS,
      instrumentation: instrumentation$LWS,
      liveTargetCallback: liveTargetCallback$LWS,
      revokedProxyCallback: revokedProxyCallback$LWS,
      signSourceCallback: signSourceCallback$LWS
      // eslint-disable-next-line prefer-object-spread
    } = ObjectAssign$LWS({
      __proto__: null
    }, options$LWS);
    let blueHooks$LWS;
    const blueConnect$LWS = blueConnector$LWS('blue', (...hooks$LWS) => {
      blueHooks$LWS = hooks$LWS;
    }, {
      distortionCallback: distortionCallback$LWS,
      instrumentation: instrumentation$LWS,
      liveTargetCallback: liveTargetCallback$LWS,
      revokedProxyCallback: revokedProxyCallback$LWS
    });
    const {
      0: blueGlobalThisPointer$LWS,
      1: blueGetSelectedTarget$LWS,
      2: blueGetTransferableValue$LWS,
      3: blueCallableGetPropertyValuePointer$LWS,
      // 4: blueCallableEvaluate,
      5: blueCallableLinkPointers$LWS,
      6: blueCallablePushErrorTarget$LWS,
      7: blueCallablePushTarget$LWS,
      8: blueCallableApply$LWS,
      9: blueCallableConstruct$LWS,
      10: blueCallableDefineProperty$LWS,
      11: blueCallableDeleteProperty$LWS,
      12: blueCallableGet$LWS,
      13: blueCallableGetOwnPropertyDescriptor$LWS,
      14: blueCallableGetPrototypeOf$LWS,
      15: blueCallableHas$LWS,
      16: blueCallableIsExtensible$LWS,
      17: blueCallableOwnKeys$LWS,
      18: blueCallablePreventExtensions$LWS,
      19: blueCallableSet$LWS,
      20: blueCallableSetPrototypeOf$LWS,
      // 21: blueCallableDebugInfo,
      // 22: blueCallableDefineProperties,
      23: blueCallableGetLazyPropertyDescriptorStateByTarget$LWS,
      24: blueCallableGetPropertyValue$LWS,
      25: blueCallableGetTargetIntegrityTraits$LWS,
      26: blueCallableGetToStringTagOfTarget$LWS,
      27: blueCallableInstallErrorPrepareStackTrace$LWS,
      // 28: blueCallableInstallLazyPropertyDescriptors,
      29: blueCallableIsTargetLive$LWS,
      // 30: blueCallableIsTargetRevoked,
      // 31: blueCallableSerializeTarget,
      32: blueCallableSetLazyPropertyDescriptorStateByTarget$LWS,
      // 33: blueTrackAsFastTarget,
      34: blueCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS,
      35: blueCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS,
      36: blueCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS
    } = blueHooks$LWS;
    let redHooks$LWS;
    const redConnect$LWS = redConnector$LWS('red', (...hooks$LWS) => {
      redHooks$LWS = hooks$LWS;
    });
    const {
      0: redGlobalThisPointer$LWS,
      // 1: redGetSelectedTarget,
      // 2: redGetTransferableValue,
      3: redCallableGetPropertyValuePointer$LWS,
      4: redCallableEvaluate$LWS,
      5: redCallableLinkPointers$LWS,
      6: redCallablePushErrorTarget$LWS,
      7: redCallablePushTarget$LWS,
      8: redCallableApply$LWS,
      9: redCallableConstruct$LWS,
      10: redCallableDefineProperty$LWS,
      11: redCallableDeleteProperty$LWS,
      12: redCallableGet$LWS,
      13: redCallableGetOwnPropertyDescriptor$LWS,
      14: redCallableGetPrototypeOf$LWS,
      15: redCallableHas$LWS,
      16: redCallableIsExtensible$LWS,
      17: redCallableOwnKeys$LWS,
      18: redCallablePreventExtensions$LWS,
      19: redCallableSet$LWS,
      20: redCallableSetPrototypeOf$LWS,
      21: redCallableDebugInfo$LWS,
      22: redCallableDefineProperties$LWS,
      23: redCallableGetLazyPropertyDescriptorStateByTarget$LWS,
      // 24: redCallableGetPropertyValue,
      25: redCallableGetTargetIntegrityTraits$LWS,
      26: redCallableGetToStringTagOfTarget$LWS,
      27: redCallableInstallErrorPrepareStackTrace$LWS,
      28: redCallableInstallLazyPropertyDescriptors$LWS,
      // 29: redCallableIsTargetLive,
      30: redCallableIsTargetRevoked$LWS,
      31: redCallableSerializeTarget$LWS,
      32: redCallableSetLazyPropertyDescriptorStateByTarget$LWS,
      33: redCallableTrackAsFastTarget$LWS,
      34: redCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS,
      35: redCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS,
      36: redCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS
    } = redHooks$LWS;
    blueConnect$LWS(noop$LWS,
    // redGlobalThisPointer,
    noop$LWS,
    // redGetSelectedTarget,
    noop$LWS,
    // redGetTransferableValue,
    noop$LWS,
    // redCallableGetPropertyValuePointer,
    noop$LWS,
    // redCallableEvaluate,
    noop$LWS,
    // redCallableLinkPointers,
    redCallablePushErrorTarget$LWS, redCallablePushTarget$LWS, redCallableApply$LWS, redCallableConstruct$LWS, redCallableDefineProperty$LWS, redCallableDeleteProperty$LWS, redCallableGet$LWS, redCallableGetOwnPropertyDescriptor$LWS, redCallableGetPrototypeOf$LWS, redCallableHas$LWS, redCallableIsExtensible$LWS, redCallableOwnKeys$LWS, redCallablePreventExtensions$LWS, redCallableSet$LWS, redCallableSetPrototypeOf$LWS, redCallableDebugInfo$LWS, noop$LWS,
    // redCallableDefineProperties,
    redCallableGetLazyPropertyDescriptorStateByTarget$LWS, noop$LWS,
    // redCallableGetPropertyValue,
    redCallableGetTargetIntegrityTraits$LWS, redCallableGetToStringTagOfTarget$LWS, redCallableInstallErrorPrepareStackTrace$LWS, noop$LWS,
    // redCallableInstallLazyPropertyDescriptors,
    noop$LWS,
    // redCallableIsTargetLive,
    redCallableIsTargetRevoked$LWS, redCallableSerializeTarget$LWS, redCallableSetLazyPropertyDescriptorStateByTarget$LWS, redCallableTrackAsFastTarget$LWS, redCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS, redCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS, redCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS);
    redConnect$LWS(noop$LWS,
    // blueGlobalThisPointer,
    noop$LWS,
    // blueGetSelectedTarget,
    noop$LWS,
    // blueGetTransferableValue,
    noop$LWS,
    // blueCallableGetPropertyValuePointer,
    noop$LWS,
    // blueCallableEvaluate,
    noop$LWS,
    // blueCallableLinkPointers,
    blueCallablePushErrorTarget$LWS, blueCallablePushTarget$LWS, blueCallableApply$LWS, blueCallableConstruct$LWS, blueCallableDefineProperty$LWS, blueCallableDeleteProperty$LWS, blueCallableGet$LWS, blueCallableGetOwnPropertyDescriptor$LWS, blueCallableGetPrototypeOf$LWS, blueCallableHas$LWS, blueCallableIsExtensible$LWS, blueCallableOwnKeys$LWS, blueCallablePreventExtensions$LWS, blueCallableSet$LWS, blueCallableSetPrototypeOf$LWS, noop$LWS,
    // blueCallableDebugInfo
    noop$LWS,
    // blueCallableDefineProperties,
    blueCallableGetLazyPropertyDescriptorStateByTarget$LWS, blueCallableGetPropertyValue$LWS, blueCallableGetTargetIntegrityTraits$LWS, blueCallableGetToStringTagOfTarget$LWS, blueCallableInstallErrorPrepareStackTrace$LWS, noop$LWS,
    // blueCallableInstallLazyPropertyDescriptors,
    blueCallableIsTargetLive$LWS, noop$LWS,
    // blueCallableIsTargetRevoked,
    noop$LWS,
    // blueCallableSerializeTarget,,
    blueCallableSetLazyPropertyDescriptorStateByTarget$LWS, noop$LWS,
    // blueCallableTrackAsFastTarget,
    blueCallableBatchGetPrototypeOfAndGetOwnPropertyDescriptors$LWS, blueCallableBatchGetPrototypeOfWhenHasNoOwnProperty$LWS, blueCallableBatchGetPrototypeOfWhenHasNoOwnPropertyDescriptor$LWS);
    this.blueGlobalThisPointer = blueGlobalThisPointer$LWS;
    this.blueGetSelectedTarget = blueGetSelectedTarget$LWS;
    this.blueGetTransferableValue = blueGetTransferableValue$LWS;
    this.blueCallableGetPropertyValuePointer = blueCallableGetPropertyValuePointer$LWS;
    this.blueCallableLinkPointers = blueCallableLinkPointers$LWS;
    // Ensure the `this` context of red callable functions is `undefined`.
    this.redGlobalThisPointer = () => redGlobalThisPointer$LWS();
    this.redCallableGetPropertyValuePointer = (targetPointer$LWS, key$LWS) => redCallableGetPropertyValuePointer$LWS(targetPointer$LWS, key$LWS);
    this.redCallableEvaluate = signSourceCallback$LWS ? sourceText$LWS => redCallableEvaluate$LWS(signSourceCallback$LWS(sourceText$LWS)) : sourceText$LWS => redCallableEvaluate$LWS(sourceText$LWS);
    this.redCallableLinkPointers = (targetPointer$LWS, foreignTargetPointer$LWS) => redCallableLinkPointers$LWS(targetPointer$LWS, foreignTargetPointer$LWS);
    this.redCallableSetPrototypeOf = (targetPointer$LWS, protoPointerOrNull$LWS) => redCallableSetPrototypeOf$LWS(targetPointer$LWS, protoPointerOrNull$LWS);
    this.redCallableDefineProperties = (targetPointer$LWS, ...descriptorTuples$LWS) => {
      const {
        length: length$LWS
      } = descriptorTuples$LWS;
      const args$LWS = new ArrayCtor$LWS(length$LWS + 1);
      args$LWS[0] = targetPointer$LWS;
      for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
        args$LWS[i$LWS + 1] = descriptorTuples$LWS[i$LWS];
      }
      ReflectApply$LWS(redCallableDefineProperties$LWS, undefined, args$LWS);
    };
    this.redCallableInstallLazyPropertyDescriptors = (targetPointer$LWS, ...ownKeysAndUnforgeableGlobalThisKeys$LWS) => {
      const {
        length: length$LWS
      } = ownKeysAndUnforgeableGlobalThisKeys$LWS;
      const args$LWS = new ArrayCtor$LWS(length$LWS + 1);
      args$LWS[0] = targetPointer$LWS;
      for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
        args$LWS[i$LWS + 1] = ownKeysAndUnforgeableGlobalThisKeys$LWS[i$LWS];
      }
      ReflectApply$LWS(redCallableInstallLazyPropertyDescriptors$LWS, undefined, args$LWS);
    };
    this.redCallableTrackAsFastTarget = targetPointer$LWS => redCallableTrackAsFastTarget$LWS(targetPointer$LWS);
  }
  evaluate(sourceText$LWS) {
    try {
      const bluePointerOrPrimitiveValue$LWS = this.redCallableEvaluate(sourceText$LWS);
      if (typeof bluePointerOrPrimitiveValue$LWS === 'function') {
        bluePointerOrPrimitiveValue$LWS();
        return this.blueGetSelectedTarget();
      }
      return bluePointerOrPrimitiveValue$LWS;
    } catch (error) {
      var _this$blueGetSelected$LWS;
      throw (_this$blueGetSelected$LWS = this.blueGetSelectedTarget()) != null ? _this$blueGetSelected$LWS : error;
    }
  }
  lazyRemapProperties(target$LWS, ownKeys$LWS, unforgeableGlobalThisKeys$LWS) {
    if (typeof target$LWS === 'object' && target$LWS !== null || typeof target$LWS === 'function') {
      const args$LWS = [this.blueGetTransferableValue(target$LWS)];
      ReflectApply$LWS(ArrayProtoPush$LWS, args$LWS, ownKeys$LWS);
      if (unforgeableGlobalThisKeys$LWS != null && unforgeableGlobalThisKeys$LWS.length) {
        // Use `LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL` to delimit
        // `ownKeys` and `unforgeableGlobalThisKeys`.
        args$LWS[args$LWS.length] = LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        ReflectApply$LWS(ArrayProtoPush$LWS, args$LWS, unforgeableGlobalThisKeys$LWS);
      }
      ReflectApply$LWS(this.redCallableInstallLazyPropertyDescriptors, undefined, args$LWS);
    }
  }
  link(...keys$LWS) {
    let bluePointer$LWS = this.blueGlobalThisPointer;
    let redPointer$LWS = this.redGlobalThisPointer;
    for (let i$LWS = 0, {
        length: length$LWS
      } = keys$LWS; i$LWS < length$LWS; i$LWS += 1) {
      const key$LWS = keys$LWS[i$LWS];
      bluePointer$LWS = this.blueCallableGetPropertyValuePointer(bluePointer$LWS, key$LWS);
      redPointer$LWS = this.redCallableGetPropertyValuePointer(redPointer$LWS, key$LWS);
      this.redCallableLinkPointers(redPointer$LWS, bluePointer$LWS);
      this.blueCallableLinkPointers(bluePointer$LWS, redPointer$LWS);
    }
  }
  remapProperties(target$LWS, unsafeBlueDescs$LWS) {
    if (typeof target$LWS === 'object' && target$LWS !== null || typeof target$LWS === 'function') {
      const targetPointer$LWS = this.blueGetTransferableValue(target$LWS);
      const ownKeys$LWS = ReflectOwnKeys$LWS(unsafeBlueDescs$LWS);
      const {
        length: length$LWS
      } = ownKeys$LWS;
      const args$LWS = new ArrayCtor$LWS(1 + length$LWS * 7);
      args$LWS[0] = targetPointer$LWS;
      for (let i$LWS = 0, j$LWS = 1; i$LWS < length$LWS; i$LWS += 1, j$LWS += 7) {
        const ownKey$LWS = ownKeys$LWS[i$LWS];
        const unsafeBlueDesc$LWS = unsafeBlueDescs$LWS[ownKey$LWS];
        // Avoid poisoning by only installing own properties from unsafeBlueDescs.
        // We don't use a toSafeDescriptor() style helper since that mutates
        // the unsafeBlueDesc.
        // eslint-disable-next-line prefer-object-spread
        const safeBlueDesc$LWS = ObjectAssign$LWS({
          __proto__: null
        }, unsafeBlueDesc$LWS);
        args$LWS[j$LWS] = ownKey$LWS;
        args$LWS[j$LWS + 1] = 'configurable' in safeBlueDesc$LWS ? !!safeBlueDesc$LWS.configurable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        args$LWS[j$LWS + 2] = 'enumerable' in safeBlueDesc$LWS ? !!safeBlueDesc$LWS.enumerable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        args$LWS[j$LWS + 3] = 'writable' in safeBlueDesc$LWS ? !!safeBlueDesc$LWS.writable : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        args$LWS[j$LWS + 4] = 'value' in safeBlueDesc$LWS ? this.blueGetTransferableValue(safeBlueDesc$LWS.value) : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        args$LWS[j$LWS + 5] = 'get' in safeBlueDesc$LWS ? this.blueGetTransferableValue(safeBlueDesc$LWS.get) : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
        args$LWS[j$LWS + 6] = 'set' in safeBlueDesc$LWS ? this.blueGetTransferableValue(safeBlueDesc$LWS.set) : LOCKER_NEAR_MEMBRANE_UNDEFINED_VALUE_SYMBOL$LWS;
      }
      ReflectApply$LWS(this.redCallableDefineProperties, this, args$LWS);
    }
  }
  remapProto(target$LWS, proto$LWS) {
    if (typeof target$LWS === 'object' && target$LWS !== null || typeof target$LWS === 'function') {
      const foreignTargetPointer$LWS = this.blueGetTransferableValue(target$LWS);
      const transferableProto$LWS = proto$LWS ? this.blueGetTransferableValue(proto$LWS) : proto$LWS;
      this.redCallableSetPrototypeOf(foreignTargetPointer$LWS, transferableProto$LWS);
    }
  }
  trackAsFastTarget(target$LWS) {
    if (typeof target$LWS === 'object' && target$LWS !== null || typeof target$LWS === 'function') {
      this.redCallableTrackAsFastTarget(this.blueGetTransferableValue(target$LWS));
    }
  }
}

/**
 * This list must be in sync with ecma-262, anything new added to the global object
 * should be considered, to decide whether or not they need remapping. The default
 * behavior, if missing form the following list, is to be remapped, which is safer.
 *
 * Note: remapped means the functionality is provided by the blue realm, rather than
 * the red one. This helps with the identity discontinuity issue, e.g.: all Set objects
 * have the same identity because it is always derived from the outer realm's Set.
 *
 * Note 1: We have identified 3 types of intrinsics
 * A: primitives driven intrinsics
 * B: syntax driven intrinsics (they usually have a imperative form as well)
 * C: imperative only intrinsics
 *
 * While A is not remapped, it is safe, and works fast that way, and C is remapped to
 * preserve the identity of all produced objects from the same realm, B is really
 * problematic, and requires a lot more work to guarantee that objects from both sides
 * can be considered equivalents (without identity discontinuity).
 */
function getESGlobalKeys$LWS(maxPerfMode$LWS) {
  const ESGlobalKeys$LWS = [
  // *** 19.1 Value Properties of the Global Object
  'globalThis', 'Infinity', 'NaN', 'undefined',
  // *** 19.2 Function Properties of the Global Object
  // 'eval', // dangerous & Reflective
  'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent',
  // *** 19.3 Constructor Properties of the Global Object
  // 'AggregateError', // Reflective
  // 'Array', // Reflective
  'BigInt', 'Boolean',
  // 'Date', // Remapped
  // 'Error', // Reflective
  // 'EvalError', // Reflective
  'FinalizationRegistry',
  // 'Function', // dangerous & Reflective
  'Map', 'Number',
  // 'Object', // Reflective
  // Allow blue `Promise` constructor to overwrite the Red one so that promises
  // created by the `Promise` constructor or APIs like `fetch` will work.
  // 'Promise', // Remapped
  // 'Proxy', // Reflective
  // 'RangeError', // Reflective
  // 'ReferenceError', // Reflective
  'RegExp', 'Set', 'String', 'Symbol',
  // 'SyntaxError', // Reflective
  // 'TypeError', // Reflective
  // 'URIError', // Reflective
  'WeakMap', 'WeakSet', 'WeakRef',
  // *** 18.4 Other Properties of the Global Object
  // 'Atomics', // Remapped
  'JSON', 'Math', 'Reflect',
  // *** Annex B
  'escape', 'unescape'
  // *** ECMA-402
  // 'Intl',  // Remapped
  ];
  // This set is for maxPerfMode, all of these must be from the same global object
  const maxPerfModeKeys$LWS = {
    intrinsics: ['ArrayBuffer', 'Atomics', 'BigInt64Array', 'BigUint64Array', 'DataView', 'Float32Array', 'Float64Array', 'Int16Array', 'Int32Array', 'Int8Array', 'SharedArrayBuffer', 'Uint16Array', 'Uint32Array', 'Uint8Array', 'Uint8ClampedArray'],
    // Ideally these should come from browser-realm, that's a code reorg improvement for later
    browser: ['Blob', 'crypto', 'Crypto', 'File', 'FileReader', 'SubtleCrypto', 'URL']
  };
  if (maxPerfMode$LWS) {
    ESGlobalKeys$LWS.push(...maxPerfModeKeys$LWS.intrinsics, ...maxPerfModeKeys$LWS.browser);
  }
  return ESGlobalKeys$LWS;
}
// These are foundational things that should never be wrapped but are equivalent
// @TODO: Revisit this list.
const ReflectiveIntrinsicObjectNames$LWS = ['AggregateError', 'Array', 'Error', 'EvalError', 'Function', 'Object', 'Proxy', 'RangeError', 'ReferenceError', 'SyntaxError', 'TypeError', 'URIError', 'eval', 'globalThis'];
function getESGlobalsAndReflectiveIntrinsicObjectNames$LWS(maxPerfMode$LWS) {
  const ESGlobalKeys$LWS = getESGlobalKeys$LWS(maxPerfMode$LWS);
  return toSafeArray$LWS([...ESGlobalKeys$LWS, ...ReflectiveIntrinsicObjectNames$LWS]);
}
function getGlobalObjectOwnKeys$LWS(source$LWS) {
  const ownKeys$LWS = ReflectOwnKeys$LWS(source$LWS);
  // WKWebView incorrectly excludes the 'webkit' own property of the global
  // object from `Object.keys()` and `Reflect.ownKeys()` results, so add it.
  // istanbul ignore if: currently unreachable via tests
  if (ObjectHasOwn$LWS(source$LWS, 'webkit') && !ReflectApply$LWS(ArrayProtoIncludes$LWS, ownKeys$LWS, ['webkit'])) {
    ownKeys$LWS[ownKeys$LWS.length] = 'webkit';
  }
  return ownKeys$LWS;
}
function assignFilteredGlobalDescriptorsFromPropertyDescriptorMap$LWS(descs$LWS, source$LWS, maxPerfMode$LWS) {
  const ownKeys$LWS = getGlobalObjectOwnKeys$LWS(source$LWS);
  const ESGlobalsAndReflectiveIntrinsicObjectNames$LWS = getESGlobalsAndReflectiveIntrinsicObjectNames$LWS(maxPerfMode$LWS);
  for (let i$LWS = 0, {
      length: length$LWS
    } = ownKeys$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const ownKey$LWS = ownKeys$LWS[i$LWS];
    // Avoid overriding ECMAScript global names that correspond to
    // global intrinsics. This guarantee that those entries will be
    // ignored if present in the source property descriptor map.
    if (!ESGlobalsAndReflectiveIntrinsicObjectNames$LWS.includes(ownKey$LWS)) {
      const unsafeDesc$LWS = source$LWS[ownKey$LWS];
      if (unsafeDesc$LWS) {
        // Avoid poisoning by only installing own properties from
        // unsafeDesc. We don't use a toSafeDescriptor() style helper
        // since that mutates the unsafeBlueDesc.
        // eslint-disable-next-line prefer-object-spread
        descs$LWS[ownKey$LWS] = ObjectAssign$LWS({
          __proto__: null
        }, unsafeDesc$LWS);
      }
    }
  }
  return descs$LWS;
}
function getFilteredGlobalOwnKeys$LWS(source$LWS, maxPerfMode$LWS) {
  const result$LWS = [];
  let resultOffset$LWS = 0;
  const ownKeys$LWS = getGlobalObjectOwnKeys$LWS(source$LWS);
  const ESGlobalsAndReflectiveIntrinsicObjectNames$LWS = getESGlobalsAndReflectiveIntrinsicObjectNames$LWS(maxPerfMode$LWS);
  for (let i$LWS = 0, {
      length: length$LWS
    } = ownKeys$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const ownKey$LWS = ownKeys$LWS[i$LWS];
    // Avoid overriding ECMAScript global names that correspond to global
    // intrinsics. This guarantees that those entries will be ignored if
    // present in the source object.
    if (!ESGlobalsAndReflectiveIntrinsicObjectNames$LWS.includes(ownKey$LWS)) {
      result$LWS[resultOffset$LWS++] = ownKey$LWS;
    }
  }
  return result$LWS;
}
function linkIntrinsics$LWS(env$LWS, globalObject$LWS) {
  // Remap intrinsics that are realm agnostic.
  for (let i$LWS = 0, {
      length: length$LWS
    } = ReflectiveIntrinsicObjectNames$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const globalName$LWS = ReflectiveIntrinsicObjectNames$LWS[i$LWS];
    const reflectiveValue$LWS = globalObject$LWS[globalName$LWS];
    if (reflectiveValue$LWS) {
      // Proxy.prototype is undefined.
      if (reflectiveValue$LWS.prototype) {
        env$LWS.link(globalName$LWS, 'prototype');
      } else {
        env$LWS.link(globalName$LWS);
      }
    }
  }
}
const blueDocumentToRecordMap$LWS = toSafeWeakMap$LWS(new WeakMap());
// Chromium based browsers have a bug that nulls the result of `window`
// getters in detached iframes when the property descriptor of `window.window`
// is retrieved.
// https://bugs.chromium.org/p/chromium/issues/detail?id=1305302
const unforgeablePoisonedWindowKeys$LWS = IS_CHROMIUM_BROWSER$LWS ? ['window'] : undefined;
function getCachedGlobalObjectReferences$LWS(globalObject$LWS) {
  const {
    window: window$LWS
  } = globalObject$LWS;
  let record$LWS;
  let document$LWS;
  // Suppress errors thrown on cross-origin opaque windows.
  try {
    ({
      document: document$LWS
    } = globalObject$LWS);
    record$LWS = blueDocumentToRecordMap$LWS.get(document$LWS);
    // eslint-disable-next-line no-empty
  } catch (_unused$LWS) {
    return undefined;
  }
  if (record$LWS) {
    return record$LWS;
  }
  // Cache references to object values that can't be replaced
  // window -> Window -> WindowProperties -> EventTarget
  const WindowProto$LWS = ReflectGetPrototypeOf$LWS(window$LWS);
  const WindowPropertiesProto$LWS = ReflectGetPrototypeOf$LWS(WindowProto$LWS);
  const EventTargetProto$LWS = ReflectGetPrototypeOf$LWS(WindowPropertiesProto$LWS);
  record$LWS = {
    document: document$LWS,
    DocumentProto: ReflectGetPrototypeOf$LWS(document$LWS),
    window: window$LWS,
    WindowProto: ReflectGetPrototypeOf$LWS(window$LWS),
    WindowPropertiesProto: ReflectGetPrototypeOf$LWS(WindowProto$LWS),
    EventTargetProto: EventTargetProto$LWS,
    // Some simulated browser environments, e.g. those using JSDOM, may lack an EventTargetProto.
    EventTargetProtoOwnKeys: EventTargetProto$LWS ? ReflectOwnKeys$LWS(EventTargetProto$LWS) : []
  };
  blueDocumentToRecordMap$LWS.set(document$LWS, record$LWS);
  return record$LWS;
}
function filterWindowKeys$LWS(keys$LWS) {
  const excludedKeys$LWS = new SetCtor$LWS(['document', 'location', 'top', 'window']);
  const result$LWS = [];
  let resultOffset$LWS = 0;
  for (let i$LWS = 0, {
      length: length$LWS
    } = keys$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const key$LWS = keys$LWS[i$LWS];
    if (ReflectApply$LWS(SetProtoHas$LWS, excludedKeys$LWS, [key$LWS])) {
      continue;
    }
    result$LWS[resultOffset$LWS++] = key$LWS;
  }
  return result$LWS;
}
/**
 * global descriptors are a combination of 3 set of descriptors:
 * - first, the key of the red descriptors define the descriptors
 *   provided by the browser when creating a brand new window.
 * - second, once we know the base keys, we get the actual descriptors
 *   from the blueDescriptors, since those are the one we want to provide
 *   access to via the membrane.
 * - third, the user of this library can provide endowments, which define
 *   global descriptors that should be installed into the sandbox on top
 *   of the base descriptors.
 *
 * Note: The main reason for using redDescriptors as the base keys instead
 * of blueDescriptor is because there is no guarantee that this library is
 * the first one to be evaluated in the host app, which means it has no ways
 * to determine what is a real DOM API vs app specific globals.
 *
 * Quirk: The only quirk here is for the case in which this library runs
 * after some other code that patches some of the DOM APIs. This means
 * the installed proxy in the sandbox will point to the patched global
 * API in the blue realm, rather than the original, because we don't have
 * a way to access the original anymore. This should not be a deal-breaker
 * if the patched API behaves according to the spec.
 *
 * The result of this method is a descriptor map that contains everything
 * that will be installed (via the membrane) as global descriptors in
 * the red realm.
 */
function removeWindowDescriptors$LWS(unsafeDescs$LWS) {
  // Remove unforgeable descriptors that cannot be installed.
  ReflectDeleteProperty$LWS(unsafeDescs$LWS, 'document');
  ReflectDeleteProperty$LWS(unsafeDescs$LWS, 'location');
  ReflectDeleteProperty$LWS(unsafeDescs$LWS, 'top');
  ReflectDeleteProperty$LWS(unsafeDescs$LWS, 'window');
  // Remove other browser specific unforgeables.
  ReflectDeleteProperty$LWS(unsafeDescs$LWS, 'chrome');
  return unsafeDescs$LWS;
}
/**
 * Initialization operation to capture and cache all unforgeable references
 * and their respective descriptor maps before any other code runs, this
 * usually help because this library runs before anything else that can poison
 * the environment.
 */
getCachedGlobalObjectReferences$LWS(rootWindow$LWS);
const IFRAME_SANDBOX_ATTRIBUTE_VALUE$LWS = 'allow-same-origin allow-scripts';
const revoked$LWS = toSafeWeakSet$LWS(new WeakSetCtor$LWS());
const blueCreateHooksCallbackCache$LWS = toSafeWeakMap$LWS(new WeakMapCtor$LWS());
function createDetachableIframe$LWS(doc$LWS) {
  var _ReflectApply$LWS;
  const iframe$LWS = ReflectApply$LWS(DocumentProtoCreateElement$LWS, doc$LWS, ['iframe']);
  // It is impossible to test whether the NodeProtoLastChildGetter branch is
  // reached in a normal Karma test environment.
  const parent$LWS = (_ReflectApply$LWS = ReflectApply$LWS(DocumentProtoBodyGetter$LWS, doc$LWS, [])) != null ? _ReflectApply$LWS : /* istanbul ignore next */ReflectApply$LWS(NodeProtoLastChildGetter$LWS, doc$LWS, []);
  const style$LWS = ReflectApply$LWS(HTMLElementProtoStyleGetter$LWS, iframe$LWS, []);
  style$LWS.display = 'none';
  ReflectApply$LWS(ElementProtoSetAttribute$LWS, iframe$LWS, ['sandbox', IFRAME_SANDBOX_ATTRIBUTE_VALUE$LWS]);
  ReflectApply$LWS(NodeProtoAppendChild$LWS, parent$LWS, [iframe$LWS]);
  return iframe$LWS;
}
function createIframeVirtualEnvironment$LWS(globalObject$LWS, providedOptions$LWS) {
  if (typeof globalObject$LWS !== 'object' || globalObject$LWS === null) {
    throw new TypeErrorCtor$LWS('Missing global object virtualization target.');
  }
  const blueRefs$LWS = getCachedGlobalObjectReferences$LWS(globalObject$LWS);
  if (typeof blueRefs$LWS !== 'object' || blueRefs$LWS === null) {
    throw new TypeErrorCtor$LWS('Invalid virtualization target.');
  }
  const {
    distortionCallback: distortionCallback$LWS,
    defaultPolicy: defaultPolicy$LWS,
    endowments: endowments$LWS,
    globalObjectShape: globalObjectShape$LWS,
    instrumentation: instrumentation$LWS,
    keepAlive: keepAlive$LWS = true,
    liveTargetCallback: liveTargetCallback$LWS,
    maxPerfMode: maxPerfMode$LWS = false,
    signSourceCallback: signSourceCallback$LWS
    // eslint-disable-next-line prefer-object-spread
  } = ObjectAssign$LWS({
    __proto__: null
  }, providedOptions$LWS);
  const iframe$LWS = createDetachableIframe$LWS(blueRefs$LWS.document);
  const redWindow$LWS = ReflectApply$LWS(HTMLIFrameElementProtoContentWindowGetter$LWS, iframe$LWS, []);
  const shouldUseDefaultGlobalOwnKeys$LWS = typeof globalObjectShape$LWS !== 'object' || globalObjectShape$LWS === null;
  const defaultGlobalOwnKeys$LWS = filterWindowKeys$LWS(getFilteredGlobalOwnKeys$LWS(redWindow$LWS, maxPerfMode$LWS));
  let blueConnector$LWS = blueCreateHooksCallbackCache$LWS.get(blueRefs$LWS.document);
  if (blueConnector$LWS === undefined) {
    blueConnector$LWS = createBlueConnector$LWS(globalObject$LWS);
    blueCreateHooksCallbackCache$LWS.set(blueRefs$LWS.document, blueConnector$LWS);
  }
  // Install default TrustedTypes policy in the virtual environment.
  // @ts-ignore trustedTypes does not exist on GlobalObject
  if (typeof redWindow$LWS.trustedTypes !== 'undefined' && isObject$LWS(defaultPolicy$LWS)) {
    // @ts-ignore trustedTypes does not exist on GlobalObject
    redWindow$LWS.trustedTypes.createPolicy('default', defaultPolicy$LWS);
  }
  const {
    eval: redIndirectEval$LWS
  } = redWindow$LWS;
  const env$LWS = new VirtualEnvironment$LWS({
    blueConnector: blueConnector$LWS,
    redConnector: createRedConnector$LWS(signSourceCallback$LWS ? sourceText$LWS => redIndirectEval$LWS(signSourceCallback$LWS(sourceText$LWS)) : redIndirectEval$LWS),
    distortionCallback: distortionCallback$LWS,
    instrumentation: instrumentation$LWS,
    liveTargetCallback: liveTargetCallback$LWS,
    revokedProxyCallback: keepAlive$LWS ? revokedProxyCallback$LWS : undefined,
    signSourceCallback: signSourceCallback$LWS
  });
  linkIntrinsics$LWS(env$LWS, globalObject$LWS);
  // window
  // window.document
  // In browsers globalThis is === window.
  if (typeof globalThis === 'undefined') {
    // Support for globalThis was added in Chrome 71.
    // However, environments like Android emulators are running Chrome 69.
    env$LWS.link('window', 'document');
  } else {
    // document is === window.document.
    env$LWS.link('document');
  }
  // window.__proto__ (aka Window.prototype)
  // window.__proto__.__proto__ (aka WindowProperties.prototype)
  // window.__proto__.__proto__.__proto__ (aka EventTarget.prototype)
  env$LWS.link('__proto__', '__proto__', '__proto__');
  env$LWS.remapProto(blueRefs$LWS.document, blueRefs$LWS.DocumentProto);
  env$LWS.lazyRemapProperties(blueRefs$LWS.window, shouldUseDefaultGlobalOwnKeys$LWS ? defaultGlobalOwnKeys$LWS : filterWindowKeys$LWS(getFilteredGlobalOwnKeys$LWS(globalObjectShape$LWS, maxPerfMode$LWS)),
  // Chromium based browsers have a bug that nulls the result of `window`
  // getters in detached iframes when the property descriptor of `window.window`
  // is retrieved.
  // https://bugs.chromium.org/p/chromium/issues/detail?id=1305302
  keepAlive$LWS ? undefined : unforgeablePoisonedWindowKeys$LWS);
  if (endowments$LWS) {
    const filteredEndowments$LWS = {};
    assignFilteredGlobalDescriptorsFromPropertyDescriptorMap$LWS(filteredEndowments$LWS, endowments$LWS, maxPerfMode$LWS);
    removeWindowDescriptors$LWS(filteredEndowments$LWS);
    env$LWS.remapProperties(blueRefs$LWS.window, filteredEndowments$LWS);
  }
  // We intentionally skip remapping Window.prototype because there is nothing
  // in it that needs to be remapped.
  env$LWS.lazyRemapProperties(blueRefs$LWS.EventTargetProto, blueRefs$LWS.EventTargetProtoOwnKeys);
  // We don't remap `blueRefs.WindowPropertiesProto` because it is "magical"
  // in that it provides access to elements by id.
  //
  // Once we get the iframe info ready, and all mapped, we can proceed to
  // detach the iframe only if `options.keepAlive` isn't true.
  if (keepAlive$LWS) {
    // @TODO: Temporary hack to preserve the document reference in Firefox.
    // https://bugzilla.mozilla.org/show_bug.cgi?id=543435
    const {
      document: redDocument$LWS
    } = redWindow$LWS;
    // Revoke the proxies of the redDocument and redWindow to prevent access.
    revoked$LWS.add(redDocument$LWS);
    revoked$LWS.add(redWindow$LWS);
    ReflectApply$LWS(DocumentProtoOpen$LWS, redDocument$LWS, []);
    ReflectApply$LWS(DocumentProtoClose$LWS, redDocument$LWS, []);
  } else {
    if (IS_OLD_CHROMIUM_BROWSER$LWS) {
      // For Chromium < v86 browsers we evaluate the `window` object to
      // kickstart the realm so that `window` persists when the iframe is
      // removed from the document.
      redIndirectEval$LWS('window');
    }
    ReflectApply$LWS(ElementProtoRemove$LWS, iframe$LWS, []);
  }
  return env$LWS;
}
function revokedProxyCallback$LWS(value$LWS) {
  return revoked$LWS.has(value$LWS);
}

// istanbul ignore next: currently unreachable via tests, platformResourceLoader testing is exclusively done in AMD format mode
function createResourceLoadError$LWS(url$LWS) {
  return new Error(`lightning/platformResourceLoader encountered an error loading ${enquote$LWS(url$LWS)}.`);
}
const EMPTY_EVAL_HELPERS$LWS = {
  forAwaitOf: noop$LWS$1,
  genToAsync: noop$LWS$1,
  loadScript: noop$LWS$1,
  loadStyle: noop$LWS$1,
  makeRedGet: noop$LWS$1,
  makeRedSyncImports: noop$LWS$1,
  namespace: noop$LWS$1,
  spreadable: noop$LWS$1,
  super: noop$LWS$1
};
// https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md
// istanbul ignore next
const EVAL_HELPERS_SOURCE_TEXT$LWS = `'use strict';
        ${SANDBOX_EVAL_CONTEXT_NAME$LWS}(${function redHelpersFactory$LWS(baseGenToAsync$LWS, forAwaitOf$LWS, loadScript$LWS, loadStyle$LWS) {
  const ArrayCtor$LWS = Array;
  // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow
  const {
    iterator: SymbolIterator$LWS
  } = Symbol;
  const {
    [SymbolIterator$LWS]: ArrayProtoIterator$LWS
  } = ArrayCtor$LWS.prototype;
  // The Generator prototype object is %GeneratorFunction.prototype.prototype%.
  // https://tc39.es/ecma262/#sec-generatorfunction.prototype.prototype
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  const GeneratorProto$LWS = function* () {}.constructor.prototype.prototype;
  const {
    next: GeneratorProtoNext$LWS,
    throw: GeneratorProtoThrow$LWS
  } = GeneratorProto$LWS;
  const {
    defineProperties: ObjectDefineProperties$LWS,
    freeze: ObjectFreeze$LWS
  } = Object;
  const {
    // eslint-disable-next-line @typescript-eslint/no-shadow, no-shadow
    apply: ReflectApply$LWS,
    get: ReflectGet$LWS,
    getPrototypeOf: ReflectGetPrototypeOf$LWS,
    setPrototypeOf: ReflectSetPrototypeOf$LWS
  } = Reflect;
  function genToAsync$LWS(func$LWS, thisArg$LWS) {
    let gen$LWS;
    const wrapGenMethod$LWS = genMethod$LWS => value$LWS => {
      if (gen$LWS === undefined) {
        gen$LWS = ReflectApply$LWS(func$LWS, thisArg$LWS, []);
      }
      return ReflectApply$LWS(genMethod$LWS, gen$LWS, [value$LWS]);
    };
    return baseGenToAsync$LWS(wrapGenMethod$LWS(GeneratorProtoNext$LWS), wrapGenMethod$LWS(GeneratorProtoThrow$LWS));
  }
  function makeRedGet$LWS(...bindings$LWS) {
    const {
      length: length$LWS
    } = bindings$LWS;
    const redGet$LWS = ArrayCtor$LWS(length$LWS);
    const descriptors$LWS = {};
    for (let i$LWS = 0; i$LWS < length$LWS; i$LWS += 1) {
      descriptors$LWS[i$LWS] = {
        __proto__: null,
        get: bindings$LWS[i$LWS]
      };
    }
    ObjectDefineProperties$LWS(redGet$LWS, descriptors$LWS);
    return redGet$LWS;
  }
  function makeRedSyncImports$LWS(bindings$LWS) {
    return function (...args$LWS) {
      for (let i$LWS = 0, {
          length: length$LWS
        } = bindings$LWS; i$LWS < length$LWS; i$LWS += 1) {
        try {
          // eslint-disable-next-line @typescript-eslint/no-unused-expressions
          bindings$LWS[i$LWS];
          // eslint-disable-next-line no-empty
        } catch (_unused35$LWS) {}
      }
      return spreadable$LWS(args$LWS);
    };
  }
  function namespace$LWS(object$LWS) {
    return ObjectFreeze$LWS(object$LWS);
  }
  function spreadable$LWS(array$LWS) {
    ReflectSetPrototypeOf$LWS(array$LWS, null);
    array$LWS[SymbolIterator$LWS] = ArrayProtoIterator$LWS;
    return array$LWS;
  }
  function superApplyOrGet$LWS(target$LWS, key$LWS, thisArgOrReceiver$LWS, args$LWS) {
    const superProto$LWS = ReflectGetPrototypeOf$LWS(target$LWS);
    if (superProto$LWS === null) {
      return undefined;
    }
    return args$LWS ? ReflectApply$LWS(superProto$LWS[key$LWS], thisArgOrReceiver$LWS, args$LWS) : ReflectGet$LWS(superProto$LWS, key$LWS, thisArgOrReceiver$LWS);
  }
  return {
    forAwaitOf: forAwaitOf$LWS,
    genToAsync: genToAsync$LWS,
    loadScript: loadScript$LWS,
    loadStyle: loadStyle$LWS,
    makeRedGet: makeRedGet$LWS,
    makeRedSyncImports: makeRedSyncImports$LWS,
    namespace: namespace$LWS,
    spreadable: spreadable$LWS,
    super: superApplyOrGet$LWS
  };
}})`;
function createEvalHelpersFactoryArgs$LWS(record$LWS) {
  const {
    document: document$LWS,
    document: {
      head: head$LWS
    },
    distortions: distortions$LWS,
    globalObject: {
      HTMLScriptElement: HTMLScriptElement$LWS,
      HTMLScriptElement: {
        prototype: HTMLScriptElementProto$LWS
      }
    },
    root: _root$LWS
  } = record$LWS;
  const isRootRecord$LWS = record$LWS === _root$LWS;
  const forOfStateCache$LWS = toSafeMap$LWS$1(new MapCtor$LWS$1());
  const resourcePromiseCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
  const resourceStatusCache$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
  const scriptSrcGetterDistortion$LWS = distortions$LWS.get(isRootRecord$LWS ? HTMLScriptElementProtoSrcGetter$LWS : ObjectLookupOwnGetter$LWS$1(HTMLScriptElementProto$LWS, 'src'));
  const scriptSrcSetterDistortion$LWS = distortions$LWS.get(isRootRecord$LWS ? HTMLScriptElementProtoSrcSetter$LWS : ObjectLookupOwnSetter$LWS(HTMLScriptElementProto$LWS, 'src'));
  // istanbul ignore next: deprecated code path unreachable via tests
  function genStep$LWS(resolve$LWS, reject$LWS, next$LWS, thrower$LWS, genMethodWrapper$LWS, arg$LWS) {
    let info$LWS;
    let value$LWS;
    try {
      info$LWS = genMethodWrapper$LWS(arg$LWS);
      value$LWS = info$LWS.value;
    } catch (error) {
      reject$LWS(error);
      return;
    }
    if (info$LWS.done) {
      resolve$LWS(value$LWS);
    } else {
      ReflectApply$LWS$1(PromiseProtoThen$LWS, PromiseResolve$LWS(value$LWS), [next$LWS, thrower$LWS]);
    }
  }
  // istanbul ignore next: currently unreachable via tests, platformResourceLoader testing is exclusively done in AMD format mode
  function loadPromise$LWS(element$LWS, urlAsString$LWS) {
    const promise$LWS = new PromiseCtor$LWS((resolve$LWS, reject$LWS) => {
      function onerror$LWS(event$LWS) {
        ReflectApply$LWS$1(EventTargetProtoRemoveEventListener$LWS, element$LWS, ['error', onerror$LWS]);
        ReflectApply$LWS$1(EventTargetProtoRemoveEventListener$LWS, element$LWS, ['load', onload$LWS]);
        ReflectApply$LWS$1(EventProtoStopPropagation$LWS, event$LWS, []);
        resourceStatusCache$LWS.set(element$LWS, 1 /* ResourceLoaderStatus.Errored */);
        reject$LWS(createResourceLoadError$LWS(urlAsString$LWS));
      }
      function onload$LWS() {
        ReflectApply$LWS$1(EventTargetProtoRemoveEventListener$LWS, element$LWS, ['error', onerror$LWS]);
        ReflectApply$LWS$1(EventTargetProtoRemoveEventListener$LWS, element$LWS, ['load', onload$LWS]);
        resourceStatusCache$LWS.set(element$LWS, 3 /* ResourceLoaderStatus.Loaded */);
        // platformResourceLoader and ltng:require have to be synchronized in terms of
        // creating and loading scripts. This expando is used by ltng:require to know if a
        // script has been loaded by it or not. See W-13034908.
        if (element$LWS instanceof HTMLScriptElement$LWS) {
          // eslint-disable-next-line no-underscore-dangle
          element$LWS._ltngRequireLoaded = true;
        }
        resolve$LWS(undefined);
      }
      ReflectApply$LWS$1(EventTargetProtoAddEventListener$LWS, element$LWS, ['error', onerror$LWS]);
      ReflectApply$LWS$1(EventTargetProtoAddEventListener$LWS, element$LWS, ['load', onload$LWS]);
    });
    resourceStatusCache$LWS.set(element$LWS, 2 /* ResourceLoaderStatus.Loading */);
    resourcePromiseCache$LWS.set(element$LWS, promise$LWS);
    ReflectApply$LWS$1(NodeProtoAppendChild$LWS$1, head$LWS, [element$LWS]);
    return promise$LWS;
  }
  return [
  // This helper is used to wrap the bodies of async functions that are
  // transformed into generator functions. It's based on @babel/helpers
  // `helpers.asyncToGenerator()`:
  // https://github.com/babel/babel/blob/a967910/packages/babel-helpers/src/helpers.js#L255-L288
  // istanbul ignore next: deprecated code path unreachable via tests
  function baseGenToAsync$LWS(genNextWrapper$LWS, genThrowWrapper$LWS) {
    return new PromiseCtor$LWS((resolve$LWS, reject$LWS) => {
      function next$LWS(value$LWS) {
        genStep$LWS(resolve$LWS, reject$LWS, next$LWS, thrower$LWS, genNextWrapper$LWS, value$LWS);
      }
      function thrower$LWS(error) {
        genStep$LWS(resolve$LWS, reject$LWS, next$LWS, thrower$LWS, genThrowWrapper$LWS, error);
      }
      next$LWS(undefined);
    });
  },
  // istanbul ignore next: deprecated code path unreachable via tests
  function forAwaitOf$LWS(index$LWS, stage$LWS, object$LWS) {
    if (stage$LWS === 0 /* init */) {
      let sync$LWS = false;
      let {
        [SymbolAsyncIterator$LWS]: iterator$LWS
      } = object$LWS;
      if (iterator$LWS === null || iterator$LWS === undefined) {
        sync$LWS = true;
        ({
          [SymbolIterator$LWS$1]: iterator$LWS
        } = object$LWS);
      }
      if (typeof iterator$LWS !== 'function') {
        throw new TypeErrorCtor$LWS$1('Object is not async iterable');
      }
      forOfStateCache$LWS.set(index$LWS, {
        iterable: ReflectApply$LWS$1(iterator$LWS, object$LWS, []),
        step: undefined,
        sync: sync$LWS
      });
      return undefined;
    }
    const state$LWS = forOfStateCache$LWS.get(index$LWS);
    if (stage$LWS === 1 /* step */) {
      const result$LWS = state$LWS.iterable.next();
      return state$LWS.sync ? new PromiseCtor$LWS(resolve$LWS => {
        state$LWS.step = result$LWS;
        resolve$LWS();
      }) : ReflectApply$LWS$1(PromiseProtoThen$LWS, result$LWS, [step$LWS => {
        state$LWS.step = step$LWS;
      }]);
    }
    if (stage$LWS === 2 /* value */) {
      return state$LWS.step.value;
    }
    // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false if execution has reached this line.
    if (stage$LWS === 3 /* done */) {
      const done$LWS = !!state$LWS.step.done;
      if (done$LWS) {
        forOfStateCache$LWS.delete(index$LWS);
      }
      return done$LWS;
    }
    // istanbul ignore next: this is a safety precaution, not reachable via any normal execution
    return undefined;
  },
  // Functionality based on platformResourceLoader#loadScript (https://sfdc.co/7FuDU) but
  // adjusted for multiple sandboxes. This loadScript will create one <script> element in the
  // DOM per url per sandbox.
  // istanbul ignore next: currently unreachable via tests, platformResourceLoader testing is exclusively done in AMD format mode
  function loadScript$LWS(_thisArg$LWS, url$LWS) {
    const urlResolved$LWS = resolveURL$LWS(toSafeStringValue$LWS(url$LWS));
    const scripts$LWS = ReflectApply$LWS$1(ElementProtoQuerySelectorAll$LWS, head$LWS, ['script']);
    for (let i$LWS = 0, {
        length: length$LWS
      } = scripts$LWS; i$LWS < length$LWS; i$LWS += 1) {
      var _resourceStatusCache$$LWS;
      const script$LWS = scripts$LWS[i$LWS];
      // Ensure that this <script> is actually in the resource cache for this sandbox.
      // Previously this check only looked at the <script>'s src, which would give a
      // false positive if more than one sandbox had loaded this resource.
      const status$LWS = (_resourceStatusCache$$LWS = resourceStatusCache$LWS.get(script$LWS)) != null ? _resourceStatusCache$$LWS : 0 /* ResourceLoaderStatus.None */;
      // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false
      if (status$LWS && ReflectApply$LWS$1(scriptSrcGetterDistortion$LWS, script$LWS, []) === urlResolved$LWS) {
        if (status$LWS === 3 /* ResourceLoaderStatus.Loaded */) {
          return PromiseResolve$LWS(undefined);
        }
        // istanbul ignore if: this status cannot be tested without navigating the page itself during the execution of the request.
        if (status$LWS === 1 /* ResourceLoaderStatus.Errored */) {
          return PromiseReject$LWS(createResourceLoadError$LWS(urlResolved$LWS));
        }
        if (status$LWS === 2 /* ResourceLoaderStatus.Loading */) {
          return resourcePromiseCache$LWS.get(script$LWS);
        }
      }
    }
    const script$LWS = ReflectApply$LWS$1(DocumentProtoCreateElement$LWS$1, document$LWS, ['script']);
    script$LWS.type = 'text/javascript';
    // platformResourceLoader and ltng:require have to be synchronized in terms of creating
    // and loading scripts. This expando is used by ltng:require to know if a script
    // has been created by it or not. See W-13034908.
    // eslint-disable-next-line no-underscore-dangle
    script$LWS._ltngRequireCreated = true;
    ReflectApply$LWS$1(scriptSrcSetterDistortion$LWS, script$LWS, [urlResolved$LWS]);
    return loadPromise$LWS(script$LWS, urlResolved$LWS);
  },
  // Functionality based on platformResourceLoader#loadStyle (http://sfdc.co/bIpMYB) but
  // adjusted for multiple sandboxes. This loadStyle will create one <link> element in the DOM
  // per url for all the sandboxes.
  // istanbul ignore next: currently unreachable via tests, platformResourceLoader testing is exclusively done in AMD format mode
  function loadStyle$LWS(_thisArg$LWS, url$LWS) {
    const urlResolved$LWS = resolveURL$LWS(toSafeStringValue$LWS(url$LWS));
    let link$LWS = ReflectApply$LWS$1(ElementProtoQuerySelector$LWS, head$LWS, [`link[href=${enquote$LWS(urlResolved$LWS)}]`]);
    if (link$LWS) {
      var _resourceStatusCache$2$LWS;
      const status$LWS = (_resourceStatusCache$2$LWS = resourceStatusCache$LWS.get(link$LWS)) != null ? _resourceStatusCache$2$LWS : 0 /* ResourceLoaderStatus.None */;
      if (status$LWS === 0 /* ResourceLoaderStatus.None */ || status$LWS === 3 /* ResourceLoaderStatus.Loaded */) {
        return PromiseResolve$LWS(undefined);
      }
      // istanbul ignore if: this status cannot be tested without navigating the page itself during the execution of the request.
      if (status$LWS === 1 /* ResourceLoaderStatus.Errored */) {
        return PromiseReject$LWS(createResourceLoadError$LWS(urlResolved$LWS));
      }
      const promise$LWS = status$LWS === 2 /* ResourceLoaderStatus.Loading */ ? resourcePromiseCache$LWS.get(link$LWS) : undefined;
      return promise$LWS != null ? promise$LWS : PromiseResolve$LWS(undefined);
    }
    link$LWS = ReflectApply$LWS$1(DocumentProtoCreateElement$LWS$1, document$LWS, ['link']);
    link$LWS.type = 'text/css';
    link$LWS.rel = 'stylesheet';
    link$LWS.href = urlResolved$LWS;
    return loadPromise$LWS(link$LWS, urlResolved$LWS);
  }];
}
function toSourceText$LWS(value$LWS, sourceType$LWS) {
  let sourceText$LWS = typeof value$LWS === 'function' ? extractFunctionBodySource$LWS(value$LWS) : toSafeStringValue$LWS(value$LWS);
  // We workaround bundlers, like Rollup, aggressively stripping inline source
  // maps by compiling them with the name "sandboxMappingURL". At runtime the
  // name is changed so the inline source map is registered.
  sourceText$LWS = ReflectApply$LWS$1(StringProtoReplace$LWS, sourceText$LWS, [
  // This regexp looks involved, but it prevents browsers and developer
  // tools from mistaking the regexp or the replacement string for an
  // actual source mapping URL.
  /\/\/# sandbox(?=MappingURL=.*?\s*$)/, '//# source']);
  sourceText$LWS = `\n//# LWS Version = "0.23.6"\n${sourceText$LWS}`;
  return sourceType$LWS === 1 /* SourceType.Module */ && indexOfPragma$LWS(sourceText$LWS, 'use strict') === -1 ?
  // Append "'use strict'" to the extracted function body so it is
  // evaluated in strict mode.
  `'use strict';${sourceText$LWS}` : sourceText$LWS;
}

// Flag whether the iframe should remain connected to the DOM.
const IFRAME_KEEP_ALIVE_FLAG$LWS = LOCKER_UNMINIFIED_FLAG$LWS$1 && !false;
// Fast path non-configurable document, location, and window objects in the
// virtual environment distortion callback by seeding them in the root window's
// created distortion map.
const rootDistortionMapSeedEntries$LWS = [[rootDocument$LWS, rootDocument$LWS], [rootWindowLocation$LWS, rootWindowLocation$LWS], [rootWindow$LWS$1, rootWindow$LWS$1]];
const seenGlobalObjects$LWS = toSafeWeakSet$LWS$1(new WeakSetCtor$LWS$1());
function createGetVirtualEnvironment$LWS(record$LWS) {
  let virtualEnvironment$LWS;
  return () => {
    // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false
    if (virtualEnvironment$LWS === undefined) {
      virtualEnvironment$LWS = createVirtualEnvironment$LWS(record$LWS);
    }
    return virtualEnvironment$LWS;
  };
}
function createVirtualEnvironmentEvaluator$LWS(record$LWS, getVirtualEnvironment$LWS) {
  let virtualEnvironment$LWS;
  return sourceText$LWS => {
    // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false
    if (virtualEnvironment$LWS === undefined) {
      virtualEnvironment$LWS = getVirtualEnvironment$LWS();
      // Stash the old eval context.
      const context$LWS = clearEvalContext$LWS();
      // Populate `record.helpers`.
      setEvalContext$LWS(redEvalHelpersFactory$LWS => {
        const helpers$LWS = ReflectApply$LWS$1(redEvalHelpersFactory$LWS, undefined, createEvalHelpersFactoryArgs$LWS(record$LWS));
        record$LWS.helpers = helpers$LWS;
        setEvalHelpers$LWS(helpers$LWS);
      });
      virtualEnvironment$LWS.evaluate(EVAL_HELPERS_SOURCE_TEXT$LWS);
      if (typeof context$LWS === 'object' && context$LWS !== null) {
        // Track the `context` object and its properties as a fast
        // targets because it may contain things like `blueGet` and
        // `blueSet` arrays.
        virtualEnvironment$LWS.trackAsFastTarget(context$LWS);
        const ownKeys$LWS = ReflectOwnKeys$LWS$1(context$LWS);
        for (let i$LWS = 0, {
            length: length$LWS
          } = ownKeys$LWS; i$LWS < length$LWS; i$LWS += 1) {
          const value$LWS = context$LWS[ownKeys$LWS[i$LWS]];
          if (typeof value$LWS === 'object' && value$LWS !== null) {
            virtualEnvironment$LWS.trackAsFastTarget(value$LWS);
          }
        }
      }
      // Restore the old eval context.
      setEvalContext$LWS(context$LWS);
    }
    return virtualEnvironment$LWS.evaluate(sourceText$LWS);
  };
}
function createSandboxEvaluator$LWS({
  LOCKER_VERBOSE_INSTRUMENTATION_FLAG: verboseInstrumentation$LWS,
  document: document$LWS,
  globalObject: globalObject$LWS,
  instrumentation: instrumentation$LWS,
  key: key$LWS,
  type: type$LWS
}) {
  return (sourceText$LWS, evalContext$LWS = EMPTY_OBJECT$LWS, evalGlobalObject$LWS = globalObject$LWS, evalDocument$LWS = document$LWS) => internalEvaluateInSandbox$LWS({
    context: evalContext$LWS,
    document: evalDocument$LWS,
    endowments: EMPTY_OBJECT$LWS,
    globalObject: evalGlobalObject$LWS,
    instrumentation: instrumentation$LWS,
    key: key$LWS,
    source: sourceText$LWS,
    sourceType: 0 /* SourceType.Script */,
    type: type$LWS,
    verboseInstrumentation: verboseInstrumentation$LWS
  });
}
function createVirtualEnvironment$LWS(record$LWS) {
  const {
    endowments: endowments$LWS,
    globalObject: globalObject$LWS,
    instrumentation: instrumentation$LWS,
    key: key$LWS,
    root: _root$LWS,
    root: {
      distortions: distortions$LWS
    },
    type: type$LWS
  } = record$LWS;
  const maxPerfMode$LWS = isGaterEnabledFeature$LWS(ENABLE_MAX_PERF_MODE_GATE$LWS) ||
  // 'devopsimpkg*' or exact 'omnistudio' will override INTO maxPerfMode
  isAllowedToOverrideGaterEnabledFeature$LWS(key$LWS, ENABLE_MAX_PERF_MODE_GATE$LWS);
  return createIframeVirtualEnvironment$LWS(globalObject$LWS, {
    defaultPolicy: {
      createScript:
      // istanbul ignore next: this is used to create a default in near-membrane
      dirty$LWS => dirty$LWS
    },
    distortionCallback(originalTarget$LWS) {
      const distortedTarget$LWS = distortions$LWS.get(originalTarget$LWS);
      if (distortedTarget$LWS) {
        return distortedTarget$LWS;
      }
      if (typeof originalTarget$LWS === 'function') {
        return originalTarget$LWS;
      }
      // Perform the first own property check in a try-catch to avoid
      // throwing an error on opaque, non-window, objects of a cross-origin
      // window.
      try {
        // The location property is the only common non-configurable
        // property between window and document, so it serves this check
        // very well.
        if (!ObjectHasOwn$LWS$1(originalTarget$LWS, 'location')) {
          return originalTarget$LWS;
        }
      } catch (_unused36$LWS) {
        // Likely an opaque object of a cross-origin window.
        // istanbul ignore next: an access of property iframe.contentWindow.location.href on an opaque window, that should reach this catch clause IS tested (see packages/integration-karma/test/distortions/HTMLIFrameElement/untrusted/snippets.js, "doesNotThrowOnCreationOrAccessOfCrossOriginIframeContentWindow"), but reported as uncovered
        return originalTarget$LWS;
      }
      let originalTargetDocument$LWS;
      let originalTargetWindow$LWS;
      // Do the safe cross-origin window object check first to avoid
      // failure caused by touching non-cross-origin-safe properties.
      if (ObjectHasOwn$LWS$1(originalTarget$LWS, 'window') && originalTarget$LWS.window === originalTarget$LWS) {
        // Slower check to detect a window object.
        try {
          // `WindowDocumentGetter` will throw if `originalTarget` is
          // not a window object, or if it is an opaque cross-origin window.
          originalTargetDocument$LWS = ReflectApply$LWS$1(WindowDocumentGetter$LWS, originalTarget$LWS, []);
          originalTargetWindow$LWS = originalTarget$LWS;
        } catch (_unused37$LWS) {
          try {
            // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false
            if (ReflectApply$LWS$1(WindowLocationGetter$LWS, originalTarget$LWS, [])) {
              createOpaqueSecondaryWindowSandboxRecord$LWS({
                globalObject: originalTarget$LWS,
                key: key$LWS,
                type: type$LWS
              }, _root$LWS);
              return originalTarget$LWS;
            }
            // eslint-disable-next-line no-empty
          } catch (_unused38$LWS) {}
        }
        // Check if originalTarget is a document and get its defaultView.
      } else if ('defaultView' in originalTarget$LWS) {
        // If the object doesn't appear to be a window, same or
        // cross-origin, then it may be a document for window that we
        // haven't seen yet, but can safely check non-cross-origin-safe
        // properties of, specifically `defaultView` which will give us
        // a window if one exists.
        let defaultView$LWS;
        try {
          // This will throw if `originalTarget` is not a document object.
          defaultView$LWS = ReflectApply$LWS$1(DocumentProtoDefaultViewGetter$LWS, originalTarget$LWS, []);
          // eslint-disable-next-line no-empty
        } catch (_unused39$LWS) {}
        if (defaultView$LWS) {
          originalTargetDocument$LWS = originalTarget$LWS;
          originalTargetWindow$LWS = defaultView$LWS;
        }
      }
      if (originalTargetWindow$LWS) {
        createSecondaryWindowSandboxRecord$LWS({
          context: EMPTY_OBJECT$LWS,
          document: originalTargetDocument$LWS,
          globalObject: originalTargetWindow$LWS,
          key: key$LWS,
          type: type$LWS
        }, _root$LWS);
      }
      return originalTarget$LWS;
    },
    endowments: endowments$LWS && endowments$LWS !== EMPTY_OBJECT$LWS ?
    // Normalize the descriptors of the provided endowments object,
    // and the default endowments descriptors so they can be
    // accessible from inside the sandbox.
    ObjectAssign$LWS$1({}, DEFAULT_ENDOWMENTS_DESCRIPTOR_MAP$LWS, ObjectGetOwnPropertyDescriptors$LWS(endowments$LWS)) : DEFAULT_ENDOWMENTS_DESCRIPTOR_MAP$LWS,
    instrumentation: instrumentation$LWS,
    maxPerfMode: maxPerfMode$LWS,
    keepAlive:
    // istanbul ignore next: cannot test isLockerFeatureEnabled
    maxPerfMode$LWS && isLockerFeatureEnabled$LWS('isLockerNextForOmnistudioEnabled') || IFRAME_KEEP_ALIVE_FLAG$LWS,
    liveTargetCallback: isTargetLive$LWS,
    signSourceCallback: sourceText$LWS => trusted.createScript(sourceText$LWS)
  });
}
// istanbul ignore next: currently unreachable via tests
function getDefaultType$LWS(key$LWS) {
  return key$LWS === CORE_SANDBOX_KEY$LWS ? 1 /* SandboxType.Internal */ : 0 /* SandboxType.External */;
}
function createRootWindowSandboxRecord$LWS({
  // istanbul ignore next: destructured default assignments are not correctly instrumented
  context: context$LWS = EMPTY_OBJECT$LWS,
  // istanbul ignore next: destructured default assignments are not correctly instrumented
  endowments: endowments$LWS = EMPTY_OBJECT$LWS,
  // istanbul ignore next: destructured default assignments are not correctly instrumented
  instrumentation: instrumentation$LWS = EMPTY_OBJECT$LWS,
  key: key$LWS,
  // istanbul ignore next: destructured default assignments are not correctly instrumented
  type: type$LWS = getDefaultType$LWS(key$LWS),
  // istanbul ignore next: destructured default assignments are not correctly instrumented
  verboseInstrumentation: verboseInstrumentation$LWS = false
}) {
  let record$LWS = rootSandboxRegistry$LWS[key$LWS];
  if (record$LWS) {
    return record$LWS;
  }
  // istanbul ignore next: instrumentation is not tested
  const LOCKER_INSTRUMENTATION_FLAG$LWS =
  // In the future we can preface the LOCKER_INSTRUMENTATION_FLAG
  // definition with a LOCKER_UNMINIFIED_FLAG check to have instrumentation
  // removed in minified production builds.
  instrumentation$LWS !== EMPTY_OBJECT$LWS && typeof instrumentation$LWS === 'object' && instrumentation$LWS !== null;
  const distortions$LWS = createDistortionMap$LWS(rootDistortionMapSeedEntries$LWS);
  record$LWS = {
    BASIC_INSTRUMENTATION_DATA: LOCKER_INSTRUMENTATION_FLAG$LWS ? {
      sandboxKey: key$LWS
    } : EMPTY_OBJECT$LWS,
    LOCKER_INSTRUMENTATION_FLAG: LOCKER_INSTRUMENTATION_FLAG$LWS,
    LOCKER_VERBOSE_INSTRUMENTATION_FLAG:
    // In the future we can preface the LOCKER_INSTRUMENTATION_FLAG
    // definition with a LOCKER_UNMINIFIED_FLAG check to have instrumentation
    // removed in minified production builds.
    verboseInstrumentation$LWS && LOCKER_INSTRUMENTATION_FLAG$LWS,
    UNCOMPILED_CONTEXT: ROOT_UNCOMPILED_CONTEXT$LWS,
    context: context$LWS,
    document: rootDocument$LWS,
    distortions: distortions$LWS,
    endowments: endowments$LWS,
    globalObject: rootWindow$LWS$1,
    helpers: EMPTY_EVAL_HELPERS$LWS,
    instrumentation: instrumentation$LWS,
    key: key$LWS,
    root: EMPTY_OBJECT$LWS,
    sandboxEvaluator: noop$LWS$1,
    type: type$LWS,
    virtualEnvironmentEvaluator: noop$LWS$1
  };
  const getVirtualEnvironment$LWS = createGetVirtualEnvironment$LWS(record$LWS);
  record$LWS.root = record$LWS;
  record$LWS.sandboxEvaluator = createSandboxEvaluator$LWS(record$LWS);
  record$LWS.virtualEnvironmentEvaluator = createVirtualEnvironmentEvaluator$LWS(record$LWS, getVirtualEnvironment$LWS);
  const entries$LWS = createDistortionEntries$LWS(record$LWS, getDistortionFactories$LWS(record$LWS));
  // Add distortions to the root window's distortion map.
  for (let i$LWS = 0, {
      length: length$LWS
    } = entries$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const {
      0: entryKey$LWS,
      1: entryValue$LWS
    } = entries$LWS[i$LWS];
    distortions$LWS.set(entryKey$LWS, entryValue$LWS);
  }
  rootSandboxRegistry$LWS[key$LWS] = record$LWS;
  return record$LWS;
}
function createOpaqueSecondaryWindowSandboxRecord$LWS({
  globalObject: globalObject$LWS,
  key: key$LWS,
  // istanbul ignore next: destructured default assignments are not correctly instrumented
  type: type$LWS = /* istannul ignore next: nothing works to ignore these */getDefaultType$LWS(key$LWS)
}, _root$LWS) {
  const sandboxRegistry$LWS = getOpaqueSandboxRegistry$LWS(globalObject$LWS);
  let record$LWS = sandboxRegistry$LWS[key$LWS];
  // istanbul ignore if: calls that would evaluate to true here ARE tested (see packages/integration-karma/test/distortions/HTMLIFrameElement/untrusted/snippets.js, "doesNotThrowOnCreationOrAccessOfCrossOriginIframeContentWindow"), but reported as uncovered
  if (record$LWS) {
    return record$LWS;
  }
  const {
    BASIC_INSTRUMENTATION_DATA: BASIC_INSTRUMENTATION_DATA$LWS,
    LOCKER_INSTRUMENTATION_FLAG: LOCKER_INSTRUMENTATION_FLAG$LWS,
    LOCKER_VERBOSE_INSTRUMENTATION_FLAG: LOCKER_VERBOSE_INSTRUMENTATION_FLAG$LWS,
    distortions: distortions$LWS,
    instrumentation: instrumentation$LWS
  } = _root$LWS;
  record$LWS = {
    BASIC_INSTRUMENTATION_DATA: BASIC_INSTRUMENTATION_DATA$LWS,
    LOCKER_INSTRUMENTATION_FLAG: LOCKER_INSTRUMENTATION_FLAG$LWS,
    LOCKER_VERBOSE_INSTRUMENTATION_FLAG: LOCKER_VERBOSE_INSTRUMENTATION_FLAG$LWS,
    UNCOMPILED_CONTEXT: EMPTY_OBJECT$LWS,
    context: EMPTY_OBJECT$LWS,
    document,
    distortions: EMPTY_DISTORTIONS_MAP$LWS,
    endowments: EMPTY_OBJECT$LWS,
    globalObject: globalObject$LWS,
    helpers: EMPTY_EVAL_HELPERS$LWS,
    instrumentation: instrumentation$LWS,
    key: key$LWS,
    root: _root$LWS,
    sandboxEvaluator: noop$LWS$1,
    type: type$LWS,
    virtualEnvironmentEvaluator: noop$LWS$1
  };
  // Fast path non-configurable location and window objects in the virtual
  // environment distortion callback by adding them to the root window's
  // distortion map.
  const {
    location: location$LWS
  } = globalObject$LWS;
  distortions$LWS.set(location$LWS, location$LWS);
  // istanbul ignore else: current tests have no way of expressing a state that would cause this condition to evaluate false
  if (!seenGlobalObjects$LWS.has(globalObject$LWS)) {
    distortions$LWS.set(globalObject$LWS, globalObject$LWS);
  }
  // Add opaque window postMessage distortion for the child window to the root
  // window's distortion map.
  const opaqueWindowPostMessageDistortionFactory$LWS = getOpaqueWindowPostMessageDistortionFactory$LWS(record$LWS);
  const opaqueWindowPostMessageDistortionEntry$LWS = opaqueWindowPostMessageDistortionFactory$LWS(record$LWS);
  const originalOpaqueWindowPostMessage$LWS = opaqueWindowPostMessageDistortionEntry$LWS[0];
  distortions$LWS.set(originalOpaqueWindowPostMessage$LWS, proxyMaskFunctionDistortion$LWS(record$LWS, opaqueWindowPostMessageDistortionFactory$LWS, opaqueWindowPostMessageDistortionEntry$LWS[1], originalOpaqueWindowPostMessage$LWS));
  sandboxRegistry$LWS[key$LWS] = record$LWS;
  return record$LWS;
}
function createSecondaryWindowSandboxRecord$LWS({
  globalObject: globalObject$LWS,
  document: document$LWS,
  // istanbul ignore next: destructured default assignments are not correctly instrumented
  context: context$LWS = /* istanbul ignore next: currently unreachable via tests */EMPTY_OBJECT$LWS,
  key: key$LWS,
  // istanbul ignore next: destructured default assignments are not correctly instrumented
  type: type$LWS = /* istanbul ignore next: currently unreachable via tests */getDefaultType$LWS(key$LWS)
}, _root$LWS) {
  const sandboxRegistry$LWS = getSandboxRegistry$LWS(document$LWS);
  let record$LWS = sandboxRegistry$LWS[key$LWS];
  if (record$LWS) {
    return record$LWS;
  }
  const {
    BASIC_INSTRUMENTATION_DATA: BASIC_INSTRUMENTATION_DATA$LWS,
    LOCKER_INSTRUMENTATION_FLAG: LOCKER_INSTRUMENTATION_FLAG$LWS,
    LOCKER_VERBOSE_INSTRUMENTATION_FLAG: LOCKER_VERBOSE_INSTRUMENTATION_FLAG$LWS,
    distortions: distortions$LWS,
    instrumentation: instrumentation$LWS
  } = _root$LWS;
  const {
    location: location$LWS,
    top: top$LWS
  } = globalObject$LWS;
  record$LWS = {
    BASIC_INSTRUMENTATION_DATA: BASIC_INSTRUMENTATION_DATA$LWS,
    LOCKER_INSTRUMENTATION_FLAG: LOCKER_INSTRUMENTATION_FLAG$LWS,
    LOCKER_VERBOSE_INSTRUMENTATION_FLAG: LOCKER_VERBOSE_INSTRUMENTATION_FLAG$LWS,
    UNCOMPILED_CONTEXT: {
      [UNCOMPILED_LOCATION_NAME$LWS]: location$LWS,
      [UNCOMPILED_TOP_NAME$LWS]: top$LWS,
      // The following context entries are explicitly added because the
      // UNCOMPILED_*_NAME entries will only be added to the contextNames
      // via transforms when the fully qualified member expression is detected
      // in the code, eg. window.location, or window.top.
      // See complete explanation in packages/@locker/shared-dom/src/source-transformations.ts.
      location: location$LWS,
      top: top$LWS
    },
    context: context$LWS,
    document: document$LWS,
    distortions: EMPTY_DISTORTIONS_MAP$LWS,
    endowments: EMPTY_OBJECT$LWS,
    globalObject: globalObject$LWS,
    helpers: EMPTY_EVAL_HELPERS$LWS,
    instrumentation: instrumentation$LWS,
    key: key$LWS,
    root: _root$LWS,
    sandboxEvaluator: noop$LWS$1,
    type: type$LWS,
    virtualEnvironmentEvaluator: noop$LWS$1
  };
  const getVirtualEnvironment$LWS = createGetVirtualEnvironment$LWS(record$LWS);
  record$LWS.sandboxEvaluator = createSandboxEvaluator$LWS(record$LWS);
  record$LWS.virtualEnvironmentEvaluator = createVirtualEnvironmentEvaluator$LWS(record$LWS, getVirtualEnvironment$LWS);
  // Fast path non-configurable document, location, and window objects in the
  // virtual environment distortion callback by adding them to the root window's
  // distortion map.
  distortions$LWS.set(document$LWS, document$LWS);
  distortions$LWS.set(location$LWS, location$LWS);
  const seenGlobalObject$LWS = seenGlobalObjects$LWS.has(globalObject$LWS);
  if (!seenGlobalObject$LWS) {
    // WindowProxy object references don't change when the window location
    // changes.
    // https://developer.mozilla.org/en-US/docs/Glossary/WindowProxy
    distortions$LWS.set(globalObject$LWS, globalObject$LWS);
  }
  const entries$LWS = createDistortionEntries$LWS(record$LWS, getDistortionFactories$LWS(record$LWS));
  for (let i$LWS = 0, {
      length: length$LWS
    } = entries$LWS; i$LWS < length$LWS; i$LWS += 1) {
    const {
      0: entryKey$LWS,
      1: entryValue$LWS
    } = entries$LWS[i$LWS];
    // Add distortion to the root window's distortion map.
    distortions$LWS.set(entryKey$LWS, entryValue$LWS);
  }
  sandboxRegistry$LWS[key$LWS] = record$LWS;
  if (seenGlobalObject$LWS) {
    return record$LWS;
  }
  seenGlobalObjects$LWS.add(globalObject$LWS);
  const onDOMContentLoadedOrWindowLoad$LWS = () => {
    try {
      // We don't need to use `WindowDocumentGetter()` because we know
      // this is a window object and the 'document' property is
      // non-configurable.
      const {
        document: newDocument$LWS
      } = globalObject$LWS;
      // Ensure the document has changed before attempting to create a
      // sandbox record.
      if (document$LWS !== newDocument$LWS) {
        createSecondaryWindowSandboxRecord$LWS({
          context: EMPTY_OBJECT$LWS,
          document: newDocument$LWS,
          globalObject: globalObject$LWS,
          key: key$LWS,
          type: type$LWS
        }, _root$LWS);
      }
    } catch (_unused40$LWS) {
      // istanbul ignore next: this is a safety precaution that is unreachable via tests
      createOpaqueSecondaryWindowSandboxRecord$LWS({
        globalObject: globalObject$LWS,
        key: key$LWS,
        type: type$LWS
      }, _root$LWS);
    }
  };
  const frameElement$LWS = ReflectApply$LWS$1(WindowFrameElementGetter$LWS, globalObject$LWS, []);
  if (frameElement$LWS) {
    // Create a new sandbox record when the iframe window location changes.
    ReflectApply$LWS$1(EventTargetProtoAddEventListener$LWS, frameElement$LWS, ['load', onDOMContentLoadedOrWindowLoad$LWS,
    // useCapture
    true]);
  } else {
    // Create a new sandbox record when the opened window location changes.
    // https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event#usage_notes
    //
    // The 'unload' event handler is okay to use here under the assumption
    // that most `window.open()` calls are not done with the 'noopener'
    // option, so the back/forward cache (i.e. bfcache) is likely being
    // skipped anyways.
    // https://web.dev/bfcache/#avoid-window.opener-references
    ReflectApply$LWS$1(EventTargetProtoAddEventListener$LWS, globalObject$LWS, ['unload', function onWindowUnload$LWS() {
      WindowQueueMicrotask$LWS(() => {
        try {
          // Ensure the document has changed before adding event
          // listeners.
          const {
            document: newDocument$LWS
          } = globalObject$LWS;
          if (document$LWS === newDocument$LWS) {
            return;
          }
          // istanbul ignore next: currently unreachable via tests
          ReflectApply$LWS$1(EventTargetProtoAddEventListener$LWS, globalObject$LWS, ['DOMContentLoaded', onDOMContentLoadedOrWindowLoad$LWS, true]);
          // istanbul ignore next: currently unreachable via tests
          ReflectApply$LWS$1(EventTargetProtoAddEventListener$LWS, globalObject$LWS, ['unload', onWindowUnload$LWS, true]);
        } catch (_unused41$LWS) {
          // istanbul ignore next: this is a safety precaution that is unreachable via tests
          createOpaqueSecondaryWindowSandboxRecord$LWS({
            globalObject: globalObject$LWS,
            key: key$LWS,
            type: type$LWS
          }, _root$LWS);
        }
      });
    },
    // useCapture
    true]);
  }
  return record$LWS;
}
function internalEvaluateInSandbox$LWS(evaluateOptions$LWS) {
  const {
    document: document$LWS,
    context: context$LWS,
    endowments: endowments$LWS,
    globalObject: globalObject$LWS,
    instrumentation: instrumentation$LWS,
    key: key$LWS,
    source: source$LWS,
    sourceType: sourceType$LWS,
    type: type$LWS,
    verboseInstrumentation: verboseInstrumentation$LWS
  } = evaluateOptions$LWS;
  if (typeof key$LWS !== 'string') {
    throw new LockerSecurityError$LWS(ERR_INVALID_SANDBOX_KEY$LWS);
  }
  const {
    LOCKER_INSTRUMENTATION_FLAG: LOCKER_INSTRUMENTATION_FLAG$LWS,
    helpers: helpers$LWS,
    virtualEnvironmentEvaluator: virtualEnvironmentEvaluator$LWS
  } = globalObject$LWS === rootWindow$LWS$1 ? createRootWindowSandboxRecord$LWS({
    context: context$LWS,
    endowments: endowments$LWS,
    instrumentation: instrumentation$LWS,
    key: key$LWS,
    type: type$LWS,
    verboseInstrumentation: verboseInstrumentation$LWS
  }) : createSecondaryWindowSandboxRecord$LWS({
    context: context$LWS,
    document: document$LWS,
    globalObject: globalObject$LWS,
    key: key$LWS,
    type: type$LWS
  }, rootSandboxRegistry$LWS[key$LWS]);
  // Setting the context before evaluating the sourceText so compiled code
  // can wire up import/exports from both sides of the membrane.
  if (context$LWS !== EMPTY_OBJECT$LWS) {
    setEvalContext$LWS(context$LWS);
  }
  if (helpers$LWS !== EMPTY_EVAL_HELPERS$LWS) {
    setEvalHelpers$LWS(helpers$LWS);
  }
  let result$LWS;
  const sourceText$LWS = toSourceText$LWS(source$LWS, sourceType$LWS);
  // istanbul ignore next: instrumentation is not tested
  const activity$LWS = LOCKER_INSTRUMENTATION_FLAG$LWS ? instrumentation$LWS == null ? void 0 : instrumentation$LWS.startActivity('lws.evaluate') : undefined;
  try {
    // Protecting against errors during evaluation can guarantee the state
    // of the EvalContext to avoid leaking context values
    result$LWS = virtualEnvironmentEvaluator$LWS(sourceText$LWS);
    // istanbul ignore next: instrumentation is not tested
    instrumentation$LWS == null || instrumentation$LWS.incrementCounter == null || instrumentation$LWS.incrementCounter('lws.evaluate', 1, false);
  } catch (error) {
    // istanbul ignore next: instrumentation is not tested
    instrumentation$LWS == null || instrumentation$LWS.incrementCounter == null || instrumentation$LWS.incrementCounter('lws.evaluate', 1, true);
    // istanbul ignore next: instrumentation is not tested
    activity$LWS == null || activity$LWS.error({
      sandboxKey: key$LWS,
      error
    });
    // istanbul ignore next: instrumentation is not tested
    activity$LWS == null || activity$LWS.stop();
    throw error;
  } finally {
    clearEvalContext$LWS();
    clearEvalHelpers$LWS();
  }
  // istanbul ignore next: instrumentation is not tested
  activity$LWS == null || activity$LWS.stop();
  return result$LWS;
}
// istanbul ignore next: currently unreachable via tests, exclusively used in AMD format mode
function evaluateFunction$LWS(key$LWS, fn$LWS, scope$LWS = EMPTY_OBJECT$LWS, sourceURL$LWS = '', endowments$LWS = EMPTY_OBJECT$LWS, instrumentation$LWS = EMPTY_OBJECT$LWS, verboseInstrumentation$LWS = false) {
  const argValues$LWS = toSafeArray$LWS$1([rootWindow$LWS$1.location, rootWindow$LWS$1.top]);
  const argNames$LWS = toSafeArray$LWS$1(['location', 'top']);
  const providedScopeNames$LWS = ObjectKeys$LWS$1(scope$LWS);
  for (let i$LWS = 0, {
      length: length$LWS
    } = providedScopeNames$LWS; i$LWS < length$LWS; i$LWS++) {
    const name$LWS = providedScopeNames$LWS[i$LWS];
    argNames$LWS.push(name$LWS);
    argValues$LWS.push(scope$LWS[name$LWS]);
  }
  return internalEvaluateInSandbox$LWS({
    context: EMPTY_OBJECT$LWS,
    document: rootDocument$LWS,
    endowments: endowments$LWS,
    globalObject: rootWindow$LWS$1,
    instrumentation: instrumentation$LWS,
    key: key$LWS,
    source: `((${argNames$LWS.join(',')}) => ${fn$LWS})\n${sourceURL$LWS}`,
    sourceType: 1 /* SourceType.Module */,
    type: 0 /* SandboxType.External */,
    verboseInstrumentation: verboseInstrumentation$LWS
  })(...argValues$LWS);
}
const sandboxDependencies$LWS = toSafeMap$LWS$1(new MapCtor$LWS$1());
const lprDepNames$LWS = toSafeSet$LWS(new SetCtor$LWS$1(['lightning/platformResourceLoader', 'lightning:platformResourceLoader', 'lightningmobileruntime/platformResourceLoader', 'lightningmobileruntime:platformResourceLoader']));
// istanbul ignore next: currently unreachable via tests, platformResourceLoader testing is exclusively done in AMD format mode
function wrapDependency$LWS(dep$LWS, depName$LWS, key$LWS) {
  if (depName$LWS === 'lwc' || depName$LWS === '@lwc/engine-dom' || depName$LWS === '@lwc:engine-dom') {
    return wrapLWC$LWS(dep$LWS, key$LWS);
  }
  if (lprDepNames$LWS.has(depName$LWS)) {
    return wrapPlatformResourceLoader$LWS(dep$LWS, key$LWS);
  }
  return dep$LWS;
}
/**
 * Given an instance of 'lwc,' this returns a facade with a limited set
 * of exposed properties. These properties are safe to expose in the
 * sandbox. High privilege properties are not exposed.
 * @param {any} dep 'lwc' fv
 * @param {string} key sandbox key
 */
// istanbul ignore next: currently unreachable via tests, platformResourceLoader testing is exclusively done in AMD format mode
function wrapLWC$LWS(dep$LWS, key$LWS) {
  let depRegistry$LWS = sandboxDependencies$LWS.get(key$LWS);
  if (depRegistry$LWS === undefined) {
    depRegistry$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
    sandboxDependencies$LWS.set(key$LWS, depRegistry$LWS);
  }
  let secureDep$LWS = depRegistry$LWS.get(dep$LWS);
  if (secureDep$LWS) {
    return secureDep$LWS;
  }
  secureDep$LWS = ObjectAssign$LWS$1({}, dep$LWS);
  ReflectDefineProperty$LWS$1(secureDep$LWS, 'sanitizeAttribute', {
    __proto__: null,
    enumerable: true,
    configurable: true,
    writable: true,
    value(tag$LWS, _namespace$LWS, attrName$LWS, attrValue$LWS) {
      if ((attrName$LWS === 'href' || attrName$LWS === 'xlink:href') && ReflectApply$LWS$1(StringProtoToLowerCase$LWS, tag$LWS, []) === 'use') {
        return sanitizeSvgHref$LWS(attrValue$LWS);
      }
      return attrValue$LWS;
    }
  });
  ReflectDefineProperty$LWS$1(secureDep$LWS, 'renderer', {
    __proto__: null,
    enumerable: true,
    configurable: true,
    get: function () {
      let renderer$LWS;
      return function () {
        if (renderer$LWS === undefined) {
          renderer$LWS = createRootWindowSandboxRecord$LWS({
            key: key$LWS
          }).virtualEnvironmentEvaluator(`'use strict';
                    (${ReflectApply$LWS$1(FunctionProtoToString$LWS, dep$LWS.rendererFactory, [])})`)(dep$LWS.renderer);
        }
        return renderer$LWS;
      };
    }(),
    set(_value$LWS) {}
  });
  depRegistry$LWS.set(dep$LWS, secureDep$LWS);
  return secureDep$LWS;
}
/**
 * Given an instance of 'lightning/platfromResourceLoader,' this returns
 * our secure versions of 'loadScript' and 'loadStyle' from the sandbox helpers.
 * @param {any} dep 'lightning/platfromResourceLoader'
 * @param {string} key sandbox key
 */
// istanbul ignore next: currently unreachable via tests, platformResourceLoader testing is exclusively done in AMD format mode
function wrapPlatformResourceLoader$LWS(dep$LWS, key$LWS) {
  let depRegistry$LWS = sandboxDependencies$LWS.get(key$LWS);
  if (depRegistry$LWS === undefined) {
    depRegistry$LWS = toSafeWeakMap$LWS$1(new WeakMapCtor$LWS$1());
    sandboxDependencies$LWS.set(key$LWS, depRegistry$LWS);
  }
  let secureDep$LWS = depRegistry$LWS.get(dep$LWS);
  if (secureDep$LWS) {
    return secureDep$LWS;
  }
  secureDep$LWS = {
    loadScript: (cmp$LWS, url$LWS, config$LWS) => {
      const urlResolved$LWS = resolveURL$LWS(url$LWS);
      const sandbox$LWS = createRootWindowSandboxRecord$LWS({
        key: key$LWS
      });
      if (isGaterEnabledFeature$LWS('enableTrustedMode') && config$LWS != null && config$LWS.trustedMode) {
        const trustedGlobals$LWS = config$LWS.trustedGlobals;
        if ((trustedGlobals$LWS == null ? void 0 : trustedGlobals$LWS.length) > 0) {
          return dep$LWS.loadScript(cmp$LWS, urlResolved$LWS).then(() => {
            const installGlobals$LWS = sandbox$LWS.virtualEnvironmentEvaluator(`(list) => list.forEach(([key, get, set]) => Object.defineProperty(window, key, { get, set, configurable: true, enumerable: true }));`);
            const globals$LWS = trustedGlobals$LWS.map(globalName$LWS => [globalName$LWS, function get$LWS() {
              return window[globalName$LWS];
            }, function set$LWS(value$LWS) {
              window[globalName$LWS] = value$LWS;
            }]);
            installGlobals$LWS(globals$LWS);
          });
        }
        return dep$LWS.loadScript(cmp$LWS, urlResolved$LWS);
      }
      return sandbox$LWS.helpers.loadScript(cmp$LWS, urlResolved$LWS);
    },
    loadStyle: (cmp$LWS, url$LWS) => {
      const urlResolved$LWS = resolveURL$LWS(url$LWS);
      return createRootWindowSandboxRecord$LWS({
        key: key$LWS
      }).helpers.loadStyle(cmp$LWS, urlResolved$LWS);
    }
  };
  depRegistry$LWS.set(dep$LWS, secureDep$LWS);
  return secureDep$LWS;
}
/*! version: 0.23.6 */

const loaderDefine = globalThis.LWR.define;

/**
 * Mark an exports object as "live", see https://github.com/caridy/secure-javascript-environment/pull/87.
 *
 * @returns the marked object
 */
function markLiveObject(object) {
    Reflect.defineProperty(object, Symbol.for('@@lockerLiveValue'), {});
    return object;
}

/**
 * Evaluate the given exporter in a sandbox of the given namespace
 */
function vNextEvaluateModule(namespace, specifier, exporter) {
    return evaluateFunction$LWS(namespace, exporter, undefined, `//# sourceURL=modules/${specifier}.js\n`);
}

/**
 * Return a "secure" version of the given exporter, either
 * the given exporter as is if the module is from a trusted
 * namespace/component, or a "lockerized" version of the exporter if not.
 */
function secureExporter(
    specifier,
    dependencies,
    exporter,
    trustedNamespaces,
) {
    const [namespace, name] = specifier.split('/');

    // return the exporter as is if it's from a trusted component or namespace
    if (
        trustedNamespaces.includes(namespace) ||
        trustedNamespaces.includes(`${namespace}/*`) ||
        trustedNamespaces.includes(`${namespace}/${name}`)
    ) {
        return exporter;
    }

    // not a trusted namespace/component, let's lockerize the exporter
    const out = vNextEvaluateModule(namespace, specifier, exporter);

    // Dependencies that require modification.
    let exportsIndex = -1;
    let lwcIndex = -1;
    let platformResourceLoaderIndex = -1;
    let lmrPlatformResourceLoaderIndex = -1;
    for (let i = 0; i < dependencies.length; i++) {
        const dependency = dependencies[i];
        const [dependencyName] = dependency.split('/v/');
        switch (dependencyName) {
            case 'exports':
                exportsIndex = i;
                break;
            case 'lwc':
            case '@lwc/engine-dom':
                lwcIndex = i;
                break;
            case 'lightning/platformResourceLoader':
                platformResourceLoaderIndex = i;
                break;
            case 'lightningmobileruntime/platformResourceLoader':
                lmrPlatformResourceLoaderIndex = i;
                break;
        }
    }
    if (exportsIndex !== -1 || lwcIndex !== -1 || platformResourceLoaderIndex !== -1) {
        return function (...args) {
            if (exportsIndex !== -1) {
                const arg = args[exportsIndex];
                args[exportsIndex] = markLiveObject(arg) || arg;
            }
            if (lwcIndex !== -1) {
                args[lwcIndex] = wrapDependency$LWS(args[lwcIndex], 'lwc', namespace);
            }
            if (platformResourceLoaderIndex !== -1) {
                args[platformResourceLoaderIndex] = wrapDependency$LWS(
                    args[platformResourceLoaderIndex],
                    'lightning/platformResourceLoader',
                    namespace,
                );
            }
            if (lmrPlatformResourceLoaderIndex !== -1) {
                args[lmrPlatformResourceLoaderIndex] = wrapDependency$LWS(
                    args[lmrPlatformResourceLoaderIndex],
                    'lightningmobileruntime/platformResourceLoader',
                    namespace,
                );
            }
            return out.apply(this, args);
        };
    }

    return out;
}

function registerLockerDefine(trustedNamespaces) {
    // override the global LWR.define() for Locker
    globalThis.LWR = Object.freeze(
        Object.assign(Object.assign({}, globalThis.LWR), {
            define: function (specifier, dependencies, exporter, signature) {
                if (typeof dependencies === 'function') {
                    // when the module has no dependency, the bundler only passes 3 parameters, the specifier, exporter and signature
                    // e.g. LWR.define('my/cmp', function() { return 1; }, {ownhash})
                    signature = exporter;
                    exporter = dependencies;
                    dependencies = [];
                }
                loaderDefine(
                    specifier,
                    dependencies,
                    secureExporter(specifier, dependencies, exporter, trustedNamespaces),
                    signature,
                );
            },
        }),
    );
}

export { registerLockerDefine };
//# sourceMappingURL=lockerDefine.js.map
