import { parseRequestDepth } from '@lwrjs/shared-utils';
// See: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Forwarded
function parseForwardedHeader(forwarded) {
    if (!forwarded)
        return undefined;
    // parse the Forwarded header to find the "host" and "proto"
    // case-insensitive and can contain empty space around the key=value pairs
    const couples = forwarded.toLocaleLowerCase().split(';');
    const map = couples.reduce((m, c) => {
        const [key, value] = c.trim().split('=');
        m[key] = value;
        return m;
    }, {});
    // build the protocol:host string
    const proto = map.proto ? `${map.proto}://` : '';
    return map.host ? `${proto}${map.host}` : undefined;
}
export class AbstractMiddlewareRequest {
    constructor(isSiteGenerationRequest) {
        this.isSiteGenerationRequest = isSiteGenerationRequest || false;
    }
    cookie(key) {
        // Does not require the cookie-parser middleware
        const rawCookies = (this.headers.cookie?.split(';') || []).map((c) => c.trim());
        const rawCookie = rawCookies.find((c) => c.startsWith(`${key}=`));
        return rawCookie ? decodeURIComponent(rawCookie.replace(`${key}=`, '')) : undefined;
    }
    isSiteGeneration() {
        return this.isSiteGenerationRequest;
    }
    hasJsonParam() {
        return this.query.json !== undefined;
    }
    isJsonRequest() {
        const acceptHeader = this.headers?.accept || '';
        const hasJsonHeader = acceptHeader.indexOf('application/json') >= 0;
        return hasJsonHeader || this.query.json !== undefined;
    }
    validateJsonRequest() {
        const hasJsonQueryParam = this.hasJsonParam();
        const hasAcceptHeader = this.headers?.accept !== undefined;
        const hasJsonAcceptHeader = hasAcceptHeader && this.headers?.accept?.includes('application/json');
        return ((!hasAcceptHeader && !hasJsonQueryParam) ||
            hasJsonQueryParam !== hasAcceptHeader ||
            hasJsonQueryParam === hasJsonAcceptHeader);
    }
    validateEnvironmentRequest(config) {
        const targetEnvironment = this.params.environment;
        const defaultEnvironment = config.environment.default;
        const supportedEnvironments = config.environment.supported || [];
        return (!targetEnvironment ||
            targetEnvironment === defaultEnvironment ||
            supportedEnvironments?.includes(targetEnvironment));
    }
    validateApiVersion(config) {
        const apiVersion = this.params.apiVersion;
        return apiVersion === config.apiVersion;
    }
    getRuntimeContext(defaultRuntimeEnvironment) {
        const { format, apiVersion, basePath: basePathParam, compat, locale: localeParam, environment, bundleSpecifier, } = this.params;
        const debug = this.query.debug !== undefined;
        const bundle = !!bundleSpecifier;
        const runtimeEnvironment = {
            ...defaultRuntimeEnvironment,
            // override default runtime environment with request parameters
            format: format || defaultRuntimeEnvironment.format,
            compat: compat || defaultRuntimeEnvironment.compat,
            debug: debug || defaultRuntimeEnvironment.debug,
            apiVersion: apiVersion || defaultRuntimeEnvironment.apiVersion,
            bundle: bundle || defaultRuntimeEnvironment.bundle,
            basePath: this.basePath || basePathParam || defaultRuntimeEnvironment.basePath,
        };
        let host = parseForwardedHeader(this.headers?.forwarded) || this.headers?.host || undefined;
        if (host && !host.startsWith('http')) {
            // If the Forwarded header did not set a protocol prefer X-Forwarded-Proto over the local server protocol
            host = `${this.headers?.['x-forwarded-proto'] || this.protocol}://${host}`;
        }
        // Increment the depth for any fetch calls
        const requestDepth = parseRequestDepth(this.headers, this.query) + 1;
        const basePath = runtimeEnvironment.basePath;
        const defaultLocale = runtimeEnvironment.i18n.defaultLocale;
        const locale = localeParam || this.locale || defaultLocale;
        // Base path to be used in routing ${basePath}/locale
        const uiBasePath = runtimeEnvironment.i18n.uriPattern === 'path-prefix' && defaultLocale !== locale
            ? `${basePath}/${locale}`
            : `${basePath}`;
        // Path to static artifacts on MRT the is ${basePath}/mobify/build/${bundleId}
        // On express this is ${basePath}
        const assetBasePath = `${runtimeEnvironment.basePath}${runtimeEnvironment.defaultAssetPath}`;
        const runtimeParams = {
            basePath,
            locale,
            assetBasePath,
            uiBasePath,
            environment,
            host,
            requestDepth,
        };
        return {
            runtimeEnvironment,
            runtimeParams,
        };
    }
    getCoreProxy(appCoreProxy, proxyForSSR = false) {
        const origin = process.env.CORE_ORIGIN;
        const host = process.env.CORE_HOST;
        const servername = process.env.CORE_SERVERNAME;
        const override = process.env.PROXY_FOR_SSR;
        // override the value of the route-level bootstrap proxyForSSR flag:
        //      "false" => override the route-level flag to be false
        //      "true" => override the route-level flag to be true
        //      empty/unset -> use route-level flag as-is
        if (override === 'false' || (!proxyForSSR && override !== 'true'))
            return undefined;
        // origin is required to proxy to Core
        return origin ? { origin, host, servername } : appCoreProxy;
    }
}
//# sourceMappingURL=abstract-request.js.map