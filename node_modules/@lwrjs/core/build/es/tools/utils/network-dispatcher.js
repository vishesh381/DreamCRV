import http from 'http';
import https from 'https';
import { logger } from '@lwrjs/diagnostics';
import { isLocalDev, isModuleOrBundleUrl } from '@lwrjs/shared-utils';
export default class NetworkDispatcher {
    constructor(port, internalRequestKey) {
        this.port = port || 3000;
        const httpClient = this.port == 443 ? https : http;
        this.pool = new httpClient.Agent({
            maxSockets: 25,
        });
        this.internalRequestKey = internalRequestKey || '';
    }
    dispatchUrl(url, method, lang) {
        const options = this.createRequestOptions(url, method, lang);
        return this.handleRequest(options, url, method, lang);
    }
    createRequestOptions(url, method, lang) {
        return {
            method: method,
            host: 'localhost',
            port: this.port,
            path: url,
            agent: this.pool,
            headers: {
                'Accept-Language': lang,
                // pass private key to get access to internal metadata
                'lwr-metadata-request': this.internalRequestKey,
            },
        };
    }
    handleRequest(options, url, method, lang) {
        return new Promise((resolve, reject) => {
            const httpClient = options.port == 443 ? https : http;
            const bodyChunks = [];
            logger.verbose({
                label: `NetworkDispatcher`,
                message: `Request: [${method}][${lang}] ${url}`,
            });
            const req = httpClient.request(options, (res) => {
                res.on('data', (chunk) => {
                    bodyChunks.push(chunk);
                });
                res.on('end', () => {
                    logger.verbose({
                        label: `NetworkDispatcher`,
                        message: `[END] Request: [${method}][${lang}] ${url}`,
                    });
                    if (!res.statusCode || (res.statusCode >= 200 && res.statusCode < 300)) {
                        const body = Buffer.concat(bodyChunks).toString();
                        try {
                            const jsonResponse = JSON.parse(body);
                            resolve(jsonResponse);
                        }
                        catch (err) {
                            const message = !isLocalDev() // avoid giant log messages during local dev
                                ? `unexpected response body: [${method}][${lang}] ${url}: '${body}'`
                                : `unexpected response body: [${method}][${lang}] ${url}`;
                            if (logger.isDebugEnabled()) {
                                logger.warn({
                                    label: `NetworkDispatcher`,
                                    message,
                                    additionalInfo: err,
                                });
                            }
                            else {
                                logger.warn({
                                    label: `NetworkDispatcher`,
                                    message,
                                });
                            }
                            resolve({});
                        }
                    }
                    else if (res.statusCode === 301 || res.statusCode === 302) {
                        // Lets follw if we know it is a module or bundle refrence
                        if (res.headers?.location && isModuleOrBundleUrl(res.headers?.location)) {
                            logger.debug({
                                label: `NetworkDispatcher`,
                                message: `Follow redirect: [${method}][${lang}][${res.statusCode}] ${url} -> ${res.headers.location}`,
                            });
                            const location = res.headers.location;
                            return (this.handleRequest(this.createRequestOptions(location, method, lang), location, method, lang)
                                // Send nested response to the resolve or reject functions defined above
                                .then((resRedirect) => resolve(resRedirect))
                                // Should not happen since we are just warning on error
                                .catch((rejectRedirect) => reject(rejectRedirect)));
                        }
                        else {
                            logger.warn({
                                label: `NetworkDispatcher`,
                                message: `Redirect not followed: [${method}][${lang}][${res.statusCode}] ${url} -> ${res.headers.location}`,
                            });
                            resolve({});
                        }
                    }
                    // if any other status codes are returned, those needed to be added here
                    else {
                        logger.warn({
                            label: `NetworkDispatcher`,
                            message: `Unexpected status code: [${method}][${lang}][${res.statusCode}] ${url}`,
                        });
                        resolve({});
                    }
                });
            });
            req.on('error', (err) => {
                if (logger.isDebugEnabled()) {
                    logger.warn({
                        label: `NetworkDispatcher`,
                        message: `Request Failed: [${method}][${lang}] ${url}`,
                        additionalInfo: err,
                    });
                }
                else {
                    logger.warn({
                        label: `NetworkDispatcher`,
                        message: `Request  Failed: [${method}][${lang}] ${url}`,
                    });
                }
                resolve({});
            });
            req.end();
        });
    }
}
//# sourceMappingURL=network-dispatcher.js.map