import { performance } from 'perf_hooks';
import { logger } from '@lwrjs/diagnostics';
import { 
// createIntegrityHash,
getSpecifier, getFeatureFlags, hashContent, isSelfUrl, getModuleUriPrefix, getMappingUriPrefix, isExternalUrl, mimeLookup, getViewUri, sortLocalesByFallback, VERSION_NOT_PROVIDED, PROTOCOL_FILE, normalizeFromFileURL, isExternalSpecifier, explodeSpecifier, prettyModuleUriSuffix, normalizeVersionToUri, signBundle, } from '@lwrjs/shared-utils';
import { SiteMetadataImpl, getSiteBundleId, getSiteResourceId } from '@lwrjs/static/site-metadata';
import { join, dirname, extname, normalize } from 'path';
import fs from 'fs-extra';
import { writeResponse } from './utils/stream.js';
import { createResourceDir } from './utils/dir.js';
import { getRuntimeEnvironment } from '@lwrjs/config';
import { fileURLToPath } from 'url';
export default class SiteGenerator {
    /**
     * Build a static site in the configured directory
     *  - Generate all routes / modules
     *  - copy assets / resources
     *
     * @deprecated - use new build api
     * @param config - LWR config for the site
     * @param dispatcher - Facilitate server requests
     */
    async buildStaticApplication(config, dispatcher) {
        const startTime = performance.now();
        logger.info({ label: `ssg`, message: `Static Site Generation` });
        // De-duplicate warming messages if log level is warn or info
        if (logger.isWarnEnabled()) {
            logger.setOptions({ dedupe: new Set(['warn']) });
        }
        const { assets, basePath, rootDir, routes, staticSiteGenerator } = config;
        if (!staticSiteGenerator.outputDir) {
            staticSiteGenerator.outputDir = 'site';
        }
        const outputDir = join(rootDir, staticSiteGenerator.outputDir);
        if (!staticSiteGenerator.skipCleanOutputDir) {
            logger.info({ label: `ssg`, message: `Clearing output directory: ${outputDir}` });
            fs.rmSync(outputDir, { recursive: true, force: true });
        }
        else if (fs.existsSync(outputDir)) {
            logger.info({ label: `ssg`, message: `Reusing existing output directory: ${outputDir}` });
        }
        const urlRewriteMap = new Map();
        const runtimeEnvironment = getRuntimeEnvironment(config);
        // For each locale, generate all the modules
        logger.info({ label: `ssg`, message: `Building routes (this may take some time to complete)` });
        await this.generateRoutes(runtimeEnvironment, staticSiteGenerator, routes, basePath, dispatcher, outputDir, urlRewriteMap);
        // Write redirect files
        this.writeNetlifyRedirectConfig(outputDir, urlRewriteMap);
        // Copy over assets
        await this.copyAssets(assets, outputDir, config);
        const endTime = performance.now();
        const timeDiff = (endTime - startTime) / 1000;
        logger.info({
            label: `ssg`,
            message: `Static Site Generation complete in ${Math.round(timeDiff)} seconds`,
        });
    }
    /**
     * Crawl all view routes for a site
     */
    async generateRoutes(runtimeEnvironment, staticSiteGenerator, routes, basePath, dispatcher, outputDir, urlRewriteMap = new Map()) {
        const generateUrl = this.createGenerateURLFunction(dispatcher);
        // Note: generateUrl can consume a lot of memory so we need to do this sequentially
        const { skipBaseDocumentGeneration = false } = staticSiteGenerator;
        const i18n = runtimeEnvironment.i18n;
        // If there is not a know URL pattern it is expected the app is accounting with the locale in the routes
        if (!i18n.uriPattern) {
            // eslint-disable-next-line no-await-in-loop
            await this.generateRoutesForLocale(routes, outputDir, { id: i18n.defaultLocale }, urlRewriteMap, skipBaseDocumentGeneration, runtimeEnvironment, basePath, generateUrl, staticSiteGenerator, dispatcher);
        }
        else {
            // Run through locales in fallback sorted order
            const sortedLocales = sortLocalesByFallback(i18n);
            // Generate all the routes
            for (const locale of sortedLocales) {
                logger.debug({ label: `ssg`, message: `Generate routes of locale: ${locale.id}` });
                // eslint-disable-next-line no-await-in-loop
                await this.generateRoutesForLocale(routes, outputDir, locale, urlRewriteMap, skipBaseDocumentGeneration, runtimeEnvironment, basePath, generateUrl, staticSiteGenerator, dispatcher);
            }
        }
    }
    /**
     * Generate all routes for a given locale
     */
    async generateRoutesForLocale(routes, outputDir, locale, urlRewriteMap, skipBaseDocumentGeneration, runtimeEnvironment, basePath, generateUrl, staticSiteGenerator, dispatcher) {
        const i18n = runtimeEnvironment.i18n;
        for (const route of routes) {
            const siteConfig = this.createSiteConfig(outputDir, locale.id, urlRewriteMap, skipBaseDocumentGeneration, runtimeEnvironment, i18n);
            const localizedPath = getViewUri(route.path, basePath, locale.id, i18n);
            // eslint-disable-next-line no-await-in-loop
            await generateUrl(localizedPath, siteConfig);
        }
        // Generate any additional urls
        if (staticSiteGenerator._additionalRoutePaths) {
            for (const uri of staticSiteGenerator._additionalRoutePaths) {
                const siteConfig = this.createSiteConfig(outputDir, locale.id, urlRewriteMap, skipBaseDocumentGeneration, runtimeEnvironment, i18n);
                // eslint-disable-next-line no-await-in-loop
                await generateUrl(uri, siteConfig);
            }
        }
        // Handle _additionalModules specifiers
        const { _additionalModules } = staticSiteGenerator;
        if (_additionalModules) {
            for (const specifier of _additionalModules) {
                logger.debug({ label: `ssg`, message: `Additional Module: ${locale.id} ${specifier}` });
                const startTime = performance.now();
                const siteConfig = this.createSiteConfig(outputDir, locale.id, urlRewriteMap, skipBaseDocumentGeneration, runtimeEnvironment, i18n);
                // eslint-disable-next-line no-await-in-loop
                await this.dispatchJSResourceRecursive(specifier, dispatcher, siteConfig, true);
                // Capture any additional collected metadata
                // eslint-disable-next-line no-await-in-loop
                await this.captureAdditionalRouteMetadata(siteConfig);
                const endTime = performance.now();
                const timeDiff = endTime - startTime;
                logger.info({
                    label: `ssg`,
                    message: `Additional Module ${locale.id} ${specifier} in ${Math.round(timeDiff)} ms`,
                });
            }
        }
    }
    /**
     * Creates a function to dispatch the root requests for a given view url
     */
    createGenerateURLFunction(dispatcher) {
        const generateRoute = async (uri, siteConfig) => {
            const locale = siteConfig.locale;
            logger.debug({ label: `ssg`, message: `Start Generate: ${locale} ${uri}` });
            const startTime = performance.now();
            // Kick off site generation for the current route
            await this.dispatchResourceRecursive(uri, dispatcher, { resourceType: 'route' }, siteConfig);
            // Capture any additional route metadata
            await this.captureAdditionalRouteMetadata(siteConfig);
            const endTime = performance.now();
            const timeDiff = endTime - startTime;
            logger.info({ label: `ssg`, message: `${locale} ${uri} in ${Math.round(timeDiff)} ms` });
        };
        return generateRoute.bind(this);
    }
    /**
     * Primary recursive dispatch function.  Executes a URL and crawls its dependents.
     *
     * @param url - URL to execute
     * @param dispatcher - Facilitates GET requests
     * @param resourceOpts - Data about the URL to execute
     * @param siteConfig - Running config for the current view
     */
    async dispatchResourceRecursive(url, dispatcher, resourceOpts, siteConfig) {
        const { visitedUrls } = siteConfig;
        if (!visitedUrls.has(url)) {
            visitedUrls.add(url); // Maintain a list of visited urls here to avoid potential infinite loops
            // Skip remote urls (i.e. http://) the static view would call the remote url at runtime
            if (isExternalUrl(url)) {
                logger.warn({ label: `ssg`, message: `Skipped generation of external url: ${url}` });
                return;
            }
            // Skip urls with path segment variables (i.e. '/custom/:bar')
            // Users can specify specific urls via the '_additionalRoutePaths' config property
            if (url.indexOf('/:') !== -1 || url.indexOf('*') !== -1) {
                logger.warn({
                    label: `ssg`,
                    message: `Skipped generation of url with variable path segment: ${url}`,
                });
                return;
            }
            // Generate resource
            let context;
            context = await dispatcher.dispatchUrl(url, 'GET', siteConfig.locale);
            // Handle 302 redirect if applicable
            if (context?.fs?.headers?.Location) {
                this.saveServerBundles(siteConfig, context.fs.metadata?.viewDefinition?.viewRecord.serverBundles);
                const redirectUrl = context?.fs?.headers?.Location;
                url = redirectUrl;
                const redirectContext = await dispatcher.dispatchUrl(url, 'GET', siteConfig.locale);
                context = redirectContext;
            }
            const { resourceType } = resourceOpts;
            // -- Routes (root resources) -------
            if (resourceType === 'route') {
                await this.handleHtmlResource(url, context, siteConfig, dispatcher);
                // -- Process Assets (css, images, ...) && Resources (lwr-loader-shim ...)
            }
            else if (resourceType === 'asset' || resourceType === 'resource') {
                await this.handleAssetOrResource(url, context, siteConfig, dispatcher);
                // -- Import Metadata Mappings
            }
            else if (resourceType == 'mapping') {
                await this.handleMappingResource(url, context, siteConfig, dispatcher);
                // -- Process JS files
            }
            else if (resourceType === 'js') {
                await this.handleJavascriptResource(url, context, siteConfig, dispatcher);
            }
        }
    }
    /**
     * Handle processing a returned javascript module or bundle and follow all returned references
     * @param url - URL of the request javascript resource
     * @param context - Response Context
     * @param siteConfig - Global metadata about the site
     * @param dispatcher - Network dispatcher
     */
    async handleJavascriptResource(url, context, siteConfig, dispatcher) {
        const { outputDir } = siteConfig;
        const moduleDefinition = context.fs?.metadata?.moduleDefinition; // LinkedModuleDefinition | BundleDefinition
        const bundleConfig = moduleDefinition?.config || {};
        const siteBundles = siteConfig?.siteMetadata?.getSiteBundles()?.bundles;
        const specifier = moduleDefinition?.specifier;
        if (isExternalSpecifier(specifier, bundleConfig)) {
            this.handleExternalBundle(specifier, siteBundles, bundleConfig.external, outputDir);
            return;
        }
        const normalizedUrl = decodeURIComponent(url);
        createResourceDir(dirname(normalizedUrl), outputDir);
        const ext = extname(normalizedUrl);
        const fullPath = join(outputDir, `${normalizedUrl}${ext ? '' : '.js'}`);
        // TEMP: Code to force client bundles to fail fast during SSR for manual testing
        // if (context.fs?.body) {
        //     const body = `if (typeof window === 'undefined') throw new Error('This is a client bundle! ${specifier}');\n${context.fs.body}`;
        //     if (moduleDefinition) moduleDefinition.integrity = createIntegrityHash(body);
        //     context.fs.body = body;
        // }
        await writeResponse(context, fullPath);
        // Build up a list of dispatch requests to kick off in parallel
        const dispatchRequests = [];
        // Add URL re-writes for module redirects
        if (normalizedUrl.indexOf('/s/') !== -1) {
            // Redirect unsigned to signed URIs
            // e.g. /1/bundle/amd/l/en-US/bi/0/module/mi/c/module/v/0_1_6 -> /1/bundle/amd/l/en-US/bi/0/module/mi/c/module/v/0_1_6/s/{signature}
            siteConfig.urlRewriteMap.set(normalizedUrl.substring(0, normalizedUrl.indexOf('/s/')), normalizedUrl);
            // Redirect encoded signed URIs to UNencoded signed URIs
            // e.g. /1/bundle/amd/l/en-US/bi/0/module/mi/c%2Fmodule%2Fv%2F0_1_6/s/{signature} -> /1/bundle/amd/l/en-US/bi/0/module/mi/c/module/v/0_1_6/s/{signature}
            siteConfig.urlRewriteMap.set(url.substring(0, url.indexOf('/s/')), normalizedUrl);
            // Redirect un-versioned/unsigned URIs to signed URIs
            // e.g. /1/bundle/amd/l/en-US/bi/0/module/mi/c/module -> /1/bundle/amd/l/en-US/bi/0/module/mi/c/module/v/0_1_6/s/{signature}
            // e.g. with importer /1/bundle/amd/l/en-US/bi/0/module/mi/c/module?importer=parent%2Fmodule%2Fv%2F2_1_0 -> /1/bundle/amd/l/en-US/bi/0/module/mi/c/module/v/0_1_6/s/{signature}
            siteConfig.urlRewriteMap.set(normalizedUrl.substring(0, normalizedUrl.indexOf('/v/')), normalizedUrl);
            // Redirect encoded un-versioned/unsigned URIs to UNencoded signed URIs
            // e.g. /1/bundle/amd/l/en-US/bi/0/module/mi/c%2Fmodule -> /1/bundle/amd/l/en-US/bi/0/module/mi/c/module/v/0_1_6/s/{signature}
            // e.g. with importer /1/bundle/amd/l/en-US/bi/0/module/mi/c%2Fmodule?importer=parent%2Fmodule%2Fv%2F2_1_0 -> /1/bundle/amd/l/en-US/bi/0/module/mi/c/module/v/0_1_6/s/{signature}
            siteConfig.urlRewriteMap.set(url.substring(0, url.indexOf('%2Fv%2F')), normalizedUrl);
        }
        // Recursively traverse dependencies
        if (moduleDefinition) {
            // Imports
            const imports = moduleDefinition.linkedModuleRecord?.imports || moduleDefinition.bundleRecord?.imports || [];
            // /1/module/esm/0/l/en-US/mi/lwc
            for (const importModule of imports) {
                const importSpecifier = importModule.specifier;
                if (isExternalSpecifier(importSpecifier, bundleConfig)) {
                    this.handleExternalBundle(importSpecifier, siteBundles, bundleConfig.external, outputDir);
                }
                else {
                    const jsUri = importSpecifier.startsWith('/')
                        ? importSpecifier
                        : getSpecifier(importModule);
                    dispatchRequests.push(this.dispatchJSResourceRecursive(jsUri, dispatcher, siteConfig));
                }
            }
            // Dynamic imports
            const dynamicImports = moduleDefinition.linkedModuleRecord?.dynamicImports ||
                moduleDefinition.bundleRecord?.dynamicImports ||
                [];
            for (const importModule of dynamicImports) {
                const importSpecifier = importModule.specifier;
                if (isExternalSpecifier(importSpecifier, bundleConfig)) {
                    this.handleExternalBundle(importSpecifier, siteBundles, bundleConfig.external, outputDir);
                }
                else {
                    const jsUri = importSpecifier.startsWith('/')
                        ? importSpecifier
                        : getSpecifier(importModule);
                    dispatchRequests.push(this.dispatchJSResourceRecursive(jsUri, dispatcher, siteConfig));
                }
            }
            // If this is a bundle add it to the bundle metadata
            if (moduleDefinition.bundleRecord) {
                this.addBundleToSiteMetadata(moduleDefinition, url, false, siteConfig);
            }
        }
        // Bundles with unresolved module uris
        const uris = context.fs?.metadata?.resolvedUris || [];
        for (const jsUri of uris) {
            dispatchRequests.push(this.dispatchJSResourceRecursive(jsUri, dispatcher, siteConfig));
        }
        // -- Dispatch dependencies
        await Promise.all(dispatchRequests);
    }
    /**
     * If this is a file based external copy it to the site folder and add it to the bundle metadata
     */
    handleExternalBundle(specifier, siteBundles, externals, outputDir) {
        if (siteBundles && externals[specifier]?.startsWith(PROTOCOL_FILE) && !siteBundles[specifier]) {
            const path = normalizeFromFileURL(externals[specifier], process.cwd());
            const normalizedPath = decodeURIComponent(path);
            createResourceDir(dirname(normalizedPath), outputDir);
            const ext = extname(normalizedPath);
            const fullPath = join(outputDir, `${normalizedPath}${ext ? '' : '.js'}`);
            fs.copyFileSync(fileURLToPath(externals[specifier]), fullPath);
            const bundleMetadata = {
                specifier,
                path: normalizedPath,
                imports: [],
            };
            siteBundles[specifier] = bundleMetadata;
        }
    }
    addBundleToSiteMetadata(bundleDefinition, url, ssr, siteConfig) {
        if (siteConfig.siteMetadata) {
            const locale = siteConfig.locale;
            const specifier = getSiteBundleId(bundleDefinition, locale, ssr, siteConfig.i18n);
            const imports = bundleDefinition.bundleRecord.imports?.map((moduleRef) => getSiteBundleId(moduleRef, locale, false, siteConfig.i18n)) || [];
            const dynamicImports = bundleDefinition.bundleRecord.dynamicImports?.map((moduleRef) => getSiteBundleId(moduleRef, locale, false, siteConfig.i18n));
            const includedModules = bundleDefinition.bundleRecord.includedModules?.map((moduleRef) => {
                const moduleId = explodeSpecifier(moduleRef);
                return getSiteBundleId(moduleId, locale, false, siteConfig.i18n);
            }) || [];
            const version = bundleDefinition.version === VERSION_NOT_PROVIDED ? undefined : bundleDefinition.version;
            const bundleMetadata = {
                version,
                path: decodeURIComponent(url),
                includedModules,
                imports,
                dynamicImports,
                integrity: bundleDefinition.integrity,
            };
            const siteBundles = siteConfig.siteMetadata.getSiteBundles().bundles;
            siteBundles[specifier] = bundleMetadata;
        }
    }
    addResourceToSiteMetadata(resourceDefinition, url, siteConfig) {
        if (siteConfig.siteMetadata) {
            if (!resourceDefinition.specifier) {
                logger.warn({
                    label: `ssg`,
                    message: `Could not save resource metadata.  There was no specifier.`,
                    additionalInfo: resourceDefinition,
                });
            }
            else {
                const resourceMetadata = {
                    path: decodeURIComponent(url),
                    mimeType: resourceDefinition.type,
                    inline: resourceDefinition.inline,
                    version: resourceDefinition.version,
                    integrity: resourceDefinition.integrity,
                };
                const siteResources = siteConfig.siteMetadata.getSiteResources();
                siteResources.resources[getSiteResourceId(resourceDefinition)] = resourceMetadata;
            }
        }
    }
    addAssetToSiteMetadata(assetDefinition, url, siteConfig) {
        if (siteConfig.siteMetadata) {
            if (!assetDefinition.uri) {
                logger.warn({
                    label: `ssg`,
                    message: `Could not save asset metadata.  There was no uri.`,
                    additionalInfo: assetDefinition,
                });
            }
            else {
                const specifier = assetDefinition.uri;
                const resourceMetadata = {
                    path: decodeURIComponent(url),
                    mimeType: String(assetDefinition.mime),
                };
                const siteAssets = siteConfig.siteMetadata.getSiteAssets();
                // Do not overwrite
                if (!siteAssets.assets[specifier]) {
                    siteAssets.assets[specifier] = resourceMetadata;
                }
                else {
                    logger.debug({ label: `ssg`, message: `Ignore asset redefinition ${specifier}` });
                }
            }
        }
    }
    /**
     * Handle processing a returned module URI mapping resource and follow all returned references
     * @param url - URL of the request mapping resource
     * @param context - Response Context
     * @param siteConfig - Global metadata about the site
     * @param dispatcher - Network dispatcher
     */
    async handleMappingResource(url, context, siteConfig, dispatcher) {
        const { importMetadata: importMetadata } = siteConfig;
        const statusCode = context.response?.status;
        // Received a server error
        if (statusCode === 200) {
            // Read JSON
            const newImportMetadata = context.fs?.body;
            let filteredImportMetadata;
            if (!importMetadata) {
                filteredImportMetadata = newImportMetadata;
            }
            else {
                // need to handle importMetadata when generating from a view
                filteredImportMetadata = importMetadata.addAdditionalMetadata(newImportMetadata);
            }
            // Filter out and import metadata already included with the view
            // const filteredImportMetadata = importMetadata.addAdditionalMetadata(newImportMetadata);
            // Build up a list of dispatch requests to kick off in parallel
            const dispatchRequests = [];
            // Iterate through the import mappings and return request uris
            for (const uri of Object.keys(filteredImportMetadata.imports)) {
                dispatchRequests.push(this.dispatchResourceRecursive(uri, dispatcher, { resourceType: 'js' }, siteConfig));
            }
            // Wait for all requests to comeback
            await Promise.all(dispatchRequests);
        }
        else {
            const body = context.fs?.body;
            logger.warn({ label: `ssg`, message: `Failed to fetch ${url}: (${statusCode}) ${body}` });
        }
    }
    /**
     * Handle processing a returned HTML resource and process any provided view metadata
     *
     * @param url - URL of the requested HTML resource
     * @param context - Response Context
     * @param siteConfig - Global metadata about the site
     * @param dispatcher - Network Dispatcher
     */
    async handleHtmlResource(url, context, siteConfig, dispatcher) {
        const { outputDir, skipBaseDocumentGeneration } = siteConfig;
        if (!skipBaseDocumentGeneration) {
            let fileName = 'index.html';
            let directoryPath = url;
            // If we have a route path that ends with a html or xml file extension,
            // use that last path segment for the file name
            if (url.endsWith('.html') || url.endsWith('.xml')) {
                const lastPathIndex = url.lastIndexOf('/') + 1;
                fileName = url.substring(lastPathIndex, url.length);
                directoryPath = url.substring(0, lastPathIndex);
            }
            const dir = createResourceDir(directoryPath, outputDir);
            // TODO: Should we handle routes with non-html extensions differently?
            // Example Route: "path": "/mixed_templates.md" (not sure why you would do this)
            //                "contentTemplate": "$contentDir/composed_markdown.md"
            // Today this will get written to  /mixed_templates.md/index.html
            // Which we workaround by setting "renderSingle": true in serve.json
            const filePath = join(dir, fileName);
            // Write out response
            siteConfig.viewPaths.add(filePath);
            await writeResponse(context, filePath);
        }
        // Get the metadata
        const viewDefinition = context.fs?.metadata?.viewDefinition;
        if (viewDefinition) {
            // Process all references in the view
            await this.handleViewDefinition(viewDefinition, siteConfig, dispatcher);
        }
    }
    /**
     * Handle processing a returned view definition by following all returned references
     * @param viewDefinition - Metadata about everything directly referenced form the view
     * @param siteConfig - Global metadata about the site
     * @param dispatcher - Network dispatcher
     */
    async handleViewDefinition(viewDefinition, siteConfig, dispatcher) {
        // Save existing import metadata
        if (viewDefinition.viewRecord.importMetadata) {
            // Initialize import metadata collector
            siteConfig.importMetadata = new ViewImportMetadataImpl(viewDefinition.viewRecord.importMetadata);
        }
        // Build up a list of dispatch requests to kick off in parallel
        const dispatchRequests = [];
        // Assets
        const assets = viewDefinition.viewRecord.assetReferences || [];
        for (const asset of assets) {
            const assetUrl = asset.override?.uri || asset.url;
            // skip self referential asset urls / data urls (i.e. <img src="" /> <img src="data:image/png;base64, iVBORw0..." />)
            if (assetUrl && !isSelfUrl(assetUrl)) {
                dispatchRequests.push(this.dispatchResourceRecursive(assetUrl, dispatcher, { resourceType: 'asset', asset }, siteConfig));
            }
        }
        // Custom Elements
        const customElements = viewDefinition.viewRecord.customElements || [];
        for (const customElement of customElements) {
            const jsUris = Object.values(customElement.flatGraph.uriMap);
            for (const jsUri of jsUris) {
                dispatchRequests.push(this.dispatchJSResourceRecursive(jsUri, dispatcher, siteConfig));
            }
        }
        // Bootstrap modules
        if (viewDefinition.viewRecord.bootstrapModule) {
            const boot = viewDefinition.viewRecord.bootstrapModule;
            const jsUris = Object.values(boot.flatGraph.uriMap);
            for (const jsUri of jsUris) {
                dispatchRequests.push(this.dispatchJSResourceRecursive(jsUri, dispatcher, siteConfig));
            }
        }
        // Server bundles
        this.saveServerBundles(siteConfig, viewDefinition.viewRecord.serverBundles);
        // Bootstrap Resources
        const bootstrapResources = viewDefinition.viewRecord.bootstrapModule?.resources || [];
        for (const resource of bootstrapResources) {
            // If resource is not inline download it for reference
            if (!resource.inline) {
                const resourceUri = resource.src || resource.specifier;
                if (resourceUri) {
                    dispatchRequests.push(this.dispatchResourceRecursive(resourceUri, dispatcher, { resourceType: 'resource' }, siteConfig));
                    // Rough identify if this is the config Uri and add it to the site config to store additional import metadata
                    if (resourceUri.match(/\/application\/.*\/ai\/.*\/configuration/)) {
                        siteConfig.viewConfigPath = this.getResourcePathFromUrl(siteConfig, resourceUri);
                    }
                }
                else {
                    logger.warn({ label: `ssg`, message: `Skipped inline bootstrap resource: ${resource}` });
                }
            }
        }
        // Resources
        const resources = viewDefinition.viewRecord.resources || [];
        for (const resource of resources) {
            const resourceUri = resource.src || resource.specifier || '';
            if (resourceUri.startsWith('/')) {
                dispatchRequests.push(this.dispatchResourceRecursive(resourceUri, dispatcher, { resourceType: 'resource' }, siteConfig));
            }
            else {
                logger.warn({ label: `ssg`, message: `Skipped resource: ${resource}` });
            }
        }
        // -- Dispatch dependencies
        await Promise.all(dispatchRequests);
    }
    async dispatchJSResourceRecursive(jsUri, dispatcher, siteConfig, isAdditionalModulesRequest) {
        if (jsUri.startsWith('/')) {
            await this.dispatchResourceRecursive(jsUri, dispatcher, { resourceType: 'js' }, siteConfig);
        }
        else {
            const supportsFingerprints = !siteConfig.featureFlags?.LEGACY_LOADER;
            if (supportsFingerprints) {
                // Download mapping
                const mappingEndpoint = siteConfig.endpoints?.uris?.mapping;
                if (mappingEndpoint) {
                    const mappingURL = siteConfig.endpoints?.uris?.mapping + encodeURIComponent(jsUri);
                    await this.dispatchResourceRecursive(mappingURL, dispatcher, { resourceType: 'mapping' }, siteConfig);
                }
                else {
                    logger.warn({
                        label: `ssg`,
                        message: `Unable to fetch mapping for bare specifier or variable dynamic import: "${jsUri}"`,
                    });
                }
            }
            // TODO: this code path was still being hit prior to _additionalModules
            // flag for bare dynamic imports metadata.  This flag keeps the behavior as
            // before until we can figure out what to do with those requests.
            else if (isAdditionalModulesRequest) {
                // fallback to globalThis.LWR.imports.default
                const uri = `${siteConfig.endpoints?.uris.legacyDefault}${encodeURIComponent(jsUri)}`;
                await this.dispatchResourceRecursive(uri, dispatcher, { resourceType: 'js' }, siteConfig);
            }
        }
    }
    /**
     * Handle processing a returned asset or resource
     * @param url - URL of the requested asset or resource
     * @param context - Response Context
     * @param siteConfig - Global metadata about the site
     */
    async handleAssetOrResource(url, context, siteConfig, dispatcher) {
        const metadata = context.fs?.metadata;
        const fullPath = this.getResourcePathFromUrl(siteConfig, url);
        await writeResponse(context, fullPath);
        // Save Metadata
        // If resource add to resource metadata
        if (metadata?.resource) {
            this.addResourceToSiteMetadata(metadata?.resource, url, siteConfig);
        }
        else if (metadata?.asset) {
            this.addAssetToSiteMetadata(metadata?.asset, url, siteConfig);
        }
        // Call and referenced assets...
        const assetReferences = metadata?.asset?.metadata?.assetReferences || [];
        const dispatchRequests = [];
        for (const ref of assetReferences) {
            const refUrl = ref.override?.uri || ref.url;
            dispatchRequests.push(this.dispatchResourceRecursive(refUrl, dispatcher, { resourceType: 'asset', asset: metadata?.asset }, siteConfig).catch((err) => {
                // Warn the user that the we failed to fetch a referenced asset
                logger.warn({
                    label: `ssg`,
                    message: `Failed to fetch asset reference => ${refUrl} from ${url}`,
                    additionalInfo: err,
                });
            }));
        }
        return Promise.all(dispatchRequests);
    }
    getResourcePathFromUrl(siteConfig, url) {
        const { outputDir } = siteConfig;
        const normalizedUrl = decodeURIComponent(url);
        createResourceDir(dirname(normalizedUrl), outputDir);
        const fullPath = join(outputDir, normalizedUrl);
        // Remove query params from file paths
        const index = fullPath ? fullPath.indexOf('?') : -1;
        return index !== -1 ? fullPath.substring(0, index) : fullPath;
    }
    /**
     *  Write out redirect mapping files for static hosting services like netlify. Examples for why this is needed:
     *  -- Redirect /1/bundle/amd/l/en-US/bi/0/module/mi/lwr/navigation/v/0_1_6 -> /1/bundle/amd/l/en-US/bi/0/module/mi/lwr/navigation/v/0_1_6/s/{signature}
     *  -- Redirect /1/bundle/amd/l/en-US/bi/0/module/mi/lwr%2Fnavigation%2Fv%2F0_1_6 -> /1/bundle/amd/l/en-US/bi/0/module/mi/lwr/navigation/v/0_1_6/s/{signature}
     *
     * @param outputDir
     * @param urlRewriteMap
     */
    writeNetlifyRedirectConfig(outputDir, urlRewriteMap) {
        const serveJsonPath = join(outputDir, 'serve.json');
        const _redirectsPath = join(outputDir, '_redirects');
        if (fs.existsSync(_redirectsPath)) {
            fs.unlinkSync(_redirectsPath); // Delete the file if it exists
        }
        fs.createFileSync(_redirectsPath);
        const rewrites = [];
        urlRewriteMap.forEach((destination, source) => {
            // serve.json (serve)
            rewrites.push({
                source,
                destination,
            });
            // _redirects (netlify)
            fs.appendFileSync(_redirectsPath, source + ' ' + destination + ' 302!\n');
        });
        // write out the serve.json - redirects for modules without signatures
        fs.writeFileSync(serveJsonPath, JSON.stringify({ rewrites, directoryListing: false, renderSingle: true }, null, 1));
    }
    /**
     * Copy over assets
     * TODO this results in duplicate assets at the moment since assets can be referenced multiple ways:
     * '/public/assets/images/logo.svg'
     * '/1/asset/s/latest/public/assets/images/logo.svg'
     *
     * @param assets AssetConfig
     *
     */
    async copyAssets(assets, outputDir, config) {
        const { basePath } = config;
        const runtimeEnvironment = getRuntimeEnvironment(config);
        const siteConfig = this.createSiteConfig(outputDir, 'en-US', // Copy Assets should not use the locale
        new Map(), true, runtimeEnvironment, config.i18n);
        for (const asset of assets) {
            try {
                const assetSrcFile = asset.file;
                const assetSrcDir = asset.dir;
                const isRootConfig = asset.root;
                const urlPath = asset.urlPath;
                const assetsPath = join(outputDir, basePath ? basePath + urlPath : urlPath);
                if (assetSrcDir && fs.existsSync(assetSrcDir)) {
                    // If this is a root folder we do not want to recurse sub directories.
                    if (isRootConfig) {
                        const files = fs.readdirSync(assetSrcDir);
                        for (const file of files) {
                            const filePath = join(assetSrcDir, file);
                            if (fs.statSync(filePath).isFile()) {
                                const fileDestPath = join(assetsPath, file);
                                fs.copySync(filePath, fileDestPath);
                                this.addAssetToMetadata(fileDestPath, siteConfig);
                            }
                        }
                    }
                    else {
                        // else copy the source to the ssg root and then add the ssg paths to the metadata
                        fs.copySync(assetSrcDir, assetsPath);
                        this.addAssetsToMetadata(assetsPath, siteConfig);
                    }
                }
                else if (assetSrcFile && fs.existsSync(assetSrcFile)) {
                    fs.copySync(assetSrcFile, assetsPath);
                    this.addAssetToMetadata(assetsPath, siteConfig);
                }
                else {
                    logger.warn({
                        label: `ssg`,
                        message: `Could not find assets to copy at path: ${assetsPath}`,
                    });
                }
            }
            catch (e) {
                logger.error(`[ssg] Error occurred processing asset config: ${JSON.stringify(asset)}`);
                logger.error(e);
            }
        }
        await siteConfig.siteMetadata?.persistSiteMetadata();
    }
    addAssetsToMetadata(directoryPath, siteConfig) {
        try {
            const files = fs.readdirSync(directoryPath);
            for (const file of files) {
                const filePath = join(directoryPath, file);
                if (fs.statSync(filePath).isDirectory()) {
                    this.addAssetsToMetadata(filePath, siteConfig);
                }
                else {
                    this.addAssetToMetadata(filePath, siteConfig);
                }
            }
        }
        catch (err) {
            logger.warn({
                label: `ssg`,
                message: `Unexpected error collecting asset directory metadata for ${directoryPath}`,
                additionalInfo: err,
            });
        }
    }
    addAssetToMetadata(filePath, siteConfig) {
        try {
            const uri = encodeURI(normalize(filePath).replace(siteConfig.outputDir, ''));
            this.addAssetToSiteMetadata({
                uri,
                type: 'asset',
                stream: function (_encoding) {
                    throw new Error('Function not implemented.');
                },
                entry: filePath,
                ext: extname(filePath),
                mime: mimeLookup(filePath),
                ownHash: 'not-provided',
                content: function (_encoding) {
                    throw new Error('Function not implemented.');
                },
            }, uri, siteConfig);
        }
        catch (err) {
            logger.warn({
                label: `ssg`,
                message: `Unexpected error collecting asset metadata for ${filePath}`,
                additionalInfo: err,
            });
        }
    }
    /**
     * Create a new site config for the current view
     */
    createSiteConfig(outputDir, locale, urlRewriteMap, skipBaseDocumentGeneration, runtimeEnvironment, i18n) {
        const featureFlags = this.filterFeatureFlags();
        const endpoints = {
            uris: {
                // legacy globalThis.LWR.importMappings.default
                legacyDefault: getModuleUriPrefix(runtimeEnvironment, { locale }),
                mapping: getMappingUriPrefix(runtimeEnvironment, { locale }),
                server: getModuleUriPrefix({ ...runtimeEnvironment, bundle: true }, { locale }).replace('/bundle/', '/bundle-server/'),
            },
        };
        return {
            outputDir,
            viewPaths: new Set(),
            visitedUrls: new Set(),
            locale,
            urlRewriteMap,
            endpoints,
            skipBaseDocumentGeneration,
            // Only include LEGACY_LOADER if true
            ...featureFlags,
            siteMetadata: new SiteMetadataImpl({ rootDir: outputDir, i18n }),
            i18n,
        };
    }
    filterFeatureFlags() {
        const ffs = getFeatureFlags();
        if (ffs && Object.keys(ffs).length) {
            const accumulator = {};
            for (const [key, value] of Object.entries(ffs)) {
                if (value) {
                    accumulator[key] = true;
                }
            }
            return { featureFlags: accumulator };
        }
        else {
            return undefined;
        }
    }
    /**
     * Add any additional import metadata collected during static site generation to the Client Bootstrap Config for this view.
     */
    addAdditionalImportMetadataToViewConfig(siteConfig) {
        const supportsFingerprints = !siteConfig.featureFlags?.LEGACY_LOADER;
        const additionalImportMetadata = siteConfig?.importMetadata?.getAdditionalImportMetadata();
        if (supportsFingerprints &&
            siteConfig.viewConfigPath &&
            additionalImportMetadata?.imports &&
            Object.keys(additionalImportMetadata.imports).length > 0) {
            // Build and stringify the new import metadata
            const imports = additionalImportMetadata.imports
                ? JSON.stringify(additionalImportMetadata.imports)
                : '{}';
            const initImports = `if (!globalThis.LWR.imports) { globalThis.LWR.imports = {}; }`;
            const mergeImports = `Object.assign(globalThis.LWR.imports, ${imports})`;
            const index = additionalImportMetadata.index
                ? JSON.stringify(additionalImportMetadata.index)
                : '{}';
            const initIndex = `if (!globalThis.LWR.index) { globalThis.LWR.index = {}; }`;
            const mergeIndex = `Object.assign(globalThis.LWR.index, ${index})`;
            // Read in the old config and append the new import metadata
            const oldConfig = fs.readFileSync(siteConfig.viewConfigPath, 'utf-8');
            const newConfig = `${oldConfig}\n// Appended by Static Site Generator\n${initImports}\n${mergeImports}\n${initIndex}\n${mergeIndex}\n`;
            const configHash = hashContent(newConfig);
            // Write the updated config to a new filepath containing its hash signature, and delete the old config
            const sigRegex = /\/s\/[a-z0-9]+\/config\.js/i;
            const configSuffix = `/s/${configHash}/config.js`;
            const newConfigPath = siteConfig.viewConfigPath.replace(sigRegex, configSuffix);
            fs.mkdirSync(dirname(newConfigPath), { recursive: true }); // we know this dir does not exist
            fs.writeFileSync(newConfigPath, newConfig, 'utf-8');
            fs.rmSync(siteConfig.viewConfigPath);
            // Update the config script src in the view document(s)
            siteConfig.viewPaths.forEach((path) => {
                const oldDoc = fs.readFileSync(path, 'utf-8');
                const newDoc = oldDoc.toString().replace(sigRegex, configSuffix);
                fs.writeFileSync(path, newDoc, 'utf-8');
            });
        }
    }
    /**
     * Capture additional metadata collected during the processing of a route or additional module
     */
    async captureAdditionalRouteMetadata(siteConfig) {
        // If there is a view config add any extra collected import metadata to the config
        this.addAdditionalImportMetadataToViewConfig(siteConfig);
        // Save site meta data
        await siteConfig.siteMetadata?.persistSiteMetadata();
    }
    /**
     * Save the server bundles gathered during view generation to the file system and metadata
     */
    async saveServerBundles(siteConfig, bundles) {
        if (bundles?.size) {
            const { endpoints, outputDir } = siteConfig;
            bundles.forEach(async (bundle) => {
                const { specifier, version } = bundle;
                const vSpecifier = getSpecifier({
                    specifier,
                    version: version ? normalizeVersionToUri(version) : undefined,
                });
                const url = `${endpoints?.uris.server}${vSpecifier}/s/${signBundle(bundle)}/bundle_${prettyModuleUriSuffix(specifier)}.js`;
                this.addBundleToSiteMetadata(bundle, url, true, siteConfig);
                createResourceDir(dirname(url), outputDir);
                // TEMP: Code to force server bundles to fail fast on the client during manual testing
                // const body = `if (typeof window !== 'undefined') throw new Error('This is a server bundle! ${specifier}');\n${await bundle.getCode()}`;
                // await writeResponse({ fs: { body } }, join(outputDir, url));
                await writeResponse({ fs: { body: await bundle.getCode() } }, join(outputDir, url));
            });
        }
    }
}
// Class used to track import metadata for a view
export class ViewImportMetadataImpl {
    constructor(existingImportMetadata, additionalImportMetadata) {
        this.existing = existingImportMetadata;
        this.additional = additionalImportMetadata || { imports: {}, index: {} };
    }
    /**
     * Get the additional import metadata collected while generating this view
     * @returns
     */
    getAdditionalImportMetadata() {
        return this.additional;
    }
    /**
     * Adds any new imports found to the additional metadata map.  Returns a filtered
     * map of imports not in the initial view
     */
    addAdditionalMetadata(newMetadata) {
        const filteredImports = this.filterMetadata(newMetadata);
        this.mergeImportMetadata(this.additional, filteredImports);
        return filteredImports;
    }
    /**
     * Filter out any existing import metadata the would have already been sent back with the view from set of additional metadata detected
     */
    filterMetadata(newMetadata) {
        // Filter Imports
        const importsArray = Object.entries(newMetadata.imports);
        const filteredImports = importsArray.filter(([key]) => !this.existing.imports[key]);
        const imports = Object.fromEntries(filteredImports);
        // Filter Index
        const indexArray = Object.entries(newMetadata.index || {});
        const filteredIndex = indexArray.filter(([key]) => !this.existing.index || !this.existing.index[key]);
        const index = Object.fromEntries(filteredIndex);
        return {
            imports,
            index,
        };
    }
    /**
     * Merge new import metadata into target import metadata
     */
    mergeImportMetadata(targetImportMetadata, newImportMetadata) {
        Object.assign(targetImportMetadata.imports, newImportMetadata.imports);
        if (targetImportMetadata.index) {
            Object.assign(targetImportMetadata.index, newImportMetadata.index || {});
        }
    }
}
//# sourceMappingURL=static-generation.js.map