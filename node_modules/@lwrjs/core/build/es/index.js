import { getFeatureFlags } from '@lwrjs/shared-utils';
import { createInternalServer } from '@lwrjs/server';
import { LwrServerError, createSingleDiagnosticError, descriptions, logger } from '@lwrjs/diagnostics';
import { DEFAULT_LWR_BOOTSTRAP_CONFIG, loadConfig, executeConfigHooks, executeStartHooks, executeInstrumentationHooks, executeContextHooks, } from '@lwrjs/config';
import { loadHooks, loadServices, loadRouteHandlers } from '@lwrjs/config/modules';
import SiteGenerator from './tools/static-generation.js';
import { warmupServer } from './tools/server-warmup.js';
import { createServerContext } from './context/server.js';
import { createProviderContext } from './context/provider.js';
import { requestProcessorMiddleware } from './middleware/request-processor-middleware.js';
import { localeMiddleware } from './middleware/locale-middleware.js';
import { moduleMiddleware } from './middleware/module-middleware.js';
import { bundleMiddleware } from './middleware/bundle-middleware.js';
import { mappingMiddleware } from './middleware/mapping-middleware.js';
import { assetMiddleware } from './middleware/asset-middleware.js';
import { viewMiddleware } from './middleware/view-middleware.js';
import { resourceMiddleware } from './middleware/resource-middleware.js';
import { hmrMiddleware } from './middleware/hmr-middleware.js';
import { getTracer, CoreSpan } from '@lwrjs/instrumentation';
function initMiddleware(app, server, serverContext) {
    // TODO if we knew the target here we could make this middleware optional to target=mrt
    requestProcessorMiddleware(app, serverContext);
    localeMiddleware(app, serverContext);
    moduleMiddleware(app, serverContext);
    bundleMiddleware(app, serverContext);
    mappingMiddleware(app, serverContext);
    assetMiddleware(app, serverContext);
    resourceMiddleware(app, serverContext);
    // attach before the view middleware, so HMR polling is not treated as a view request
    if (serverContext.runtimeEnvironment.hmrEnabled) {
        hmrMiddleware(server, serverContext, app);
    }
    // view middleware MUST be attached last because it contains a greedy middleware
    // to handle unsupported routes
    viewMiddleware(app, serverContext);
    // initialize routes MUST be called when using koa
    app.initRoutes();
}
function createServices(entries, providerContext) {
    return entries.map(([ctor, providerConfig = {}]) => new ctor(providerConfig, providerContext));
}
async function initContext(appConfig, runtimeEnvironment, globalData) {
    // load all hooks
    const hooks = await loadHooks(appConfig);
    // apply both config and on start hooks
    if (hooks.length) {
        const skipValidation = true; // skip for config hook, since `executeStartHooks` hook will validate
        await executeConfigHooks(hooks, appConfig, runtimeEnvironment, globalData, skipValidation);
        executeInstrumentationHooks(hooks);
    }
    // load all configurable modules
    const services = await loadServices(appConfig);
    // create all framework components(ie. registries)
    const serverContext = getTracer().trace({ name: CoreSpan.CreateServerContext }, () => createServerContext(appConfig, runtimeEnvironment, globalData));
    // set routes on server context
    const routeHandlers = await loadRouteHandlers(appConfig);
    serverContext.routeHandlers = routeHandlers;
    if (hooks.length) {
        await executeContextHooks(hooks, serverContext);
        executeStartHooks(hooks, appConfig, runtimeEnvironment);
    }
    // create public subset of configurations
    const providerContext = createProviderContext(serverContext);
    const { moduleRegistry, assetRegistry, resourceRegistry, viewRegistry, moduleBundler } = serverContext;
    // instantiate each service
    const moduleProviders = createServices(services.moduleProviders, providerContext);
    const assetProviders = createServices(services.assetProviders, providerContext);
    const assetTransformers = createServices(services.assetTransformers, providerContext);
    const resourceProviders = createServices(services.resourceProviders, providerContext);
    const viewProviders = createServices(services.viewProviders, providerContext);
    const viewTransformers = createServices(services.viewTransformers, providerContext);
    const bundleProviders = createServices(services.bundleProviders, providerContext);
    const uriTransformers = createServices(services.uriTransformers, providerContext);
    // add services to their corresponding registry
    // Assets
    assetRegistry.addAssetProviders(assetProviders);
    assetRegistry.addAssetTransformers([...assetTransformers, ...uriTransformers]);
    // Bundles
    moduleBundler.addBundleProviders(bundleProviders);
    moduleBundler.addBundleTransformers(uriTransformers);
    // Modules
    moduleRegistry.addModuleProviders(moduleProviders);
    // Resources
    resourceRegistry.addResourceProviders(resourceProviders);
    resourceRegistry.addResourceTransformers(uriTransformers);
    // Views
    viewRegistry.addViewProviders(viewProviders);
    viewRegistry.addViewTransformers(viewTransformers);
    // invoke async initialization
    await serverContext.viewRegistry.initializeViewProviders();
    return serverContext;
}
export class LwrApp {
    constructor(configs) {
        this.initialized = false;
        const span = getTracer().startSpan({ name: CoreSpan.CreateServer });
        const { appConfig, runtimeEnvironment, globalData } = configs;
        this.config = appConfig;
        this.runtimeEnvironment = runtimeEnvironment;
        this.globalData = globalData;
        const { basePath, serverType, caseSensitiveRoutes } = this.config;
        this.serverType = serverType;
        this.app = createInternalServer(serverType, { basePath, caseSensitiveRoutes });
        this.server = this.app.createHttpServer();
        this.use = this.app.use.bind(this.app);
        this.all = this.app.all.bind(this.app);
        this.get = this.app.get.bind(this.app);
        this.post = this.app.post.bind(this.app);
        span.end();
    }
    getConfig() {
        return this.config;
    }
    async init() {
        const span = getTracer().startSpan({ name: CoreSpan.InitServer });
        if (this.initialized) {
            return;
        }
        // preemptively mark the server as initialized
        this.initialized = true;
        try {
            // create the application server context
            const context = await initContext(this.config, this.runtimeEnvironment, this.globalData);
            // attach framework middleware to the server
            initMiddleware(this.app, this.server, context);
        }
        catch (e) {
            // reset the initialized property if the server fails to initialize
            this.initialized = false;
            throw e;
        }
        span.end();
    }
    async listen(callback) {
        const span = getTracer().startSpan({ name: CoreSpan.StartServer });
        await this.init();
        const { server, config, app } = this;
        const { serverMode, port } = config;
        return new Promise((resolve, reject) => {
            const handleError = (err) => {
                server.off('error', handleError);
                if (err.code === 'EADDRINUSE') {
                    err = new Error(`Port ${port} is already in use.`);
                }
                reject(err);
            };
            server.on('error', handleError);
            server.listen(port, async () => {
                server.off('error', handleError);
                if (process.env.WARMUP?.toLowerCase() === 'true') {
                    try {
                        await warmupServer(config, app.getInternalRequestKey());
                    }
                    catch (err) {
                        const diagnostic = createSingleDiagnosticError({
                            description: descriptions.SERVER.WARMUP_ERROR(err.message),
                        }, LwrServerError);
                        return reject(diagnostic);
                    }
                }
                const opts = { serverMode, port };
                callback?.(opts);
                span.end(); // TODO is this the right tracing for start server?
                resolve(opts);
            });
        });
    }
    close() {
        this.server?.close && this.server.close();
    }
    // Get the underlying server (e.g. express, koa...)
    getInternalServer() {
        return this.app.getImpl();
    }
}
export function createServer(config) {
    const configs = loadConfig(config);
    return new LwrApp(configs);
}
export async function generateStaticSite(config) {
    config = config || {};
    config.serverType = 'fs'; // override serverType
    const { serverMode } = config;
    if (serverMode === 'dev' || serverMode === 'compat') {
        // TODO: dynamic imports are not generated in dev mode
        // https://github.com/salesforce-experience-platform-emu/lwr/issues/1111
        logger.warn({
            label: `ssg`,
            message: `static generation in 'dev' or 'compat' mode is currently not fully supported'`,
        });
    }
    const lwrApp = createServer(config);
    overrideConfigAsSrc(lwrApp);
    await lwrApp.init();
    const dispatcher = lwrApp.getInternalServer();
    await new SiteGenerator().buildStaticApplication(lwrApp.getConfig(), dispatcher);
    return lwrApp.getConfig();
}
/**
 * Create normalized config for static generation forcing the app config to come as src
 */
function overrideConfigAsSrc(lwrApp) {
    if (!getFeatureFlags().LEGACY_LOADER) {
        const normalizedConfig = lwrApp.getConfig();
        const routes = normalizedConfig.routes || [];
        for (const route of routes) {
            route.bootstrap = {
                ...DEFAULT_LWR_BOOTSTRAP_CONFIG,
                ...route.bootstrap,
                configAsSrc: true,
            };
        }
    }
}
//# sourceMappingURL=index.js.map