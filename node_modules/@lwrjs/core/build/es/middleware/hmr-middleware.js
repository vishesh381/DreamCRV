import { WebSocketServer } from 'ws';
import { logger } from '@lwrjs/diagnostics';
import { getCacheKeyFromJson } from '@lwrjs/shared-utils';
import { getRequestProperties } from './utils/request.js';
let hmr;
const HMR_URI = '/:apiVersion/hmr/:format/:compat';
class Hmr {
    constructor(server, context) {
        this.server = server;
        this.context = context;
        this.moduleRegistry = context.moduleRegistry;
        const observer = context.appObserver;
        observer.onModuleDefinitionChange(({ payload }) => this.updateModuleDefOnClients(payload));
        observer.onViewSourceChange(({ payload }) => this.updateTemplateOnClients(payload));
        observer.onAssetSourceChange(({ payload }) => this.updateAssetOnClients(payload));
    }
    setupHotModuleReload() {
        const { server } = this;
        const wss = new WebSocketServer({ server });
        const connectedClients = new Map();
        this.connectedClients = connectedClients;
        wss.on('connection', function connection(ws, req) {
            const request = getRequestProperties(HMR_URI, req);
            // only accept connections on the /:apiVersion/hmr/:format/:compat endpoint
            if (request) {
                const { params, query } = request;
                const { format, compat } = params;
                const debug = query.debug !== undefined;
                const cacheId = getCacheKeyFromJson({ format, compat, debug });
                connectedClients.set(ws, cacheId);
                ws.send(JSON.stringify({ eventType: 'connected' }));
                ws.on('close', () => connectedClients.delete(ws));
                ws.on('error', () => connectedClients.delete(ws));
            }
        });
        wss.on('error', (error) => {
            if (error.code === 'EADDRINUSE') {
                logger.error(`HMR Socket Server: Port ${this.context.appConfig.port} already in use.`);
            }
            else {
                logger.error(error);
            }
        });
    }
    updateModuleDefOnClients(moduleDefinition) {
        const { moduleRegistry } = this;
        const { specifier, namespace, name, version, ownHash: signature, runtimeEnvironment, runtimeParams, } = moduleDefinition;
        const { format, debug, compat } = runtimeEnvironment;
        logger.info({ label: `hmr`, message: `Recompiled module: ${specifier}, ${signature}` });
        const moduleId = {
            specifier,
            namespace,
            name,
            version,
        };
        const modulesCacheId = getCacheKeyFromJson({ format, compat, debug });
        const newUri = moduleRegistry.resolveModuleUriSync(moduleId, signature, runtimeEnvironment, runtimeParams);
        const oldUri = moduleRegistry.resolveModuleUriSync(moduleId, 'latest', runtimeEnvironment, runtimeParams);
        if (this.connectedClients) {
            for (const [ws, cacheId] of this.connectedClients) {
                if (cacheId === modulesCacheId) {
                    ws.send(JSON.stringify({
                        eventType: 'moduleUpdate',
                        payload: {
                            format,
                            module: moduleId,
                            newHash: signature,
                            oldHash: 'latest',
                            newUri,
                            oldUri,
                        },
                    }));
                }
            }
        }
    }
    updateTemplateOnClients(compiledView) {
        logger.info({ label: `hmr`, message: `Recompiled view source`, additionalInfo: compiledView.viewId });
        const { contentTemplate } = compiledView.viewId;
        if (this.connectedClients && contentTemplate) {
            for (const ws of this.connectedClients.keys()) {
                ws.send(JSON.stringify({
                    eventType: 'viewUpdate',
                    payload: {
                        viewId: contentTemplate,
                    },
                }));
            }
        }
    }
    updateAssetOnClients(asset) {
        const assetId = asset.entry;
        logger.info({ label: `hmr`, message: `Updated asset: ${assetId}` });
        if (this.connectedClients) {
            for (const ws of this.connectedClients.keys()) {
                ws.send(JSON.stringify({
                    eventType: 'viewUpdate',
                    payload: {
                        assetId,
                    },
                }));
            }
        }
    }
}
export function hmrMiddleware(server, context, app) {
    app.get(HMR_URI, (_, res) => res.send('hello HMR!')); // handle polling from the HMR client
    hmr = new Hmr(server, context);
    hmr.setupHotModuleReload();
}
//# sourceMappingURL=hmr-middleware.js.map