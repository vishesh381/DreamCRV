import { getFeatureFlags } from '@lwrjs/shared-utils';
import path from 'path';
import { DiagnosticsError, logger } from '@lwrjs/diagnostics';
import { RequestHandlerSpan, getTracer } from '@lwrjs/instrumentation';
import { getAssetIdentity } from './utils/identity.js';
import { handleErrors } from './utils/error-handling.js';
import fs from 'fs-extra';
export function assetMiddleware(app, context) {
    const paths = context.appConfig.assets.map((config) => {
        const assetDirConfig = config;
        let urlPath = config.urlPath;
        // If this is a root config add a /:filename path to match any file in the root.  The middleware will fall through if there is no match.
        if (assetDirConfig.root) {
            urlPath = '/:filename';
        }
        else if (assetDirConfig.dir) {
            urlPath += app.getRegexWildcard();
        }
        return urlPath;
    });
    app.get([
        // De-dupe paths (i.e. root path may have been added more than once)
        ...[...new Set(paths)],
        '/:apiVersion/:assetType(asset|content-asset)/:immutable?/s/:signature/' + app.getRegexWildcard(),
        '/:apiVersion/:assetType(asset|content-asset)/:immutable?/' + app.getRegexWildcard(),
    ], handleErrors(createAssetMiddleware(context)));
}
/**
 * Create middleware function to handle get assets requests
 */
function createAssetMiddleware(context) {
    const { assetRegistry, runtimeEnvironment: { basePath }, } = context;
    return async (req, res, next) => {
        const { runtimeEnvironment } = req.getRuntimeContext(context.runtimeEnvironment);
        const { assetId, immutable, signature } = getAssetIdentity(req);
        if (basePath && !assetId.specifier.startsWith(basePath)) {
            assetId.specifier = path.join(basePath, assetId.specifier);
        }
        try {
            let asset;
            const assetUri = await assetRegistry.resolveAssetUri(assetId, runtimeEnvironment);
            // Check if this asset is available externally
            if (assetUri.external) {
                // This asset is marked external but hit the middleware anyway
                // Check if we have this file locally, if not, send a 302 to
                // redirect to the external URL
                asset = await getAssetDefinition(assetId, req, assetRegistry, signature, runtimeEnvironment);
                // Verify the content actually exists locally
                if (!fs.existsSync(asset.entry) && assetUri.uri.startsWith('/mobify/bundle')) {
                    return sendRedirect(res, assetUri);
                }
            }
            else {
                asset = await getAssetDefinition(assetId, req, assetRegistry, signature, runtimeEnvironment);
            }
            if (req.isSiteGeneration()) {
                res.setSiteGenerationMetadata({ asset });
            }
            if (asset.mime) {
                res.type(asset.mime);
            }
            if (runtimeEnvironment.immutableAssets && immutable) {
                res.setHeader('Cache-control', 'public, max-age=12895706, immutable');
            }
            else if (runtimeEnvironment.immutableAssets) {
                res.setHeader('Cache-control', 'public, max-age=60');
                const extraAssetHeaders = parseHeaderStringToObject(getFeatureFlags().EXPERIMENTAL_ASSET_HEADERS);
                if (extraAssetHeaders) {
                    for (const [key, value] of Object.entries(extraAssetHeaders)) {
                        res.setHeader(key, value);
                    }
                }
            }
            res.status(200).stream(asset.stream());
        }
        catch (error) {
            // Ignore asset not found for root asset requests
            if (path.dirname(assetId.specifier) === (basePath ? basePath : '/') &&
                error instanceof DiagnosticsError &&
                error?.diagnostics[0]?.description.category === 'lwrUnresolvable/asset') {
                // Must await other middleware or this can respond before expected.
                await next();
                return;
            }
            // else throw the error
            throw error;
        }
    };
}
/**
 * Get the asset definition if asset is local
 */
async function getAssetDefinition(assetId, req, assetRegistry, signature, runtimeEnvironment) {
    const asset = await getTracer().trace({
        name: RequestHandlerSpan.GetAsset,
        attributes: {
            specifier: assetId.specifier,
            url: req.originalUrl,
        },
    }, () => {
        return assetRegistry.getAsset({ ...assetId, signature }, runtimeEnvironment, req.isSiteGeneration());
    });
    return asset;
}
/**
 * Send a redirect (302) response
 */
function sendRedirect(res, assetUri) {
    res.set({
        Location: assetUri.uri,
        'cache-control': 'public, max-age=60',
    });
    res.sendStatus(302);
}
/**
 * Parses a semicolon-separated string of key-value pairs into an object.
 *
 * The input string must contain key-value pairs in the format `key:value;key2:value2`.
 * This function validates the format of each pair and logs errors for malformed entries.
 * If no errors are encountered, the function returns an object representing the parsed pairs.
 * Otherwise, errors are logged, and only valid pairs are included in the result.
 *
 * @param {string | undefined} assetHeadersString - The semicolon-separated string to parse. Can be undefined.
 * @returns {Record<string, string> | undefined} - A key-value pair object if valid pairs are found,
 * or `undefined` if the input is invalid or empty.
 *
 * ### Example Usage:
 * ```typescript
 * const input = "key1:value1;key2:value2";
 * const result = parseHeaderStringToObject(input);
 * console.log(result);
 * // Output: { key1: "value1", key2: "value2" }
 * ```
 *
 * ### Error Logging Example:
 * For an input like `key1:value1;invalidpair;key3:`, the function logs:
 * ```
 * {
 *   label: 'asset-middleware',
 *   message: 'Parse Errors: Error at Header 2: Malformed Header "invalidpair"\nError at Header 3: Malformed Header "key3:"'
 * }
 * ```
 */
export function parseHeaderStringToObject(assetHeadersString) {
    if (typeof assetHeadersString !== 'string') {
        return undefined;
    }
    const headersObject = {};
    const errors = [];
    // Split the string into key-value pairs by semicolon
    const pairs = assetHeadersString.split(';').filter(Boolean); // Remove empty segments
    pairs.forEach((pair, index) => {
        const [key, value] = pair.split(':').map((s) => s.trim()); // Split by colon and trim spaces
        if (!key || !value) {
            errors.push(`Error at Header ${index + 1}: Malformed Header "${pair.trim()}"`);
        }
        else {
            headersObject[key] = value;
        }
    });
    if (errors.length > 0) {
        logger.error({
            label: 'asset-middleware',
            message: 'Parse Errors:' + errors.join('\n'),
        });
    }
    return headersObject;
}
//# sourceMappingURL=asset-middleware.js.map