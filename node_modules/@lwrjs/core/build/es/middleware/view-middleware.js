import { TextEncoder } from 'util';
import { URLSearchParams } from 'url';
import { descriptions, logger } from '@lwrjs/diagnostics';
import { getClientRoutes } from '@lwrjs/router';
import { decodeViewPath, extractRequestParams, getClientBootstrapConfigurationRoutes, isURL, parseRequestDepth, REQUEST_DEPTH_KEY, isLocalDev, shortestTtl, isLambdaEnv, isLocalAuthEnabled, isLocalPreview, } from '@lwrjs/shared-utils';
import { RequestHandlerSpan, getTracer } from '@lwrjs/instrumentation';
import { handleErrors } from './utils/error-handling.js';
import { LwrViewHandler } from '@lwrjs/view-registry';
import { getTraceCollector } from '@lwrjs/instrumentation';
import { brotliCompressSync, gzipSync } from 'zlib';
import { getMrtCompressionThreshold } from './utils/compression.js';
function createViewMiddleware(route, errorRoutes, context, viewHandler) {
    const errorRoute = errorRoutes.find((route) => route.status === 500);
    const appConfig = context.appConfig;
    const { environment: environmentConfig } = appConfig;
    const mrtCompressionThreshold = getMrtCompressionThreshold();
    return async (req, res) => {
        if (!req.validateEnvironmentRequest(appConfig)) {
            res.status(400);
            res.send(descriptions.UNRESOLVABLE.INVALID_ENVIRONMENT(req.params.environment).message);
            return;
        }
        if (!req.validateJsonRequest()) {
            res.status(400);
            res.send(descriptions.UNRESOLVABLE.INVALID_JSON().message);
            return;
        }
        const { runtimeEnvironment, runtimeParams: defaultRuntimeParams } = req.getRuntimeContext(context.runtimeEnvironment);
        // set the default environment if an environment is configured in the app config
        if (!defaultRuntimeParams.environment && environmentConfig?.default) {
            defaultRuntimeParams.environment = environmentConfig.default;
        }
        const viewRequest = {
            url: req.originalUrl,
            params: req.params,
            query: req.query,
            requestPath: req.path,
        };
        // Augment runtime params with viewRequest info
        const runtimeParams = {
            ...defaultRuntimeParams,
            url: viewRequest.url,
            params: viewRequest.params,
            query: viewRequest.query,
            cookie: req.headers?.cookie,
            trueClientIP: req.headers && req.headers['true-client-ip'],
            coreProxy: req.getCoreProxy(appConfig.coreProxy ?? undefined, route.bootstrap?.proxyForSSR),
        };
        const resolve = req.isJsonRequest() ? viewHandler.getViewJson : viewHandler.getViewContent;
        let viewResponse;
        let resolvedRoute;
        let traceId;
        try {
            viewResponse = await getTracer().trace({
                name: RequestHandlerSpan.GetView,
                attributes: {
                    view: route.id,
                    url: req.originalUrl,
                    host: runtimeParams.host,
                    basePath: runtimeParams.basePath,
                    locale: runtimeParams.locale,
                },
            }, async (span) => {
                traceId = span.traceId;
                const res = await resolve.call(viewHandler, viewRequest, route, runtimeEnvironment, runtimeParams);
                // Add the view size metric
                span.setAttributes({
                    size: byteSize(res.body),
                });
                return res;
            });
            resolvedRoute = route;
        }
        catch (err) {
            if (!errorRoute) {
                throw err;
            }
            // Log Unexpected Routing Errors
            logger.error(`[view-middleware] Route Error ${req.originalUrl}`);
            logger.error(err);
            viewResponse = await getTracer().trace({
                name: RequestHandlerSpan.GetView,
                attributes: {
                    view: errorRoute.id,
                },
            }, () => {
                return resolve.call(viewHandler, viewRequest, errorRoute, runtimeEnvironment, runtimeParams);
            });
            resolvedRoute = errorRoute;
        }
        finally {
            if (traceId?.length) {
                res.setHeader('x-trace-id', traceId);
                res.set({
                    'Server-Timing': getTraceCollector().getSpansInTrace(traceId),
                });
                getTraceCollector().dropTrace(traceId);
            }
        }
        if (req.isSiteGeneration()) {
            res.setSiteGenerationMetadata(viewResponse.metadata);
        }
        // view response will be html by default
        res.type('text/html');
        // Add a custom auth cookie to the browser for all view requests during local dev / local preview
        if (isLocalAuthEnabled()) {
            res.setHeader('Set-Cookie', 'LocalAuthenticationEnabled=1;');
        }
        else if (isLocalDev() || isLocalPreview()) {
            // When running locally, expire the previously set cookie if we are previewing with the guest user or no auth token
            res.setHeader('Set-Cookie', 'LocalAuthenticationEnabled=0; Expires=Thu, 01 Jan 1970 00:00:00 GMT;');
        }
        // the default content type can be overridden if specified by the view response
        if (viewResponse.headers) {
            if (isLocalDev()) {
                // Disable CSP for local dev
                // TODO we should find a cleaner way to accomplish this but has to be here for now
                delete viewResponse.headers['content-security-policy'];
            }
            res.set(viewResponse.headers);
        }
        // pick the shortest TTL between the view response and route object
        if (!res.hasHeader('cache-control')) {
            const cacheTtl = shortestTtl(viewResponse.cache?.ttl, resolvedRoute.cache?.ttl);
            if (cacheTtl) {
                res.setHeader('cache-control', `public, max-age=${cacheTtl}`);
            }
        }
        let status = resolvedRoute.status || viewResponse.status || 200;
        const viewDefinitionStatus = viewResponse.metadata?.viewDefinition?.status;
        if (viewResponse.status === 301 || viewResponse.status === 302) {
            // route handle redirect status takes precedence
            status = viewResponse.status;
        }
        else if (viewDefinitionStatus && viewDefinitionStatus.code) {
            const origStatus = status;
            const { code, location } = viewDefinitionStatus;
            const isRedirect = code === 301 || code === 302;
            status = code;
            if (isRedirect) {
                if ((location && isURL(location)) || location?.startsWith('/')) {
                    res.set({
                        location: addRedirectQueryParam(location, parseRequestDepth(req.headers, req.query)),
                    });
                }
                else {
                    // reset the status in the event of an invalid location when redirecting
                    status = origStatus;
                    logger.warn(`[view-middleware] Ignoring invalid location header: "${location}"`);
                }
            }
        }
        res.status(status);
        // LWR@MRT 254 temporary safeguard for "dupe styles" issue causing huge base docs
        // Re-evaluate for removal once we determine it is no longer needed: W-17201070
        const viewResponseBody = viewResponse.body;
        let shouldCompress, viewResponseSize;
        if (isLambdaEnv() && typeof viewResponseBody === 'string') {
            viewResponseSize = Buffer.byteLength(viewResponseBody, 'utf-8');
            shouldCompress = Buffer.byteLength(viewResponseBody, 'utf-8') >= mrtCompressionThreshold;
        }
        // Conditionally apply compression if size is near the threshold
        if (shouldCompress) {
            const start = performance.now();
            let compressionMethod;
            if (req.headers['accept-encoding']?.includes('gzip')) {
                compressionMethod = gzipSync;
                res.setHeader('Content-Encoding', 'gzip');
            }
            else {
                // Default to Brotli compression even if the header is missing.
                res.setHeader('Content-Encoding', 'br');
                compressionMethod = brotliCompressSync;
            }
            const compressedView = compressionMethod(viewResponseBody);
            const end = performance.now();
            logger.warn(`View size (${viewResponseSize}) compressed due to Lambda response limit. Compression took ${Math.round(end - start)} ms`);
            res.send(compressedView);
        }
        else {
            res.send(viewResponse.body);
        }
    };
}
function createConfigMiddleware(routes, context, viewHandler) {
    return async (req, res) => {
        const { runtimeEnvironment, runtimeParams: defaultRuntimeParams } = req.getRuntimeContext(context.runtimeEnvironment);
        const { appId, encodedViewPath } = req.params;
        // match the app id to a route
        const route = routes.find((route) => route.id === appId);
        if (!route) {
            res.status(404).send(descriptions.UNRESOLVABLE.APP_CONFIG(appId).message);
            return;
        }
        // decode the resolved view path and extract any params.
        const url = decodeViewPath(encodedViewPath);
        let requestPath = url;
        // Create an empty object to store the key-value pairs
        const query = {};
        if (url.indexOf('?') !== -1) {
            // Remove query string from the requestPath
            requestPath = url.substring(0, url.indexOf('?'));
            const searchParams = new URLSearchParams(url.substring(url.indexOf('?')));
            // Iterate over the entries of the URLSearchParams and populate the object
            for (const [key, value] of searchParams.entries()) {
                query[key] = value;
            }
        }
        const originalUrl = req.originalUrl;
        const routePath = route.path;
        const params = extractRequestParams(routePath, url, req.params);
        const viewRequest = {
            url,
            originalUrl,
            params,
            query,
            requestPath,
        };
        // Augment runtime params with viewRequest info
        const runtimeParams = {
            ...defaultRuntimeParams,
            url: viewRequest.url,
            params: viewRequest.params,
            query: viewRequest.query,
        };
        const viewResponse = await viewHandler.getViewConfiguration(viewRequest, route, runtimeEnvironment, runtimeParams);
        if (!viewResponse) {
            res.status(404).send(descriptions.UNRESOLVABLE.VIEW_CONFIG(url).message);
            return;
        }
        // Pick the shortest TTL between the view response and route object
        if (!res.hasHeader('cache-control')) {
            const cacheTtl = shortestTtl(viewResponse.cache?.ttl, route.cache?.ttl);
            if (cacheTtl) {
                res.setHeader('cache-control', `public, max-age=${cacheTtl}`);
            }
        }
        res.type('application/javascript');
        res.status(viewResponse.status || 200);
        res.send(viewResponse.body);
    };
}
function createNotFoundMiddleware(errorRoutes, context, viewHandler) {
    const notFoundRoute = errorRoutes.find((route) => route.status === 404);
    if (notFoundRoute) {
        return createViewMiddleware(notFoundRoute, errorRoutes, context, viewHandler);
    }
    return (req, res) => {
        res.status(404).send(descriptions.UNRESOLVABLE.VIEW(req.originalUrl).message);
    };
}
export function viewMiddleware(app, context) {
    const { appConfig, viewRegistry, moduleRegistry, routeHandlers } = context;
    const { i18n, routes, errorRoutes } = appConfig;
    const viewHandler = new LwrViewHandler({ viewRegistry, moduleRegistry, routeHandlers }, appConfig);
    // create and attach middleware for each route
    for (const route of routes) {
        const paths = [route.path];
        const subRoutes = route.subRoutes && getClientRoutes(route.subRoutes);
        if (subRoutes) {
            const prefix = route.path === '/' ? '' : route.path;
            subRoutes.routes.forEach((subRoute) => subRoute.uri !== route.path && paths.push(`${prefix}${subRoute.uri}`));
        }
        // Add localized routes
        if (i18n.uriPattern === 'path-prefix') {
            // Map all supported locale ids into an or patter /:locale(es|es-MX|fr|rd-CA).
            // Filter out the default locale.  It will be handled separately
            const supportedStr = i18n.locales
                .map((l) => l.id)
                .filter((id) => id !== i18n.defaultLocale)
                .join('|');
            if (supportedStr) {
                // Add a redirect handler for the default locale for each route  /en-US/home -> 301 /home
                const defaultLocalePaths = paths.map((routePath) => `/${i18n.defaultLocale}${routePath}`);
                paths.forEach((routePath) => {
                    const localizedPath = `/:locale(${supportedStr})${routePath}`;
                    paths.push(localizedPath);
                });
                addDefaultLocaleRedirects(i18n.defaultLocale, defaultLocalePaths, i18n.defaultRedirectParams, app);
            }
        }
        logger.debug({ label: `view-middleware`, message: `Add view paths ${paths}` });
        app.get(paths, handleErrors(createViewMiddleware(route, errorRoutes, context, viewHandler)));
    }
    // create and attach middleware for bootstrap configurations
    app.get(getClientBootstrapConfigurationRoutes(), handleErrors(createConfigMiddleware(routes, context, viewHandler)));
    // create and attach a greedy middleware to handle unsupported paths
    // NOTE: a greedy `all` is used over `use` due to the way middleware is mounted in the server abstraction
    app.get('/' + app.getRegexWildcard(), handleErrors(createNotFoundMiddleware(errorRoutes, context, viewHandler)));
}
/**
 * Adds a 301 redirect if attempting to route with default locale as the path prefix
 */
function addDefaultLocaleRedirects(defaultLocale, defaultLocalePaths, defaultRedirectParams, app) {
    logger.debug({ label: `view-middleware`, message: `Add default localized paths ${defaultLocalePaths}` });
    app.get(defaultLocalePaths, (req, res, next) => {
        // This middleware should only have been called with paths that start with /{defaultLocale}.
        // If somehow that is not the case log a warning and do not re-direct
        if (!req.originalUrl?.startsWith(`/${defaultLocale}`)) {
            logger.warn({
                label: 'view-middleware',
                message: `Attempted to redirect to a URL that did not start with the default locale: /${defaultLocale} ${req.originalUrl}`,
            });
            return next();
        }
        // Separate the path and query string from the original URL
        const [originalPath, queryString] = req.originalUrl.split('?');
        // Remove the default locale from the original path
        let modifiedPath = originalPath.replace(`/${defaultLocale}`, '');
        // Ensure modifiedPath starts with req.basePath if set
        if (req.basePath) {
            modifiedPath = `${req.basePath}${modifiedPath}`;
        }
        // Parse existing query parameters into an object
        const queryParams = new URLSearchParams(queryString);
        // Merge in defaultRedirectParams, replacing values if the key exists with a different value
        if (defaultRedirectParams) {
            Object.entries(defaultRedirectParams).forEach(([key, value]) => {
                // If the key exists but has a different value, replace it
                if (queryParams.has(key) && queryParams.get(key) !== value) {
                    queryParams.set(key, value);
                }
                else if (!queryParams.has(key)) {
                    // Add the parameter if it doesn't exist
                    queryParams.set(key, value);
                }
            });
        }
        // Rebuild the modified path, adding query params only if they exist
        modifiedPath = queryParams.toString() ? `${modifiedPath}?${queryParams.toString()}` : modifiedPath;
        // Perform a 301 redirect to the modified URL
        res.setHeader('Location', modifiedPath);
        return res.sendStatus(301);
    });
}
function addRedirectQueryParam(redirectUrl, depth) {
    // add a request depth query param to the URL
    // the depth header cannot be used since headers cannot be added to a redirect
    const fakeOrigin = 'http://parse.com';
    const url = isURL(redirectUrl) ? new URL(redirectUrl) : new URL(`${fakeOrigin}${redirectUrl}`);
    url.searchParams.set(REQUEST_DEPTH_KEY, String(depth + 1));
    return url.toString().replace(fakeOrigin, '');
}
// Get number of bytes from a string.  Different char encodings can effect size per char.
function byteSize(body) {
    if (Buffer.isBuffer(body)) {
        return body.length;
    }
    else if (typeof body === 'string') {
        return new TextEncoder().encode(body).length; // Get byte size of the string
    }
    // Return -1 if JSON or undefined
    return -1;
}
//# sourceMappingURL=view-middleware.js.map