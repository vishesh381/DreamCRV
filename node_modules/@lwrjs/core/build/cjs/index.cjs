var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/core/src/index.ts
__markAsModule(exports);
__export(exports, {
  LwrApp: () => LwrApp,
  createServer: () => createServer,
  generateStaticSite: () => generateStaticSite
});
var import_shared_utils = __toModule(require("@lwrjs/shared-utils"));
var import_server = __toModule(require("@lwrjs/server"));
var import_diagnostics = __toModule(require("@lwrjs/diagnostics"));
var import_config = __toModule(require("@lwrjs/config"));
var import_modules = __toModule(require("@lwrjs/config/modules"));
var import_static_generation = __toModule(require("./tools/static-generation.cjs"));
var import_server_warmup = __toModule(require("./tools/server-warmup.cjs"));
var import_server2 = __toModule(require("./context/server.cjs"));
var import_provider = __toModule(require("./context/provider.cjs"));
var import_request_processor_middleware = __toModule(require("./middleware/request-processor-middleware.cjs"));
var import_locale_middleware = __toModule(require("./middleware/locale-middleware.cjs"));
var import_module_middleware = __toModule(require("./middleware/module-middleware.cjs"));
var import_bundle_middleware = __toModule(require("./middleware/bundle-middleware.cjs"));
var import_mapping_middleware = __toModule(require("./middleware/mapping-middleware.cjs"));
var import_asset_middleware = __toModule(require("./middleware/asset-middleware.cjs"));
var import_view_middleware = __toModule(require("./middleware/view-middleware.cjs"));
var import_resource_middleware = __toModule(require("./middleware/resource-middleware.cjs"));
var import_hmr_middleware = __toModule(require("./middleware/hmr-middleware.cjs"));
var import_instrumentation = __toModule(require("@lwrjs/instrumentation"));
function initMiddleware(app, server, serverContext) {
  (0, import_request_processor_middleware.requestProcessorMiddleware)(app, serverContext);
  (0, import_locale_middleware.localeMiddleware)(app, serverContext);
  (0, import_module_middleware.moduleMiddleware)(app, serverContext);
  (0, import_bundle_middleware.bundleMiddleware)(app, serverContext);
  (0, import_mapping_middleware.mappingMiddleware)(app, serverContext);
  (0, import_asset_middleware.assetMiddleware)(app, serverContext);
  (0, import_resource_middleware.resourceMiddleware)(app, serverContext);
  if (serverContext.runtimeEnvironment.hmrEnabled) {
    (0, import_hmr_middleware.hmrMiddleware)(server, serverContext, app);
  }
  (0, import_view_middleware.viewMiddleware)(app, serverContext);
  app.initRoutes();
}
function createServices(entries, providerContext) {
  return entries.map(([ctor, providerConfig = {}]) => new ctor(providerConfig, providerContext));
}
async function initContext(appConfig, runtimeEnvironment, globalData) {
  const hooks = await (0, import_modules.loadHooks)(appConfig);
  if (hooks.length) {
    const skipValidation = true;
    await (0, import_config.executeConfigHooks)(hooks, appConfig, runtimeEnvironment, globalData, skipValidation);
    (0, import_config.executeInstrumentationHooks)(hooks);
  }
  const services = await (0, import_modules.loadServices)(appConfig);
  const serverContext = (0, import_instrumentation.getTracer)().trace({name: import_instrumentation.CoreSpan.CreateServerContext}, () => (0, import_server2.createServerContext)(appConfig, runtimeEnvironment, globalData));
  const routeHandlers = await (0, import_modules.loadRouteHandlers)(appConfig);
  serverContext.routeHandlers = routeHandlers;
  if (hooks.length) {
    await (0, import_config.executeContextHooks)(hooks, serverContext);
    (0, import_config.executeStartHooks)(hooks, appConfig, runtimeEnvironment);
  }
  const providerContext = (0, import_provider.createProviderContext)(serverContext);
  const {moduleRegistry, assetRegistry, resourceRegistry, viewRegistry, moduleBundler} = serverContext;
  const moduleProviders = createServices(services.moduleProviders, providerContext);
  const assetProviders = createServices(services.assetProviders, providerContext);
  const assetTransformers = createServices(services.assetTransformers, providerContext);
  const resourceProviders = createServices(services.resourceProviders, providerContext);
  const viewProviders = createServices(services.viewProviders, providerContext);
  const viewTransformers = createServices(services.viewTransformers, providerContext);
  const bundleProviders = createServices(services.bundleProviders, providerContext);
  const uriTransformers = createServices(services.uriTransformers, providerContext);
  assetRegistry.addAssetProviders(assetProviders);
  assetRegistry.addAssetTransformers([...assetTransformers, ...uriTransformers]);
  moduleBundler.addBundleProviders(bundleProviders);
  moduleBundler.addBundleTransformers(uriTransformers);
  moduleRegistry.addModuleProviders(moduleProviders);
  resourceRegistry.addResourceProviders(resourceProviders);
  resourceRegistry.addResourceTransformers(uriTransformers);
  viewRegistry.addViewProviders(viewProviders);
  viewRegistry.addViewTransformers(viewTransformers);
  await serverContext.viewRegistry.initializeViewProviders();
  return serverContext;
}
var LwrApp = class {
  constructor(configs) {
    this.initialized = false;
    const span = (0, import_instrumentation.getTracer)().startSpan({name: import_instrumentation.CoreSpan.CreateServer});
    const {appConfig, runtimeEnvironment, globalData} = configs;
    this.config = appConfig;
    this.runtimeEnvironment = runtimeEnvironment;
    this.globalData = globalData;
    const {basePath, serverType, caseSensitiveRoutes} = this.config;
    this.serverType = serverType;
    this.app = (0, import_server.createInternalServer)(serverType, {basePath, caseSensitiveRoutes});
    this.server = this.app.createHttpServer();
    this.use = this.app.use.bind(this.app);
    this.all = this.app.all.bind(this.app);
    this.get = this.app.get.bind(this.app);
    this.post = this.app.post.bind(this.app);
    span.end();
  }
  getConfig() {
    return this.config;
  }
  async init() {
    const span = (0, import_instrumentation.getTracer)().startSpan({name: import_instrumentation.CoreSpan.InitServer});
    if (this.initialized) {
      return;
    }
    this.initialized = true;
    try {
      const context = await initContext(this.config, this.runtimeEnvironment, this.globalData);
      initMiddleware(this.app, this.server, context);
    } catch (e) {
      this.initialized = false;
      throw e;
    }
    span.end();
  }
  async listen(callback) {
    const span = (0, import_instrumentation.getTracer)().startSpan({name: import_instrumentation.CoreSpan.StartServer});
    await this.init();
    const {server, config, app} = this;
    const {serverMode, port} = config;
    return new Promise((resolve, reject) => {
      const handleError = (err) => {
        server.off("error", handleError);
        if (err.code === "EADDRINUSE") {
          err = new Error(`Port ${port} is already in use.`);
        }
        reject(err);
      };
      server.on("error", handleError);
      server.listen(port, async () => {
        server.off("error", handleError);
        if (process.env.WARMUP?.toLowerCase() === "true") {
          try {
            await (0, import_server_warmup.warmupServer)(config, app.getInternalRequestKey());
          } catch (err) {
            const diagnostic = (0, import_diagnostics.createSingleDiagnosticError)({
              description: import_diagnostics.descriptions.SERVER.WARMUP_ERROR(err.message)
            }, import_diagnostics.LwrServerError);
            return reject(diagnostic);
          }
        }
        const opts = {serverMode, port};
        callback?.(opts);
        span.end();
        resolve(opts);
      });
    });
  }
  close() {
    this.server?.close && this.server.close();
  }
  getInternalServer() {
    return this.app.getImpl();
  }
};
function createServer(config) {
  const configs = (0, import_config.loadConfig)(config);
  return new LwrApp(configs);
}
async function generateStaticSite(config) {
  config = config || {};
  config.serverType = "fs";
  const {serverMode} = config;
  if (serverMode === "dev" || serverMode === "compat") {
    import_diagnostics.logger.warn({
      label: `ssg`,
      message: `static generation in 'dev' or 'compat' mode is currently not fully supported'`
    });
  }
  const lwrApp = createServer(config);
  overrideConfigAsSrc(lwrApp);
  await lwrApp.init();
  const dispatcher = lwrApp.getInternalServer();
  await new import_static_generation.default().buildStaticApplication(lwrApp.getConfig(), dispatcher);
  return lwrApp.getConfig();
}
function overrideConfigAsSrc(lwrApp) {
  if (!(0, import_shared_utils.getFeatureFlags)().LEGACY_LOADER) {
    const normalizedConfig = lwrApp.getConfig();
    const routes = normalizedConfig.routes || [];
    for (const route of routes) {
      route.bootstrap = {
        ...import_config.DEFAULT_LWR_BOOTSTRAP_CONFIG,
        ...route.bootstrap,
        configAsSrc: true
      };
    }
  }
}
