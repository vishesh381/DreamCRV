var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/core/src/tools/static-generation.ts
__markAsModule(exports);
__export(exports, {
  ViewImportMetadataImpl: () => ViewImportMetadataImpl,
  default: () => static_generation_default
});
var import_perf_hooks = __toModule(require("perf_hooks"));
var import_diagnostics = __toModule(require("@lwrjs/diagnostics"));
var import_shared_utils = __toModule(require("@lwrjs/shared-utils"));
var import_site_metadata = __toModule(require("@lwrjs/static/site-metadata"));
var import_path = __toModule(require("path"));
var import_fs_extra = __toModule(require("fs-extra"));
var import_stream = __toModule(require("./utils/stream.cjs"));
var import_dir = __toModule(require("./utils/dir.cjs"));
var import_config = __toModule(require("@lwrjs/config"));
var import_url = __toModule(require("url"));
var SiteGenerator = class {
  async buildStaticApplication(config, dispatcher) {
    const startTime = import_perf_hooks.performance.now();
    import_diagnostics.logger.info({label: `ssg`, message: `Static Site Generation`});
    if (import_diagnostics.logger.isWarnEnabled()) {
      import_diagnostics.logger.setOptions({dedupe: new Set(["warn"])});
    }
    const {assets, basePath, rootDir, routes, staticSiteGenerator} = config;
    if (!staticSiteGenerator.outputDir) {
      staticSiteGenerator.outputDir = "site";
    }
    const outputDir = (0, import_path.join)(rootDir, staticSiteGenerator.outputDir);
    if (!staticSiteGenerator.skipCleanOutputDir) {
      import_diagnostics.logger.info({label: `ssg`, message: `Clearing output directory: ${outputDir}`});
      import_fs_extra.default.rmSync(outputDir, {recursive: true, force: true});
    } else if (import_fs_extra.default.existsSync(outputDir)) {
      import_diagnostics.logger.info({label: `ssg`, message: `Reusing existing output directory: ${outputDir}`});
    }
    const urlRewriteMap = new Map();
    const runtimeEnvironment = (0, import_config.getRuntimeEnvironment)(config);
    import_diagnostics.logger.info({label: `ssg`, message: `Building routes (this may take some time to complete)`});
    await this.generateRoutes(runtimeEnvironment, staticSiteGenerator, routes, basePath, dispatcher, outputDir, urlRewriteMap);
    this.writeNetlifyRedirectConfig(outputDir, urlRewriteMap);
    await this.copyAssets(assets, outputDir, config);
    const endTime = import_perf_hooks.performance.now();
    const timeDiff = (endTime - startTime) / 1e3;
    import_diagnostics.logger.info({
      label: `ssg`,
      message: `Static Site Generation complete in ${Math.round(timeDiff)} seconds`
    });
  }
  async generateRoutes(runtimeEnvironment, staticSiteGenerator, routes, basePath, dispatcher, outputDir, urlRewriteMap = new Map()) {
    const generateUrl = this.createGenerateURLFunction(dispatcher);
    const {skipBaseDocumentGeneration = false} = staticSiteGenerator;
    const i18n = runtimeEnvironment.i18n;
    if (!i18n.uriPattern) {
      await this.generateRoutesForLocale(routes, outputDir, {id: i18n.defaultLocale}, urlRewriteMap, skipBaseDocumentGeneration, runtimeEnvironment, basePath, generateUrl, staticSiteGenerator, dispatcher);
    } else {
      const sortedLocales = (0, import_shared_utils.sortLocalesByFallback)(i18n);
      for (const locale of sortedLocales) {
        import_diagnostics.logger.debug({label: `ssg`, message: `Generate routes of locale: ${locale.id}`});
        await this.generateRoutesForLocale(routes, outputDir, locale, urlRewriteMap, skipBaseDocumentGeneration, runtimeEnvironment, basePath, generateUrl, staticSiteGenerator, dispatcher);
      }
    }
  }
  async generateRoutesForLocale(routes, outputDir, locale, urlRewriteMap, skipBaseDocumentGeneration, runtimeEnvironment, basePath, generateUrl, staticSiteGenerator, dispatcher) {
    const i18n = runtimeEnvironment.i18n;
    for (const route of routes) {
      const siteConfig = this.createSiteConfig(outputDir, locale.id, urlRewriteMap, skipBaseDocumentGeneration, runtimeEnvironment, i18n);
      const localizedPath = (0, import_shared_utils.getViewUri)(route.path, basePath, locale.id, i18n);
      await generateUrl(localizedPath, siteConfig);
    }
    if (staticSiteGenerator._additionalRoutePaths) {
      for (const uri of staticSiteGenerator._additionalRoutePaths) {
        const siteConfig = this.createSiteConfig(outputDir, locale.id, urlRewriteMap, skipBaseDocumentGeneration, runtimeEnvironment, i18n);
        await generateUrl(uri, siteConfig);
      }
    }
    const {_additionalModules} = staticSiteGenerator;
    if (_additionalModules) {
      for (const specifier of _additionalModules) {
        import_diagnostics.logger.debug({label: `ssg`, message: `Additional Module: ${locale.id} ${specifier}`});
        const startTime = import_perf_hooks.performance.now();
        const siteConfig = this.createSiteConfig(outputDir, locale.id, urlRewriteMap, skipBaseDocumentGeneration, runtimeEnvironment, i18n);
        await this.dispatchJSResourceRecursive(specifier, dispatcher, siteConfig, true);
        await this.captureAdditionalRouteMetadata(siteConfig);
        const endTime = import_perf_hooks.performance.now();
        const timeDiff = endTime - startTime;
        import_diagnostics.logger.info({
          label: `ssg`,
          message: `Additional Module ${locale.id} ${specifier} in ${Math.round(timeDiff)} ms`
        });
      }
    }
  }
  createGenerateURLFunction(dispatcher) {
    const generateRoute = async (uri, siteConfig) => {
      const locale = siteConfig.locale;
      import_diagnostics.logger.debug({label: `ssg`, message: `Start Generate: ${locale} ${uri}`});
      const startTime = import_perf_hooks.performance.now();
      await this.dispatchResourceRecursive(uri, dispatcher, {resourceType: "route"}, siteConfig);
      await this.captureAdditionalRouteMetadata(siteConfig);
      const endTime = import_perf_hooks.performance.now();
      const timeDiff = endTime - startTime;
      import_diagnostics.logger.info({label: `ssg`, message: `${locale} ${uri} in ${Math.round(timeDiff)} ms`});
    };
    return generateRoute.bind(this);
  }
  async dispatchResourceRecursive(url, dispatcher, resourceOpts, siteConfig) {
    const {visitedUrls} = siteConfig;
    if (!visitedUrls.has(url)) {
      visitedUrls.add(url);
      if ((0, import_shared_utils.isExternalUrl)(url)) {
        import_diagnostics.logger.warn({label: `ssg`, message: `Skipped generation of external url: ${url}`});
        return;
      }
      if (url.indexOf("/:") !== -1 || url.indexOf("*") !== -1) {
        import_diagnostics.logger.warn({
          label: `ssg`,
          message: `Skipped generation of url with variable path segment: ${url}`
        });
        return;
      }
      let context;
      context = await dispatcher.dispatchUrl(url, "GET", siteConfig.locale);
      if (context?.fs?.headers?.Location) {
        this.saveServerBundles(siteConfig, context.fs.metadata?.viewDefinition?.viewRecord.serverBundles);
        const redirectUrl = context?.fs?.headers?.Location;
        url = redirectUrl;
        const redirectContext = await dispatcher.dispatchUrl(url, "GET", siteConfig.locale);
        context = redirectContext;
      }
      const {resourceType} = resourceOpts;
      if (resourceType === "route") {
        await this.handleHtmlResource(url, context, siteConfig, dispatcher);
      } else if (resourceType === "asset" || resourceType === "resource") {
        await this.handleAssetOrResource(url, context, siteConfig, dispatcher);
      } else if (resourceType == "mapping") {
        await this.handleMappingResource(url, context, siteConfig, dispatcher);
      } else if (resourceType === "js") {
        await this.handleJavascriptResource(url, context, siteConfig, dispatcher);
      }
    }
  }
  async handleJavascriptResource(url, context, siteConfig, dispatcher) {
    const {outputDir} = siteConfig;
    const moduleDefinition = context.fs?.metadata?.moduleDefinition;
    const bundleConfig = moduleDefinition?.config || {};
    const siteBundles = siteConfig?.siteMetadata?.getSiteBundles()?.bundles;
    const specifier = moduleDefinition?.specifier;
    if ((0, import_shared_utils.isExternalSpecifier)(specifier, bundleConfig)) {
      this.handleExternalBundle(specifier, siteBundles, bundleConfig.external, outputDir);
      return;
    }
    const normalizedUrl = decodeURIComponent(url);
    (0, import_dir.createResourceDir)((0, import_path.dirname)(normalizedUrl), outputDir);
    const ext = (0, import_path.extname)(normalizedUrl);
    const fullPath = (0, import_path.join)(outputDir, `${normalizedUrl}${ext ? "" : ".js"}`);
    await (0, import_stream.writeResponse)(context, fullPath);
    const dispatchRequests = [];
    if (normalizedUrl.indexOf("/s/") !== -1) {
      siteConfig.urlRewriteMap.set(normalizedUrl.substring(0, normalizedUrl.indexOf("/s/")), normalizedUrl);
      siteConfig.urlRewriteMap.set(url.substring(0, url.indexOf("/s/")), normalizedUrl);
      siteConfig.urlRewriteMap.set(normalizedUrl.substring(0, normalizedUrl.indexOf("/v/")), normalizedUrl);
      siteConfig.urlRewriteMap.set(url.substring(0, url.indexOf("%2Fv%2F")), normalizedUrl);
    }
    if (moduleDefinition) {
      const imports = moduleDefinition.linkedModuleRecord?.imports || moduleDefinition.bundleRecord?.imports || [];
      for (const importModule of imports) {
        const importSpecifier = importModule.specifier;
        if ((0, import_shared_utils.isExternalSpecifier)(importSpecifier, bundleConfig)) {
          this.handleExternalBundle(importSpecifier, siteBundles, bundleConfig.external, outputDir);
        } else {
          const jsUri = importSpecifier.startsWith("/") ? importSpecifier : (0, import_shared_utils.getSpecifier)(importModule);
          dispatchRequests.push(this.dispatchJSResourceRecursive(jsUri, dispatcher, siteConfig));
        }
      }
      const dynamicImports = moduleDefinition.linkedModuleRecord?.dynamicImports || moduleDefinition.bundleRecord?.dynamicImports || [];
      for (const importModule of dynamicImports) {
        const importSpecifier = importModule.specifier;
        if ((0, import_shared_utils.isExternalSpecifier)(importSpecifier, bundleConfig)) {
          this.handleExternalBundle(importSpecifier, siteBundles, bundleConfig.external, outputDir);
        } else {
          const jsUri = importSpecifier.startsWith("/") ? importSpecifier : (0, import_shared_utils.getSpecifier)(importModule);
          dispatchRequests.push(this.dispatchJSResourceRecursive(jsUri, dispatcher, siteConfig));
        }
      }
      if (moduleDefinition.bundleRecord) {
        this.addBundleToSiteMetadata(moduleDefinition, url, false, siteConfig);
      }
    }
    const uris = context.fs?.metadata?.resolvedUris || [];
    for (const jsUri of uris) {
      dispatchRequests.push(this.dispatchJSResourceRecursive(jsUri, dispatcher, siteConfig));
    }
    await Promise.all(dispatchRequests);
  }
  handleExternalBundle(specifier, siteBundles, externals, outputDir) {
    if (siteBundles && externals[specifier]?.startsWith(import_shared_utils.PROTOCOL_FILE) && !siteBundles[specifier]) {
      const path = (0, import_shared_utils.normalizeFromFileURL)(externals[specifier], process.cwd());
      const normalizedPath = decodeURIComponent(path);
      (0, import_dir.createResourceDir)((0, import_path.dirname)(normalizedPath), outputDir);
      const ext = (0, import_path.extname)(normalizedPath);
      const fullPath = (0, import_path.join)(outputDir, `${normalizedPath}${ext ? "" : ".js"}`);
      import_fs_extra.default.copyFileSync((0, import_url.fileURLToPath)(externals[specifier]), fullPath);
      const bundleMetadata = {
        specifier,
        path: normalizedPath,
        imports: []
      };
      siteBundles[specifier] = bundleMetadata;
    }
  }
  addBundleToSiteMetadata(bundleDefinition, url, ssr, siteConfig) {
    if (siteConfig.siteMetadata) {
      const locale = siteConfig.locale;
      const specifier = (0, import_site_metadata.getSiteBundleId)(bundleDefinition, locale, ssr, siteConfig.i18n);
      const imports = bundleDefinition.bundleRecord.imports?.map((moduleRef) => (0, import_site_metadata.getSiteBundleId)(moduleRef, locale, false, siteConfig.i18n)) || [];
      const dynamicImports = bundleDefinition.bundleRecord.dynamicImports?.map((moduleRef) => (0, import_site_metadata.getSiteBundleId)(moduleRef, locale, false, siteConfig.i18n));
      const includedModules = bundleDefinition.bundleRecord.includedModules?.map((moduleRef) => {
        const moduleId = (0, import_shared_utils.explodeSpecifier)(moduleRef);
        return (0, import_site_metadata.getSiteBundleId)(moduleId, locale, false, siteConfig.i18n);
      }) || [];
      const version = bundleDefinition.version === import_shared_utils.VERSION_NOT_PROVIDED ? void 0 : bundleDefinition.version;
      const bundleMetadata = {
        version,
        path: decodeURIComponent(url),
        includedModules,
        imports,
        dynamicImports,
        integrity: bundleDefinition.integrity
      };
      const siteBundles = siteConfig.siteMetadata.getSiteBundles().bundles;
      siteBundles[specifier] = bundleMetadata;
    }
  }
  addResourceToSiteMetadata(resourceDefinition, url, siteConfig) {
    if (siteConfig.siteMetadata) {
      if (!resourceDefinition.specifier) {
        import_diagnostics.logger.warn({
          label: `ssg`,
          message: `Could not save resource metadata.  There was no specifier.`,
          additionalInfo: resourceDefinition
        });
      } else {
        const resourceMetadata = {
          path: decodeURIComponent(url),
          mimeType: resourceDefinition.type,
          inline: resourceDefinition.inline,
          version: resourceDefinition.version,
          integrity: resourceDefinition.integrity
        };
        const siteResources = siteConfig.siteMetadata.getSiteResources();
        siteResources.resources[(0, import_site_metadata.getSiteResourceId)(resourceDefinition)] = resourceMetadata;
      }
    }
  }
  addAssetToSiteMetadata(assetDefinition, url, siteConfig) {
    if (siteConfig.siteMetadata) {
      if (!assetDefinition.uri) {
        import_diagnostics.logger.warn({
          label: `ssg`,
          message: `Could not save asset metadata.  There was no uri.`,
          additionalInfo: assetDefinition
        });
      } else {
        const specifier = assetDefinition.uri;
        const resourceMetadata = {
          path: decodeURIComponent(url),
          mimeType: String(assetDefinition.mime)
        };
        const siteAssets = siteConfig.siteMetadata.getSiteAssets();
        if (!siteAssets.assets[specifier]) {
          siteAssets.assets[specifier] = resourceMetadata;
        } else {
          import_diagnostics.logger.debug({label: `ssg`, message: `Ignore asset redefinition ${specifier}`});
        }
      }
    }
  }
  async handleMappingResource(url, context, siteConfig, dispatcher) {
    const {importMetadata} = siteConfig;
    const statusCode = context.response?.status;
    if (statusCode === 200) {
      const newImportMetadata = context.fs?.body;
      let filteredImportMetadata;
      if (!importMetadata) {
        filteredImportMetadata = newImportMetadata;
      } else {
        filteredImportMetadata = importMetadata.addAdditionalMetadata(newImportMetadata);
      }
      const dispatchRequests = [];
      for (const uri of Object.keys(filteredImportMetadata.imports)) {
        dispatchRequests.push(this.dispatchResourceRecursive(uri, dispatcher, {resourceType: "js"}, siteConfig));
      }
      await Promise.all(dispatchRequests);
    } else {
      const body = context.fs?.body;
      import_diagnostics.logger.warn({label: `ssg`, message: `Failed to fetch ${url}: (${statusCode}) ${body}`});
    }
  }
  async handleHtmlResource(url, context, siteConfig, dispatcher) {
    const {outputDir, skipBaseDocumentGeneration} = siteConfig;
    if (!skipBaseDocumentGeneration) {
      let fileName = "index.html";
      let directoryPath = url;
      if (url.endsWith(".html") || url.endsWith(".xml")) {
        const lastPathIndex = url.lastIndexOf("/") + 1;
        fileName = url.substring(lastPathIndex, url.length);
        directoryPath = url.substring(0, lastPathIndex);
      }
      const dir = (0, import_dir.createResourceDir)(directoryPath, outputDir);
      const filePath = (0, import_path.join)(dir, fileName);
      siteConfig.viewPaths.add(filePath);
      await (0, import_stream.writeResponse)(context, filePath);
    }
    const viewDefinition = context.fs?.metadata?.viewDefinition;
    if (viewDefinition) {
      await this.handleViewDefinition(viewDefinition, siteConfig, dispatcher);
    }
  }
  async handleViewDefinition(viewDefinition, siteConfig, dispatcher) {
    if (viewDefinition.viewRecord.importMetadata) {
      siteConfig.importMetadata = new ViewImportMetadataImpl(viewDefinition.viewRecord.importMetadata);
    }
    const dispatchRequests = [];
    const assets = viewDefinition.viewRecord.assetReferences || [];
    for (const asset of assets) {
      const assetUrl = asset.override?.uri || asset.url;
      if (assetUrl && !(0, import_shared_utils.isSelfUrl)(assetUrl)) {
        dispatchRequests.push(this.dispatchResourceRecursive(assetUrl, dispatcher, {resourceType: "asset", asset}, siteConfig));
      }
    }
    const customElements = viewDefinition.viewRecord.customElements || [];
    for (const customElement of customElements) {
      const jsUris = Object.values(customElement.flatGraph.uriMap);
      for (const jsUri of jsUris) {
        dispatchRequests.push(this.dispatchJSResourceRecursive(jsUri, dispatcher, siteConfig));
      }
    }
    if (viewDefinition.viewRecord.bootstrapModule) {
      const boot = viewDefinition.viewRecord.bootstrapModule;
      const jsUris = Object.values(boot.flatGraph.uriMap);
      for (const jsUri of jsUris) {
        dispatchRequests.push(this.dispatchJSResourceRecursive(jsUri, dispatcher, siteConfig));
      }
    }
    this.saveServerBundles(siteConfig, viewDefinition.viewRecord.serverBundles);
    const bootstrapResources = viewDefinition.viewRecord.bootstrapModule?.resources || [];
    for (const resource of bootstrapResources) {
      if (!resource.inline) {
        const resourceUri = resource.src || resource.specifier;
        if (resourceUri) {
          dispatchRequests.push(this.dispatchResourceRecursive(resourceUri, dispatcher, {resourceType: "resource"}, siteConfig));
          if (resourceUri.match(/\/application\/.*\/ai\/.*\/configuration/)) {
            siteConfig.viewConfigPath = this.getResourcePathFromUrl(siteConfig, resourceUri);
          }
        } else {
          import_diagnostics.logger.warn({label: `ssg`, message: `Skipped inline bootstrap resource: ${resource}`});
        }
      }
    }
    const resources = viewDefinition.viewRecord.resources || [];
    for (const resource of resources) {
      const resourceUri = resource.src || resource.specifier || "";
      if (resourceUri.startsWith("/")) {
        dispatchRequests.push(this.dispatchResourceRecursive(resourceUri, dispatcher, {resourceType: "resource"}, siteConfig));
      } else {
        import_diagnostics.logger.warn({label: `ssg`, message: `Skipped resource: ${resource}`});
      }
    }
    await Promise.all(dispatchRequests);
  }
  async dispatchJSResourceRecursive(jsUri, dispatcher, siteConfig, isAdditionalModulesRequest) {
    if (jsUri.startsWith("/")) {
      await this.dispatchResourceRecursive(jsUri, dispatcher, {resourceType: "js"}, siteConfig);
    } else {
      const supportsFingerprints = !siteConfig.featureFlags?.LEGACY_LOADER;
      if (supportsFingerprints) {
        const mappingEndpoint = siteConfig.endpoints?.uris?.mapping;
        if (mappingEndpoint) {
          const mappingURL = siteConfig.endpoints?.uris?.mapping + encodeURIComponent(jsUri);
          await this.dispatchResourceRecursive(mappingURL, dispatcher, {resourceType: "mapping"}, siteConfig);
        } else {
          import_diagnostics.logger.warn({
            label: `ssg`,
            message: `Unable to fetch mapping for bare specifier or variable dynamic import: "${jsUri}"`
          });
        }
      } else if (isAdditionalModulesRequest) {
        const uri = `${siteConfig.endpoints?.uris.legacyDefault}${encodeURIComponent(jsUri)}`;
        await this.dispatchResourceRecursive(uri, dispatcher, {resourceType: "js"}, siteConfig);
      }
    }
  }
  async handleAssetOrResource(url, context, siteConfig, dispatcher) {
    const metadata = context.fs?.metadata;
    const fullPath = this.getResourcePathFromUrl(siteConfig, url);
    await (0, import_stream.writeResponse)(context, fullPath);
    if (metadata?.resource) {
      this.addResourceToSiteMetadata(metadata?.resource, url, siteConfig);
    } else if (metadata?.asset) {
      this.addAssetToSiteMetadata(metadata?.asset, url, siteConfig);
    }
    const assetReferences = metadata?.asset?.metadata?.assetReferences || [];
    const dispatchRequests = [];
    for (const ref of assetReferences) {
      const refUrl = ref.override?.uri || ref.url;
      dispatchRequests.push(this.dispatchResourceRecursive(refUrl, dispatcher, {resourceType: "asset", asset: metadata?.asset}, siteConfig).catch((err) => {
        import_diagnostics.logger.warn({
          label: `ssg`,
          message: `Failed to fetch asset reference => ${refUrl} from ${url}`,
          additionalInfo: err
        });
      }));
    }
    return Promise.all(dispatchRequests);
  }
  getResourcePathFromUrl(siteConfig, url) {
    const {outputDir} = siteConfig;
    const normalizedUrl = decodeURIComponent(url);
    (0, import_dir.createResourceDir)((0, import_path.dirname)(normalizedUrl), outputDir);
    const fullPath = (0, import_path.join)(outputDir, normalizedUrl);
    const index = fullPath ? fullPath.indexOf("?") : -1;
    return index !== -1 ? fullPath.substring(0, index) : fullPath;
  }
  writeNetlifyRedirectConfig(outputDir, urlRewriteMap) {
    const serveJsonPath = (0, import_path.join)(outputDir, "serve.json");
    const _redirectsPath = (0, import_path.join)(outputDir, "_redirects");
    if (import_fs_extra.default.existsSync(_redirectsPath)) {
      import_fs_extra.default.unlinkSync(_redirectsPath);
    }
    import_fs_extra.default.createFileSync(_redirectsPath);
    const rewrites = [];
    urlRewriteMap.forEach((destination, source) => {
      rewrites.push({
        source,
        destination
      });
      import_fs_extra.default.appendFileSync(_redirectsPath, source + " " + destination + " 302!\n");
    });
    import_fs_extra.default.writeFileSync(serveJsonPath, JSON.stringify({rewrites, directoryListing: false, renderSingle: true}, null, 1));
  }
  async copyAssets(assets, outputDir, config) {
    const {basePath} = config;
    const runtimeEnvironment = (0, import_config.getRuntimeEnvironment)(config);
    const siteConfig = this.createSiteConfig(outputDir, "en-US", new Map(), true, runtimeEnvironment, config.i18n);
    for (const asset of assets) {
      try {
        const assetSrcFile = asset.file;
        const assetSrcDir = asset.dir;
        const isRootConfig = asset.root;
        const urlPath = asset.urlPath;
        const assetsPath = (0, import_path.join)(outputDir, basePath ? basePath + urlPath : urlPath);
        if (assetSrcDir && import_fs_extra.default.existsSync(assetSrcDir)) {
          if (isRootConfig) {
            const files = import_fs_extra.default.readdirSync(assetSrcDir);
            for (const file of files) {
              const filePath = (0, import_path.join)(assetSrcDir, file);
              if (import_fs_extra.default.statSync(filePath).isFile()) {
                const fileDestPath = (0, import_path.join)(assetsPath, file);
                import_fs_extra.default.copySync(filePath, fileDestPath);
                this.addAssetToMetadata(fileDestPath, siteConfig);
              }
            }
          } else {
            import_fs_extra.default.copySync(assetSrcDir, assetsPath);
            this.addAssetsToMetadata(assetsPath, siteConfig);
          }
        } else if (assetSrcFile && import_fs_extra.default.existsSync(assetSrcFile)) {
          import_fs_extra.default.copySync(assetSrcFile, assetsPath);
          this.addAssetToMetadata(assetsPath, siteConfig);
        } else {
          import_diagnostics.logger.warn({
            label: `ssg`,
            message: `Could not find assets to copy at path: ${assetsPath}`
          });
        }
      } catch (e) {
        import_diagnostics.logger.error(`[ssg] Error occurred processing asset config: ${JSON.stringify(asset)}`);
        import_diagnostics.logger.error(e);
      }
    }
    await siteConfig.siteMetadata?.persistSiteMetadata();
  }
  addAssetsToMetadata(directoryPath, siteConfig) {
    try {
      const files = import_fs_extra.default.readdirSync(directoryPath);
      for (const file of files) {
        const filePath = (0, import_path.join)(directoryPath, file);
        if (import_fs_extra.default.statSync(filePath).isDirectory()) {
          this.addAssetsToMetadata(filePath, siteConfig);
        } else {
          this.addAssetToMetadata(filePath, siteConfig);
        }
      }
    } catch (err) {
      import_diagnostics.logger.warn({
        label: `ssg`,
        message: `Unexpected error collecting asset directory metadata for ${directoryPath}`,
        additionalInfo: err
      });
    }
  }
  addAssetToMetadata(filePath, siteConfig) {
    try {
      const uri = encodeURI((0, import_path.normalize)(filePath).replace(siteConfig.outputDir, ""));
      this.addAssetToSiteMetadata({
        uri,
        type: "asset",
        stream: function(_encoding) {
          throw new Error("Function not implemented.");
        },
        entry: filePath,
        ext: (0, import_path.extname)(filePath),
        mime: (0, import_shared_utils.mimeLookup)(filePath),
        ownHash: "not-provided",
        content: function(_encoding) {
          throw new Error("Function not implemented.");
        }
      }, uri, siteConfig);
    } catch (err) {
      import_diagnostics.logger.warn({
        label: `ssg`,
        message: `Unexpected error collecting asset metadata for ${filePath}`,
        additionalInfo: err
      });
    }
  }
  createSiteConfig(outputDir, locale, urlRewriteMap, skipBaseDocumentGeneration, runtimeEnvironment, i18n) {
    const featureFlags = this.filterFeatureFlags();
    const endpoints = {
      uris: {
        legacyDefault: (0, import_shared_utils.getModuleUriPrefix)(runtimeEnvironment, {locale}),
        mapping: (0, import_shared_utils.getMappingUriPrefix)(runtimeEnvironment, {locale}),
        server: (0, import_shared_utils.getModuleUriPrefix)({...runtimeEnvironment, bundle: true}, {locale}).replace("/bundle/", "/bundle-server/")
      }
    };
    return {
      outputDir,
      viewPaths: new Set(),
      visitedUrls: new Set(),
      locale,
      urlRewriteMap,
      endpoints,
      skipBaseDocumentGeneration,
      ...featureFlags,
      siteMetadata: new import_site_metadata.SiteMetadataImpl({rootDir: outputDir, i18n}),
      i18n
    };
  }
  filterFeatureFlags() {
    const ffs = (0, import_shared_utils.getFeatureFlags)();
    if (ffs && Object.keys(ffs).length) {
      const accumulator = {};
      for (const [key, value] of Object.entries(ffs)) {
        if (value) {
          accumulator[key] = true;
        }
      }
      return {featureFlags: accumulator};
    } else {
      return void 0;
    }
  }
  addAdditionalImportMetadataToViewConfig(siteConfig) {
    const supportsFingerprints = !siteConfig.featureFlags?.LEGACY_LOADER;
    const additionalImportMetadata = siteConfig?.importMetadata?.getAdditionalImportMetadata();
    if (supportsFingerprints && siteConfig.viewConfigPath && additionalImportMetadata?.imports && Object.keys(additionalImportMetadata.imports).length > 0) {
      const imports = additionalImportMetadata.imports ? JSON.stringify(additionalImportMetadata.imports) : "{}";
      const initImports = `if (!globalThis.LWR.imports) { globalThis.LWR.imports = {}; }`;
      const mergeImports = `Object.assign(globalThis.LWR.imports, ${imports})`;
      const index = additionalImportMetadata.index ? JSON.stringify(additionalImportMetadata.index) : "{}";
      const initIndex = `if (!globalThis.LWR.index) { globalThis.LWR.index = {}; }`;
      const mergeIndex = `Object.assign(globalThis.LWR.index, ${index})`;
      const oldConfig = import_fs_extra.default.readFileSync(siteConfig.viewConfigPath, "utf-8");
      const newConfig = `${oldConfig}
// Appended by Static Site Generator
${initImports}
${mergeImports}
${initIndex}
${mergeIndex}
`;
      const configHash = (0, import_shared_utils.hashContent)(newConfig);
      const sigRegex = /\/s\/[a-z0-9]+\/config\.js/i;
      const configSuffix = `/s/${configHash}/config.js`;
      const newConfigPath = siteConfig.viewConfigPath.replace(sigRegex, configSuffix);
      import_fs_extra.default.mkdirSync((0, import_path.dirname)(newConfigPath), {recursive: true});
      import_fs_extra.default.writeFileSync(newConfigPath, newConfig, "utf-8");
      import_fs_extra.default.rmSync(siteConfig.viewConfigPath);
      siteConfig.viewPaths.forEach((path) => {
        const oldDoc = import_fs_extra.default.readFileSync(path, "utf-8");
        const newDoc = oldDoc.toString().replace(sigRegex, configSuffix);
        import_fs_extra.default.writeFileSync(path, newDoc, "utf-8");
      });
    }
  }
  async captureAdditionalRouteMetadata(siteConfig) {
    this.addAdditionalImportMetadataToViewConfig(siteConfig);
    await siteConfig.siteMetadata?.persistSiteMetadata();
  }
  async saveServerBundles(siteConfig, bundles) {
    if (bundles?.size) {
      const {endpoints, outputDir} = siteConfig;
      bundles.forEach(async (bundle) => {
        const {specifier, version} = bundle;
        const vSpecifier = (0, import_shared_utils.getSpecifier)({
          specifier,
          version: version ? (0, import_shared_utils.normalizeVersionToUri)(version) : void 0
        });
        const url = `${endpoints?.uris.server}${vSpecifier}/s/${(0, import_shared_utils.signBundle)(bundle)}/bundle_${(0, import_shared_utils.prettyModuleUriSuffix)(specifier)}.js`;
        this.addBundleToSiteMetadata(bundle, url, true, siteConfig);
        (0, import_dir.createResourceDir)((0, import_path.dirname)(url), outputDir);
        await (0, import_stream.writeResponse)({fs: {body: await bundle.getCode()}}, (0, import_path.join)(outputDir, url));
      });
    }
  }
};
var static_generation_default = SiteGenerator;
var ViewImportMetadataImpl = class {
  constructor(existingImportMetadata, additionalImportMetadata) {
    this.existing = existingImportMetadata;
    this.additional = additionalImportMetadata || {imports: {}, index: {}};
  }
  getAdditionalImportMetadata() {
    return this.additional;
  }
  addAdditionalMetadata(newMetadata) {
    const filteredImports = this.filterMetadata(newMetadata);
    this.mergeImportMetadata(this.additional, filteredImports);
    return filteredImports;
  }
  filterMetadata(newMetadata) {
    const importsArray = Object.entries(newMetadata.imports);
    const filteredImports = importsArray.filter(([key]) => !this.existing.imports[key]);
    const imports = Object.fromEntries(filteredImports);
    const indexArray = Object.entries(newMetadata.index || {});
    const filteredIndex = indexArray.filter(([key]) => !this.existing.index || !this.existing.index[key]);
    const index = Object.fromEntries(filteredIndex);
    return {
      imports,
      index
    };
  }
  mergeImportMetadata(targetImportMetadata, newImportMetadata) {
    Object.assign(targetImportMetadata.imports, newImportMetadata.imports);
    if (targetImportMetadata.index) {
      Object.assign(targetImportMetadata.index, newImportMetadata.index || {});
    }
  }
};
