import { hashContent, normalizeResourcePath } from '@lwrjs/shared-utils';
import { generateModule, getRouterConfigPath, parseSpecifier, setUpWatcher } from './utils.js';
import { deleteRouterConfigJsonCacheEntry, getClientRoutes } from '../index.js';
const DEFAULT_DIR = '$rootDir/src/routes';
export default class RouterModuleProvider {
    constructor({ routesDir = DEFAULT_DIR }, context) {
        this.name = 'router-module-provider';
        this.watchedFileSet = new Set(); // <config path, module id>
        const { config: { rootDir, contentDir, i18n, layoutsDir }, runtimeEnvironment: { lwrVersion, watchFiles }, watcherFactory, } = context;
        this.version = lwrVersion;
        this.i18n = i18n;
        // Replace aliases and remove trailing slash from the routes directory
        this.routesDir = normalizeResourcePath(routesDir, {
            rootDir,
            assets: [],
            contentDir,
            layoutsDir,
        }).replace(/\/$/, '');
        // Set up watcher on Router Config files
        this.routerWatcher =
            watchFiles && watcherFactory
                ? setUpWatcher(watcherFactory, this.onRouterModuleChange.bind(this))
                : undefined;
    }
    // When Router Metadata changes on the file system:
    //      1. delete the config data from the routerConfigJsonCache (in ../index)
    async onRouterModuleChange(configPath) {
        deleteRouterConfigJsonCacheEntry(configPath);
    }
    // Watch Router Config files:
    //      1. Add files to the watcher
    //      2. Track watched files in the watchedFileSet
    watchConfigs(configPath) {
        if (this.routerWatcher) {
            if (!this.watchedFileSet.has(configPath)) {
                this.routerWatcher.add(configPath);
                this.watchedFileSet.add(configPath);
            }
        }
    }
    // 1. Check that:
    //      a. the specifier is in the correct format: "@lwrjs/router/{routerId}"
    //      b. the config JSON addressed by "routerId" is available on the file system
    getRouterConfig(specifier) {
        let config;
        const routerId = parseSpecifier(specifier);
        if (routerId) {
            // Fetch the Router Config JSON
            const configPath = getRouterConfigPath(this.routesDir, specifier);
            config = getClientRoutes(configPath);
            // Watch for file changes
            this.watchConfigs(configPath);
        }
        return config;
    }
    async getModuleEntry({ specifier }, runtimeParams) {
        const config = this.getRouterConfig(specifier);
        if (config) {
            return {
                id: `${specifier}|${this.version}|${runtimeParams.basePath}|${runtimeParams.locale}`,
                virtual: true,
                entry: `<virtual>/${specifier}.js`,
                specifier,
                version: this.version,
            };
        }
    }
    async getModule(moduleId, runtimeParams) {
        // Retrieve the Module Entry
        const { specifier, namespace, name = specifier } = moduleId;
        const moduleEntry = await this.getModuleEntry({ specifier }, runtimeParams);
        if (!moduleEntry) {
            return;
        }
        // Generate code for the requested module
        const config = this.getRouterConfig(specifier);
        const compiledSource = generateModule(config, this.i18n, runtimeParams);
        // Construct a Compiled Module
        const moduleCompiled = {
            id: moduleEntry.id,
            specifier,
            namespace,
            name,
            version: this.version,
            originalSource: compiledSource,
            moduleEntry,
            ownHash: hashContent(compiledSource),
            compiledSource,
        };
        return moduleCompiled;
    }
}
//# sourceMappingURL=index.js.map