import { logger } from '@lwrjs/diagnostics';
import { debounce } from '@lwrjs/shared-utils';
export const SPECIFIER_PREFIX = '@lwrjs/router/';
/**
 * Parse a specifier into its Router Config ID
 * Return undefined if the specifier is invalid
 * @param specifier - The raw specifier to parse
 */
export function parseSpecifier(specifier) {
    return specifier.startsWith(SPECIFIER_PREFIX) ? specifier.replace(SPECIFIER_PREFIX, '') : undefined;
}
/**
 * Given a Router Config ID and directory, return the file path to the router metadata
 * @param dir       - Path to directory containing Router Config files
 * @param specifier - Specifier for the Router Config module
 */
export function getRouterConfigPath(dir, specifier) {
    const routerId = parseSpecifier(specifier);
    return `${dir}/${routerId}.json`;
}
/**
 * Set up a file system watcher; used to spy on Router Config file changes
 * @param onModuleChange - File change callback function
 */
export function setUpWatcher(factory, onModuleChange) {
    const watcher = factory.createFileWatcher();
    watcher.on('change', debounce((file) => onModuleChange(file), 500));
    watcher.on('unlink', debounce((file) => onModuleChange(file, true), 500));
    watcher.on('add', (file) => logger.info({ label: `@lwrjs/router`, message: `Watching Router Config file at "${file}"` }));
    return watcher;
}
/**
 * Convert a lwc specifier into a Class name to use as a RouteHandler
 * @param specifier - A component specifier
 */
function getHandlerClassName(specifier) {
    return specifier.replace(/\//g, '_').replace('@', '');
}
/**
 * Generate a RouteHandler Class for every "component" specifier in an array of Route Definitions
 * The javascript is returned as a string, so it can be used in module source code
 * @param routes - Portable Route Definition array
 */
function generateHandlerClasses(routes) {
    let handlerClasses = '';
    const seenComponents = new Set();
    const filteredAndDeDupedArray = routes.filter((item) => {
        // Filter out entries without a component
        if (!item.component)
            return false;
        // De-dupe entries with a component
        if (!seenComponents.has(item.component)) {
            seenComponents.add(item.component);
            return true;
        }
        return false;
    });
    filteredAndDeDupedArray.forEach((r) => {
        // filtered above
        const component = r.component;
        handlerClasses += `class ${getHandlerClassName(component)} {
    callback;
    constructor(callback) {
        this.callback = callback;
    }
    dispose() {}
    update() {
        this.callback({
            viewset: {
                default: {
                    module: () => import('${component}'),
                    specifier: '${component}',
                },
            },
        });
    }
}\n`;
    });
    return handlerClasses;
}
/**
 * Convert portable JSON Route Definitions into javascript RouteDefinitions acceptable to the client-side router
 * Change string "handler" and "component" specifiers into async "handler" functions
 * The javascript is returned as a string, so it can be used in module source code
 * @param routes - Portable Route Definition array
 */
function generateRouteDefinitions(routes) {
    let routeDefs = '[\n';
    routes.forEach((r) => {
        // Make a copy of the route definition EXCLUDING the "handler" and "component" strings
        const { handler, component, ...routeDef } = r;
        const portableProps = JSON.stringify(routeDef);
        if (handler) {
            routeDefs += // translate the handler specifier => a handler dynamic import
                portableProps.slice(0, portableProps.length - 1) +
                    `, handler: () => import('${handler}') },\n`;
        }
        else if (component) {
            routeDefs += // translate the component specifier => a resolved handler class
                portableProps.slice(0, portableProps.length - 1) +
                    `, handler: () => Promise.resolve({ default: ${getHandlerClassName(component)} }) },\n`;
        }
    });
    return `${routeDefs}\t]`;
}
/**
 * Generate a module string which fulfills a router request
 * @param routes - The array of route definitions
 */
export function generateModule(config = { routes: [] }, { defaultLocale, uriPattern }, runtimeParams) {
    const { caseSensitive, routes: jsonRoutes } = config;
    const csString = caseSensitive ? 'true' : 'false';
    const routes = generateRouteDefinitions(jsonRoutes);
    const handlers = generateHandlerClasses(jsonRoutes);
    // Do we need to check basePath from router config?
    const basePath = runtimeParams?.basePath || '';
    const i18nRouterConfig = uriPattern === 'path-prefix'
        ? `${JSON.stringify({ locale: runtimeParams?.locale, defaultLocale })}`
        : undefined;
    return `import { createRouter as createLwrRouter } from 'lwr/router';
${handlers}
export function createRouter({ basePath = '${basePath}', caseSensitive = ${csString}, DEPRECATED_getRouteFromUrl, DEPRECATED_getUrlFromRoute } = {}) {
    return createLwrRouter({ basePath, caseSensitive, i18n: ${i18nRouterConfig}, routes: ${routes}, DEPRECATED_getRouteFromUrl, DEPRECATED_getUrlFromRoute });
}`;
}
//# sourceMappingURL=utils.js.map