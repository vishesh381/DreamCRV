import { currentPageReferenceContextualizer, navigationContextContextualizer, provideContext, } from 'lwr/contextProvider';
import { ROUTER_ERROR } from 'lwr/metrics';
import { CurrentPageReference, NavigationContext, registerNavigationHelm } from 'lwr/navigation';
import { CONTEXT_ID_BACKDOOR } from 'lwr/navigationMixinHacks';
import { logOperationStart } from 'lwr/profiler';
import { createRouter } from 'lwr/router';
import { generateMessageObject, messages } from 'lwr/routerErrors';
import { hasDocument } from 'lwr/routerUtils';
export class ServerRouter {
    constructor(config, router, target) {
        this.contextId = Object.freeze(() => undefined);
        this.router = router;
        this.target = target;
        this.handleNavHook = config.handleNavigation;
        this.preNavHook = config.preNavigate;
        this.errorNavHook = config.errorNavigate;
        this.initWires(config.url);
    }
    /**
     * lightning/navigation
     * Perform a hard navigation to the given page reference
     * Client only!
     */
    async navigate(address, _replace, options) {
        if (hasDocument) {
            // invoke the handleNavigation hook, which intercepts the raw page ref
            if (this.handleNavHook && !this.handleNavHook(address)) {
                return;
            }
            // continue navigating
            const url = await this.getValidatedUrl(address, options);
            if (url) {
                // hard navigation
                document.location.href = url;
            }
        }
    }
    /**
     * lightning/navigation
     * Generate a URL based on the given page reference
     */
    generateUrl(address, options) {
        return this.router.generateUrl(address, options);
    }
    /**
     * Initialize the CurrentPageReference & NavigationContext wires plus the client-only NavigationMixin
     * On the server, use the URL from the config
     * On the client, pull the URL from the current location
     */
    initWires(url) {
        if (!url && hasDocument) {
            // get the browser URL on the client
            url = document.location.href;
        }
        /* istanbul ignore next */
        if (!url) {
            this.processError(generateMessageObject(messages.NO_INIT_URL));
            return;
        }
        url = this.getRelativeUrl(url);
        // get an initial value for the current route
        // it will be undefined if this is an invalid page (errorRoute)
        this.currentRoute = this.router.matchRoute(url, {}) || undefined;
        // set up the navigation context APIs
        registerNavigationHelm(this.contextId, {
            navigate: (address, replace, options) => this.navigate(address, replace, options),
            generateUrl: (address, options) => this.generateUrl(address, options),
            // the JS context is lost during hard navigation, so subscribing to route changes will not work
            subscribe: () => {
                throw new Error('The server router does not support the subscribe API');
            },
        });
        // provide initial context values to the navigation wires
        provideContext(this.contextId, this.target, navigationContextContextualizer, NavigationContext);
        provideContext(this.currentRoute?.route.pageReference, this.target, currentPageReferenceContextualizer, CurrentPageReference);
        // used by NavigationMixin because it is very special * it can't use the @wires directly
        if (hasDocument) {
            this.target.addEventListener(CONTEXT_ID_BACKDOOR, (event) => {
                const navCtxEvent = event;
                if (navCtxEvent.detail.callback) {
                    navCtxEvent.detail.callback(this.contextId);
                }
            });
        }
    }
    /**
     * Get a relative URL from a fully qualified one
     * eg: "http://www.site.com/items/123abc?mode=dark" -> "/items/123abc?mode=dark"
     */
    getRelativeUrl(url) {
        // portable URL parsing
        if (url.startsWith('http')) {
            const parsed = new URL(url);
            return `${parsed.pathname}${parsed.search}`;
        }
        return url;
    }
    /**
     * Validate the page reference passed to the navigate API
     */
    async getValidatedUrl(address, options) {
        // match the URL to a route definition; fail if there is no match
        const routingMatch = this.router.matchRoute(address, {});
        if (!routingMatch) {
            this.processError(generateMessageObject(messages.NO_ROUTE_MATCH, [JSON.stringify(address)]));
            return;
        }
        // execute the preNav hook; fail if it blocks the navigation event
        const valid = this.preNavHook &&
            (await this.preNavHook({
                current: this.currentRoute,
                next: routingMatch,
            }));
        if (!valid) {
            this.processError(generateMessageObject(messages.PRENAV_FAILED, [JSON.stringify(address)]));
            return;
        }
        return this.router.generateUrl(address, options);
    }
    /**
     * Run the errorNavigate filters
     */
    processError(messageObject) {
        logOperationStart({ id: ROUTER_ERROR });
        this.errorNavHook && this.errorNavHook(messageObject);
    }
}
/**
 * Create and initialize a new Server Router
 * On the server, enable the CurrentPageReference & NavigationContext wires plus the generateUrl API
 * On the client, do hard navigations and enable all "lightning/navigation" APIs for hydrated or CSR islands
 * Note: This router does not implement subscribe() or the CurrentView wire
 */
export function createServerRouter(config, target) {
    new ServerRouter(config, createRouter(config), target);
}
//# sourceMappingURL=serverRouter.js.map