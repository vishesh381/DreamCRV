var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/config/src/validation/app-config-context.ts
__markAsModule(exports);
__export(exports, {
  ASSET_DIR_ATTRIBUTE_KEYS: () => ASSET_DIR_ATTRIBUTE_KEYS,
  ASSET_FILE_ATTRIBUTE_KEYS: () => ASSET_FILE_ATTRIBUTE_KEYS,
  BASE_PATH_REGEX: () => BASE_PATH_REGEX,
  BOOTSTRAP_ATTRIBUTE_KEYS: () => BOOTSTRAP_ATTRIBUTE_KEYS,
  CORE_PROXY_ATTRIBUTE_KEYS: () => CORE_PROXY_ATTRIBUTE_KEYS,
  ERROR_ROUTE_ATTRIBUTE_KEYS: () => ERROR_ROUTE_ATTRIBUTE_KEYS,
  I18N_ATTRIBUTE_KEYS: () => I18N_ATTRIBUTE_KEYS,
  LOCKER_ATTRIBUTE_KEYS: () => LOCKER_ATTRIBUTE_KEYS,
  ROOT_ATTRIBUTE_KEYS: () => ROOT_ATTRIBUTE_KEYS,
  ROUTE_ATTRIBUTE_KEYS: () => ROUTE_ATTRIBUTE_KEYS,
  STATIC_SITE_GENERATOR_ATTRIBUTE_KEYS: () => STATIC_SITE_GENERATOR_ATTRIBUTE_KEYS,
  ValidationContext: () => ValidationContext
});
var import_jsonc_parser = __toModule(require("jsonc-parser"));
var import_diagnostics = __toModule(require("@lwrjs/diagnostics"));
var import_helpers = __toModule(require("./helpers.cjs"));
var import_shared_utils = __toModule(require("@lwrjs/shared-utils"));
function createKeys(p, t) {
  return p && t;
}
var ROOT_ATTRIBUTE_KEYS = createKeys("root", [
  "amdLoader",
  "apiVersion",
  "assets",
  "assetProviders",
  "assetTransformers",
  "bundleConfig",
  "bundleProviders",
  "cacheDir",
  "caseSensitiveRoutes",
  "contentDir",
  "coreProxy",
  "environment",
  "errorRoutes",
  "esmLoader",
  "staticSiteGenerator",
  "globalData",
  "globalDataDir",
  "hooks",
  "i18n",
  "ignoreLwrConfigFile",
  "_isSsrCompilerEnabled",
  "lwrConfigFile",
  "layoutsDir",
  "locker",
  "lwc",
  "lwrVersion",
  "moduleProviders",
  "port",
  "basePath",
  "resourceProviders",
  "rootDir",
  "routeHandlers",
  "routes",
  "serverMode",
  "minify",
  "serverType",
  "uriTransformers",
  "viewProviders",
  "viewTransformers",
  "unsafeEnableViewLinkCaching"
]);
var ASSET_DIR_ATTRIBUTE_KEYS = createKeys("assetDir", ["alias", "dir", "urlPath", "root"]);
var ASSET_FILE_ATTRIBUTE_KEYS = createKeys("assetFile", ["alias", "file", "urlPath"]);
var LOCKER_ATTRIBUTE_KEYS = createKeys("locker", ["enabled", "trustedComponents"]);
var I18N_ATTRIBUTE_KEYS = createKeys("i18n", ["defaultLocale", "locales", "uriPattern", "defaultRedirectParams"]);
var CORE_PROXY_ATTRIBUTE_KEYS = createKeys("coreProxy", ["origin", "host", "servername"]);
var STATIC_SITE_GENERATOR_ATTRIBUTE_KEYS = createKeys("staticSiteGenerator", [
  "outputDir",
  "skipBaseDocumentGeneration",
  "skipCleanOutputDir",
  "_additionalModules",
  "_additionalRoutePaths"
]);
var ROUTE_ATTRIBUTE_KEYS = createKeys("routes", [
  "bootstrap",
  "subRoutes",
  "contentTemplate",
  "id",
  "cache",
  "layoutTemplate",
  "method",
  "path",
  "rootComponent",
  "routeHandler",
  "properties"
]);
var ERROR_ROUTE_ATTRIBUTE_KEYS = createKeys("errorRoutes", [
  "bootstrap",
  "subRoutes",
  "contentTemplate",
  "id",
  "layoutTemplate",
  "rootComponent",
  "routeHandler",
  "status",
  "properties",
  "cache"
]);
var BOOTSTRAP_ATTRIBUTE_KEYS = createKeys("bootstrap", [
  "autoBoot",
  "syntheticShadow",
  "workers",
  "services",
  "configAsSrc",
  "ssr",
  "preloadData",
  "proxyForSSR",
  "includeCookiesForSSR",
  "mixedMode",
  "module",
  "preloadModules",
  "lwrVersion",
  "lwcVersion",
  "preloadResources"
]);
function isNotEmptyString(node) {
  return node.type === "string" && node.value.length > 0;
}
var BASE_PATH_REGEX = /^(\/[A-Za-z0-9](?:[A-Za-z0-9-]{0,61}[A-Za-z0-9])?)+$/g;
var ValidationContext = class {
  constructor(sourceText) {
    this.diagnostics = [];
    this.sourceText = sourceText;
  }
  getLocationFromNode(node) {
    return (0, import_helpers.calculatePositionFromSource)(this.sourceText, node);
  }
  assertIsObject(node, property) {
    if (node?.type !== "object" && node) {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(property, "object", node.type),
        location: this.getLocationFromNode(node)
      });
    }
  }
  assertIsBoolean(node, property) {
    if (node && node.type !== "boolean") {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(property, "boolean", node.type),
        location: this.getLocationFromNode(node)
      });
    }
  }
  assertIsArray(node, property) {
    if (node && node.type !== "array") {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(property, "array", node.type),
        location: this.getLocationFromNode(node)
      });
    }
  }
  assertIsSpecifier(node, property) {
    if (node && (node.type !== "string" || !(0, import_shared_utils.isSpecifier)(node.value))) {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INVALID_SPECIFIER(property, node.value),
        location: this.getLocationFromNode(node)
      });
    }
  }
  assertIsFilePattern(node, property) {
    if (node) {
      const children = node.children || [];
      for (const [index, child] of children.entries()) {
        let matcher = (0, import_jsonc_parser.findNodeAtLocation)(child, ["match"])?.children?.map((val) => val.value) || (0, import_jsonc_parser.findNodeAtLocation)(child, ["match"])?.value;
        if (!Array.isArray(matcher)) {
          matcher = [matcher];
        }
        let misMatch = null;
        for (let i = 0; i < matcher.length; i++) {
          try {
            if (matcher[i] === "")
              throw new Error("Empty string is not a valid regex");
            new RegExp(matcher[i]);
          } catch (e) {
            misMatch = matcher[i];
            this.diagnostics.push({
              description: import_diagnostics.descriptions.CONFIG_PARSER.INVALID_FILE_PATTERN(`${property}[${index}].match`, misMatch),
              location: this.getLocationFromNode(node)
            });
          }
          if (misMatch)
            break;
        }
        if (misMatch !== null) {
          break;
        }
      }
    }
  }
  assertIsPath(node, property) {
    if (node && (node.type !== "string" || node.value[0] !== "/")) {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INVALID_PATH(property, node.value),
        location: this.getLocationFromNode(node)
      });
    }
  }
  assertIsOrigin(node, property) {
    if (node && (node.type !== "string" || !/^https?:\/\//i.test(node.value))) {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INVALID_ORIGIN(property, node.value),
        location: this.getLocationFromNode(node)
      });
    }
  }
  assertIsPort(node, property) {
    if (node && (node.type !== "number" || node.value < 0 || node.value > 65353)) {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INVALID_PORT(property, node.value),
        location: this.getLocationFromNode(node)
      });
    }
  }
  assertIsServerType(node, property) {
    if (node && node.value !== "express" && node.value !== "koa" && node.value !== "fs") {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INVALID_SERVER_TYPE(property, node.value),
        location: this.getLocationFromNode(node)
      });
    }
  }
  assertIsStaticSiteGenerator(node, property) {
    if (node && node.type !== "object") {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INVALID_GENERATOR_CONFIG(property, node.value),
        location: this.getLocationFromNode(node)
      });
    }
  }
  assertIsMethod(node, property) {
    if (node && node.value !== "get" && node.value !== "post") {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INVALID_METHOD(property, node.value),
        location: this.getLocationFromNode(node)
      });
    }
  }
  assertIsStatus(node, property) {
    if (node && node.value !== 404 && node.value !== 500) {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INVALID_STATUS(property, node.value),
        location: this.getLocationFromNode(node)
      });
    }
  }
  assertIsEnvironment(node, property) {
    if (!node) {
      return;
    }
    let defaultProperty;
    let supportedProperty;
    if (node.type === "object" && node.children?.length) {
      for (const child of node.children) {
        if (child.type === "property" && child.children?.length) {
          if (child.children[0].value === "default" && isNotEmptyString(child.children[1])) {
            defaultProperty = child;
          }
          if (child.children[0].value === "supported") {
            supportedProperty = child;
          }
        }
      }
    }
    if (node.type !== "object" || supportedProperty && !defaultProperty) {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INVALID_ENVIRONMENT(property),
        location: this.getLocationFromNode(node)
      });
    }
  }
  assertIsBasePath(node, property, allowSlash = false) {
    if (!node) {
      return;
    }
    if (node.type !== "string") {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(property, "string", node.type),
        location: this.getLocationFromNode(node)
      });
    } else if (node.value === "" || allowSlash && node.value === "/") {
      return;
    } else if (node.value.match(BASE_PATH_REGEX) === null) {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INVALID_BASEPATH(property, node.value),
        location: this.getLocationFromNode(node)
      });
    }
  }
  assertNotEmptyString(node, property) {
    if (!node) {
      return;
    }
    if (node.type !== "string") {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(property, "string", node.type),
        location: this.getLocationFromNode(node)
      });
    } else if (!isNotEmptyString(node)) {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.NON_EMPTY_STRING(property, node.value),
        location: this.getLocationFromNode(node)
      });
    }
  }
  assertNotEmptyArray(node, property) {
    if (!node) {
      return;
    }
    if (node.type !== "array") {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(property, "array", node.type),
        location: this.getLocationFromNode(node)
      });
    } else if (!node.children || node.children.length === 0) {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.NON_EMPTY_ARRAY(property, "[]"),
        location: this.getLocationFromNode(node)
      });
    }
  }
  assertHasOneOrMore(node, property, childProps) {
    if (!childProps.some((p) => (0, import_jsonc_parser.findNodeAtLocation)(node, [p]) !== void 0)) {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.MISSING_ONE_OF(property, childProps),
        location: this.getLocationFromNode(node)
      });
    }
  }
  assertHasOnlyOne(node, property, childProps) {
    if (childProps.filter((p) => (0, import_jsonc_parser.findNodeAtLocation)(node, [p])).length !== 1) {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.TOO_MANY(property, childProps),
        location: this.getLocationFromNode(node)
      });
    }
  }
  assertArrayOfStrings(node, property) {
    if (!node) {
      return;
    }
    if (node.type !== "array") {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(property, "array", node.type),
        location: this.getLocationFromNode(node)
      });
    } else if (node.children && node.children.length > 0) {
      node.children.forEach((n, index) => {
        if (!isNotEmptyString(n)) {
          this.diagnostics.push({
            description: import_diagnostics.descriptions.CONFIG_PARSER.NON_EMPTY_STRING(`${property}[${index}]`, n.value),
            location: this.getLocationFromNode(n)
          });
        }
      });
    }
  }
  assertArrayOfSpecifiers(node, property) {
    if (!node) {
      return;
    }
    if (node.type !== "array") {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(property, "array", node.type),
        location: this.getLocationFromNode(node)
      });
    } else if (node.children && node.children.length > 0) {
      node.children.forEach((n, index) => {
        if (n.type !== "string" || !(0, import_shared_utils.isSpecifier)(n.value)) {
          this.diagnostics.push({
            description: import_diagnostics.descriptions.CONFIG_PARSER.INVALID_SPECIFIER(`${property}[${index}]`, n.value),
            location: this.getLocationFromNode(n)
          });
        }
      });
    }
  }
  assertArrayOfServices(node, property) {
    if (!node) {
      return;
    }
    if (node.type !== "array") {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(property, "array", node.type),
        location: this.getLocationFromNode(node)
      });
    } else if (node.children && node.children.length > 0) {
      node.children.forEach((n, index) => this.assertIsService(n, property, index));
    }
  }
  assertArrayOfBootstrapServices(node, property) {
    if (!node) {
      return;
    }
    if (node.type !== "array") {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(property, "array", node.type),
        location: this.getLocationFromNode(node)
      });
    } else if (node.children && node.children.length > 0) {
      node.children.forEach((n, index) => {
        let specifier = void 0;
        if (n.type === "string") {
          specifier = n.value;
        } else if (n.type === "object") {
          const name = (0, import_jsonc_parser.findNodeAtLocation)(n, ["name"]);
          specifier = name?.value;
        }
        if (!(0, import_shared_utils.isSpecifier)(specifier)) {
          this.diagnostics.push({
            description: import_diagnostics.descriptions.CONFIG_PARSER.INVALID_SPECIFIER(`${property}[${index}]`, specifier),
            location: this.getLocationFromNode(n)
          });
        }
      });
    }
  }
  assertIsStringOrObject(node, property, index) {
    if (!node) {
      return;
    }
    if (node.type !== "string" && node.type !== "object") {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(index !== void 0 ? `${property}[${index}]` : property, "string or object", node.type),
        location: this.getLocationFromNode(node)
      });
    } else if (node.type === "string" && !isNotEmptyString(node)) {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.NON_EMPTY_STRING(property, node.value),
        location: this.getLocationFromNode(node)
      });
    }
  }
  assertIsService(node, property, index) {
    if (!node) {
      return;
    }
    if (node.type !== "string" && node.type !== "array") {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(index !== void 0 ? `${property}[${index}]` : property, "string or array", node.type),
        location: this.getLocationFromNode(node)
      });
    }
    if (node.type === "string" && node.value.length === 0 || node.type === "array" && node.children && (node.children.length !== 2 || !isNotEmptyString(node.children[0]))) {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INVALID_SERVICE(index !== void 0 ? `${property}[${index}]` : property, node.value === void 0 && node.children ? `invalid Array[${node.children.length}]` : node.value),
        location: this.getLocationFromNode(node)
      });
    }
  }
  assertUniqueIds(nodes, property) {
    const ids = nodes.map((n) => {
      const idNode = (0, import_jsonc_parser.findNodeAtLocation)(n, ["id"]);
      return idNode ? idNode.value : void 0;
    }).filter((id) => id !== void 0);
    const dupeIds = ids.filter((id, index) => ids.indexOf(id) !== index);
    if (dupeIds.length > 0) {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.DUPLICATE_IDS(property, dupeIds),
        location: this.getLocationFromNode(nodes[0])
      });
    }
  }
  assertRequiredKeys(node, property, requiredPropertyKeys) {
    const missingProps = requiredPropertyKeys.filter((p) => (0, import_jsonc_parser.findNodeAtLocation)(node, [p]) === void 0);
    if (missingProps.length > 0) {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.MISSING_REQUIRED(property, missingProps),
        location: this.getLocationFromNode(node)
      });
    }
  }
  assertValidKeys(node, property, validPropertyKeys) {
    const {children} = node;
    if (!children) {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.INVALID_EMPTY_NODE(property),
        location: this.getLocationFromNode(node)
      });
      return;
    } else {
      for (const propertyNode of children) {
        if (propertyNode.type === "property" && propertyNode.children) {
          const [keyNode] = propertyNode.children;
          const {type, value} = keyNode;
          if (type === "string" && !validPropertyKeys.includes(value)) {
            this.diagnostics.push({
              description: import_diagnostics.descriptions.CONFIG_PARSER.INVALID_PROPERTY(property, value),
              location: this.getLocationFromNode(keyNode)
            });
          }
        }
      }
    }
  }
  assertNoBundleConfigDupes(node, dupes) {
    if (dupes.length) {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.DUPLICATE_BUNDLE_CONFIG(dupes),
        location: this.getLocationFromNode(node)
      });
    }
  }
  assertDefaultInLocales(node, defaultLocale, localesIds) {
    if (!localesIds.includes(defaultLocale)) {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.DEFAULT_NOT_IN_LOCALES(defaultLocale, localesIds),
        location: this.getLocationFromNode(node)
      });
    }
  }
  assertFallbackIds(nodes) {
    const localesIds = nodes.map((n) => {
      const idNode = (0, import_jsonc_parser.findNodeAtLocation)(n, ["id"]);
      return idNode ? idNode.value : void 0;
    }).filter((id) => id !== void 0);
    for (const n of nodes) {
      const fallbackNode = (0, import_jsonc_parser.findNodeAtLocation)(n, ["fallback"]);
      if (fallbackNode?.value) {
        if (!localesIds.includes(fallbackNode.value)) {
          this.diagnostics.push({
            description: import_diagnostics.descriptions.CONFIG_PARSER.FALLBACK_NOT_IN_LOCALES(fallbackNode.value, localesIds),
            location: this.getLocationFromNode(fallbackNode)
          });
        }
      }
    }
  }
  assertSsrPreloadData(node, propPrefix) {
    const ssr = (0, import_jsonc_parser.findNodeAtLocation)(node, ["ssr"])?.value;
    const preloadData = (0, import_jsonc_parser.findNodeAtLocation)(node, ["preloadData"])?.value;
    if (ssr === true && preloadData === false) {
      this.diagnostics.push({
        description: import_diagnostics.descriptions.CONFIG_PARSER.SSR_WITHOUT_PRELOAD(propPrefix),
        location: this.getLocationFromNode(node)
      });
    }
  }
  assertIsCoreProxy(node, validationContext) {
    if (node && node.type !== "null") {
      validationContext.assertIsObject(node, "coreProxy");
      validationContext.assertValidKeys(node, "coreProxy", CORE_PROXY_ATTRIBUTE_KEYS);
      validationContext.assertRequiredKeys(node, "coreProxy", ["origin"]);
      validationContext.assertNotEmptyString((0, import_jsonc_parser.findNodeAtLocation)(node, ["origin"]), "coreProxy.origin");
      const host = (0, import_jsonc_parser.findNodeAtLocation)(node, ["host"]);
      host && validationContext.assertNotEmptyString(host, "coreProxy.host");
      const servername = (0, import_jsonc_parser.findNodeAtLocation)(node, ["servername"]);
      servername && validationContext.assertNotEmptyString(servername, "coreProxy.servername");
    }
  }
};
