var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/config/src/hooks.ts
__markAsModule(exports);
__export(exports, {
  executeConfigHooks: () => executeConfigHooks,
  executeContextHooks: () => executeContextHooks,
  executeInstrumentationHooks: () => executeInstrumentationHooks,
  executeStartHooks: () => executeStartHooks
});
var import_routes = __toModule(require("./utils/routes.cjs"));
var import_assets = __toModule(require("./utils/assets.cjs"));
var import_app_config = __toModule(require("./validation/app-config.cjs"));
var import_instrumentation = __toModule(require("@lwrjs/instrumentation"));
var import_defaults = __toModule(require("./defaults.cjs"));
var import_diagnostics = __toModule(require("@lwrjs/diagnostics"));
function isInfoRoute(route) {
  if (route.path === import_defaults.LWR_INFO_ROUTE.path && route.id === import_defaults.LWR_INFO_ROUTE.id) {
    if (Array.isArray(route.routeHandler)) {
      return route.routeHandler?.includes(`${import_defaults.LWR_INFO_ROUTE.routeHandler}`);
    } else if (typeof route.routeHandler === "string") {
      return route.routeHandler === import_defaults.LWR_INFO_ROUTE.routeHandler;
    }
  }
  return false;
}
async function executeConfigHooks(hooks, globalConfig, runtimeEnvironment, globalData, skipValidate = false) {
  const span = (0, import_instrumentation.getTracer)().startSpan({name: import_instrumentation.ConfigSpan.ExecuteConfigHooks});
  if (!hooks.length) {
    span.end();
    return;
  }
  for (const hook of hooks) {
    if (!hook.initConfigs) {
      continue;
    }
    await hook.initConfigs(globalConfig, globalData, runtimeEnvironment);
  }
  let filteredRoutes = globalConfig.routes.filter((e) => e.path !== "/lwr-info" || isInfoRoute(e));
  if (filteredRoutes.length < globalConfig.routes.length) {
    import_diagnostics.logger.warn({
      label: "config hooks",
      message: "config hook attempted to redefine protected /lwr-info path"
    });
  }
  const hasInfoRoute = filteredRoutes.some((route) => isInfoRoute(route));
  if (!hasInfoRoute) {
    filteredRoutes = [import_defaults.LWR_INFO_ROUTE, ...filteredRoutes];
    import_diagnostics.logger.warn({
      label: "config hooks",
      message: "config hook attempted to remove /lwr-info route"
    });
  }
  globalConfig.routes = (0, import_routes.normalizeRoutes)(filteredRoutes, globalConfig.routeHandlers);
  globalConfig.errorRoutes = (0, import_routes.normalizeRoutes)(globalConfig.errorRoutes, globalConfig.routeHandlers);
  if (!skipValidate) {
    (0, import_app_config.validateLwrAppConfig)(globalConfig, "post");
  }
  span.end();
}
function executeStartHooks(hooks, globalConfig, runtimeEnvironment, skipValidate = false) {
  const span = (0, import_instrumentation.getTracer)().startSpan({name: import_instrumentation.ConfigSpan.ExecuteStartHooks});
  if (!hooks.length) {
    span.end();
    return;
  }
  for (const hook of hooks) {
    if (!hook.onStart) {
      continue;
    }
    const onStartConfig = {
      _isSsrCompilerEnabled: globalConfig._isSsrCompilerEnabled,
      basePath: globalConfig.basePath,
      coreProxy: globalConfig.coreProxy,
      i18n: globalConfig.i18n,
      routes: globalConfig.routes,
      assets: globalConfig.assets,
      errorRoutes: globalConfig.errorRoutes
    };
    hook.onStart(onStartConfig);
    runtimeEnvironment.basePath = globalConfig.basePath = onStartConfig.basePath || "";
    runtimeEnvironment.i18n = globalConfig.i18n = onStartConfig.i18n;
    globalConfig.assets = (0, import_assets.normalizeAssetPaths)((0, import_assets.normalizeAssets)(onStartConfig.assets), globalConfig.rootDir);
    globalConfig._isSsrCompilerEnabled = onStartConfig._isSsrCompilerEnabled;
    globalConfig.coreProxy = onStartConfig.coreProxy;
    globalConfig.routes = onStartConfig.routes || [];
    globalConfig.errorRoutes = onStartConfig.errorRoutes || [];
  }
  let filteredRoutes = globalConfig.routes.filter((e) => e.path !== "/lwr-info" || isInfoRoute(e));
  if (filteredRoutes.length < globalConfig.routes.length) {
    import_diagnostics.logger.warn({
      label: "start hooks",
      message: "onStart hook attempted to redefine protected /lwr-info path"
    });
  }
  const hasInfoRoute = filteredRoutes.some((route) => isInfoRoute(route));
  if (!hasInfoRoute) {
    filteredRoutes = [import_defaults.LWR_INFO_ROUTE, ...filteredRoutes];
    import_diagnostics.logger.warn({
      label: "start hooks",
      message: "onStart hook attempted to remove /lwr-info route"
    });
  }
  globalConfig.routes = (0, import_routes.normalizeRoutes)(filteredRoutes, globalConfig.routeHandlers);
  globalConfig.errorRoutes = (0, import_routes.normalizeRoutes)(globalConfig.errorRoutes, globalConfig.routeHandlers);
  if (globalConfig._isSsrCompilerEnabled)
    process.env.SSR_COMPILER_ENABLED = "true";
  if (!skipValidate) {
    (0, import_app_config.validateLwrAppConfig)(globalConfig, "post");
  }
  span.end();
}
function executeInstrumentationHooks(hooks) {
  const span = (0, import_instrumentation.getTracer)().startSpan({name: import_instrumentation.ConfigSpan.ExecuteInstrHooks});
  const instrumentation = [];
  for (const hook of hooks) {
    if (!hook.initInstrumentation) {
      continue;
    }
    instrumentation.push(hook.initInstrumentation());
  }
  span.end();
  if (!instrumentation.length) {
    return void 0;
  }
  return {
    flush() {
      for (const instance of instrumentation) {
        instance.flush();
      }
    }
  };
}
async function executeContextHooks(hooks, serverContext) {
  if (!hooks.length) {
    return;
  }
  for (const hook of hooks) {
    if (!hook.setupServerContext) {
      continue;
    }
    await hook.setupServerContext(serverContext, hooks);
  }
}
