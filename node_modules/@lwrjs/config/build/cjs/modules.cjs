var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/config/src/modules.ts
__markAsModule(exports);
__export(exports, {
  loadHooks: () => loadHooks,
  loadRouteHandlers: () => loadRouteHandlers,
  loadServices: () => loadServices
});
var import_path = __toModule(require("path"));
var import_diagnostics = __toModule(require("@lwrjs/diagnostics"));
var import_shared_utils = __toModule(require("@lwrjs/shared-utils"));
async function importModule(filepath, rootDir, cacheDir) {
  let resolvedFilePath = (0, import_shared_utils.normalizeDirectory)(filepath, rootDir);
  const resolvedCacheDir = (0, import_shared_utils.normalizeDirectory)(cacheDir, rootDir);
  try {
    if (resolvedFilePath.endsWith(".ts")) {
      const fullPath = (0, import_shared_utils.resolveFileExtension)(resolvedFilePath);
      const {transpileTs} = await Promise.resolve().then(() => __toModule(require("@lwrjs/esbuild")));
      resolvedFilePath = await transpileTs(fullPath, {rootDir, cacheDir: resolvedCacheDir});
    }
    const moduleEntry = await Promise.resolve().then(() => __toModule(require((0, import_shared_utils.crossEnvFileURL)(resolvedFilePath))));
    const output = moduleEntry.default || moduleEntry;
    return output;
  } catch (err) {
    import_diagnostics.logger.error(err);
    throw new Error(`Unable to load configurable module: ${filepath}`);
  }
}
async function loadServiceEntries(entries, rootDir, cacheDir) {
  return Promise.all(entries.map(async ([entry, config]) => {
    const cacheDirServices = import_path.default.join(cacheDir, "services");
    const ctor = await importModule(entry, rootDir, cacheDirServices);
    return [ctor, config];
  }));
}
async function loadHooks(config) {
  if (!config.hooks) {
    return [];
  }
  const hookCtors = await loadServiceEntries(config.hooks, config.rootDir, config.cacheDir);
  const hooks = hookCtors.map(([hookCtor, hookConfig = {}]) => {
    return new hookCtor(hookConfig);
  });
  return hooks;
}
async function loadServices(config) {
  const moduleProviders = await loadServiceEntries(config.moduleProviders, config.rootDir, config.cacheDir);
  const bundleProviders = await loadServiceEntries(config.bundleProviders, config.rootDir, config.cacheDir);
  const assetProviders = await loadServiceEntries(config.assetProviders, config.rootDir, config.cacheDir);
  const assetTransformers = await loadServiceEntries(config.assetTransformers, config.rootDir, config.cacheDir);
  const resourceProviders = await loadServiceEntries(config.resourceProviders, config.rootDir, config.cacheDir);
  const uriTransformers = await loadServiceEntries(config.uriTransformers, config.rootDir, config.cacheDir);
  const viewProviders = await loadServiceEntries(config.viewProviders, config.rootDir, config.cacheDir);
  const viewTransformers = await loadServiceEntries(config.viewTransformers, config.rootDir, config.cacheDir);
  return {
    moduleProviders,
    bundleProviders,
    assetProviders,
    assetTransformers,
    resourceProviders,
    uriTransformers,
    viewProviders,
    viewTransformers
  };
}
async function loadRouteHandlers(config) {
  const routeHandlers = {};
  await Promise.all(Object.keys(config.routeHandlers).map(async (id) => {
    const handlerPath = config.routeHandlers[id] || id;
    const handler = await importModule(handlerPath, config.rootDir, import_path.default.join(config.cacheDir, "routeHandlers"));
    routeHandlers[id] = handler;
  }));
  return routeHandlers;
}
