import fs from 'fs';
import path from 'path';
import { parse } from 'jsonc-parser';
import { logger } from '@lwrjs/diagnostics';
import { readFile, normalizeDirectory, getFeatureFlags, ASSETS_CACHE_DIR, isLocalPath, normalizeToFileUrl } from '@lwrjs/shared-utils';
import { DEFAULT_AMD_LOADER, DEFAULT_AMD_LOADER_LEGACY, DEFAULT_ESM_LOADER, DEFAULT_LWR_CONFIG, DEFAULT_LWR_CONFIG_JSON, DEFAULT_ROOT_DIR, } from './defaults.js';
import { lwrVersion as LWR_VERSION } from '@lwrjs/config/package';
import { validateLwrAppConfig } from './validation/app-config.js';
import { normalizeAssetPaths, normalizeAssets } from './utils/assets.js';
import { normalizeServicePaths, normalizeServices } from './utils/services.js';
import { normalizeRoutePaths, normalizeRoutes, normalizeRouteHandlers, normalizeRouteHandlerPaths, } from './utils/routes.js';
import { mergeBundleConfig, mergeLockerConfig, mergeLwcConfig, mergeStaticGenerationConfig, trimLwrConfig, } from './utils/merge.js';
import { normalizeLwcConfig, normalizeModulePaths } from './utils/lwc.js';
import { getRuntimeEnvironment } from './runtime-config.js';
import { getGlobalData } from './utils/global-data.js';
import { getTracer, ConfigSpan } from '@lwrjs/instrumentation';
/**
 * Load and validate the global config file.
 *
 * @remarks
 * By default, this file is expected to be named `lwr.config.json` and be located at the root directory.
 * This default expectation can be override with the `lwrConfigFile` configuration.
 *
 * @throws {LwrConfigValidationError} Validation errors will be swallowed when the
 * `UNSAFE_IGNORE_CONFIG_VALIDATION` flag is set.
 *
 * @param {string} lwrConfigPath - config file path override
 * @param {string} rootDir - the directory used to resolve `$rootDir`
 * @returns {LwrGlobalConfig | undefined} the validated config file contents if it exists
 */
export function getLwrConfigFromFile(rootDir, lwrConfigPath = DEFAULT_LWR_CONFIG_JSON) {
    const resolvedLwrConfigPath = path.resolve(normalizeDirectory(lwrConfigPath, rootDir));
    if (!fs.existsSync(resolvedLwrConfigPath)) {
        logger.warn({ label: `config`, message: `LWR Config not found on "${resolvedLwrConfigPath}"` });
        return undefined;
    }
    const configSource = readFile(resolvedLwrConfigPath);
    validateLwrAppConfig(configSource, 'file');
    let parsedConfig = parse(configSource);
    if (parsedConfig?.routes) {
        parsedConfig.routes = parsedConfig.routes.filter(route => route.path !== '/lwr-info');
    }
    return parsedConfig;
}
/**
 * Normalize the cache directory path and create the directory
 *
 * @param {string} cache - the path to the cache directory
 * @param {string} rootDir - the directory used to resolve `$rootDir`
 * @returns {string} the absolute path of the created cache directory
 */
function createCacheFolder(cache, rootDir) {
    const cacheDir = normalizeDirectory(cache, rootDir);
    const absPath = path.resolve(cacheDir);
    fs.mkdirSync(path.join(absPath, ASSETS_CACHE_DIR), { recursive: true });
    return absPath;
}
/**
 * Load and merge all global config sources.
 *
 * @remarks
 * Configurations are merged in the following order:
 *  defaults -> environment variables -> config file (lwr.config.json) -> config argument
 *
 * @throws {LwrConfigValidationError} Validation errors will not be caught without the
 * `UNSAFE_IGNORE_CONFIG_VALIDATION` flag.
 *
 * @param {LwrGlobalConfig} configArg - programmatic global config
 * @returns {Required<LwrGlobalConfig>} a complete(but not normalized) global config
 */
function mergeConfig(configArg) {
    // process programmatic config
    if (configArg) {
        // the programmatic config is trimmed to prevent overriding properties with an undefined value
        configArg = trimLwrConfig(configArg);
        // validation errors will not be caught unless `UNSAFE_IGNORE_CONFIG_VALIDATION` is set
        validateLwrAppConfig(configArg, 'pre');
    }
    // resolve the current root dir
    const rootDir = path.resolve(configArg?.rootDir || DEFAULT_ROOT_DIR);
    // attempt to load the config file if it isn't ignored
    const configFile = !configArg?.ignoreLwrConfigFile
        ? getLwrConfigFromFile(rootDir, configArg?.lwrConfigFile)
        : undefined;
    // merge default routes with the config file routes
    if (configFile) {
        configFile.routes = [...DEFAULT_LWR_CONFIG.routes, ...(configFile?.routes ?? [])];
    }
    // Merge the bundle configs
    const bundleConfig = mergeBundleConfig(configFile, configArg);
    // Normalize external file paths to absolute file URLs
    if (bundleConfig.external) {
        for (const key of Object.keys(bundleConfig.external)) {
            const path = bundleConfig.external[key];
            if (isLocalPath(path)) {
                bundleConfig.external[key] = normalizeToFileUrl(path, rootDir);
            }
        }
    }
    // merge the various configs in order of priority
    return {
        ...DEFAULT_LWR_CONFIG,
        ...configFile,
        ...configArg,
        // merge nested configurations
        lwc: mergeLwcConfig(configFile, configArg),
        bundleConfig,
        locker: mergeLockerConfig(configFile, configArg),
        staticSiteGenerator: mergeStaticGenerationConfig(configFile, configArg),
        // root dir set by the config file will be ignored
        rootDir,
    };
}
/**
 * Normalize the shapes of all config properties.
 *
 * @remarks
 * Paths and directories are not normalized as part of this functions.
 *
 * @param {Required<LwrGlobalConfig>} config - a complete global config
 * @returns {NormalizedLwrGlobalConfig} a normalized global config
 */
function normalizeConfig(config) {
    const amdLoader = getFeatureFlags().LEGACY_LOADER ? DEFAULT_AMD_LOADER_LEGACY : DEFAULT_AMD_LOADER;
    return {
        ...config,
        // set non-configurable properties (hooks can mutate these)
        amdLoader,
        esmLoader: DEFAULT_ESM_LOADER,
        lwrVersion: LWR_VERSION,
        // normalize assets
        assets: normalizeAssets(config.assets),
        // normalize lwc config
        lwc: normalizeLwcConfig(config.lwc),
        // normalize all services
        hooks: normalizeServices(config.hooks),
        bundleProviders: normalizeServices(config.bundleProviders),
        moduleProviders: normalizeServices(config.moduleProviders),
        assetProviders: normalizeServices(config.assetProviders),
        assetTransformers: normalizeServices(config.assetTransformers),
        resourceProviders: normalizeServices(config.resourceProviders),
        uriTransformers: normalizeServices(config.uriTransformers),
        viewProviders: normalizeServices(config.viewProviders),
        viewTransformers: normalizeServices(config.viewTransformers),
        // normalize routes and capture all route handlers
        routes: normalizeRoutes(config.routes, config.routeHandlers),
        errorRoutes: normalizeRoutes(config.errorRoutes, config.routeHandlers),
        routeHandlers: normalizeRouteHandlers(config.routeHandlers),
    };
}
/**
 * Normalize all config paths to create an idempotent config.  All `$rootDir` references
 * will be resolved based on the configured root directory or the current working directory.
 *
 * @param {NormalizedLwrGlobalConfig} config - normalized global config with references to `$rootDir`
 * @returns {NormalizedLwrGlobalConfig} an idempotent normalized global config
 */
function normalizeConfigPaths(config) {
    const rootDir = config.rootDir || DEFAULT_ROOT_DIR;
    const resourcePaths = {
        rootDir,
        assets: normalizeAssetPaths(config.assets, rootDir),
        contentDir: normalizeDirectory(config.contentDir, rootDir),
        layoutsDir: normalizeDirectory(config.layoutsDir, rootDir),
    };
    return {
        ...config,
        // normalize all resource directories
        ...resourcePaths,
        globalDataDir: normalizeDirectory(config.globalDataDir, rootDir),
        cacheDir: normalizeDirectory(config.cacheDir, rootDir),
        // normalize module record paths and drop the `interchangeableModules` property
        // because it will be loaded into `interchangeableModulesMap` during normalization
        lwc: {
            modules: normalizeModulePaths(config.lwc.modules, rootDir),
            interchangeable: config.lwc.interchangeable,
            interchangeableModulesMap: config.lwc.interchangeableModulesMap,
        },
        // normalize all service paths
        hooks: normalizeServicePaths(config.hooks, rootDir),
        moduleProviders: normalizeServicePaths(config.moduleProviders, rootDir),
        assetProviders: normalizeServicePaths(config.assetProviders, rootDir),
        assetTransformers: normalizeServicePaths(config.assetTransformers, rootDir),
        resourceProviders: normalizeServicePaths(config.resourceProviders, rootDir),
        uriTransformers: normalizeServicePaths(config.uriTransformers, rootDir),
        viewProviders: normalizeServicePaths(config.viewProviders, rootDir),
        viewTransformers: normalizeServicePaths(config.viewTransformers, rootDir),
        // normalize all route paths
        routes: normalizeRoutePaths(config.routes, resourcePaths),
        errorRoutes: normalizeRoutePaths(config.errorRoutes, resourcePaths),
        routeHandlers: normalizeRouteHandlerPaths(config.routeHandlers, resourcePaths),
    };
}
/**
 * Apply Static Providers for MRT runtime (used exclusively by buildServer)
 *
 * @param {NormalizedLwrGlobalConfig} config - a normalized global config to check / mutate
 * @returns {NormalizedLwrGlobalConfig} an SSR-enabled normalized global config, if needed
 */
export function applyStaticProviderConfig(config) {
    return {
        ...config,
        assetProviders: [['@lwrjs/static/asset-provider', undefined]],
        assetTransformers: [],
        resourceProviders: [['@lwrjs/static/resource-provider', {}]],
        moduleProviders: [
            ['@lwrjs/static/module-provider', undefined],
            ['@lwrjs/module-registry/externals-module-provider', undefined],
        ],
        bundleProviders: [
            ['@lwrjs/static/bundle-provider', undefined],
            ['@lwrjs/module-bundler/amd-runtime-bundle-provider', undefined],
        ],
        uriTransformers: [['@lwrjs/static/mrt-static-uri-transformer', undefined]],
    };
}
/**
 * Load, merge, and normalize all of the config sources.
 *
 * @remarks
 * Config hooks are not loaded or applied during config resolution.
 *
 * @privateRemarks
 * The `skipDirNormalization` and `skipCacheDirCreation` options are useful for generating
 * a portable global config.  The directories can be normalized and the cache directory can
 * be created at runtime.
 *
 * @param {LwrGlobalConfig} configArg - programmatic global config
 * @param {ResolveConfigOptions} options - config resolution mutations
 * @returns {NormalizedLwrGlobalConfig} a normalized global config relative to the provided options
 */
export function resolveGlobalConfig(configArg, options) {
    const span = getTracer().startSpan({ name: ConfigSpan.ResolveConfig });
    const mergedConfig = mergeConfig(configArg);
    let normalizedConfig = normalizeConfig(mergedConfig);
    // TEMP: Add a feature flag to hold the app config value
    // This is a temporary flag attached to a Core gate. Using an env var avoids the
    // proliferation of function arguments to pass this flag around to dozens of places 
    if (normalizedConfig._isSsrCompilerEnabled)
        process.env.SSR_COMPILER_ENABLED = 'true';
    // Add static providers if applicable
    if (options?.useStaticProviders) {
        normalizedConfig = applyStaticProviderConfig(normalizedConfig);
    }
    // skip cache dir creation when the option is set
    if (!options?.skipCacheDirCreation) {
        createCacheFolder(normalizedConfig.cacheDir, normalizedConfig.rootDir);
    }
    // skip dir normalization when the option is set
    if (options?.skipDirNormalization) {
        span.end();
        return normalizedConfig;
    }
    const retVal = normalizeConfigPaths(normalizedConfig);
    span.end();
    return retVal;
}
/**
 * Resolve all application configurations by loading and merging global data, applying config hooks, and
 * importing configurable paths to javascript(ie. services and route handlers).
 *
 * @param {LwrGlobalConfig} config - programmatic global config
 * @returns {Configurations} all of the fully resolved configurations
 */
export function loadConfig(config, options) {
    const span = getTracer().startSpan({ name: ConfigSpan.LoadConfig });
    const appConfig = resolveGlobalConfig(config, options);
    const runtimeEnvironment = getRuntimeEnvironment(appConfig);
    const globalData = getGlobalData(appConfig.globalDataDir, appConfig.globalData);
    // ensure post config hook validation is ran even if config hooks don't exist
    if (!appConfig.hooks.length) {
        // route length validation happens in the `post` phase of validation
        validateLwrAppConfig(appConfig, 'post');
    }
    const retVal = {
        appConfig,
        runtimeEnvironment,
        globalData,
    };
    span.end();
    return retVal;
}
//# sourceMappingURL=global-config.js.map