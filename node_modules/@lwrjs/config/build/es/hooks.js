import { normalizeRoutes } from './utils/routes.js';
import { normalizeAssets, normalizeAssetPaths } from './utils/assets.js';
import { validateLwrAppConfig } from './validation/app-config.js';
import { getTracer, ConfigSpan } from '@lwrjs/instrumentation';
import { LWR_INFO_ROUTE } from './defaults.js';
import { logger } from '@lwrjs/diagnostics';
function isInfoRoute(route) {
    if (route.path === LWR_INFO_ROUTE.path && route.id === LWR_INFO_ROUTE.id) {
        if (Array.isArray(route.routeHandler)) {
            return route.routeHandler?.includes(`${LWR_INFO_ROUTE.routeHandler}`);
        }
        else if (typeof route.routeHandler === 'string') {
            return route.routeHandler === LWR_INFO_ROUTE.routeHandler;
        }
    }
    return false;
}
/*
 * Run `initConfigs` hooks
 *
 * @remarks
 * Route normalization and validation will be executed after all config hooks have been executed.
 *
 * @privateRemarks
 * Changes to configurations are made by reference.
 *
 * @param hooks - hooks plugins
 * @param globalConfig - global configuration
 * @param runtimeEnvironment - runtime environment resolved from programmatic config and config file
 * @param globalData - resolved global data
 */
export async function executeConfigHooks(hooks, globalConfig, runtimeEnvironment, globalData, skipValidate = false) {
    const span = getTracer().startSpan({ name: ConfigSpan.ExecuteConfigHooks });
    if (!hooks.length) {
        span.end();
        return;
    }
    for (const hook of hooks) {
        if (!hook.initConfigs) {
            continue;
        }
        // eslint-disable-next-line no-await-in-loop
        await hook.initConfigs(globalConfig, globalData, runtimeEnvironment);
    }
    // Check if /lwr-info was redefined
    let filteredRoutes = globalConfig.routes.filter(e => e.path !== "/lwr-info" || isInfoRoute(e));
    if (filteredRoutes.length < globalConfig.routes.length) {
        logger.warn({
            label: 'config hooks',
            message: 'config hook attempted to redefine protected /lwr-info path',
        });
    }
    // Check if /lwr-info was removed
    const hasInfoRoute = filteredRoutes.some(route => isInfoRoute(route));
    if (!hasInfoRoute) {
        filteredRoutes = [LWR_INFO_ROUTE, ...filteredRoutes];
        logger.warn({
            label: 'config hooks',
            message: 'config hook attempted to remove /lwr-info route',
        });
    }
    globalConfig.routes = normalizeRoutes(filteredRoutes, globalConfig.routeHandlers);
    globalConfig.errorRoutes = normalizeRoutes(globalConfig.errorRoutes, globalConfig.routeHandlers);
    if (!skipValidate) {
        validateLwrAppConfig(globalConfig, 'post');
    }
    span.end();
}
/**
 * Run `onStart` hooks
 *
 * @remarks
 * Route normalization and validation will be executed after all config hooks have been executed.
 *
 * @privateRemarks
 * Changes to configurations are made by reference.
 *
 * These hooks can modify the following global config properties:
 *     routes, errorRoutes, assets, i18n, basePath, coreProxy, _isSsrCompilerEnabled
 *
 * @param hooks - hooks plugins
 * @param globalConfig - global configuration
 */
export function executeStartHooks(hooks, globalConfig, runtimeEnvironment, skipValidate = false) {
    const span = getTracer().startSpan({ name: ConfigSpan.ExecuteStartHooks });
    if (!hooks.length) {
        span.end();
        return;
    }
    for (const hook of hooks) {
        if (!hook.onStart) {
            continue;
        }
        const onStartConfig = {
            _isSsrCompilerEnabled: globalConfig._isSsrCompilerEnabled,
            basePath: globalConfig.basePath,
            coreProxy: globalConfig.coreProxy,
            i18n: globalConfig.i18n,
            routes: globalConfig.routes,
            assets: globalConfig.assets,
            errorRoutes: globalConfig.errorRoutes,
        };
        hook.onStart(onStartConfig);
        // copy updated values back to the globalConfig
        runtimeEnvironment.basePath = globalConfig.basePath = onStartConfig.basePath || '';
        runtimeEnvironment.i18n = globalConfig.i18n = onStartConfig.i18n;
        globalConfig.assets = normalizeAssetPaths(normalizeAssets(onStartConfig.assets), globalConfig.rootDir);
        globalConfig._isSsrCompilerEnabled = onStartConfig._isSsrCompilerEnabled;
        globalConfig.coreProxy = onStartConfig.coreProxy;
        globalConfig.routes = (onStartConfig.routes || []);
        globalConfig.errorRoutes = (onStartConfig.errorRoutes || []);
    }
    // Check if /lwr-info was redefined
    let filteredRoutes = globalConfig.routes.filter(e => e.path !== "/lwr-info" || isInfoRoute(e));
    if (filteredRoutes.length < globalConfig.routes.length) {
        logger.warn({
            label: 'start hooks',
            message: 'onStart hook attempted to redefine protected /lwr-info path',
        });
    }
    // Check if /lwr-info was removed
    const hasInfoRoute = filteredRoutes.some(route => isInfoRoute(route));
    if (!hasInfoRoute) {
        filteredRoutes = [LWR_INFO_ROUTE, ...filteredRoutes];
        logger.warn({
            label: 'start hooks',
            message: 'onStart hook attempted to remove /lwr-info route',
        });
    }
    globalConfig.routes = normalizeRoutes(filteredRoutes, globalConfig.routeHandlers);
    globalConfig.errorRoutes = normalizeRoutes(globalConfig.errorRoutes, globalConfig.routeHandlers);
    // TEMP: Add a feature flag to hold the app config value
    // This is a temporary flag attached to a Core gate. Using an env var avoids the
    // proliferation of function arguments to pass this flag around to dozens of places 
    if (globalConfig._isSsrCompilerEnabled)
        process.env.SSR_COMPILER_ENABLED = 'true';
    if (!skipValidate) {
        validateLwrAppConfig(globalConfig, 'post');
    }
    span.end();
}
export function executeInstrumentationHooks(hooks) {
    const span = getTracer().startSpan({ name: ConfigSpan.ExecuteInstrHooks });
    const instrumentation = [];
    for (const hook of hooks) {
        if (!hook.initInstrumentation) {
            continue;
        }
        instrumentation.push(hook.initInstrumentation());
    }
    span.end();
    if (!instrumentation.length) {
        return undefined;
    }
    return {
        flush() {
            for (const instance of instrumentation) {
                instance.flush();
            }
        }
    };
}
export async function executeContextHooks(hooks, serverContext) {
    if (!hooks.length) {
        return;
    }
    for (const hook of hooks) {
        if (!hook.setupServerContext) {
            continue;
        }
        // eslint-disable-next-line no-await-in-loop
        await hook.setupServerContext(serverContext, hooks);
    }
}
//# sourceMappingURL=hooks.js.map