import fs from 'fs';
import path from 'path';
import { normalizeDirectory, normalizeResourcePath } from '@lwrjs/shared-utils';
import { DEFAULT_LWR_BOOTSTRAP_CONFIG } from '../defaults.js';
export function normalizeRoutes(routes, routeHandlers) {
    return routes.map((route) => {
        // normalize the bootstrap services
        const rawServices = route?.bootstrap?.services || [];
        const services = rawServices.map((s) => (typeof s === 'string' ? { name: s, ssr: false } : s));
        // default preloadData to true if ssr is true
        const preloadData = route.bootstrap?.preloadData === undefined
            ? route.bootstrap?.ssr === true
                ? true
                : false
            : route.bootstrap?.preloadData;
        const bootstrap = {
            ...DEFAULT_LWR_BOOTSTRAP_CONFIG,
            ...route.bootstrap,
            preloadData,
            services,
        };
        // when a route handler is set, ensure it is set in the route handler config
        if (route.routeHandler) {
            const handler = typeof route.routeHandler === 'string' ? route.routeHandler : route.routeHandler[0];
            if (!(handler in routeHandlers)) {
                routeHandlers[handler] = null;
            }
            return {
                ...route,
                routeHandler: typeof route.routeHandler === 'string'
                    ? [route.routeHandler, undefined]
                    : route.routeHandler,
                bootstrap,
            };
        }
        return {
            ...route,
            bootstrap,
        };
    });
}
export function normalizeRoutePaths(routes = [], resourcePaths) {
    return routes.map((route) => {
        // route handler paths are NOT normalized here to maintain the id lookup for route handler invocation
        const { contentTemplate, layoutTemplate, subRoutes } = route;
        if (contentTemplate) {
            route.contentTemplate =
                typeof contentTemplate === 'string'
                    ? path.resolve(normalizeResourcePath(contentTemplate, resourcePaths))
                    : contentTemplate;
        }
        if (layoutTemplate) {
            route.layoutTemplate = path.resolve(normalizeResourcePath(layoutTemplate, resourcePaths));
        }
        if (subRoutes) {
            route.subRoutes = path.resolve(normalizeResourcePath(subRoutes, resourcePaths));
        }
        return route;
    });
}
export function normalizeRouteHandlers(routeHandlers) {
    for (const [id, config] of Object.entries(routeHandlers)) {
        if (typeof config === 'string') {
            routeHandlers[id] = config;
        }
    }
    return routeHandlers;
}
export function normalizeRouteHandlerPaths(routeHandlers, resourcePaths) {
    for (const [id, handler] of Object.entries(routeHandlers)) {
        const normalizedPath = path.resolve(normalizeDirectory(handler || id, resourcePaths.rootDir));
        // use the normalized path if it exists; otherwise the handler is module specifier
        if (fs.existsSync(normalizedPath)) {
            routeHandlers[id] = normalizedPath;
        }
    }
    return routeHandlers;
}
//# sourceMappingURL=routes.js.map