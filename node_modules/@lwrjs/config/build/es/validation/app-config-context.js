import { findNodeAtLocation } from 'jsonc-parser';
import { descriptions } from '@lwrjs/diagnostics';
import { calculatePositionFromSource } from './helpers.js';
import { isSpecifier } from '@lwrjs/shared-utils';
// Run the duplicate and missing property checks against an object of a given type
function createKeys(p, t) {
    return p && t;
}
// These properties are kept in sync with the NormalizedLwrGlobalConfig type via ts checks
export const ROOT_ATTRIBUTE_KEYS = createKeys('root', [
    'amdLoader',
    'apiVersion',
    'assets',
    'assetProviders',
    'assetTransformers',
    'bundleConfig',
    'bundleProviders',
    'cacheDir',
    'caseSensitiveRoutes',
    'contentDir',
    'coreProxy',
    'environment',
    'errorRoutes',
    'esmLoader',
    'staticSiteGenerator',
    'globalData',
    'globalDataDir',
    'hooks',
    'i18n',
    'ignoreLwrConfigFile',
    '_isSsrCompilerEnabled',
    'lwrConfigFile',
    'layoutsDir',
    'locker',
    'lwc',
    'lwrVersion',
    'moduleProviders',
    'port',
    'basePath',
    'resourceProviders',
    'rootDir',
    'routeHandlers',
    'routes',
    'serverMode',
    'minify',
    'serverType',
    'uriTransformers',
    'viewProviders',
    'viewTransformers',
    'unsafeEnableViewLinkCaching',
]);
export const ASSET_DIR_ATTRIBUTE_KEYS = createKeys('assetDir', ['alias', 'dir', 'urlPath', 'root']);
export const ASSET_FILE_ATTRIBUTE_KEYS = createKeys('assetFile', ['alias', 'file', 'urlPath']);
export const LOCKER_ATTRIBUTE_KEYS = createKeys('locker', ['enabled', 'trustedComponents']);
export const I18N_ATTRIBUTE_KEYS = createKeys('i18n', ['defaultLocale', 'locales', 'uriPattern', 'defaultRedirectParams']);
export const CORE_PROXY_ATTRIBUTE_KEYS = createKeys('coreProxy', ['origin', 'host', 'servername']);
export const STATIC_SITE_GENERATOR_ATTRIBUTE_KEYS = createKeys('staticSiteGenerator', [
    'outputDir',
    'skipBaseDocumentGeneration',
    'skipCleanOutputDir',
    '_additionalModules',
    '_additionalRoutePaths',
]);
export const ROUTE_ATTRIBUTE_KEYS = createKeys('routes', [
    'bootstrap',
    'subRoutes',
    'contentTemplate',
    'id',
    'cache',
    'layoutTemplate',
    'method',
    'path',
    'rootComponent',
    'routeHandler',
    'properties',
]);
export const ERROR_ROUTE_ATTRIBUTE_KEYS = createKeys('errorRoutes', [
    'bootstrap',
    'subRoutes',
    'contentTemplate',
    'id',
    'layoutTemplate',
    'rootComponent',
    'routeHandler',
    'status',
    'properties',
    'cache',
]);
export const BOOTSTRAP_ATTRIBUTE_KEYS = createKeys('bootstrap', [
    'autoBoot',
    'syntheticShadow',
    'workers',
    'services',
    'configAsSrc',
    'ssr',
    'preloadData',
    'proxyForSSR',
    'includeCookiesForSSR',
    'mixedMode',
    'module',
    'preloadModules',
    'lwrVersion',
    'lwcVersion',
    'preloadResources'
]);
function isNotEmptyString(node) {
    return node.type === 'string' && node.value.length > 0;
}
export const BASE_PATH_REGEX = /^(\/[A-Za-z0-9](?:[A-Za-z0-9-]{0,61}[A-Za-z0-9])?)+$/g;
export class ValidationContext {
    constructor(sourceText) {
        this.diagnostics = [];
        this.sourceText = sourceText;
    }
    getLocationFromNode(node) {
        return calculatePositionFromSource(this.sourceText, node);
    }
    assertIsObject(node, property) {
        if (node?.type !== 'object' && node) {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(property, 'object', node.type),
                location: this.getLocationFromNode(node),
            });
        }
    }
    assertIsBoolean(node, property) {
        if (node && node.type !== 'boolean') {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(property, 'boolean', node.type),
                location: this.getLocationFromNode(node),
            });
        }
    }
    assertIsArray(node, property) {
        if (node && node.type !== 'array') {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(property, 'array', node.type),
                location: this.getLocationFromNode(node),
            });
        }
    }
    assertIsSpecifier(node, property) {
        if (node && (node.type !== 'string' || !isSpecifier(node.value))) {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INVALID_SPECIFIER(property, node.value),
                location: this.getLocationFromNode(node),
            });
        }
    }
    assertIsFilePattern(node, property) {
        if (node) {
            const children = node.children || [];
            for (const [index, child] of children.entries()) {
                let matcher = findNodeAtLocation(child, ['match'])?.children?.map(val => val.value) || findNodeAtLocation(child, ['match'])?.value;
                if (!Array.isArray(matcher)) {
                    matcher = [matcher];
                }
                let misMatch = null;
                for (let i = 0; i < matcher.length; i++) {
                    try {
                        if (matcher[i] === '')
                            throw new Error('Empty string is not a valid regex');
                        // match is a regex set as string, the below line would throw an error if the backslashes are not escaped
                        // eg: Regex /^.*\.css(?:\?.*)?$/ should be "^.*\\.css(?:\\?.*)?$"
                        new RegExp(matcher[i]);
                    }
                    catch (e) {
                        misMatch = matcher[i];
                        this.diagnostics.push({
                            description: descriptions.CONFIG_PARSER.INVALID_FILE_PATTERN(`${property}[${index}].match`, misMatch),
                            location: this.getLocationFromNode(node)
                        });
                    }
                    if (misMatch)
                        break;
                }
                if (misMatch !== null) {
                    break;
                }
            }
        }
    }
    assertIsPath(node, property) {
        if (node && (node.type !== 'string' || node.value[0] !== '/')) {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INVALID_PATH(property, node.value),
                location: this.getLocationFromNode(node),
            });
        }
    }
    assertIsOrigin(node, property) {
        if (node && (node.type !== 'string' || !/^https?:\/\//i.test(node.value))) {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INVALID_ORIGIN(property, node.value),
                location: this.getLocationFromNode(node),
            });
        }
    }
    assertIsPort(node, property) {
        if (node && (node.type !== 'number' || node.value < 0 || node.value > 65353)) {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INVALID_PORT(property, node.value),
                location: this.getLocationFromNode(node),
            });
        }
    }
    assertIsServerType(node, property) {
        if (node && node.value !== 'express' && node.value !== 'koa' && node.value !== 'fs') {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INVALID_SERVER_TYPE(property, node.value),
                location: this.getLocationFromNode(node),
            });
        }
    }
    assertIsStaticSiteGenerator(node, property) {
        if (node && node.type !== 'object') {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INVALID_GENERATOR_CONFIG(property, node.value),
                location: this.getLocationFromNode(node),
            });
        }
    }
    assertIsMethod(node, property) {
        if (node && node.value !== 'get' && node.value !== 'post') {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INVALID_METHOD(property, node.value),
                location: this.getLocationFromNode(node),
            });
        }
    }
    assertIsStatus(node, property) {
        if (node && node.value !== 404 && node.value !== 500) {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INVALID_STATUS(property, node.value),
                location: this.getLocationFromNode(node),
            });
        }
    }
    assertIsEnvironment(node, property) {
        if (!node) {
            return;
        }
        let defaultProperty;
        let supportedProperty;
        if (node.type === 'object' && node.children?.length) {
            for (const child of node.children) {
                if (child.type === 'property' && child.children?.length) {
                    if (child.children[0].value === 'default' && isNotEmptyString(child.children[1])) {
                        defaultProperty = child;
                    }
                    if (child.children[0].value === 'supported') {
                        supportedProperty = child;
                    }
                }
            }
        }
        if (node.type !== 'object' || (supportedProperty && !defaultProperty)) {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INVALID_ENVIRONMENT(property),
                location: this.getLocationFromNode(node),
            });
        }
    }
    assertIsBasePath(node, property, allowSlash = false) {
        if (!node) {
            return;
        }
        if (node.type !== 'string') {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(property, 'string', node.type),
                location: this.getLocationFromNode(node),
            });
        }
        else if (node.value === '' || allowSlash && node.value === '/') {
            return;
        }
        else if (node.value.match(BASE_PATH_REGEX) === null) {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INVALID_BASEPATH(property, node.value),
                location: this.getLocationFromNode(node),
            });
        }
    }
    assertNotEmptyString(node, property) {
        if (!node) {
            return;
        }
        if (node.type !== 'string') {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(property, 'string', node.type),
                location: this.getLocationFromNode(node),
            });
        }
        else if (!isNotEmptyString(node)) {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.NON_EMPTY_STRING(property, node.value),
                location: this.getLocationFromNode(node),
            });
        }
    }
    assertNotEmptyArray(node, property) {
        if (!node) {
            return;
        }
        if (node.type !== 'array') {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(property, 'array', node.type),
                location: this.getLocationFromNode(node),
            });
        }
        else if (!node.children || node.children.length === 0) {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.NON_EMPTY_ARRAY(property, '[]'),
                location: this.getLocationFromNode(node),
            });
        }
    }
    assertHasOneOrMore(node, property, childProps) {
        // At least one of the given child properties of node must exist
        if (!childProps.some((p) => findNodeAtLocation(node, [p]) !== undefined)) {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.MISSING_ONE_OF(property, childProps),
                location: this.getLocationFromNode(node),
            });
        }
    }
    assertHasOnlyOne(node, property, childProps) {
        // One and ONLY one of the given child properties of node must exist
        if (childProps.filter((p) => findNodeAtLocation(node, [p])).length !== 1) {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.TOO_MANY(property, childProps),
                location: this.getLocationFromNode(node),
            });
        }
    }
    assertArrayOfStrings(node, property) {
        if (!node) {
            return;
        }
        if (node.type !== 'array') {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(property, 'array', node.type),
                location: this.getLocationFromNode(node),
            });
        }
        else if (node.children && node.children.length > 0) {
            node.children.forEach((n, index) => {
                if (!isNotEmptyString(n)) {
                    this.diagnostics.push({
                        description: descriptions.CONFIG_PARSER.NON_EMPTY_STRING(`${property}[${index}]`, n.value),
                        location: this.getLocationFromNode(n),
                    });
                }
            });
        }
    }
    assertArrayOfSpecifiers(node, property) {
        if (!node) {
            return;
        }
        if (node.type !== 'array') {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(property, 'array', node.type),
                location: this.getLocationFromNode(node),
            });
        }
        else if (node.children && node.children.length > 0) {
            node.children.forEach((n, index) => {
                if (n.type !== 'string' || !isSpecifier(n.value)) {
                    this.diagnostics.push({
                        description: descriptions.CONFIG_PARSER.INVALID_SPECIFIER(`${property}[${index}]`, n.value),
                        location: this.getLocationFromNode(n),
                    });
                }
            });
        }
    }
    assertArrayOfServices(node, property) {
        if (!node) {
            return;
        }
        if (node.type !== 'array') {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(property, 'array', node.type),
                location: this.getLocationFromNode(node),
            });
        }
        else if (node.children && node.children.length > 0) {
            node.children.forEach((n, index) => this.assertIsService(n, property, index));
        }
    }
    assertArrayOfBootstrapServices(node, property) {
        if (!node) {
            return;
        }
        if (node.type !== 'array') {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(property, 'array', node.type),
                location: this.getLocationFromNode(node),
            });
        }
        else if (node.children && node.children.length > 0) {
            node.children.forEach((n, index) => {
                let specifier = undefined;
                if (n.type === 'string') {
                    specifier = n.value;
                }
                else if (n.type === 'object') {
                    const name = findNodeAtLocation(n, ['name']);
                    specifier = name?.value;
                }
                if (!isSpecifier(specifier)) {
                    this.diagnostics.push({
                        description: descriptions.CONFIG_PARSER.INVALID_SPECIFIER(`${property}[${index}]`, specifier),
                        location: this.getLocationFromNode(n),
                    });
                }
            });
        }
    }
    assertIsStringOrObject(node, property, index) {
        if (!node) {
            return;
        }
        if (node.type !== 'string' && node.type !== 'object') {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(index !== undefined ? `${property}[${index}]` : property, 'string or object', node.type),
                location: this.getLocationFromNode(node),
            });
        }
        else if (node.type === 'string' && !isNotEmptyString(node)) {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.NON_EMPTY_STRING(property, node.value),
                location: this.getLocationFromNode(node),
            });
        }
    }
    assertIsService(node, property, index) {
        if (!node) {
            return;
        }
        if (node.type !== 'string' && node.type !== 'array') {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INCORRECT_NODE_TYPE(index !== undefined ? `${property}[${index}]` : property, 'string or array', node.type),
                location: this.getLocationFromNode(node),
            });
        }
        if ((node.type === 'string' && node.value.length === 0) ||
            (node.type === 'array' &&
                node.children &&
                (node.children.length !== 2 || !isNotEmptyString(node.children[0])))) {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INVALID_SERVICE(index !== undefined ? `${property}[${index}]` : property, node.value === undefined && node.children
                    ? `invalid Array[${node.children.length}]`
                    : node.value),
                location: this.getLocationFromNode(node),
            });
        }
    }
    assertUniqueIds(nodes, property) {
        const ids = nodes
            .map((n) => {
            const idNode = findNodeAtLocation(n, ['id']);
            return idNode ? idNode.value : undefined;
        })
            .filter((id) => id !== undefined);
        const dupeIds = ids.filter((id, index) => ids.indexOf(id) !== index);
        if (dupeIds.length > 0) {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.DUPLICATE_IDS(property, dupeIds),
                location: this.getLocationFromNode(nodes[0]),
            });
        }
    }
    assertRequiredKeys(node, property, requiredPropertyKeys) {
        // All of the given properties must exist on the node
        const missingProps = requiredPropertyKeys.filter((p) => findNodeAtLocation(node, [p]) === undefined);
        if (missingProps.length > 0) {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.MISSING_REQUIRED(property, missingProps),
                location: this.getLocationFromNode(node),
            });
        }
    }
    assertValidKeys(node, property, validPropertyKeys) {
        const { children } = node;
        if (!children) {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.INVALID_EMPTY_NODE(property),
                location: this.getLocationFromNode(node),
            });
            return;
        }
        else {
            for (const propertyNode of children) {
                if (propertyNode.type === 'property' && propertyNode.children) {
                    const [keyNode] = propertyNode.children;
                    const { type, value } = keyNode;
                    if (type === 'string' && !validPropertyKeys.includes(value)) {
                        this.diagnostics.push({
                            description: descriptions.CONFIG_PARSER.INVALID_PROPERTY(property, value),
                            location: this.getLocationFromNode(keyNode),
                        });
                    }
                }
            }
        }
    }
    assertNoBundleConfigDupes(node, dupes) {
        if (dupes.length) {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.DUPLICATE_BUNDLE_CONFIG(dupes),
                location: this.getLocationFromNode(node),
            });
        }
    }
    assertDefaultInLocales(node, defaultLocale, localesIds) {
        if (!localesIds.includes(defaultLocale)) {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.DEFAULT_NOT_IN_LOCALES(defaultLocale, localesIds),
                location: this.getLocationFromNode(node),
            });
        }
    }
    assertFallbackIds(nodes) {
        const localesIds = nodes
            .map((n) => {
            const idNode = findNodeAtLocation(n, ['id']);
            return idNode ? idNode.value : undefined;
        })
            .filter((id) => id !== undefined);
        for (const n of nodes) {
            const fallbackNode = findNodeAtLocation(n, ['fallback']);
            if (fallbackNode?.value) {
                if (!localesIds.includes(fallbackNode.value)) {
                    this.diagnostics.push({
                        description: descriptions.CONFIG_PARSER.FALLBACK_NOT_IN_LOCALES(fallbackNode.value, localesIds),
                        location: this.getLocationFromNode(fallbackNode),
                    });
                }
            }
        }
    }
    assertSsrPreloadData(node, propPrefix) {
        const ssr = findNodeAtLocation(node, ['ssr'])?.value;
        const preloadData = findNodeAtLocation(node, ['preloadData'])?.value;
        if (ssr === true && preloadData === false) {
            this.diagnostics.push({
                description: descriptions.CONFIG_PARSER.SSR_WITHOUT_PRELOAD(propPrefix),
                location: this.getLocationFromNode(node),
            });
        }
    }
    assertIsCoreProxy(node, validationContext) {
        if (node && node.type !== 'null') {
            validationContext.assertIsObject(node, 'coreProxy');
            validationContext.assertValidKeys(node, 'coreProxy', CORE_PROXY_ATTRIBUTE_KEYS);
            validationContext.assertRequiredKeys(node, 'coreProxy', ['origin']);
            validationContext.assertNotEmptyString(findNodeAtLocation(node, ['origin']), 'coreProxy.origin');
            const host = findNodeAtLocation(node, ['host']);
            host && validationContext.assertNotEmptyString(host, 'coreProxy.host');
            const servername = findNodeAtLocation(node, ['servername']);
            servername && validationContext.assertNotEmptyString(servername, 'coreProxy.servername');
        }
    }
}
//# sourceMappingURL=app-config-context.js.map