import path from 'path';
import { logger } from '@lwrjs/diagnostics';
import { normalizeDirectory, resolveFileExtension, crossEnvFileURL } from '@lwrjs/shared-utils';
async function importModule(filepath, rootDir, cacheDir) {
    // ensure paths are fully resolved before loading source
    let resolvedFilePath = normalizeDirectory(filepath, rootDir);
    const resolvedCacheDir = normalizeDirectory(cacheDir, rootDir);
    try {
        if (resolvedFilePath.endsWith('.ts')) {
            const fullPath = resolveFileExtension(resolvedFilePath);
            const { transpileTs } = await import('@lwrjs/esbuild');
            resolvedFilePath = await transpileTs(fullPath, { rootDir, cacheDir: resolvedCacheDir });
        }
        const moduleEntry = await import(crossEnvFileURL(resolvedFilePath));
        const output = moduleEntry.default || moduleEntry;
        return output;
    }
    catch (err) {
        logger.error(err);
        throw new Error(`Unable to load configurable module: ${filepath}`);
    }
}
async function loadServiceEntries(entries, rootDir, cacheDir) {
    return Promise.all(entries.map(async ([entry, config]) => {
        const cacheDirServices = path.join(cacheDir, 'services');
        const ctor = await importModule(entry, rootDir, cacheDirServices);
        return [ctor, config];
    }));
}
/**
 * Import and instantiate hooks defined in the global config
 *
 * @remarks
 * The optional dependency `esbuild` MUST be installed to load hook modules.
 *
 * @param config - global config
 * @returns {HooksPlugin[]} all instantiated hooks
 */
export async function loadHooks(config) {
    if (!config.hooks) {
        return [];
    }
    const hookCtors = await loadServiceEntries(config.hooks, config.rootDir, config.cacheDir);
    const hooks = hookCtors.map(([hookCtor, hookConfig = {}]) => {
        return new hookCtor(hookConfig);
    });
    return hooks;
}
/**
 * Load service modules from the filepaths configured in the global config
 *
 * @remarks
 * The optional dependency `esbuild` MUST be installed to load service modules.
 *
 * @param config - global config
 * @returns {Services} all of the imported service constructors
 */
export async function loadServices(config) {
    const moduleProviders = await loadServiceEntries(config.moduleProviders, config.rootDir, config.cacheDir);
    const bundleProviders = await loadServiceEntries(config.bundleProviders, config.rootDir, config.cacheDir);
    const assetProviders = await loadServiceEntries(config.assetProviders, config.rootDir, config.cacheDir);
    const assetTransformers = await loadServiceEntries(config.assetTransformers, config.rootDir, config.cacheDir);
    const resourceProviders = await loadServiceEntries(config.resourceProviders, config.rootDir, config.cacheDir);
    const uriTransformers = await loadServiceEntries(config.uriTransformers, config.rootDir, config.cacheDir);
    const viewProviders = await loadServiceEntries(config.viewProviders, config.rootDir, config.cacheDir);
    const viewTransformers = await loadServiceEntries(config.viewTransformers, config.rootDir, config.cacheDir);
    return {
        moduleProviders,
        bundleProviders,
        assetProviders,
        assetTransformers,
        resourceProviders,
        uriTransformers,
        viewProviders,
        viewTransformers,
    };
}
/**
 * Load all route handlers from the filepaths configured in the global config
 *
 * @remarks
 * The optional dependency `esbuild` MUST be installed to load route handler modules.
 *
 * @param config - global config
 * @returns {Routes} resolved route handlers mapped by id
 */
export async function loadRouteHandlers(config) {
    const routeHandlers = {};
    await Promise.all(Object.keys(config.routeHandlers).map(async (id) => {
        const handlerPath = config.routeHandlers[id] || id;
        const handler = await importModule(handlerPath, config.rootDir, path.join(config.cacheDir, 'routeHandlers'));
        routeHandlers[id] = handler;
    }));
    return routeHandlers;
}
//# sourceMappingURL=modules.js.map