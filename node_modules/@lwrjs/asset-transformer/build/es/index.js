import { logger } from '@lwrjs/diagnostics';
import { createStringBuilder, mimeLookup } from '@lwrjs/shared-utils';
import { linkCss } from './metadata-collectors/css.js';
import { join, relative } from 'path';
const CSS_MIME = mimeLookup('.css');
const name = 'lwr-default-asset-transformer';
export default function defaultAssetTransformer(_options, lwrGlobalContext) {
    const { assetRegistry } = lwrGlobalContext;
    return {
        name,
        /**
         * Asset url normalization
         */
        async transformUri(assetUri, assetDef, runtimeEnvironment) {
            const { entry, uri: existingUri } = assetUri;
            const { type, ownHash } = assetDef;
            const { apiVersion, immutableAssets, basePath } = runtimeEnvironment;
            const immutable = immutableAssets ? 'immutable/' : '';
            const hash = immutableAssets ? ownHash : 'latest';
            const relativePath = basePath ? relative(basePath, existingUri) : existingUri;
            const uri = join(`${basePath}/${apiVersion}/${type}/${immutable}s/${hash}`, encodeURI(relativePath));
            logger.debug({ label: `${this.name}`, message: `normalized url ${entry} -> ${uri}` });
            return {
                ...assetUri,
                uri,
                entry,
                external: assetDef.type === 'external',
                immutable: !!immutableAssets,
            };
        },
        /**
         * Transforms CSS.  Inserts relative links
         */
        async transformSource(assetSource, runtimeEnvironment) {
            if (assetSource.mime === CSS_MIME) {
                logger.debug({ label: `${this.name}`, message: `extract metadata ${assetSource.entry}` });
                const code = assetSource.content('utf-8');
                const metadata = await linkCss(code.toString(), assetSource.entry);
                const linkedAsset = await linkAsset(code, {
                    ...assetSource,
                    metadata,
                }, runtimeEnvironment, assetRegistry.resolveAssetUri);
                return {
                    source: linkedAsset,
                    metadata,
                };
            }
            // Source not modified move on
            return undefined;
        },
    };
}
async function linkAsset(source, assetSource, runtimeEnvironment, resolveUri) {
    const assetReferences = assetSource.metadata?.assetReferences;
    if (Buffer.isBuffer(source) || !assetReferences || assetReferences.length === 0) {
        return source;
    }
    const codeStringBuilder = createStringBuilder(source);
    const importer = assetSource.entry;
    for (const assetRef of assetReferences) {
        const { url, relative, location: { startOffset, endOffset } = {} } = assetRef;
        // Only override relative assets
        if (relative && typeof startOffset === 'number' && typeof endOffset === 'number') {
            try {
                // eslint-disable-next-line no-await-in-loop
                assetRef.override = await resolveUri({ specifier: url, importer }, runtimeEnvironment);
                const overrideUrl = assetRef.override?.uri;
                codeStringBuilder.overwrite(startOffset, endOffset, overrideUrl || url);
            }
            catch (err) {
                // Just logging a waring if the user cannot resolve a linked asset reference to not disrupt other linking
                logger.warn({
                    label: `${name}`,
                    message: `Failed to resolve reference '${url}' in asset '${importer}`,
                });
            }
        }
    }
    return codeStringBuilder.toString();
}
//# sourceMappingURL=index.js.map