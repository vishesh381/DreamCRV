var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/lwc-module-provider/src/index.ts
__markAsModule(exports);
__export(exports, {
  default: () => src_default
});
var import_path = __toModule(require("path"));
var import_shared_utils = __toModule(require("@lwrjs/shared-utils"));
var import_diagnostics = __toModule(require("@lwrjs/diagnostics"));
var import_utils = __toModule(require("./utils.cjs"));
var import_cache = __toModule(require("./cache.cjs"));
var import_compiler = __toModule(require("./compiler.cjs"));
function getModuleEntryCacheKey(specifier, version, targetSSR) {
  return `${specifier}@${version}|${targetSSR ? "server" : "client"}`;
}
var LwcModuleProvider = class {
  constructor(options = {}, {
    appEmitter,
    config: {modules, rootDir, cacheDir, environment},
    runtimeEnvironment: {watchFiles},
    watcherFactory
  }) {
    this.name = "lwc-module-provider";
    this.moduleSourceCache = new Map();
    this.packageVersionCache = new Map();
    this.watchedModuleContextMap = new Map();
    this.moduleEntryVersionCache = new Map();
    this.importerMappingCache = new Map();
    this.inflightGetModuleJobs = new import_shared_utils.InflightTasks();
    this.inflightGetModuleEntryJobs = new import_shared_utils.InflightTasks();
    const {disableCaching} = options;
    this.emitter = appEmitter;
    this.modules = modules;
    this.rootDir = rootDir;
    this.watcher = watchFiles && watcherFactory ? (0, import_utils.setUpWatcher)(watcherFactory, this.onModuleChange.bind(this)) : void 0;
    this.moduleFsCacheEnabled = disableCaching !== void 0 ? !disableCaching : true;
    this.interchangeableModulesEnabled = !!environment?.default;
    this.lwcCompiler = new import_compiler.LwcCompiler(options.lwcCompiler);
    if (this.moduleFsCacheEnabled) {
      const {lwcCacheDir, lwcCacheIndex} = (0, import_cache.setupModuleCache)(cacheDir);
      this.lwcCacheDir = lwcCacheDir;
      this.lwcCacheIndex = lwcCacheIndex;
    }
  }
  async onModuleChange(fileChanged) {
    const moduleEntry = this.watchedModuleContextMap.get(fileChanged);
    if (!moduleEntry) {
      throw new Error("We are observing a file we have not yet processed, this should not happen...");
    }
    this.moduleSourceCache.delete(fileChanged);
    const hasClient = this.moduleEntryVersionCache.get(moduleEntry.id.replace("|server", "|client"));
    const hasServer = this.moduleEntryVersionCache.get(moduleEntry.id.replace("|client", "|server"));
    const recompiledClientModule = hasClient && await this.getModule(moduleEntry);
    const recompiledServerModule = hasServer && await this.getModule(moduleEntry, {ssr: true});
    if (recompiledClientModule) {
      this.emitter.notifyModuleSourceChanged(recompiledClientModule);
    }
    if (recompiledServerModule) {
      this.emitter.notifyModuleSourceChanged(recompiledServerModule);
    }
    if (!recompiledClientModule && !recompiledServerModule) {
      const recompiledModule = await this.getModule(moduleEntry);
      recompiledModule && this.emitter.notifyModuleSourceChanged(recompiledModule);
    }
  }
  async getModule(moduleId, runtimeParams = {}) {
    const id = (0, import_shared_utils.getSpecifier)(moduleId);
    import_diagnostics.logger.debug({label: this.name, message: `getModule ${id}`});
    return this.inflightGetModuleJobs.execute(id, () => {
      return this.createGetModuleJob(moduleId, runtimeParams);
    });
  }
  async createGetModuleJob(moduleId, runtimeParams) {
    const {watcher, watchedModuleContextMap, lwcCacheDir, lwcCacheIndex, moduleFsCacheEnabled} = this;
    import_diagnostics.logger.debug({
      label: this.name,
      message: "fetch module",
      additionalInfo: {moduleId, moduleFsCacheEnabled}
    });
    const moduleEntry = await this.getModuleEntry(moduleId, runtimeParams);
    if (!moduleEntry) {
      return;
    }
    const moduleSource = await this.getModuleSource(moduleId, moduleEntry);
    const {namespace, name: rawName, originalSource} = moduleSource;
    const targetSSR = !!runtimeParams.ssr;
    const cacheConfig = {lwcCacheDir, lwcCacheIndex};
    let compiledModule = moduleFsCacheEnabled && (0, import_cache.getCompiledModuleCacheEntry)(moduleSource, targetSSR, cacheConfig);
    import_diagnostics.logger.debug({
      label: this.name,
      message: "module source",
      additionalInfo: {moduleId, isPreCompiled: compiledModule != void 0}
    });
    if (!compiledModule) {
      const [name] = rawName.split("#");
      const scopedStyles = moduleEntry.entry.endsWith(".css") && moduleEntry.specifier.endsWith("?scoped=true");
      import_diagnostics.logger.debug({
        label: this.name,
        message: "compile",
        additionalInfo: {
          namespace,
          name,
          filename: moduleEntry.entry,
          scopedStyles,
          targetSSR
        }
      });
      compiledModule = await this.lwcCompiler.compileFile(originalSource, {
        namespace,
        name,
        filename: moduleEntry.entry,
        scopedStyles
      }, targetSSR);
      import_diagnostics.logger.verbose({
        label: this.name,
        message: "createGetModuleJob:compile compiledModule",
        additionalInfo: {
          namespace,
          name,
          filename: moduleEntry.entry,
          scopedStyles,
          targetSSR
        }
      });
      if (moduleFsCacheEnabled) {
        await (0, import_cache.addCompiledModuleCacheEntry)(moduleSource, compiledModule, targetSSR, cacheConfig);
      }
    }
    if (watcher && !watchedModuleContextMap.has(moduleEntry.entry)) {
      watcher.add(moduleEntry.entry);
      watchedModuleContextMap.set(moduleEntry.entry, moduleEntry);
    }
    return {
      ...moduleSource,
      compiledSource: compiledModule.code,
      compiledMetadata: compiledModule.metadata
    };
  }
  async getModuleSource({name, namespace, specifier}, moduleEntry) {
    const {entry, version, id} = moduleEntry;
    name = name || (0, import_shared_utils.explodeSpecifier)(specifier).name;
    let originalSource, ownHash;
    if (this.moduleSourceCache.has(entry)) {
      const cached = this.moduleSourceCache.get(entry);
      originalSource = cached?.originalSource;
      ownHash = cached?.ownHash;
    } else {
      const implicitLwc = (0, import_utils.isImplicitLwcImport)(entry, specifier);
      originalSource = implicitLwc ? import_utils.DEFAULT_IMPLICIT_DEP : (0, import_shared_utils.readFile)(entry);
      ownHash = (0, import_shared_utils.hashContent)(originalSource);
      this.moduleSourceCache.set(entry, {originalSource, ownHash});
    }
    return {
      id,
      namespace,
      name,
      version,
      specifier,
      moduleEntry,
      ownHash,
      originalSource
    };
  }
  async getModuleEntry({specifier, importer, version}, runtimeParams = {}) {
    const targetSSR = !!runtimeParams.ssr;
    const jobKey = `${specifier}@${version}@${importer}|${targetSSR ? "server" : "client"}`;
    import_diagnostics.logger.debug({
      label: `${this.name}`,
      message: `getModuleEntry ${jobKey}`
    });
    const moduleEntry = this.getCachedModuleEntry(specifier, version, importer, targetSSR);
    if (moduleEntry) {
      return moduleEntry;
    }
    return this.inflightGetModuleEntryJobs.execute(jobKey, async () => {
      return this.createModuleEntry({specifier, importer, version}, runtimeParams);
    });
  }
  async createModuleEntry({specifier, importer, version}, runtimeParams) {
    const targetSSR = !!runtimeParams.ssr;
    import_diagnostics.logger.debug({
      label: `${this.name}`,
      message: "createModuleEntry",
      additionalInfo: {
        specifier,
        importer,
        rootDir: this.rootDir,
        version,
        targetSSR
      }
    });
    const [baseSpecifier, fileRelativePathRaw] = specifier.split("#");
    const fileRelativePath = fileRelativePathRaw?.split("?")[0];
    let moduleEntry;
    if (fileRelativePath) {
      moduleEntry = this.getCachedModuleEntry(specifier, version, importer, targetSSR);
    }
    if (!moduleEntry) {
      try {
        import_diagnostics.logger.debug({
          label: `${this.name}`,
          message: "createModuleEntry:resolveModuleSpecifier",
          additionalInfo: {
            baseSpecifier,
            importer,
            rootDir: this.rootDir
          }
        });
        const registryEntry = (0, import_utils.resolveModuleSpecifier)(baseSpecifier, importer || this.rootDir, this.modules, this.packageVersionCache);
        import_diagnostics.logger.debug({
          label: `${this.name}`,
          message: "createModuleEntry:registryEntry",
          additionalInfo: {registryEntry}
        });
        moduleEntry = {
          id: getModuleEntryCacheKey(registryEntry.specifier, registryEntry.version, targetSSR),
          ...registryEntry
        };
        if (this.interchangeableModulesEnabled && moduleEntry.scope) {
          const metadata = (0, import_shared_utils.resolveCustomLWCMetadata)(moduleEntry.scope);
          if (metadata.interchangeable?.includes(moduleEntry.specifier)) {
            moduleEntry.interchangeable = true;
          }
        }
      } catch (e) {
        if (e.code !== "NO_LWC_MODULE_FOUND") {
          throw e;
        } else {
          import_diagnostics.logger.verbose({
            label: `${this.name}`,
            message: `LWC provider could not find the module ${specifier}`
          });
        }
      }
    }
    if (!moduleEntry) {
      return;
    }
    if (fileRelativePath) {
      const moduleEntryRoot = (0, import_path.dirname)(moduleEntry.entry);
      const filePath = (0, import_path.join)(moduleEntryRoot, fileRelativePath);
      moduleEntry = {
        ...moduleEntry,
        entry: (0, import_shared_utils.resolveFileExtension)(filePath),
        specifier
      };
    }
    const cacheKey = getModuleEntryCacheKey(specifier, moduleEntry.version, targetSSR);
    const finalModuleEntry = {...moduleEntry, id: cacheKey};
    this.moduleEntryVersionCache.set(cacheKey, finalModuleEntry);
    if (!version) {
      const importerCacheKey = getModuleEntryCacheKey(specifier, importer || this.rootDir, targetSSR);
      this.importerMappingCache.set(importerCacheKey, cacheKey);
    }
    return finalModuleEntry;
  }
  getCachedModuleEntry(specifier, version, importer, targetSSR) {
    let moduleEntry;
    if (version) {
      const cacheKey = getModuleEntryCacheKey(specifier, version, targetSSR);
      moduleEntry = this.moduleEntryVersionCache.get(cacheKey);
    }
    if (!moduleEntry) {
      const importerKey = getModuleEntryCacheKey(specifier, importer || this.rootDir, targetSSR);
      const cacheKey = this.importerMappingCache.get(importerKey);
      if (cacheKey) {
        moduleEntry = this.moduleEntryVersionCache.get(cacheKey);
      }
    }
    return moduleEntry;
  }
};
var src_default = LwcModuleProvider;
