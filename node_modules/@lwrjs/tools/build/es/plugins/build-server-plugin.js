import path from 'path';
import { executeConfigHooks, loadConfig } from '@lwrjs/config';
import { loadHooks } from '@lwrjs/config/modules';
import { logger } from '@lwrjs/diagnostics';
import { normalizeDirectory } from '@lwrjs/shared-utils';
function getServices(t) {
    return t;
}
const services = getServices([
    'moduleProviders',
    'bundleProviders',
    'viewProviders',
    'viewTransformers',
    'resourceProviders',
    'assetProviders',
    'assetTransformers',
    'uriTransformers',
]);
function processServices(kind, entries, rootDir) {
    const output = {
        imports: [],
        entries: [],
    };
    for (const [index, [entry, config]] of entries.entries()) {
        const name = kind + index;
        output.imports.push(`import ${name} from '${normalizeDirectory(entry, rootDir)}';`);
        output.entries.push([name, config]);
    }
    return output;
}
function processHooks(hooksConfig, hooks, rootDir) {
    const output = {
        imports: [],
        entries: [],
    };
    for (const [index, [entry, config]] of hooksConfig.entries()) {
        if (!hooks[index].onStart && !hooks[index].initInstrumentation) {
            continue;
        }
        if (hooks[index].initConfigs) {
            logger.warn({
                label: `lwr-server-build`,
                message: `Consider splitting 'initConfigs' hooks to a separate file.`,
            });
        }
        const name = 'hook' + index;
        output.imports.push(`import ${name} from '${normalizeDirectory(entry, rootDir)}';`);
        output.entries.push([name, config]);
    }
    return output;
}
function processRouteHandlers(routeHandlers, rootDir) {
    const output = {
        imports: [],
        routeHandlers: {},
    };
    for (const [id, handler] of Object.entries(routeHandlers)) {
        if (!output.routeHandlers[id]) {
            const name = `routeHandler${output.imports.length}`;
            output.imports.push(`import ${name} from '${normalizeDirectory(handler || id, rootDir)}';`);
            output.routeHandlers[id] = name;
        }
    }
    return output;
}
function printServices(config) {
    return `{${Object.entries(config)
        .map(([key, value]) => {
        const entries = value;
        return `${key}: [${entries.map(([ctor, config = {}]) => `[${ctor}, ${JSON.stringify(config)}]`)}]`;
    })
        .join(',')}}`;
}
function printHooks(hooks) {
    return `[${hooks
        .map(([ctor, config = {}]) => {
        return `new ${ctor}(${JSON.stringify(config)})`;
    })
        .join(',')}]`;
}
function printRouteHandlers(routeHandlers) {
    return `{${Object.entries(routeHandlers)
        .map(([id, handler]) => {
        return `'${id}': ${handler}`;
    })
        .join(',')}}`;
}
/**
 * Creates an esbuild plugin that generates a server build module
 *
 * @remarks
 * The generated server build module contains:
 * - normalized lwr global config(without normalized directories and after config hooks are applied)
 * - runtime environment(after config hooks are applied)
 * - global data(after config hooks are applied)
 * - lwr services(ie. module providers) with static imports
 * - route handlers with static imports
 *
 * @param config - programmatic global config
 * @returns esbuild plugin
 */
export default function buildLwrServer(config, buildDir) {
    return {
        name: 'lwr-server-build',
        setup(build) {
            // This file is generated during the build, so it is mapped to a custom namespace
            // to prevent looking for it on the file system.
            build.onResolve({ filter: /.*\/lwr.build.js$/ }, (args) => ({
                path: args.path,
                namespace: 'lwr-server-build',
            }));
            build.onLoad({ filter: /.*/, namespace: 'lwr-server-build' }, async (args) => {
                const { appConfig, runtimeEnvironment, globalData } = loadConfig(config, {
                    skipDirNormalization: true,
                    useStaticProviders: true,
                });
                // apply config hooks at build time
                const hooks = await loadHooks(appConfig);
                if (hooks.length) {
                    // note: execute config hooks here, but defer validation until after onStart config hook
                    const skipValidation = true;
                    await executeConfigHooks(hooks, appConfig, runtimeEnvironment, globalData, skipValidation);
                }
                const remoteAppConfig = {
                    ...appConfig,
                    ignoreLwrConfigFile: true,
                    rootDir: undefined,
                    port: undefined,
                };
                const serviceImports = [];
                const serviceConfig = {};
                for (const service of services) {
                    const entries = processServices(service, appConfig[service], appConfig.rootDir);
                    serviceImports.push(...entries.imports);
                    serviceConfig[service] = entries.entries;
                }
                const hooksConfig = processHooks(appConfig.hooks, hooks, appConfig.rootDir);
                const routeHandlersConfig = processRouteHandlers(appConfig.routeHandlers, appConfig.rootDir);
                return {
                    contents: [
                        ...serviceImports,
                        ...hooksConfig.imports,
                        ...routeHandlersConfig.imports,
                        `export const buildDir = '${buildDir || 'app'}';`,
                        `export const appConfig = ${JSON.stringify(remoteAppConfig)};`,
                        `export const runtimeEnvironment = ${JSON.stringify(runtimeEnvironment)};`,
                        `export const globalData = ${JSON.stringify(globalData)};`,
                        `export const services = ${printServices(serviceConfig)};`,
                        `export const hooks = ${printHooks(hooksConfig.entries)};`,
                        `export const routeHandlers = ${printRouteHandlers(routeHandlersConfig.routeHandlers)};`,
                    ].join('\n'),
                    loader: 'ts',
                    resolveDir: path.dirname(args.path),
                };
            });
        },
    };
}
//# sourceMappingURL=build-server-plugin.js.map