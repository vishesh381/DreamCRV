var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/asset-registry/src/index.ts
__markAsModule(exports);
__export(exports, {
  LwrAssetRegistry: () => LwrAssetRegistry
});
var import_crypto = __toModule(require("crypto"));
var import_path = __toModule(require("path"));
var import_fs_extra = __toModule(require("fs-extra"));
var import_diagnostics = __toModule(require("@lwrjs/diagnostics"));
var import_shared_utils = __toModule(require("@lwrjs/shared-utils"));
var LwrAssetRegistry = class {
  constructor(context, lwrGlobalConfig) {
    this.name = "lwr-asset-registry";
    this.providers = [];
    this.transformers = [];
    const {assets, rootDir, layoutsDir, contentDir, cacheDir} = lwrGlobalConfig;
    this.resourcePaths = {assets, rootDir, layoutsDir, contentDir};
    this.cacheDir = (0, import_path.join)(cacheDir, import_shared_utils.ASSETS_CACHE_DIR);
    this._memoizeResolveUri = this.resolveAssetUriWithoutLinking.bind(this);
  }
  async delegateGetAsset(assetIdentifier) {
    for (const provider of this.providers) {
      const result = await provider.getAsset(assetIdentifier);
      if (result) {
        return result;
      }
    }
    throw (0, import_diagnostics.createSingleDiagnosticError)({
      description: import_diagnostics.descriptions.UNRESOLVABLE.ASSET(assetIdentifier.specifier)
    }, import_diagnostics.LwrUnresolvableError);
  }
  addAssetProviders(providers) {
    this.providers.push(...providers);
  }
  addAssetTransformers(transformers) {
    this.transformers.push(...transformers);
  }
  async getAsset(assetId, runtimeEnvironment, includeMetadata) {
    const rawAsset = await this.delegateGetAsset(assetId);
    if (rawAsset.noTransform) {
      const assetDef = await this.getAssetDefinition(rawAsset, runtimeEnvironment);
      import_diagnostics.logger.debug({
        label: `LwrAssetRegistry`,
        message: `[getAsset] no-transform source ${assetId.specifier} -> ${assetDef.uri}`
      });
      return assetDef;
    }
    const overrideFilePath = this.getHashedAssetPath(rawAsset, runtimeEnvironment);
    if (import_fs_extra.default.existsSync(overrideFilePath)) {
      if (includeMetadata && import_fs_extra.default.existsSync(`${overrideFilePath}.meta.json`)) {
        rawAsset.metadata = JSON.parse(import_fs_extra.default.readFileSync(`${overrideFilePath}.meta.json`).toString());
      }
      return this.getAssetDefinition(rawAsset, runtimeEnvironment);
    }
    let transformResult;
    for (const transformPlugin of this.transformers) {
      const curResult = await transformPlugin.transformSource?.(rawAsset, runtimeEnvironment);
      if (curResult) {
        transformResult = {
          ...transformResult,
          ...curResult
        };
        rawAsset.content = () => curResult.source;
        if (curResult.metadata) {
          rawAsset.metadata = curResult.metadata;
        }
      }
    }
    if (transformResult) {
      import_fs_extra.default.writeFileSync(overrideFilePath, transformResult.source, "utf-8");
      if (transformResult.metadata) {
        import_fs_extra.default.writeFileSync(`${overrideFilePath}.meta.json`, JSON.stringify(transformResult.metadata), "utf-8");
      }
      import_diagnostics.logger.debug({
        label: `LwrAssetRegistry`,
        message: `[getAsset] cached transformed asset ${assetId.specifier}`
      });
    } else {
      rawAsset.noTransform = true;
    }
    const newDef = await this.getAssetDefinition(rawAsset, runtimeEnvironment);
    import_diagnostics.logger.debug({
      label: `LwrAssetRegistry`,
      message: `[getAsset] fully processed ${assetId.specifier} -> ${newDef.uri}`
    });
    if (includeMetadata) {
      return {...newDef, metadata: rawAsset.metadata};
    } else {
      return newDef;
    }
  }
  getHashedAssetPath({ownHash, entry, type}, runtimeEnvironment) {
    const runtimeHash = [
      runtimeEnvironment.basePath,
      runtimeEnvironment.lwrVersion,
      type || "d",
      runtimeEnvironment.compat ? "c" : "",
      runtimeEnvironment.immutableAssets ? "i" : "",
      runtimeEnvironment.minify ? "m" : ""
    ].join("");
    const fullPathHash = import_crypto.default.createHash("sha1").update(`${entry}:${ownHash}`).digest("hex").toString();
    const hashedPath = (0, import_path.join)(this.cacheDir, `${runtimeHash}_${fullPathHash}_${(0, import_path.basename)(entry)}`);
    import_diagnostics.logger.debug({
      label: `LwrAssetRegistry`,
      message: `[getHashedAssetPath] ${runtimeHash} -> ${hashedPath}`
    });
    return hashedPath;
  }
  async getAssetDefinition(assetSource, runtimeEnvironment) {
    const {type, uri} = this.validateSpecifier(assetSource.entry);
    const overrideFilePath = assetSource.noTransform ? assetSource.entry : this.getHashedAssetPath(assetSource, runtimeEnvironment);
    return {
      ...assetSource,
      artifactType: "asset",
      type: assetSource.uri ? "external" : type,
      uri: assetSource.uri || uri,
      stream: (encoding) => import_fs_extra.default.createReadStream(overrideFilePath, {encoding}),
      content: (encoding) => import_fs_extra.default.readFileSync(overrideFilePath, encoding)
    };
  }
  async resolveAssetUri(assetId, runtimeEnvironment) {
    const {specifier} = assetId;
    if ((0, import_shared_utils.isExternalUrl)(specifier)) {
      import_diagnostics.logger.debug({
        label: `LwrAssetRegistry`,
        message: `[resolveAssetUri] external url ${specifier}`
      });
      return {
        artifactType: "asset",
        uri: specifier,
        entry: specifier,
        immutable: true,
        external: true
      };
    }
    const assetDef = await this.getAsset(assetId, runtimeEnvironment);
    const ret = await this.getUriFromAsset(assetDef, runtimeEnvironment);
    import_diagnostics.logger.debug({
      label: `LwrAssetRegistry`,
      message: `[resolveAssetUri] getUriFromAsset ${specifier} -> ${ret.uri}`
    });
    return ret;
  }
  async resolveAssetUriWithoutLinking(assetId, runtimeEnvironment) {
    const {specifier} = assetId;
    if ((0, import_shared_utils.isExternalUrl)(specifier)) {
      import_diagnostics.logger.debug({
        label: `LwrAssetRegistry`,
        message: `[resolveAssetUriWithoutLinking] external url ${specifier}`
      });
      return {
        artifactType: "asset",
        uri: specifier,
        entry: specifier,
        immutable: true,
        external: true
      };
    }
    const rawAsset = await this.delegateGetAsset(assetId);
    const assetDef = await this.getAssetDefinition(rawAsset, runtimeEnvironment);
    const uri = await this.getUriFromAsset(assetDef, runtimeEnvironment);
    import_diagnostics.logger.debug({
      label: `LwrAssetRegistry`,
      message: `[resolveAssetUriWithoutLinking] getUriFromAsset ${specifier} -> ${assetDef.uri}`
    });
    return uri;
  }
  async getUriFromAsset(assetDef, runtimeEnvironment) {
    let uri = {
      artifactType: "asset",
      uri: String((0, import_path.join)(runtimeEnvironment.basePath, assetDef.uri)),
      entry: assetDef.entry,
      immutable: false,
      external: (0, import_shared_utils.isAssetSourceExternal)(assetDef)
    };
    for (const transformPlugin of this.transformers) {
      const resolveUriResult = await transformPlugin.transformUri?.(uri, assetDef, runtimeEnvironment);
      if (resolveUriResult) {
        uri = resolveUriResult;
      }
    }
    return uri;
  }
  getPublicApi() {
    return {
      getAsset: this.getAsset.bind(this),
      resolveAssetUri: this.resolveAssetUri.bind(this)
    };
  }
  validateSpecifier(specifier) {
    if ((0, import_shared_utils.isExternalUrl)(specifier)) {
      return {
        type: "external",
        uri: specifier
      };
    }
    const {assets, contentDir} = this.resourcePaths;
    const assetsMap = assets.reduce((map, asset) => {
      const {urlPath} = asset;
      const fsPath = asset?.dir || asset?.file;
      if (fsPath) {
        map[fsPath] = urlPath;
      }
      return map;
    }, {});
    if (specifier.startsWith(contentDir)) {
      return {
        type: "content-asset",
        uri: (0, import_path.relative)(contentDir, specifier)
      };
    }
    for (const [fsPath, urlPath] of Object.entries(assetsMap)) {
      if (specifier.startsWith(fsPath)) {
        return {
          type: "asset",
          uri: specifier.replace(fsPath, urlPath)
        };
      }
    }
    return {
      type: "unknown",
      uri: specifier
    };
  }
};
