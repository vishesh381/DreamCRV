var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/lwc-ssr/src/moduleLoader.ts
__markAsModule(exports);
__export(exports, {
  FETCH_ABORT_KEY: () => FETCH_ABORT_KEY,
  createModuleLoader: () => createModuleLoader
});
var import_path = __toModule(require("path"));
var import_crypto = __toModule(require("crypto"));
var import_shared_utils = __toModule(require("@lwrjs/shared-utils"));
var import_utils = __toModule(require("./utils.cjs"));
var import_fetchController = __toModule(require("./fetchController.cjs"));
var import_diagnostics = __toModule(require("@lwrjs/diagnostics"));
var FETCH_ABORT_KEY = "__fetchAbortId__";
var BOOTSTRAP_SPECIFIER = "@lwrjs/ssr-bootstrap";
function createModuleLoader(config, resourceRegistry, bundleRegistry, runtimeEnvironment, runtimeParams, serverData, bootstrapConfig, abortController) {
  const createLoader = runtimeEnvironment.format === "amd" ? createAMDModuleLoader : createESMModuleLoader;
  return createLoader(config, resourceRegistry, bundleRegistry, runtimeEnvironment, runtimeParams, serverData, bootstrapConfig, abortController);
}
async function createAMDModuleLoader(config, resourceRegistry, bundleRegistry, runtimeEnvironment, runtimeParams, serverData, bootstrapConfig, abortController) {
  const loaderConfig = (0, import_utils.getLoaderConfig)(BOOTSTRAP_SPECIFIER, config, runtimeParams, serverData);
  const {context, controller} = createContext(loaderConfig, runtimeParams, runtimeEnvironment, abortController);
  const contextKeyMap = new Map(Object.keys(context).map((key) => [key, true]));
  let run;
  context.LWR.customInit = async (lwr) => {
    run = lwr.initializeApp;
  };
  const useEval = process.env.SSR_DEBUG === "true";
  const init = (source) => {
    if (!useEval) {
      const fn = new Function("globalThis", ...Object.keys(context), source);
      fn(context, ...Object.values(context));
    } else {
      ((context) => {
        const evalSource = `${Object.keys(context).reduce((c, k) => c + `const ${k} = context['${k}'];`, "const globalThis=context;")} ${source}`;
        eval(evalSource);
      })(context);
    }
  };
  init(await (0, import_utils.getLoaderShim)(resourceRegistry, runtimeEnvironment, bootstrapConfig));
  if (!run) {
    throw new Error("Failed to init loader shim: custom init not called");
  }
  const p = new Promise((resolve) => {
    context.LWR.define(BOOTSTRAP_SPECIFIER, [(0, import_utils.getLoaderId)(context.LWR, bootstrapConfig)], (l) => resolve(l));
  });
  run();
  const {load, define, services, clearRegistry} = await p;
  const visited = new Map();
  const evaluatedBundleFilePaths = new Set();
  const bundleDefs = new Set();
  let loaderHooks = [];
  return {
    services: {
      ...services,
      addLoaderPlugin(hooks) {
        loaderHooks.push(hooks);
        return services.addLoaderPlugin(hooks);
      }
    },
    clearRegistry: () => {
      loaderHooks = [];
      return clearRegistry();
    },
    clearBundles: () => {
      bundleDefs.clear();
    },
    getBundles: () => {
      return bundleDefs;
    },
    load: async (specifier, aliases) => {
      const injectBundle = async (bundleRootSpecifier, aliases2) => {
        if (visited.has(bundleRootSpecifier)) {
          const entry = visited.get(bundleRootSpecifier);
          const def2 = isPromise(entry) ? await entry : entry;
          bundleDefs.add(def2);
          return def2;
        }
        const moduleId = (0, import_shared_utils.explodeSpecifier)(bundleRootSpecifier);
        const bundlePromise = (async () => {
          const def2 = await bundleRegistry.getModuleBundle(moduleId, runtimeEnvironment, {
            ...runtimeParams,
            ssr: true
          });
          if (!def2) {
            throw (0, import_diagnostics.createSingleDiagnosticError)({
              description: import_diagnostics.descriptions.UNRESOLVABLE.BUNDLE(bundleRootSpecifier)
            }, import_diagnostics.LwrUnresolvableError);
          }
          let code = await def2.getCode();
          if (typeof def2.src === "string" && !code.includes("//# sourceURL=")) {
            const srcUrl = def2.srcOverride ?? def2.src;
            code = code + `
//# sourceURL=${import_path.default.resolve(srcUrl)}`;
          }
          const staticImports = def2.bundleRecord.imports?.map((dep) => (0, import_shared_utils.getSpecifier)(dep)) ?? [];
          const dynamicImports = def2.bundleRecord.dynamicImports?.map((dep) => (0, import_shared_utils.getSpecifier)(dep)) ?? [];
          if (staticImports.length || dynamicImports.length) {
            const resolvedDeps = await Promise.all([...staticImports, ...dynamicImports].map((dep) => {
              return resolveModuleSpecifier(loaderHooks, dep);
            }));
            const missingDeps = resolvedDeps.filter((dep) => !visited.has(dep));
            for (const dep of missingDeps) {
              await injectBundle(dep);
            }
          }
          if (def2.src && evaluatedBundleFilePaths.has(def2.src)) {
            return def2;
          }
          init(code);
          evaluatedBundleFilePaths.add(def2.src);
          const definedId = (0, import_shared_utils.getSpecifier)(def2);
          if (aliases2?.length) {
            for (const alias of aliases2) {
              if (!visited.has(alias)) {
                define(alias, [definedId], (mod2) => mod2);
                visited.set(alias, def2);
              }
              const versionedAlias = (0, import_shared_utils.getSpecifier)({
                specifier: alias,
                version: def2.version
              });
              if (!visited.has(versionedAlias)) {
                define(versionedAlias, [definedId], (mod2) => mod2);
                visited.set(versionedAlias, def2);
              }
            }
          }
          if ((def2.specifier.startsWith("@app") || def2.specifier.startsWith("@salesforce")) && !visited.has(def2.specifier)) {
            define(definedId, [def2.specifier], (mod2) => mod2);
            visited.set(def2.specifier, def2);
          }
          visited.set(bundleRootSpecifier, def2);
          return def2;
        })();
        visited.set(bundleRootSpecifier, bundlePromise);
        const def = await bundlePromise;
        bundleDefs.add(def);
        return def;
      };
      const resolvedSpecifier = await resolveModuleSpecifier(loaderHooks, specifier);
      const injected = await injectBundle(resolvedSpecifier, aliases);
      if (!injected) {
        throw new Error(`Failed to inject bundle ${resolvedSpecifier}`);
      }
      const id = (0, import_shared_utils.getSpecifier)(injected);
      const mod = await load(id);
      return {
        specifier: injected.specifier,
        module: mod
      };
    },
    getFetchController: () => controller,
    resetGlobalContext: () => {
      for (const key in context) {
        if (Object.prototype.hasOwnProperty.call(context, key) && !contextKeyMap.has(key)) {
          delete context[key];
        }
      }
      context.LWR = {
        ...context.LWR,
        serverData: void 0
      };
    },
    getContext: () => {
      return context;
    }
  };
}
async function resolveModuleSpecifier(loaderHooks, bundleSpecifier) {
  if (loaderHooks) {
    for (const element of loaderHooks) {
      const loaderHook = element;
      const resolveHook = loaderHook.resolveModule;
      if (resolveHook) {
        const response = resolveHook(bundleSpecifier, {parentUrl: "not supported"});
        let result;
        if (response || response === null) {
          result = isPromise(response) ? await response : response;
        }
        if (!isValidResolveResponse(result)) {
          throw new Error(`Invalid resolve hook response: ${result}`);
        }
        if (result !== null) {
          return result;
        }
      }
    }
  }
  return bundleSpecifier;
}
function isPromise(response) {
  return !!(response && response.then);
}
function isValidResolveResponse(res) {
  return res === null || typeof res === "string";
}
async function createESMModuleLoader() {
  throw new Error("ESM support coming soon.");
}
function createContext(LWR, runtimeParams, runtimeEnvironment, abortController) {
  const fetchController = new import_fetchController.FetchController({
    host: runtimeParams.host,
    requestDepth: runtimeParams.requestDepth,
    coreProxy: runtimeParams.coreProxy,
    abortController
  });
  const context = {
    LWR,
    lwcRuntimeFlags: {ENABLE_WIRE_SYNC_EMIT: true},
    crypto: import_crypto.default,
    CustomEvent: Event,
    fetch: fetchController.controlledFetch
  };
  return {
    context,
    controller: {
      enableNoOpFetch: () => {
        fetchController.activateNoOp();
      },
      disableNoOpFetch: () => {
        fetchController.deactivateNoOp();
      },
      enableFetchKillSwitch: () => {
        fetchController.activateKillSwitch();
      },
      disableFetchKillSwitch: () => {
        fetchController.deactivateKillSwitch();
      },
      setFetchRequestContext: (context2) => {
        fetchController.setFetchRequestContext(context2);
      }
    }
  };
}
