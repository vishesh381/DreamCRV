import path from 'path';
import crypto from 'crypto';
import { explodeSpecifier, getSpecifier } from '@lwrjs/shared-utils';
import { getLoaderConfig, getLoaderId, getLoaderShim } from './utils.js';
import { FetchController } from './fetchController.js';
import { createSingleDiagnosticError, descriptions, LwrUnresolvableError } from '@lwrjs/diagnostics';
export const FETCH_ABORT_KEY = '__fetchAbortId__';
const BOOTSTRAP_SPECIFIER = '@lwrjs/ssr-bootstrap';
export function createModuleLoader(config, resourceRegistry, bundleRegistry, runtimeEnvironment, runtimeParams, serverData, bootstrapConfig, abortController) {
    const createLoader = runtimeEnvironment.format === 'amd' ? createAMDModuleLoader : createESMModuleLoader;
    return createLoader(config, resourceRegistry, bundleRegistry, runtimeEnvironment, runtimeParams, serverData, bootstrapConfig, abortController);
}
async function createAMDModuleLoader(config, resourceRegistry, bundleRegistry, runtimeEnvironment, runtimeParams, serverData, bootstrapConfig, abortController) {
    // creating a render context to avoid polluting globals
    const loaderConfig = getLoaderConfig(BOOTSTRAP_SPECIFIER, config, runtimeParams, serverData);
    const { context, controller } = createContext(loaderConfig, runtimeParams, runtimeEnvironment, abortController);
    const contextKeyMap = new Map(Object.keys(context).map((key) => [key, true]));
    // attaching custom init to delay bootstrap module evaluation
    let run;
    context.LWR.customInit = async (lwr) => {
        run = lwr.initializeApp;
    };
    // instantiate modules with shadowed globals
    const useEval = process.env.SSR_DEBUG === 'true';
    const init = (source) => {
        if (!useEval) {
            // Runtime Default: use new Function() for source evaluation due its to performance benefits / code isolation
            const fn = new Function('globalThis', ...Object.keys(context), source);
            fn(context, ...Object.values(context));
        }
        else {
            // Debugging: use eval() when debugging SSR to ensure source map line numbers are correct
            ((context) => {
                const evalSource = `${Object.keys(context).reduce((c, k) => c + `const ${k} = context['${k}'];`, 'const globalThis=context;')} ${source}`;
                eval(evalSource);
            })(context);
        }
    };
    // load and instantiate the loader shim
    init(await getLoaderShim(resourceRegistry, runtimeEnvironment, bootstrapConfig));
    if (!run) {
        throw new Error('Failed to init loader shim: custom init not called');
    }
    // manually define bootstrap module to export the loader
    const p = new Promise((resolve) => {
        context.LWR.define(BOOTSTRAP_SPECIFIER, [getLoaderId(context.LWR, bootstrapConfig)], (l) => resolve(l));
    });
    // execute the bootstrap module
    run();
    // loader API should be available after bootstrap module evaluation
    const { load, define, services, clearRegistry } = await p;
    const visited = new Map();
    const evaluatedBundleFilePaths = new Set();
    const bundleDefs = new Set();
    let loaderHooks = [];
    return {
        services: {
            ...services,
            addLoaderPlugin(hooks) {
                // Store locally for SSR resolution
                loaderHooks.push(hooks);
                // Add hook in the loader module
                return services.addLoaderPlugin(hooks);
            },
        },
        clearRegistry: () => {
            loaderHooks = [];
            return clearRegistry();
        },
        clearBundles: () => {
            bundleDefs.clear();
        },
        getBundles: () => {
            return bundleDefs;
        },
        load: async (specifier, aliases) => {
            const injectBundle = async (bundleRootSpecifier, aliases) => {
                if (visited.has(bundleRootSpecifier)) {
                    const entry = visited.get(bundleRootSpecifier);
                    const def = isPromise(entry) ? await entry : entry;
                    bundleDefs.add(def);
                    return def;
                }
                // start bundle resolution
                const moduleId = explodeSpecifier(bundleRootSpecifier);
                const bundlePromise = (async () => {
                    const def = await bundleRegistry.getModuleBundle(moduleId, runtimeEnvironment, {
                        ...runtimeParams,
                        ssr: true, // get a server bundle for SSR
                    });
                    if (!def) {
                        throw createSingleDiagnosticError({
                            description: descriptions.UNRESOLVABLE.BUNDLE(bundleRootSpecifier),
                        }, LwrUnresolvableError);
                    }
                    let code = await def.getCode();
                    if (typeof def.src === 'string' && !code.includes('//# sourceURL=')) {
                        // @view bundles are stored in a special location during local-dev
                        const srcUrl = def.srcOverride ?? def.src;
                        code = code + `\n//# sourceURL=${path.resolve(srcUrl)}`;
                    }
                    const staticImports = def.bundleRecord.imports?.map((dep) => getSpecifier(dep)) ?? [];
                    const dynamicImports = def.bundleRecord.dynamicImports?.map((dep) => getSpecifier(dep)) ?? [];
                    if (staticImports.length || dynamicImports.length) {
                        // First Async resolve via loader hooks
                        const resolvedDeps = await Promise.all([...staticImports, ...dynamicImports].map((dep) => {
                            // Prefer the value from the loader hook
                            return resolveModuleSpecifier(loaderHooks, dep);
                        }));
                        // Prevent circular dependency loops by checking if dep is already being resolved
                        const missingDeps = resolvedDeps.filter((dep) => !visited.has(dep));
                        // Can running these in parallel bite us on expected ordering?  Especially for externals.
                        for (const dep of missingDeps) {
                            // eslint-disable-next-line no-await-in-loop
                            await injectBundle(dep);
                        }
                    }
                    // exit early if the entry has already been evaluated
                    // note: the loader's registry must be cleared if the content at the entry point changes.
                    // Loading a bundle containing previously defined specifiers will not override the existing entries.
                    if (def.src && evaluatedBundleFilePaths.has(def.src)) {
                        return def;
                    }
                    // inject the bundle into the loader's module registry
                    init(code);
                    evaluatedBundleFilePaths.add(def.src);
                    const definedId = getSpecifier(def);
                    // create aliases
                    if (aliases?.length) {
                        for (const alias of aliases) {
                            if (!visited.has(alias)) {
                                define(alias, [definedId], (mod) => mod);
                                visited.set(alias, def);
                            }
                            const versionedAlias = getSpecifier({
                                specifier: alias,
                                version: def.version,
                            });
                            if (!visited.has(versionedAlias)) {
                                define(versionedAlias, [definedId], (mod) => mod);
                                visited.set(versionedAlias, def);
                            }
                        }
                    }
                    // TODO: remove this once we confirm it's no longer needed in CLWR
                    if ((def.specifier.startsWith('@app') || def.specifier.startsWith('@salesforce')) &&
                        // the module id is versioned(ie. the visited index), but the define in the source is un-versioned.
                        // this alias will apply the inverse: un-versioned module id with a versioned define
                        !visited.has(def.specifier)) {
                        define(definedId, [def.specifier], (mod) => mod);
                        visited.set(def.specifier, def);
                    }
                    // replace cache with resolved value
                    visited.set(bundleRootSpecifier, def);
                    return def;
                })();
                // cache inflight bundle resolution
                visited.set(bundleRootSpecifier, bundlePromise);
                // wait for inflight bundle resolution
                const def = await bundlePromise;
                bundleDefs.add(def);
                return def;
            };
            // Prefer the value from the loader hook
            const resolvedSpecifier = await resolveModuleSpecifier(loaderHooks, specifier);
            // load and inject the module graph if not already loaded
            const injected = await injectBundle(resolvedSpecifier, aliases);
            if (!injected) {
                throw new Error(`Failed to inject bundle ${resolvedSpecifier}`);
            }
            const id = getSpecifier(injected);
            // "dynamically" load and evaluate the module
            const mod = await load(id);
            return {
                specifier: injected.specifier,
                module: mod,
            };
        },
        getFetchController: () => controller,
        resetGlobalContext: () => {
            // Clear the context of all of the keys that may be added by module evaluation.
            // Do not delete keys that we added ourselves.
            for (const key in context) {
                if (Object.prototype.hasOwnProperty.call(context, key) && !contextKeyMap.has(key)) {
                    delete context[key];
                }
            }
            // Reset LWR globals as needed.
            // Note: we only need to reset serverData today, since it is the only
            // property that mutates between page renders.
            context.LWR = {
                ...context.LWR,
                serverData: undefined,
            };
        },
        // Note: only used for testing
        getContext: () => {
            return context;
        },
    };
}
async function resolveModuleSpecifier(loaderHooks, bundleSpecifier) {
    if (loaderHooks) {
        for (const element of loaderHooks) {
            const loaderHook = element;
            const resolveHook = loaderHook.resolveModule;
            if (resolveHook) {
                const response = resolveHook(bundleSpecifier, { parentUrl: 'not supported' });
                let result;
                if (response || response === null) {
                    // eslint-disable-next-line no-await-in-loop
                    result = isPromise(response) ? await response : response;
                }
                if (!isValidResolveResponse(result)) {
                    throw new Error(`Invalid resolve hook response: ${result}`);
                }
                // if result is not null, attempt resolution
                if (result !== null) {
                    return result;
                }
            }
        }
    }
    return bundleSpecifier;
}
function isPromise(response) {
    return !!(response && response.then);
}
function isValidResolveResponse(res) {
    return res === null || typeof res === 'string';
}
async function createESMModuleLoader() {
    throw new Error('ESM support coming soon.');
}
/**
 * Create a context object that mimics the `globalThis` object in the browser environment.  The object
 * contains polyfills for missing browser APIs and overrides select APIs, like `fetch`.
 *
 * @param LWR - client bootstrap config
 * @param runtimeParams - request parameters
 * @returns a `globalThis` object
 */
function createContext(LWR, runtimeParams, runtimeEnvironment, abortController) {
    const fetchController = new FetchController({
        host: runtimeParams.host,
        requestDepth: runtimeParams.requestDepth,
        coreProxy: runtimeParams.coreProxy,
        abortController,
    });
    const context = {
        LWR,
        lwcRuntimeFlags: { ENABLE_WIRE_SYNC_EMIT: true },
        // browser api polyfills
        crypto,
        CustomEvent: Event,
        // global fetch api override
        fetch: fetchController.controlledFetch,
    };
    return {
        context,
        controller: {
            enableNoOpFetch: () => {
                fetchController.activateNoOp();
            },
            disableNoOpFetch: () => {
                fetchController.deactivateNoOp();
            },
            enableFetchKillSwitch: () => {
                fetchController.activateKillSwitch();
            },
            disableFetchKillSwitch: () => {
                fetchController.deactivateKillSwitch();
            },
            setFetchRequestContext: (context) => {
                fetchController.setFetchRequestContext(context);
            },
        },
    };
}
//# sourceMappingURL=moduleLoader.js.map