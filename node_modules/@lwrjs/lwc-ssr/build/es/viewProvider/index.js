import BaseViewProvider from '@lwrjs/base-view-provider';
import { createSingleDiagnosticError, descriptions, logger, LwrApplicationError } from '@lwrjs/diagnostics';
import { ViewSpan, getTracer } from '@lwrjs/instrumentation';
import { getFeatureFlags, hashContent, isLocalDev, isSpecifier, moduleSpecifierToKebabCase, slugify, } from '@lwrjs/shared-utils';
import { createHeadMarkup, createSsrErrorMarkup, createSsrErrorMessage } from '../utils.js';
import { getRenderer } from '../renderer.js';
export default class LwcViewProvider extends BaseViewProvider {
    constructor(_pluginConfig, providerConfig) {
        super();
        this.name = 'ssr-view-provider';
        this.moduleBundler = providerConfig.moduleBundler;
        this.resourceRegistry = providerConfig.resourceRegistry;
        this.routes = [...providerConfig.config.routes, ...providerConfig.config.errorRoutes];
        this.runtimeEnvironment = providerConfig.runtimeEnvironment;
        this.config = providerConfig.config;
    }
    async initialize() {
        return;
    }
    async getView(viewId) {
        // This view provider creates content templates with islands from LWC component specifiers
        const specifier = viewId.contentTemplate?.component;
        if (!specifier || !isSpecifier(specifier)) {
            return;
        }
        const viewProperties = { serverHeadMarkup: '' }; // filled in by getServerData
        return {
            name: specifier,
            slug: slugify(specifier),
            ownHash: hashContent(specifier),
            originalSource: specifier,
            filePath: specifier,
            viewId,
            properties: viewProperties,
            render: async (runtimeParams, runtimeEnvironment) => {
                // SSR the root component (without passing any public properties)
                const { config, moduleBundler, resourceRegistry } = this;
                const { debug } = runtimeEnvironment;
                const element = moduleSpecifierToKebabCase(specifier);
                return getTracer().trace({
                    name: ViewSpan.RenderPage,
                    attributes: { specifier },
                }, async () => {
                    const route = this.routes.find((r) => r.id === viewId.id);
                    if (!route) {
                        throw new Error(`Unable to resolve configuration for view: ${viewId.id}`);
                    }
                    const { results = {}, errors, bundles, } = await getRenderer(config, moduleBundler, resourceRegistry).render({ [specifier]: { specifier, props: {} } }, route, runtimeEnvironment, Object(runtimeParams), undefined, 
                    // lets the renderer know this is the first of 2-pass SSR
                    true);
                    // Handle errors: throw or return an error page
                    if (errors) {
                        const errorString = Object.values(errors).join(', ');
                        // always fallback to CSR if debug === true
                        // throw in local dev mode if SSR_WITH_CSR_FALLBACK === false
                        if ((!debug || isLocalDev()) && !getFeatureFlags().SSR_WITH_CSR_FALLBACK) {
                            // 500 error for the page request
                            throw createSingleDiagnosticError({
                                description: descriptions.APPLICATION.SSR_ERROR(specifier, errorString),
                            }, LwrApplicationError);
                        }
                        // error page
                        const message = createSsrErrorMessage(specifier, errorString, false);
                        logger.warn(message, errors[specifier]); // TODO specific metadata for errors
                        return {
                            // render the errors on the browser page; fallback to CSR is not possible on the 1st pass
                            renderedView: createSsrErrorMarkup(errors, this.runtimeEnvironment.basePath),
                            // send an error message to the client if debug mode is on
                            metadata: {
                                serverDebug: { message: debug ? message : undefined },
                                customElements: [],
                                assetReferences: [],
                            },
                        };
                    }
                    // Insert the SSRed HTML into the document
                    const { html, props, markup, cache, status } = results[specifier];
                    if (!html) {
                        throw new Error(`Failed to render content template component '${specifier}'`);
                    }
                    if (markup)
                        viewProperties.serverHeadMarkup = createHeadMarkup([results[specifier]]); // generate <head> markup
                    return {
                        // add "lwc:external" to the contentTemplate component to mark it as already processed
                        renderedView: html.replace(`<${element}`, `<${element} lwc:external`),
                        metadata: {
                            serverData: props,
                            customElements: [],
                            assetReferences: [],
                            serverBundles: bundles,
                        },
                        cache,
                        status,
                    };
                });
            },
        };
    }
}
//# sourceMappingURL=index.js.map