import { Pool as ClientPool } from 'undici';
import { logger } from '@lwrjs/diagnostics';
import { getTracer, ViewSpan } from '@lwrjs/instrumentation';
import { REQUEST_DEPTH_HEADER } from '@lwrjs/shared-utils';
const ROUTE_CORE_HEADER = 'X-SFDC-Route-Core';
// a single Lambda only services 1 org, so this cache will not grow too large
const CORE_CLIENTS = new Map();
/**
 * During SSR a context is created with a new fetchController. At this point any fetches work as expected in this context.
 *
 * Right before renderComponents we call activateNoOp. At this point any new fetch calls in this context result in a no-op
 * fetch waiting to be aborted.
 *
 * When SSR for this request is complete we call activateKillSwitch which aborts any pending fetch calls in this context.
 * Any new fetch calls (i.e. from other async function calls) would be immediately aborted.
 */
export class FetchController {
    constructor(context) {
        this.controlledFetch = (request, init) => {
            if (this.killSwitchActivated) {
                return this.handleAbortError(request, undefined);
            }
            if (!this.abortController) {
                this.abortController = new AbortController();
            }
            const signal = this.abortController?.signal;
            // Ensure the init object exists and then add the signal to it.
            const updatedInit = {
                ...init,
                headers: { ...init?.headers, ...this.headers },
                signal,
            };
            const fetchFunction = this.noOpActivated
                ? this.fetchNoOp(request, updatedInit)
                : this.fetchEndowment(request, updatedInit);
            const fetchPromise = fetchFunction.catch((error) => {
                // Check if the error is an AbortError
                if (error && error?.stack.startsWith('AbortError')) {
                    return this.handleAbortError(request, error);
                }
                else {
                    // Re-throw the error if it's not an AbortError
                    throw error;
                }
            });
            return fetchPromise;
        };
        /**
         * After SSR is complete the kill switch will abort any pending fetch requests.
         */
        this.activateKillSwitch = () => {
            this.killSwitchActivated = true;
            this.abortController?.abort();
            this.abortController = undefined;
        };
        this.deactivateKillSwitch = () => {
            this.killSwitchActivated = false;
        };
        /**
         * During SSR renderComponent (which is synchronous) Do not even call any fetch requests
         * since they would not complete before SSR is done.
         */
        this.activateNoOp = () => {
            this.noOpActivated = true;
        };
        this.deactivateNoOp = () => {
            this.noOpActivated = false;
        };
        this.setFetchRequestContext = (context) => {
            const { abortController, host, headers, requestDepth, coreProxy } = context;
            this.host = host;
            this.headers = headers;
            this.requestDepth = requestDepth;
            this.coreProxy = coreProxy;
            this.abortController = abortController;
        };
        this.killSwitchActivated = false;
        this.noOpActivated = false;
        this.setFetchRequestContext(context);
        this.fetchEndowment = this.createFetchEndowment();
    }
    handleAbortError(request, error) {
        const message = `Orphaned ${String(request)} request was killed. Either the request timed out or it was dispatched during SSR. Async processes are not supported during SSR. For more information, see: https://developer.salesforce.com/docs/platform/lwr/guide/lwr-configure-component-ssr.html.`;
        logger.warn({ label: `Server-side Rendering`, message }, error);
        // Return a response to indicate kill switch
        return Promise.resolve(new Response(message, { status: 500 }));
    }
    /**
     * Create a fetch API that never calls a request.
     * This is not expected to be called without an AbortController setup.
     */
    fetchNoOp(request, init) {
        return new Promise((resolve) => {
            if (!init?.signal) {
                // This should not happen?  This is only called internally to the class and we setup an abort controller.
                resolve(this.handleAbortError(request, new Error('RequestInit was not setup as expected')));
            }
            else if (init.signal.aborted) {
                // The request was already aborted go ahead and return the abort error
                resolve(this.handleAbortError(request, new Error('Request was aborted')));
            }
            else {
                // Wait until fetches are aborted to resolve with an abort error
                const abortHandler = (err) => {
                    init?.signal?.removeEventListener('abort', abortHandler);
                    // Resolve the fetch
                    resolve(this.handleAbortError(request, err));
                };
                init.signal.addEventListener('abort', abortHandler);
            }
        });
    }
    createFetchEndowment() {
        return (request, init) => {
            const { host = '', requestDepth = 1, coreProxy } = this;
            const origin = coreProxy?.origin && coreProxy.origin.startsWith('http') ? coreProxy.origin : host; // The Direct-to-Core proxy origin takes precedence over the Forwarded host
            const { finalRequest, finalUrl } = this.getFinalRequest(request, origin);
            const finalInit = {
                ...init,
                headers: {
                    ...init?.headers,
                    [REQUEST_DEPTH_HEADER]: String(requestDepth),
                },
            };
            if (coreProxy || (host && finalUrl.startsWith(host))) {
                // hint for the CDN that the request is targeted to Core
                finalInit.headers[ROUTE_CORE_HEADER] = 'true';
            }
            const proxyStr = coreProxy ? JSON.stringify(coreProxy) : 'none';
            const hasCookies = this.headers && this.headers.Cookie ? 'yes' : 'no';
            logger.info({
                label: `pre ${ViewSpan.Fetch}`,
                message: `finalUrl: ${finalUrl}, coreProxy: ${proxyStr}, hasCookies: ${hasCookies}`,
            });
            return getTracer().trace(
            // fetchType is one of ['cdn' (default), 'direct', 'cdnFallback']
            // Default URL to  final URL if successful addInfoToSpan will replace with response.url
            {
                name: ViewSpan.Fetch,
                attributes: { url: finalUrl, fetchType: 'cdn', coreProxy: proxyStr, hasCookies },
            }, (span) => {
                // this trace will NOT fail if fetch fails; it is meant to log the URLs fetched from the server
                // the fetch caller (ie: getServerData) should handle the error if response.ok is false
                // if the caller throws the fetch error, then it will be surfaced in the PARENT traces:
                // lwr.view.ssr.fetch (this) > lwr.view.ssr > lwr.view.ssr.island > lwr.view.render > lwr.handle.view
                const addInfoToSpan = (res) => {
                    // add attributes to the trace which are only available post-fetch
                    res.url && span.setAttributes({ url: res.url }); // res.url is '' with undici
                    span.setAttributes({ statusCode: res.status });
                    return res;
                };
                if (coreProxy) {
                    return this.fetchWithAgent(finalUrl, finalInit, host, coreProxy, span)
                        .then((res) => addInfoToSpan(res))
                        .catch((err) => {
                        const { finalRequest: cdnRequest, finalUrl: cdnUrl } = this.getFinalRequest(request, host);
                        logger.warn(`Fetching data directly from Core failed, retrying through CDN: ${cdnUrl} Error is: ${err.message || err}`);
                        span.setAttributes({ fetchType: 'cdnFallback' });
                        return fetch(cdnRequest, finalInit).then((res) => addInfoToSpan(res));
                    });
                }
                return fetch(finalRequest, finalInit).then((res) => addInfoToSpan(res));
            });
        };
    }
    getFinalRequest(request, host) {
        let finalRequest;
        let finalUrl;
        if (request instanceof Request) {
            const curUrl = request.url;
            // proxy relative URLs through the host
            if (curUrl.startsWith('/')) {
                finalUrl = host + curUrl;
                finalRequest = new Request(finalUrl, request);
            }
            else {
                finalUrl = curUrl;
                finalRequest = request;
            }
        }
        else {
            const curUrl = typeof request === 'string' ? request : request.toString(); // handle string-able types, eg: URL
            finalRequest = finalUrl = curUrl.startsWith('/') ? host + curUrl : curUrl; // proxy relative URLs through the host
        }
        return { finalRequest, finalUrl };
    }
    async fetchWithAgent(rawUrl, init, forwardedHost, coreProxy, span) {
        let { origin, servername } = coreProxy;
        const host = coreProxy.host ?? forwardedHost.replace(/^https?:\/\//, '');
        const ENHANCED_DOMAIN_TLD = '.site.com';
        const MY_DOMAIN_TLD = '.salesforce.com';
        if (forwardedHost.endsWith(ENHANCED_DOMAIN_TLD)) {
            // use the Salesforce TLD by replacing the Site TLD
            // caller must be an Enhanced Domain on Cloudflare
            origin = forwardedHost.slice(0, -ENHANCED_DOMAIN_TLD.length) + MY_DOMAIN_TLD;
            // do not use SNI with the Enhanced Domain route
            servername = origin;
        }
        else if (origin.startsWith('.')) {
            // use the CDN origin if the leading '.' is missing in the coreProxy origin
            origin = forwardedHost + origin;
        }
        const urlParts = new URL(rawUrl);
        const path = urlParts.pathname + urlParts.search;
        const url = origin + path;
        // The host header and servername attrs are only used for Direct-to-Core requests
        // They are not used again if this request fails and falls back to CDN
        span.setAttributes({
            fetchType: 'direct',
            url,
            coreUrl: url,
            coreHostHeader: host,
            coreServername: servername,
        });
        let client = CORE_CLIENTS.get(origin);
        if (!client) {
            client = new ClientPool(origin, {
                connections: parseInt(process.env.CLIENT_CONNECTION_LIMIT ?? '100', 10),
                keepAliveTimeout: 30000,
            });
            CORE_CLIENTS.set(origin, client);
        }
        return client
            .request({
            ...init,
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore - HttpMethod not available for typecasting :|
            method: init.method || 'GET',
            path,
            headers: { ...init?.headers, Host: host },
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore - not properly typed >:|
            servername,
        })
            .then(async (res) => {
            // Set the core* attrs early, so the info is not lost if we fallback to CDN
            // With no CDN fallback url=coreUrl and statusCode=coreStatusCode
            span.setAttributes({ coreStatusCode: res.statusCode });
            // convert the response to a fetch Response object
            // downstream consumers expect a Response since it's the standard fetch return object
            // this allows callers to check the response with "instanceof Response"
            const bodyBuffer = await res.body.arrayBuffer();
            const body = res.statusCode === 204 || res.statusCode === 205 ? null : bodyBuffer;
            const headers = new Headers();
            for (const [key, value] of Object.entries(res.headers)) {
                if (!value)
                    continue;
                const values = Array.isArray(value) ? value : [value];
                values.forEach((v) => headers.append(key, v));
            }
            return new Response(body, { status: res.statusCode, headers });
            // If we want to fallback to CDN for certain status codes
            // if (!fetchRes.ok) {
            //     throw new Error('Failed with status code: ' + fetchRes.status);
            // }
            // return {
            //     ...res,
            //     url: origin + path,
            //     ok: res.statusCode < 400,
            //     status: res.statusCode,
            //     redirected: res.statusCode >= 300 && res.statusCode < 400,
            //     text: res.body.text.bind(res.body),
            //     json: res.body.json.bind(res.body),
            // } as unknown as Response;
        });
    }
}
//# sourceMappingURL=fetchController.js.map