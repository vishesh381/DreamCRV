import { createSingleDiagnosticError, descriptions, logger, LwrApplicationError } from '@lwrjs/diagnostics';
import { ViewSpan, getTracer } from '@lwrjs/instrumentation';
import { HYDRATE_CLIENT_VALUE, HYDRATE_DIRECTIVE, getFeatureFlags, isCsrIsland, isHydrateOnLoad, isLocalDev, kebabCaseToModuleSpecifier, shortestTtl, } from '@lwrjs/shared-utils';
import { SSR_PROPS_ATTR, addHeadMarkup, getPropsId, createSsrErrorMessage } from '../utils.js';
import { getRenderer } from '../renderer.js';
/**
 * This is a view transformer run by the view registry during linking of a page document/route (configured in lwr.config.json[routes]).
 * If the "ssr" bootstrap flag is on for the route, it will server-side render (SSR) each eligible custom element found in the page HTML.
 *
 * Flow:
 *  1. There is a request to generate a view (ie: page document) via the UI middleware or static site generation
 *  2. During view generation, the view registry runs all the registered view transformers (including this one)
 *  3. This view transformer links the SSRed string for EVERY eligible custom element (ie: root component) found in the page document:
 *      a) It requests a module which SSRs a given custom element, generated by "lwc-ssr/moduleProvider"
 *      b) A bundle is created for the generated server bootstrap module (see "./ssr-bootstrap")
 *      c) The bundle code is run inside a worker (see "./ssr-bootstrap"), with context stored in "workerData"
 *      d) RootComponent.getServerData() is run to preload data and <head> markup, if available
 *      e) The generated server bootstrap module (running the worker) passes the SSRed code string, data and cache info back to the main thread
 *      f) The SSRed string is used to overwrite/link each custom element (eg: "<c-app></c-app>") in the document (see "stringBuilder.overwrite")
 *      g) A script containing all the serialized properties is added for hydration
 * 4. The view/page document now contains SSRed components and data, which will be sent to the client
 * 5. During bootstrap on the client, the "lwr/init" module will hydrate the custom elements on the page, as needed
 */
export default function lwcSsrViewTransformer(options, { config, moduleBundler, resourceRegistry }) {
    const routes = [...config.routes, ...config.errorRoutes];
    return {
        name: 'ssr-lwc-transformer',
        async link(stringBuilder, viewContext, metadata) {
            if (!viewContext.view.bootstrap?.ssr) {
                return {}; // no SSR
            }
            logger.debug({ label: 'lwcSsrViewTransformer', message: 'link' });
            logger.verbose({
                label: 'lwcSsrViewTransformer',
                message: 'link input',
                additionalInfo: stringBuilder,
            });
            if (!metadata.serverData) {
                metadata.serverData = {};
            }
            if (!metadata.serverDebug) {
                metadata.serverDebug = {};
            }
            const allBundles = new Set([...(metadata.serverBundles ?? [])]); // make a copy
            const { customElements, serverData, serverDebug } = metadata;
            const { debug } = viewContext.runtimeEnvironment;
            // Gather all the SSRable custom elements (ie: root components) into 1 list
            const ssrModules = getComponentsToSSR(customElements, stringBuilder);
            const rootSpecifiers = Object.values(ssrModules).map((m) => m.specifier);
            if (!rootSpecifiers.length) {
                return {}; // no SSR because there are no root eligible components
            }
            // SSR and gather the properties and <head> markup for each eligible custom element
            const islands = rootSpecifiers.join(',');
            let pageTtl;
            await getTracer().trace({ name: ViewSpan.RenderIsland, attributes: { specifiers: islands } }, async () => {
                const route = routes.find((r) => r.id === viewContext.view.id);
                if (!route) {
                    throw new Error(`Unable to resolve configuration for view: ${viewContext.view.id}`);
                }
                const { results, errors, bundles: islandBundles, } = await getRenderer(config, moduleBundler, resourceRegistry).render(ssrModules, route, viewContext.runtimeEnvironment, viewContext.runtimeParams, metadata.serverData, false);
                for (const root in results) {
                    const { html, props, cache } = results[root];
                    const { tagName, startOffset, endOffset, hydrate } = ssrModules[root];
                    pageTtl = shortestTtl(cache?.ttl, pageTtl);
                    if (html) {
                        // Add the props id to the HTML for the custom element
                        // eg: <some-cmp> -> <some-cmp data-lwr-props-id="1234">
                        // Then overwrite the custom element with the SSRed component string
                        let propsAttr = '';
                        if (hydrate) {
                            // Only serialize props for custom elements that are to be hydrated
                            const propsId = getPropsId();
                            propsAttr = ` ${SSR_PROPS_ATTR}="${propsId}"`;
                            serverData[propsId] = props;
                        }
                        const [, remain] = html.split(`<${tagName}`);
                        stringBuilder.overwrite(startOffset, endOffset, [`<${tagName}`, propsAttr, remain].join(''));
                    }
                }
                metadata.serverBundles = islandBundles
                    ? new Set([...allBundles, ...islandBundles])
                    : allBundles;
                results && addHeadMarkup(Object.values(results), stringBuilder);
                errors && handleErrors(errors, customElements, islands, debug, serverDebug);
            });
            logger.verbose({
                label: 'lwcSsrViewTransformer',
                message: 'response',
                additionalInfo: stringBuilder,
            });
            return { cache: { ttl: pageTtl } };
        },
    };
}
function getComponentsToSSR(customElements, stringBuilder) {
    const cmpInfo = {};
    for (const { tagName, location, props: rawProps = {} } of customElements.values()) {
        const isCsr = isCsrIsland(rawProps);
        if (isCsr && location) {
            // Strip the CSR-only island directive from the HTML
            const { startOffset, endOffset } = location;
            stringBuilder.overwrite(startOffset, endOffset, `<${tagName}></${tagName}>`);
        }
        if (!isCsr && !rawProps?.['lwc:external'] && location) {
            // Only SSR the custom elements which are NOT CSR islands or lwc:external
            const { startOffset, endOffset } = location;
            const specifier = kebabCaseToModuleSpecifier(tagName);
            const hydrate = isHydrateOnLoad(rawProps);
            const props = { ...rawProps };
            delete props[HYDRATE_DIRECTIVE];
            cmpInfo[specifier] = { startOffset, endOffset, props, tagName, specifier, hydrate };
        }
    }
    return cmpInfo;
}
function handleErrors(errors, customElements, specifiers, debug, serverDebug) {
    const allErrors = Object.values(errors).join(', ');
    // always fallback to CSR if debug === true
    // throw in local dev mode if SSR_WITH_CSR_FALLBACK === false
    if ((!debug || isLocalDev()) && !getFeatureFlags().SSR_WITH_CSR_FALLBACK) {
        // 500 error for the page request
        throw createSingleDiagnosticError({
            description: descriptions.APPLICATION.SSR_ERROR(specifiers, allErrors),
        }, LwrApplicationError);
    }
    // Fallback to CSR in debug mode or if enabled
    Object.entries(errors).forEach(([specifier, err]) => {
        const ce = customElements.find(({ tagName }) => specifier === kebabCaseToModuleSpecifier(tagName));
        if (ce) {
            // Fallback to CSR by adding lwr:hydrate="client-only" to the custom element
            // This ENSURES the component's JavaScript gets sent to the client for CSRing
            ce.props === undefined
                ? (ce.props = {
                    [HYDRATE_DIRECTIVE]: HYDRATE_CLIENT_VALUE,
                })
                : (ce.props[HYDRATE_DIRECTIVE] = HYDRATE_CLIENT_VALUE);
        }
        // Log error with stack details
        const errMessage = createSsrErrorMessage(specifier, err);
        logger.warn(errMessage, err); // TODO specific metadata for errors
    });
    // Inform the client of the failing modules without exposing any additional
    // details (such as callstack) for security reasons
    if (debug) {
        serverDebug.message = createSsrErrorMessage(specifiers, allErrors);
    }
}
//# sourceMappingURL=index.js.map