import type { DirectToCoreProxy } from '@lwrjs/types';
export type FetchFunction = (request: string | URL | globalThis.Request, init?: RequestInit) => Promise<Response>;
export type FetchRequestContext = {
    host?: string;
    requestDepth?: number;
    headers?: HeadersInit | undefined;
    coreProxy?: DirectToCoreProxy;
    abortController?: AbortController;
};
/**
 * During SSR a context is created with a new fetchController. At this point any fetches work as expected in this context.
 *
 * Right before renderComponents we call activateNoOp. At this point any new fetch calls in this context result in a no-op
 * fetch waiting to be aborted.
 *
 * When SSR for this request is complete we call activateKillSwitch which aborts any pending fetch calls in this context.
 * Any new fetch calls (i.e. from other async function calls) would be immediately aborted.
 */
export declare class FetchController {
    private killSwitchActivated;
    private noOpActivated;
    private abortController;
    private headers;
    private host;
    private requestDepth;
    private coreProxy;
    fetchEndowment: FetchFunction;
    constructor(context: FetchRequestContext);
    controlledFetch: FetchFunction;
    /**
     * After SSR is complete the kill switch will abort any pending fetch requests.
     */
    activateKillSwitch: () => void;
    deactivateKillSwitch: () => void;
    /**
     * During SSR renderComponent (which is synchronous) Do not even call any fetch requests
     * since they would not complete before SSR is done.
     */
    activateNoOp: () => void;
    deactivateNoOp: () => void;
    setFetchRequestContext: (context: FetchRequestContext) => void;
    private handleAbortError;
    /**
     * Create a fetch API that never calls a request.
     * This is not expected to be called without an AbortController setup.
     */
    private fetchNoOp;
    private createFetchEndowment;
    private getFinalRequest;
    private fetchWithAgent;
}
//# sourceMappingURL=fetchController.d.ts.map