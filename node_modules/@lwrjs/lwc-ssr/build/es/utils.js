import { logger, stringifyError } from '@lwrjs/diagnostics';
import { buildEnvironmentContext, getFeatureFlags, normalizeVersionToUri, isLambdaEnv, getSpecifier, } from '@lwrjs/shared-utils';
const DEFAULT_SSR_TIMEOUT = 5000; // 5 seconds, override with process.env.SSR_TIMEOUT
export const SSR_PROPS_ATTR = 'data-lwr-props-id';
export function getPropsId() {
    return `lwcprops${Math.floor(Math.random() * 0x10000).toString(16)}`;
}
export function getRenderTimeout() {
    const override = process.env.SSR_TIMEOUT;
    return override ? Number.parseInt(override) : DEFAULT_SSR_TIMEOUT;
}
export function createSsrErrorMessage(specifier, e, fallback = true) {
    const fallbackMsg = fallback ? ' Falling back to client-side rendering.' : '';
    return `Server-side rendering for "${specifier}" failed.${fallbackMsg} Reason: ${stringifyError(e)}`;
}
export function createSsrErrorMarkup(errors, basePath) {
    let markup = '<div style="font-family:sans-serif;margin:50px;font-size:1.2em;"><h1>500: Server-side rendering failed</h1><p>Reasons:</p><ul>';
    Object.entries(errors).forEach(([specifier, reason]) => {
        markup += `<li><strong>${specifier}</strong>: ${stringifyError(reason)}</li>`;
    });
    markup += `</ul><p style="padding-top:1em;">See more information in the browser console. Contact your administrator for assistance.</p></div>`;
    return markup;
}
export async function getLoaderShim(resourceRegistry, runtimeEnvironment, bootstrapConfig) {
    const { debug } = runtimeEnvironment;
    // debug resources are not available in deployed lambda env
    const useDebug = debug && !isLambdaEnv();
    const specifier = getFeatureFlags().LEGACY_LOADER
        ? useDebug
            ? 'lwr-loader-shim-legacy.bundle.js'
            : 'lwr-loader-shim-legacy.bundle.min.js'
        : useDebug
            ? 'lwr-loader-shim.bundle.js'
            : 'lwr-loader-shim.bundle.min.js';
    const resource = await resourceRegistry.getResource({ specifier, version: bootstrapConfig.lwrVersion }, runtimeEnvironment, 
    // HACK: this code is tricky because resource IDs are different between prod vs debug ("lwr-loader-shim.bundle.min.js" vs "lwr-loader-shim.bundle.js").
    // 1. In debug mode on Lambda (during SSR), we need to ignore runtimeEnvironment.debug because we will always ask for the prod version (lwr-loader-shim.bundle.min.js)
    // 2. But when we generate the view, we can't ignore runtimeEnvironment.debug because we need the debug version of the loader shim (lwr-loader-shim.bundle.js)
    { ignoreDebug: !useDebug });
    if (!resource?.content && !resource?.stream) {
        throw new Error('Failed to find the loader shim');
    }
    let result = '';
    if (resource.content) {
        result = resource.content;
    }
    else {
        const stream = resource.stream();
        for await (const chunk of stream) {
            result += chunk;
        }
    }
    result += `\n//# sourceURL=${resource.entry}`;
    return result;
}
export function getLoaderId(config, bootstrapConfig) {
    // TODO W-15509657 - hack: checking `requiredModules` because the loader may not be the same version as the current runtime
    if (config.requiredModules) {
        const id = config.requiredModules.find((specifier) => specifier.startsWith('lwr/loader'));
        if (id) {
            return id;
        }
    }
    // default to the active LWR version
    const version = normalizeVersionToUri(bootstrapConfig.lwrVersion);
    return getFeatureFlags().LEGACY_LOADER ? `lwr/loaderLegacy/v/${version}` : `lwr/loader/v/${version}`;
}
export function getLoaderConfig(bootstrapModule, config, runtimeParams, serverData) {
    return Object.assign({}, {
        bootstrapModule,
        serverData,
        autoBoot: false,
        disableInitDefer: true,
        rootComponents: [],
        endpoints: {
            uris: {
                mapping: `/1/mapping/amd/1/l/${runtimeParams.locale ?? config.i18n.defaultLocale}/mp/`,
            },
        },
        env: {
            ...buildEnvironmentContext(runtimeParams),
            SSR: true,
        },
    }, getFeatureFlags().LEGACY_LOADER
        ? {
            baseUrl: 'ssr',
        }
        : {
            baseUrl: '/',
            imports: {
                'any/thing.js': ['any/thing'],
            },
        });
}
export function getServerBootstrapServices(route) {
    return route.bootstrap.services.reduce((acc, service) => {
        if (service.ssr === true) {
            const serviceId = getSpecifier({ specifier: service.name, version: service.version });
            acc.push(serviceId);
        }
        return acc;
    }, []);
}
/** SSR HEAD MARKUP UTILS */
function createMetaTags(meta) {
    return meta.reduce((metaStr, { name, content, httpEquiv }) => {
        if (!name && !content && !httpEquiv)
            return metaStr; // do not create empty <meta> tags
        const nameStr = name ? ` name="${name}"` : '', httpEquivStr = httpEquiv ? ` http-equiv="${httpEquiv}"` : '', contentStr = content ? ` content="${content}"` : '';
        return metaStr + `<meta${nameStr}${httpEquivStr}${contentStr}>\n`;
    }, '');
}
function createScriptTags(scripts) {
    return scripts.reduce((scriptStr, { body }) => scriptStr + `<script type="application/ld+json">${body}</script>\n`, '');
}
function createLinkTags(links) {
    return links.reduce((linkStr, { href, rel, as, fetchpriority }) => {
        const relStr = rel ? ` rel="${rel}"` : '', asStr = as ? ` as="${as}"` : '', fetchStr = fetchpriority ? ` fetchpriority="${fetchpriority}"` : '';
        return linkStr + `<link href="${href}"${relStr}${asStr}${fetchStr}>\n`;
    }, '');
}
function createStyleTags(styles) {
    return styles.reduce((styleStr, { body, id }) => {
        const idStr = id ? ` id="${id}"` : '';
        return styleStr + `<style type="text/css"${idStr}>${body}</style>\n`;
    }, '');
}
/**
 * Serialize SsrDataResponse.markup into an HTML string
 * @param results An array of responses from getServerData hooks
 * @returns A string of HTML generated from markup metadata
 */
export function createHeadMarkup(results) {
    // Loop through the <title>, <script>, <meta>, and <link> tag information
    // Create an HTML string for each tag
    let hasTitle = false;
    return results.reduce((str, { markup: { title, scripts = [], meta = [], links = [], styles = [] } = {} }) => {
        if (title && !hasTitle) {
            // first <title> wins
            hasTitle = true;
            str += `<title>${title}</title>\n`;
        }
        return (str +
            createMetaTags(meta) +
            createScriptTags(scripts) +
            createLinkTags(links) +
            createStyleTags(styles));
    }, '');
}
/**
 * Serialize SsrDataResponse.markup into HTML, then add it to the <head> of a base doc
 * @param results An array of responses from getServerData hooks
 * @param stringBuilder The string builder for a base document
 */
export function addHeadMarkup(results, stringBuilder) {
    // Create HTML tags for each item in the SsrDataResponse.markup bag
    const headMarkup = createHeadMarkup(Object.values(results));
    if (headMarkup) {
        // Add all the links to the <head> section of the base document
        const headIndex = stringBuilder.original.indexOf('</head>');
        if (headIndex >= 0) {
            stringBuilder.prependLeft(headIndex, headMarkup);
        }
        else {
            logger.error('Adding markup during server-side rendering failed. Could not find the </head> tag.');
        }
    }
}
//# sourceMappingURL=utils.js.map