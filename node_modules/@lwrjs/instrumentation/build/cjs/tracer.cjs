var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/instrumentation/src/tracer.ts
__markAsModule(exports);
__export(exports, {
  TraceLevel: () => TraceLevel,
  getTracer: () => getTracer
});
var import_api = __toModule(require("@opentelemetry/api"));
var import_package = __toModule(require("@lwrjs/instrumentation/package"));
var import_spans = __toModule(require("./spans.cjs"));
var import_context = __toModule(require("./context.cjs"));
var TraceLevel;
(function(TraceLevel2) {
  TraceLevel2["OFF"] = "off";
  TraceLevel2["DEFAULT"] = "default";
  TraceLevel2["VERBOSE"] = "verbose";
})(TraceLevel || (TraceLevel = {}));
function getTraceLevel() {
  const level = process.env.LWR_TRACING;
  if (!level) {
    return TraceLevel.OFF;
  }
  if (Object.values(TraceLevel).includes(level)) {
    return level;
  }
  return TraceLevel.DEFAULT;
}
function shouldTrace(level, name) {
  return level === TraceLevel.VERBOSE || level === TraceLevel.DEFAULT && import_spans.DefaultSpans.has(name);
}
function isPromise(promise) {
  return !!promise && typeof promise.then === "function";
}
function handleError(span, error) {
  if (error) {
    span.recordException(error);
  }
  span.setStatus({code: import_api.SpanStatusCode.ERROR, message: error?.message});
  span.end();
}
var Tracer = class {
  constructor() {
    this.traceLevel = getTraceLevel();
  }
  startSpan(id, options) {
    if (!shouldTrace(this.traceLevel, id.name)) {
      return new DisabledSpan();
    }
    return new LwrSpanImpl(id, options);
  }
  trace(id, fn) {
    if (!shouldTrace(this.traceLevel, id.name)) {
      return fn(new DisabledSpan());
    }
    const api = import_api.trace.getTracer("lwr", import_package.version);
    const activeContext = import_api.context.active();
    return import_api.context.with(activeContext.setValue(import_context.LWR_TRACE_CONTEXT, (0, import_context.getContextKey)()), () => {
      return api.startActiveSpan(id.name, (span) => {
        if (id.attributes) {
          span.setAttributes(id.attributes);
        }
        span.setAttribute("lwrVersion", import_package.version);
        try {
          const lwrSpan = {
            traceId: span.spanContext().traceId,
            setAttributes: span.setAttributes.bind(span),
            end: span.end
          };
          const result = fn(lwrSpan);
          if (isPromise(result)) {
            result.then(() => span.end(), (err) => handleError(span, err));
            return result;
          }
          span.end();
          return result;
        } catch (err) {
          handleError(span, err);
          throw err;
        }
      });
    });
  }
};
var LwrSpanImpl = class {
  constructor(id, options) {
    const api = import_api.trace.getTracer("lwr", import_package.version);
    const activeContext = import_api.context.active();
    this.span = api.startSpan(id.name, options, activeContext);
    if (id.attributes) {
      this.setAttributes(id.attributes);
    }
  }
  get traceId() {
    return this.span.spanContext().traceId;
  }
  setAttributes(attributes) {
    this.span.setAttributes(attributes);
    return this;
  }
  end(endTime) {
    this.span.end(endTime);
  }
};
var DisabledSpan = class {
  constructor() {
    this.traceId = "";
  }
  setAttributes(attributes) {
    return this;
  }
  end() {
    return;
  }
};
var getTracer = (() => {
  const tracer = new Tracer();
  return () => tracer;
})();
