import { context } from '@opentelemetry/api';
import { hrTimeToMilliseconds, suppressTracing } from '@opentelemetry/core';
import { ServerTimingSupportedSpans } from './spans.js';
export function convertMetricsToString(traceObj) {
    if (!traceObj)
        return '';
    return Object.entries(traceObj)
        .map(([spanName, duration]) => {
        const metricName = spanName.split('lwr.view.')[1];
        return `${metricName || spanName};dur=${duration}`;
    })
        .join(',');
}
class TraceCollector {
    constructor() {
        this.traceMap = {};
    }
    onStart(span) {
        // Track both child and parent spans
        context.with(suppressTracing(context.active()), () => {
            if (
            // Check if the span is meant to be tracked
            !ServerTimingSupportedSpans.has(span.name) ||
                // Verify the page doesn't throw error
                span.status.code !== 0) {
                return;
            }
            const { traceId } = span.spanContext();
            if (!this.traceMap[traceId]) {
                this.traceMap[traceId] = {};
            }
        });
    }
    shutdown() {
        /* noop */
        return Promise.resolve();
    }
    forceFlush() {
        /* noop */
        return Promise.resolve();
    }
    onEnd(span) {
        context.with(suppressTracing(context.active()), () => {
            if (
            // Check if the span is meant to be tracked
            !ServerTimingSupportedSpans.has(span.name) ||
                // Verify the page doesn't throw error
                span.status.code !== 0) {
                return;
            }
            const { traceId } = span.spanContext();
            const traceObj = this.traceMap[traceId], duration = traceObj?.[span.name] || 0;
            if (traceObj) {
                traceObj[span.name] = duration + Number(hrTimeToMilliseconds(span.duration).toFixed(2));
            }
        });
    }
    getSpansInTrace(traceId) {
        // Get the trace values in Server timing format
        return convertMetricsToString(this.traceMap[traceId]);
    }
    dropTrace(traceId) {
        delete this.traceMap[traceId];
    }
    clearAllTraces() {
        this.traceMap = {};
    }
}
/**
 * TraceCollector Singleton
 */
export const getTraceCollector = (() => {
    const traceCollector = new TraceCollector();
    return () => traceCollector;
})();
//# sourceMappingURL=trace-collector.js.map