import { ExportResultCode, hrTimeToMilliseconds, hrTimeToTimeStamp } from '@opentelemetry/core';
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import { MetricsSender } from '@salesforce/pwa-kit-runtime/utils/ssr-server/metrics-sender.js';
import { RequestHandlerSpan, ViewSpan } from './spans.js';
const DEFAULT_DIMENSIONS = {
    Project: process.env.MOBIFY_PROPERTY_ID,
    Target: process.env.DEPLOY_TARGET,
};
// only report metrics that are used for graphs
const SUPPORTED_SPANS = new Set([
    RequestHandlerSpan.GetView,
    RequestHandlerSpan.GetAsset,
    ViewSpan.ExecuteRouteHandler,
    ViewSpan.GetServerData,
]);
function toDurationMetric(name, span) {
    return {
        name,
        dimensions: DEFAULT_DIMENSIONS,
        timestamp: new Date(hrTimeToTimeStamp(span.startTime)),
        unit: 'Milliseconds',
        value: hrTimeToMilliseconds(span.duration),
    };
}
function toCountMetric(name, span) {
    return {
        name,
        dimensions: DEFAULT_DIMENSIONS,
        timestamp: new Date(hrTimeToTimeStamp(span.startTime)),
        unit: 'Count',
        value: 1,
    };
}
function getErrorType(span) {
    if (span.status.code > 0 && span.events.length === 0) {
        return;
    }
    for (const event of span.events) {
        if (event.name === 'exception' && event.attributes) {
            if (typeof event.attributes['exception.type'] === 'string') {
                return event.attributes['exception.type'];
            }
        }
    }
}
function isFrameworkError(errorType) {
    return errorType !== 'DiagnosticError' && errorType !== 'ApplicationError';
}
function toCustomMetrics(span) {
    const metrics = [];
    const errorType = getErrorType(span);
    // view availability metrics
    if (span.name === RequestHandlerSpan.GetView) {
        metrics.push(toDurationMetric('ResolveViewTime', span));
        if (errorType && isFrameworkError(errorType)) {
            metrics.push(toCountMetric('ResolveViewErrors', span));
        }
    }
    // route handler availability metrics
    if (span.name === ViewSpan.ExecuteRouteHandler) {
        metrics.push(toDurationMetric('RouteHandlerTime', span));
        if (errorType && errorType === 'ApplicationError') {
            metrics.push(toCountMetric('RouteHandlerErrors', span));
        }
    }
    // asset availability metrics
    if (span.name === RequestHandlerSpan.GetAsset) {
        metrics.push(toDurationMetric('ResolveAssetTime', span));
        if (errorType && isFrameworkError(errorType)) {
            metrics.push(toCountMetric('ResolveAssetErrors', span));
        }
    }
    // external request availability metrics
    if (span.name === ViewSpan.GetServerData) {
        // reusing pwa-kit metric name for `getServerData` duration
        metrics.push(toDurationMetric('ExternalRequestTime', span));
        if (errorType && isFrameworkError(errorType)) {
            // reusing pwa-kit metric name for `getServerData` errors
            metrics.push(toCountMetric('ExternalRequestFailed', span));
        }
    }
    return metrics;
}
export function convertToReadableSpan(span) {
    if (!span) {
        return {};
    }
    return {
        traceId: span.spanContext?.().traceId,
        parentId: span.parentSpanId,
        traceState: span.spanContext?.().traceState?.serialize(),
        name: span.name,
        id: span.spanContext?.().spanId,
        kind: span.kind,
        ...(span.startTime
            ? {
                timestamp: hrTimeToTimeStamp(span.startTime),
            }
            : {}),
        ...(span.duration
            ? {
                duration: hrTimeToMilliseconds(span.duration),
            }
            : {}),
        attributes: span.attributes,
        status: span.status,
        events: span.events,
        links: span.links,
    };
}
export class AWSExporter {
    constructor() {
        this.metricsSender = MetricsSender.getSender();
        this.isShutdown = false;
        // Use the env variable directly rather than shared utils to avoid dependencies in this package
        this.isLambda = process.env.AWS_LAMBDA_FUNCTION_NAME;
    }
    export(spans, done) {
        if (this.isShutdown) {
            done({
                code: ExportResultCode.FAILED,
                error: new Error('Failed to export spans: Exporter shutdown'),
            });
            return;
        }
        // log all spans even if they are not exported as a custom metric
        this.log(spans);
        if (!this.isLambda) {
            done({ code: ExportResultCode.SUCCESS });
            return;
        }
        this.send(spans.filter(({ name }) => SUPPORTED_SPANS.has(name)), done);
    }
    log(spans) {
        for (const span of spans) {
            // eslint-disable-next-line
            console.log(JSON.stringify(convertToReadableSpan(span)));
        }
    }
    send(spans, done) {
        this.metricsSender.send(spans.map(toCustomMetrics).flat());
        done({ code: ExportResultCode.SUCCESS });
    }
    async shutdown() {
        this.isShutdown = true;
    }
}
//# sourceMappingURL=aws-exporter.js.map