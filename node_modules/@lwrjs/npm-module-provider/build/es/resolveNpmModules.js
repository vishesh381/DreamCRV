import { join } from 'path';
import resolve from 'resolve';
import esbuildEsm from 'esbuild';
import NodeModulesPolyfills from '@esbuild-plugins/node-modules-polyfill';
import { logger } from '@lwrjs/diagnostics';
// https://github.com/evanw/esbuild/issues/706
// Fixed in 0.11.0 but upgrading past 0.9.7 has caused breaking changes for consumers...
// https://github.com/salesforce-experience-platform-emu/lwr/issues/1014
let esbuild = esbuildEsm;
if (!esbuildEsm) {
    try {
        esbuild = require('esbuild');
    }
    catch {
        /* this is to support mjs/cjs dual impl */
    }
}
const NodePolyfillsPlugin = NodeModulesPolyfills.default || NodeModulesPolyfills;
const ExternalsPlugin = function ({ external }) {
    return {
        name: 'replace-extension-plugin',
        setup(build) {
            build.onResolve({ filter: /.*/ }, ({ path, importer }) => {
                if (importer && external && external.includes(path)) {
                    return { path, external: true };
                }
            });
        },
    };
};
export async function resolveNpmModuleSpecifierBlock(specifier, dest, config) {
    let res;
    try {
        let pkgVersion;
        try {
            res = resolve.sync(specifier, {
                packageFilter: function (pkg) {
                    const { exports, browser } = pkg;
                    if (exports && exports['.']) {
                        const root = exports['.'];
                        pkg.main =
                            root?.browser?.import ||
                                root?.browser?.default ||
                                (typeof root?.browser === 'string' ? root.browser : undefined) ||
                                root?.import?.browser?.default ||
                                root?.import?.default ||
                                (typeof root?.import === 'string' ? root.import : undefined) ||
                                root?.default;
                    }
                    else if (browser && typeof browser === 'string') {
                        pkg.main = pkg.browser;
                    }
                    else if (pkg.module) {
                        pkg.main = pkg.module;
                    }
                    // grab package.json version (if set) before we go
                    if (pkg.version) {
                        pkgVersion = pkg.version;
                    }
                    return pkg;
                },
            });
        }
        catch (error) {
            // Just return undefined from resolve module not found
            if (error.code === 'MODULE_NOT_FOUND') {
                logger.debug({
                    label: 'npm-module-provider',
                    message: `Failed to resolve ${specifier} from npm`,
                    additionalInfo: { cause: error },
                });
                return undefined;
            }
            throw error;
        }
        if (!res) {
            return undefined;
        }
        // ensure package version is set
        if (pkgVersion === undefined) {
            throw new Error('Failed to find version in package.json');
        }
        const outfile = join(dest, specifier, '_bundle.js');
        const cacheKey = `${specifier}@${pkgVersion}`;
        await esbuild.build({
            entryPoints: [res],
            format: 'esm',
            bundle: true,
            write: true,
            platform: 'browser',
            mainFields: ['browser', 'module', 'main'],
            outfile: outfile,
            define: {
                'process.env.NODE_ENV': JSON.stringify('production'),
            },
            plugins: [ExternalsPlugin(config), NodePolyfillsPlugin()],
        });
        return {
            id: cacheKey,
            entry: outfile,
            specifier,
            version: pkgVersion,
        };
    }
    catch (err) {
        logger.error(`[npm-module-provider][esbuild] resolveNpmModules: ${specifier} ${dest}`, { res, err });
    }
}
class Queue {
    constructor() {
        this.queue = [];
        this.workingOnPromise = false;
        this.pendingPromise = false;
    }
    enqueue(promise) {
        return new Promise((resolve, reject) => {
            this.queue.push({ promise, resolve, reject });
            this.dequeue();
        });
    }
    dequeue() {
        if (this.workingOnPromise) {
            return false;
        }
        const item = this.queue.shift();
        if (!item) {
            return false;
        }
        this.workingOnPromise = true;
        try {
            item.promise()
                .then((value) => {
                this.workingOnPromise = false;
                item.resolve(value);
                this.dequeue();
            })
                .catch((err) => {
                this.workingOnPromise = false;
                item.reject(err);
                this.dequeue();
            });
        }
        catch (err) {
            this.workingOnPromise = false;
            item.reject(err);
            this.dequeue();
        }
        return true;
    }
}
const RESOLVER_QUEUE = new Queue();
export async function resolveNpmModuleSpecifier(specifier, dest, config) {
    return RESOLVER_QUEUE.enqueue(resolveNpmModuleSpecifierBlock.bind(null, specifier, dest, config));
}
//# sourceMappingURL=resolveNpmModules.js.map