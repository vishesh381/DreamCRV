if (getFeatureFlags().REEVALUATE_MODULES && !getFeatureFlags().LEGACY_LOADER) {
    throw new Error('REEVALUATE_MODULES is only supported with LEGACY_LOADER');
}
export function getFeatureFlags() {
    return {
        // Should we load load the assets from the lambda on MRT
        ASSETS_ON_LAMBDA: parseBooleanFlag('ASSETS_ON_LAMBDA'),
        // Number of BundleDefinition and BundleCode instances held in memory
        BUNDLE_CACHE_SIZE: parseStringFlag('BUNDLE_CACHE_SIZE'),
        ENABLE_NONCE: parseBooleanFlag('ENABLE_NONCE'),
        // AMD Module Bundles include un-versioned aliases
        EXPERIMENTAL_UNVERSIONED_ALIASES: parseBooleanFlag('EXPERIMENTAL_UNVERSIONED_ALIASES'),
        // DEFAULT LEGACY_LOADER = false;
        LEGACY_LOADER: parseBooleanFlag('LEGACY_LOADER'),
        // Enable metrics log level 'off', 'default' or 'verbose'
        LWR_TRACING: parseTracingFlag(),
        // Max size of ViewDefinition time to live
        MAX_VIEW_CACHE_TTL: parseStringFlag('MAX_VIEW_CACHE_TTL'),
        // Forces SSR to re-evaluate modules for every page render. By default, modules are evaluated only once.
        REEVALUATE_MODULES: parseBooleanFlag('REEVALUATE_MODULES'),
        // Use the LWC SSR compiler and v2 SSR API
        SSR_COMPILER_ENABLED: parseBooleanFlag('SSR_COMPILER_ENABLED'),
        // Create a new SSR Loader on every request
        SSR_LOADER_PER_REQUEST: parseBooleanFlag('SSR_LOADER_PER_REQUEST'),
        // Islands fallback to CSR if SSR fails
        SSR_WITH_CSR_FALLBACK: parseBooleanFlag('SSR_WITH_CSR_FALLBACK'),
        // Max number of ViewDefinitions help in memory
        VIEW_CACHE_SIZE: parseStringFlag('VIEW_CACHE_SIZE'),
        // Allows setting/overriding headers for non-immutable assets.
        // Expected format is `<header_key_1>: <header_value_1>, header_value_2>; <header_key_2>: <header_value_2>`
        // E.g., assetHeadersString Cloudflare-CDN-Cache-Control: max-age=2813308004; Cache-Tag: ABC123;
        EXPERIMENTAL_ASSET_HEADERS: parseStringFlag('EXPERIMENTAL_ASSET_HEADERS'),
    };
}
/**
 * Helper function to parse boolean environment variables.
 * Returns true if the variable is set to 'true', false otherwise.
 */
function parseBooleanFlag(flag) {
    return process.env[flag]?.toLowerCase() === 'true' || false;
}
/**
 * Helper function to parse string environment variables.
 * Returns the trimmed string if the variable is defined, otherwise returns undefined.
 */
function parseStringFlag(flag) {
    const value = process.env[flag]?.trim();
    return value || undefined;
}
/**
 * Helper function to parse the LWR_TRACING flag.
 * Returns the value if it's not 'off' and is defined, otherwise returns false.
 */
function parseTracingFlag() {
    const tracingValue = process.env.LWR_TRACING?.toLowerCase();
    return tracingValue && tracingValue !== 'off' ? process.env.LWR_TRACING : undefined;
}
/**
 * This function is used to determine if the current environment is a lambda.
 *
 * @returns true if process is running in lambda environment
 */
export function isLambdaEnv() {
    return process.env.AWS_LAMBDA_FUNCTION_NAME !== undefined;
}
/**
 * This function is used to determine if lwr is running in the context of local development.
 *
 * @returns true if running in localdev mode
 */
export function isLocalDev() {
    // TODO still need to formalize environment variable names
    return process.env.MRT_HMR === 'true';
}
/**
 * This function is used to determine if lwr is running in the context of local preview.
 *
 * @returns true if running in preview mode
 */
export function isLocalPreview() {
    return process.env.LOCAL_PREVIEW_MODE === 'true';
}
/**
 * This function is used to determine if lwr is running with an authenticated context locally
 *
 * @returns true if local dev/preview authentication is enabled
 */
export function isLocalAuthEnabled() {
    return process.env.AUTH_TOKEN !== undefined;
}
/**
 * Create a serializable context for user-land exposed environment variables
 */
export function buildEnvironmentContext(runtimeParams) {
    // The baseBath from the config or set from the request (e.g. /shop)
    const basePath = runtimeParams.basePath;
    // The locale set from the request or the defaultLocale from the config (e.g. en-US)
    const locale = runtimeParams.locale;
    // Root base path for static assets (e.g. /shop/mobify/bundle/1234/site)
    const assetBasePath = runtimeParams.assetBasePath;
    // Base path for UI routing (e.g. /shop/en-US)
    const uiBasePath = runtimeParams.uiBasePath;
    return {
        basePath,
        locale,
        assetBasePath,
        uiBasePath,
    };
}
export const REQUEST_DEPTH_HEADER = 'X-SFDC-Request-Depth';
export const REQUEST_DEPTH_KEY = REQUEST_DEPTH_HEADER.toLowerCase();
export function parseRequestDepth(headers = {}, query = {}) {
    let maxDepth = 0;
    const value = headers && headers[REQUEST_DEPTH_KEY];
    if (value) {
        if (Array.isArray(value)) {
            for (const depth of value) {
                if (typeof depth === 'string') {
                    const depthValue = parseInt(depth, 10);
                    if (!isNaN(depthValue) && depthValue > maxDepth) {
                        maxDepth = depthValue;
                    }
                }
            }
        }
        else if (typeof value === 'string') {
            const depth = parseInt(value, 10);
            if (!isNaN(depth) && depth > maxDepth) {
                maxDepth = depth;
            }
        }
    }
    if (query[REQUEST_DEPTH_KEY]) {
        const queryValue = parseInt(query[REQUEST_DEPTH_KEY], 10);
        if (!isNaN(queryValue) && queryValue > maxDepth) {
            maxDepth = queryValue;
        }
    }
    return maxDepth;
}
//# sourceMappingURL=env.js.map