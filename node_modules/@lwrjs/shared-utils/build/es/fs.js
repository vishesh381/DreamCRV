import fs from 'fs-extra';
import pathLib from 'path';
import url from 'url';
import crypto from 'crypto';
import { slugify } from './identity.js';
import { LwrUnresolvableError, createSingleDiagnosticError, descriptions } from '@lwrjs/diagnostics';
import { lookup } from 'mime-types';
import { Readable } from 'stream';
import { logger } from '@lwrjs/diagnostics';
let fileCount = 0;
const files = new Map();
// LWR Internal URL protocol
export const PROTOCOL_HTTP = 'http://';
export const PROTOCOL_HTTPS = 'https://';
export const PROTOCOL_FILE = 'file://';
/**
 * Create a hash string for a source
 * @param source
 */
export function hashContent(source) {
    return crypto.createHash('md5').update(source).digest('hex');
}
/**
 * Create a Sub-resource Integrity Hash https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity
 */
export function createIntegrityHash(source) {
    const hash = crypto.createHash('sha256').update(source).digest('base64');
    return `sha256-${hash}`;
}
/**
 * Read in the contents of the file path
 * @param filePath
 */
export function readFile(filePath) {
    logMetrics(filePath);
    return fs.readFileSync(filePath, 'utf8');
}
/**
 * Given a filepath, ensure it has a file extension by checking for the file on the fs
 * @param filePath
 */
export function resolveFileExtension(filePath) {
    const fileName = pathLib.basename(filePath);
    const hasExt = !!pathLib.extname(fileName);
    // If it has extension just return it
    if (hasExt) {
        return filePath;
    }
    // No extension, if it exist, it can be a dir or a file
    if (fs.existsSync(filePath)) {
        if (fs.statSync(filePath).isFile()) {
            return filePath; // extension-less file, which is odd but...
        }
        else {
            filePath = pathLib.join(filePath, 'index'); // if is a dir we will be testing the extensions
        }
    }
    // At this point we have a file with no extension so we try for the default (js,ts) or fail
    if (fs.existsSync(filePath + '.js')) {
        return filePath + '.js';
    }
    else if (fs.existsSync(filePath + '.ts')) {
        return filePath + '.ts';
    }
    else {
        throw new Error(`Unable to find file "${filePath}"`);
    }
}
/**
 * Returns if view of specific type can be resolved
 *
 * @param source - possible path to view
 * @param type - extension of file that should be expected, i.e. 'html'
 */
export function canResolveView(source, type) {
    if (typeof source !== 'string') {
        return false;
    }
    if (!source.endsWith(`.${type}`)) {
        return false;
    }
    if (!fs.existsSync(pathLib.resolve(source))) {
        throw new Error(`View template cannot be found: "${source}"`);
    }
    return true;
}
/**
 * Construct a ViewSource from the associated file on the fs
 * @param source - Filepath with the source (source can be an absolute or relative path)
 * @param viewFolder - File in the fs which holds the view
 */
export function getViewSourceFromFile(source) {
    const sourceFilePath = pathLib.resolve(source);
    const viewSource = readFile(sourceFilePath);
    const ext = pathLib.extname(sourceFilePath);
    const name = pathLib.basename(sourceFilePath, ext);
    return {
        name,
        slug: slugify(name),
        filePath: sourceFilePath,
        ownHash: hashContent(viewSource),
        originalSource: viewSource,
    };
}
/**
 * Replace all instances of `$rootDir` with `rootDir`
 * @param dir
 * @param rootDir
 */
const ROOT_DIR_REGEX = /\$rootDir/g;
export function normalizeDirectory(dir, rootDir) {
    return dir.replace(ROOT_DIR_REGEX, rootDir);
}
/**
 * Replace all instances of `$rootDir` with `rootDir`.
 * Convert path to file:// url
 * @param file
 * @param rootDir
 */
export function normalizeToFileUrl(filePath, rootDir) {
    // Check if filePath already starts with 'file://'
    if (filePath.startsWith(PROTOCOL_FILE)) {
        return filePath;
    }
    const replacedPath = filePath.replace(ROOT_DIR_REGEX, rootDir);
    const fullPath = pathLib.resolve(rootDir, replacedPath);
    return url.pathToFileURL(fullPath).href;
}
export function normalizeFromFileURL(fileURL, basePath) {
    if (typeof fileURL !== 'string' || !fileURL.startsWith('file://')) {
        return null;
    }
    // Convert fileURL to a system-specific path
    const filePath = url.fileURLToPath(fileURL);
    // Resolve and normalize base path to ensure it's in the correct format and system-specific
    const normalizedBasePath = pathLib.resolve(pathLib.normalize(basePath));
    // Ensure compatibility across different OS by replacing path separators accordingly
    const compatibleFilePath = filePath.split(pathLib.sep).join('/');
    const compatibleBasePath = normalizedBasePath.split(pathLib.sep).join('/');
    // Check if filePath starts with the basePath
    if (compatibleFilePath.startsWith(compatibleBasePath)) {
        // Return the relative path from basePath, ensuring it starts with a '/'
        const relativePath = '/' + pathLib.relative(normalizedBasePath, filePath).split(pathLib.sep).join('/');
        return relativePath;
    }
    else {
        // Return the full path if outside of basePath, ensuring it starts with a '/'
        return compatibleFilePath.startsWith('/') ? compatibleFilePath : '/' + compatibleFilePath;
    }
}
export function isLocalPath(filePath) {
    // handle null or undefined
    if (!filePath) {
        return false;
    }
    // Check for protocol-relative URLs or network paths
    if (filePath.startsWith('//')) {
        return false;
    }
    // Check for file protocol or absolute file paths on Unix/Linux
    if (filePath.startsWith('$rootDir') || filePath.startsWith(PROTOCOL_FILE) || filePath.startsWith('/')) {
        return true;
    }
    // Check for Windows absolute paths (e.g., C:\path\to\file)
    if (/^[a-zA-Z]:\\/.test(filePath)) {
        return true;
    }
    // Consider anything not identified as a file protocol or an absolute path as non-local
    return false;
}
/**
 * Replace all instances of `$*Dir` with `resourcePaths.*Dir`
 * @param rawPath
 * @param param1 - root directories
 */
const RESOURCE_DIR_REGEX = /\$(\w+)|^\$(\w+)/g;
export function normalizeResourcePath(rawPath, { rootDir, assets, contentDir, layoutsDir }, allowUnresolvedAlias) {
    const assetsMap = assets.reduce((map, asset) => {
        if (asset.alias) {
            // Asset config has either a "dir" OR a "file"
            map[asset.alias] = asset.dir || asset.file;
        }
        return map;
    }, { rootDir, contentDir, layoutsDir });
    return rawPath.replace(RESOURCE_DIR_REGEX, function (fullMatch, m1, m2) {
        const alias = assetsMap[m1] || assetsMap[m2];
        if (!alias && !allowUnresolvedAlias) {
            throw createSingleDiagnosticError({
                description: descriptions.UNRESOLVABLE.DIR_ALIAS(fullMatch),
            }, LwrUnresolvableError);
        }
        return alias;
    });
}
export { lookup as mimeLookup };
function logMetrics(filePath) {
    if (logger.isDebugEnabled()) {
        let count = files.get(filePath) || 0;
        if (++count % 100 === 0) {
            logger.debug({ label: `logMetrics`, message: `[${count}] Repeat Read ${filePath}` });
        }
        files.set(filePath, count);
        if (++fileCount % 1000 === 0) {
            logger.debug({ label: `logMetrics`, message: `Open file count [${fileCount}]` });
        }
    }
}
/**
 * Tries to convert any URL or $aliased path into a canonical fs path
 */
export function normalizeAssetSpecifier(assetId, assetPathMap, resourcePaths, basePath) {
    const { specifier, importer, type } = assetId;
    if (specifier.startsWith('./') || specifier.startsWith('../')) {
        if (!importer) {
            throw Error(`Unable to resolve relative import "${specifier}" without an importer.`);
        }
        return pathLib.join(pathLib.dirname(importer), specifier);
    }
    if (type === 'content-asset') {
        const originSpecifier = !basePath ? specifier : specifier.split(basePath)[1];
        return pathLib.join(resourcePaths.contentDir, originSpecifier);
    }
    if (specifier[0] === '$') {
        // This is a fs path containing an asset alias
        return normalizeResourcePath(specifier, resourcePaths);
    }
    // This is an absolute path to the server
    // Match in 2 ways:
    //      - Directories: the prefix of the asset specifier/path matches a configured assets[i].urlPath
    //      - Individual files: the asset specifier is equal to a configured assets[i].urlPath
    for (const [urlPath, fsPath] of assetPathMap.entries()) {
        const slashPath = urlPath.endsWith('/') ? urlPath : `${urlPath}/`;
        const fsSlashPath = fsPath.endsWith('/') ? fsPath : `${fsPath}/`;
        // Matches directory
        if (specifier.startsWith(slashPath)) {
            return specifier.replace(slashPath, fsSlashPath);
            // Matches File
        }
        else if (specifier === urlPath) {
            return specifier.replace(urlPath, fsPath);
        }
    }
    return specifier;
}
export function streamToString(stream, encoding = 'utf8') {
    const chunks = [];
    return new Promise((resolve, reject) => {
        stream.on('data', (c) => chunks.push(c));
        stream.on('error', reject);
        stream.on('end', () => resolve(Buffer.concat(chunks).toString(encoding)));
    });
}
export function stringToStream(str) {
    let index = 0;
    const isBuffer = Buffer.isBuffer(str);
    const readable = new Readable({
        read(size) {
            if (index >= str.length) {
                this.push(null);
                return;
            }
            let chunk;
            if (isBuffer) {
                chunk = str.subarray(index, index + size);
            }
            else {
                chunk = str.slice(index, index + size);
            }
            index += size;
            this.push(chunk);
        },
    });
    return readable;
}
// Function to filter out entries where the value starts with given protocol
export function filterProtocolEntries(record, protocol) {
    // Use Object.entries to get an array of [key, value] pairs,
    // then filter out the pairs where value starts with {protocol}
    const filteredEntries = Object.entries(record).filter(([_key, value]) => !value || !value.startsWith(protocol));
    // Use Object.fromEntries to convert the filtered entries back into an object
    return Object.fromEntries(filteredEntries);
}
//# sourceMappingURL=fs.js.map