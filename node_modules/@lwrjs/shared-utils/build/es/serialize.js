import ms from 'ms';
// Given a Module Identifier, return a JSON entry
async function createJsonModule(moduleId, moduleRegistry, runtimeEnvironment, runtimeParams) {
    const { ownHash, moduleEntry: { version }, } = await moduleRegistry.getModule(moduleId, runtimeParams);
    return {
        specifier: moduleId.specifier,
        version,
        ownHash,
        links: {
            self: await moduleRegistry.resolveModuleUri(moduleId, runtimeEnvironment, runtimeParams, ownHash),
        },
    };
}
/**
 * Take a Module Definition and return its JSON serialization
 *
 * @param code - the compiled code string for the given module
 * @param param1 - the Module Definition to serialize
 * @param moduleRegistry
 * @returns - Promise to the JSON serialization of the module
 */
export async function serializeModuleToJson(code = '', { specifier, version, ownHash, runtimeEnvironment, linkedConfig: { minified }, moduleRecord: { imports = [] }, }, moduleRegistry, runtimeParams) {
    const { format } = runtimeEnvironment;
    // Build the dependencies array
    const dependencies = imports.map((dep) => createJsonModule(dep, moduleRegistry, runtimeEnvironment, runtimeParams));
    return {
        specifier,
        version,
        ownHash,
        dependencies: await Promise.all(dependencies),
        format,
        minified,
        code,
    };
}
/**
 * Replace a part of a source string at the indices with a different value
 *
 * @param src - source string
 * @param param1 - offset indices
 * @param replaceValue - replacement
 */
export function replaceStringFromLocation(src, { startOffset, endOffset }, replaceValue) {
    return src.substr(0, startOffset) + replaceValue + src.substr(endOffset, src.length);
}
/**
 * Given two TTLs, return the shortest one
 * @param newTtl - time-to-live: time string or number of seconds
 * @param oldTtl - the current shortest TTL (if it exists)
 * @returns - the shorter of the two TTLs IN SECONDS, undefined if both TTLs are missing
 */
export function shortestTtl(newTtl, oldTtl, maxTtl) {
    if (newTtl === undefined && oldTtl === undefined)
        return undefined;
    const newSeconds = typeof newTtl === 'string' ? ms(newTtl) / 1000 : newTtl;
    const oldSeconds = typeof oldTtl === 'string' ? ms(oldTtl) / 1000 : oldTtl;
    const maxSeconds = typeof maxTtl === 'string' ? ms(maxTtl) / 1000 : maxTtl;
    let shortest = undefined;
    if (newSeconds !== undefined && (shortest === undefined || newSeconds < shortest)) {
        shortest = newSeconds;
    }
    if (oldSeconds !== undefined && (shortest === undefined || oldSeconds < shortest)) {
        shortest = oldSeconds;
    }
    if (maxSeconds !== undefined && (shortest === undefined || maxSeconds < shortest)) {
        shortest = maxSeconds;
    }
    return shortest;
}
//# sourceMappingURL=serialize.js.map