import { pathToRegexp } from 'path-to-regexp';
import path from 'path';
import os from 'os';
import { pathToFileURL } from 'url';
const CONFIG_SUFFIX = '/config.js';
const SIGNATURE_SIGIL = 's';
export function getClientBootstrapConfigurationUri(routeInfo, runtimeEnvironment, runtimeParams, signature) {
    // Add extra dashes around encoded path so when saved as static file leading and
    // trailing slashes are preserved as file path.
    const url = routeInfo.url + sortedQueryParamString(routeInfo.query);
    const encodeUrl = `-${encodeURIComponent(url)}-`;
    const configUrlPrefix = getClientBootstrapConfigurationUriPrefix(routeInfo, runtimeEnvironment, runtimeParams);
    const signatureSegment = signature ? `/${SIGNATURE_SIGIL}/${signature}` : '';
    return `${configUrlPrefix}/${encodeUrl}${signatureSegment}${CONFIG_SUFFIX}`;
}
export function decodeViewPath(encodedViewPath) {
    let decodePath = decodeURIComponent(encodedViewPath);
    // Remove surrounding dashes
    if (encodedViewPath.startsWith('-') && encodedViewPath.endsWith('-')) {
        decodePath = decodePath.substring(1, decodePath.length - 1);
    }
    return decodePath;
}
export function getClientBootstrapConfigurationUriPrefix(routeInfo, runtimeEnvironment, runtimeParams) {
    const { apiVersion, format, basePath } = runtimeEnvironment;
    const { id } = routeInfo;
    const locale = runtimeParams?.locale;
    const environment = runtimeParams?.environment;
    if (locale && environment) {
        return `${basePath}/${apiVersion}/application/${format}/l/${locale}/e/${environment}/ai/${id}/configuration/ci`;
    }
    else if (locale) {
        return `${basePath}/${apiVersion}/application/${format}/l/${locale}/ai/${id}/configuration/ci`;
    }
    else if (environment) {
        return `${basePath}/${apiVersion}/application/${format}/e/${environment}/ai/${id}/configuration/ci`;
    }
    else {
        return `${basePath}/${apiVersion}/application/${format}/ai/${id}/configuration/ci`;
    }
}
/**
 * Remove the suffix from config
 */
export function removeClientBootstrapConfigurationSuffix(url) {
    let ret = url;
    if (url.endsWith(CONFIG_SUFFIX)) {
        ret = url.slice(0, -CONFIG_SUFFIX.length);
    }
    return ret;
}
/**
 * Get the parameterized client bootstrap app configuration routes
 */
export function getClientBootstrapConfigurationRoutes() {
    return [
        `/:apiVersion/application/:format/l/:locale/ai/:appId/configuration/ci/:encodedViewPath${CONFIG_SUFFIX}`,
        `/:apiVersion/application/:format/l/:locale/e/:environment/ai/:appId/configuration/ci/:encodedViewPath${CONFIG_SUFFIX}`,
        `/:apiVersion/application/:format/ai/:appId/configuration/ci/:encodedViewPath${CONFIG_SUFFIX}`,
        `/:apiVersion/application/:format/e/:environment/ai/:appId/configuration/ci/:encodedViewPath${CONFIG_SUFFIX}`,
        // with signature
        `/:apiVersion/application/:format/l/:locale/ai/:appId/configuration/ci/:encodedViewPath/s/:signature${CONFIG_SUFFIX}`,
        `/:apiVersion/application/:format/l/:locale/e/:environment/ai/:appId/configuration/ci/:encodedViewPath/s/:signature${CONFIG_SUFFIX}`,
        `/:apiVersion/application/:format/ai/:appId/configuration/ci/:encodedViewPath/s/:signature${CONFIG_SUFFIX}`,
        `/:apiVersion/application/:format/e/:environment/ai/:appId/configuration/ci/:encodedViewPath/s/:signature${CONFIG_SUFFIX}`,
    ];
}
/**
 * Extract param values from a resolved URL based on a parameterized route.  Keep existing param values.
 * Uses path-to-regexp to match -> https://www.npmjs.com/package/path-to-regexp
 *
 * extractRequestParams('/:p1/:p2*', '/foo/bar/barz', {e1:'v1'}) => {e1:'v1', p1:'foo', p2:'bar/barz'}
 *
 * @param parameterizedRoute - A Url with parameter tokens
 * @param resolvedUrl - A url with tokens filled in to match against
 * @param existingParams - optional existing request parameters to match against
 * @returns A parameter maps with existing parameters plus token value pairs from route and url
 */
export function extractRequestParams(parameterizedRoute, resolvedUrl, existingParams) {
    const keys = [];
    const re = pathToRegexp(parameterizedRoute, keys);
    const params = existingParams || {};
    if (keys.length > 0) {
        const result = re.exec(resolvedUrl) || new Array(keys.length);
        for (let i = 0; i < keys.length; i++) {
            const key = keys[i].name;
            // result array if [url, value, value] so add 1 to count to get matching value
            const value = result[i + 1];
            params[key] = value;
        }
    }
    return params;
}
const isModuleOrBundleRegEx = /^\/.*\/(module|bundle)\//i;
export function isModuleOrBundleUrl(url) {
    return isModuleOrBundleRegEx.test(url);
}
/**
 * Return a view route URL considering the basePath and the i18N config
 */
export function getViewUri(routePath, basePath, locale, i18n) {
    // Use a regular expression to check if the URI has a domain
    if (isURL(routePath)) {
        return routePath;
    }
    let url = basePath;
    if (i18n.uriPattern === 'path-prefix' && locale !== i18n.defaultLocale) {
        url = path.join(url, `/${locale}`);
    }
    url = path.join(url, routePath);
    return url;
}
/**
 * Returns true is the URI starts with http:// or https://
 */
export function isURL(uri) {
    return /^https?:\/\//i.test(uri);
}
function sortedQueryParamString(query) {
    if (!query) {
        return '';
    }
    const keys = Object.keys(query);
    if (!keys || keys.length === 0) {
        return '';
    }
    const sortedKeys = keys.sort();
    return ('?' +
        sortedKeys
            .map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(query[key])}`)
            .join('&'));
}
// Only URLs with a scheme in: file, data, and node are supported by the default ESM loader
// On Windows, absolute paths must be valid file:// URLs.
// Without this code for windows, dynamic imports will fail
export function crossEnvFileURL(url) {
    if (os.platform() === 'win32' && !url.startsWith('@')) {
        return pathToFileURL(url).href;
    }
    return url;
}
//# sourceMappingURL=urls.js.map