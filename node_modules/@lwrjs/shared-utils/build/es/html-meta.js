import * as parse5 from 'parse5';
import { getPropFromAttrName, kebabCaseToModuleSpecifier } from './identity.js';
function parseAssetLocation(htmlSource, tagName, attrLocation) {
    const { startOffset, endOffset } = attrLocation;
    const srcAttr = htmlSource.substring(startOffset, endOffset);
    // Split src="myURL"
    const split = srcAttr.indexOf('=');
    const keyAttr = srcAttr.substr(0, split);
    // Also remove the "s to just get myURL
    const url = srcAttr.slice(split + 2, -1);
    return {
        url,
        tagName,
        relative: isRelative(url),
        location: {
            startOffset: startOffset + keyAttr.length + 2 /* =" */,
            endOffset: endOffset - 1,
        },
    };
}
function parseInlineStyleImages(htmlSource, tagName, attrLocation) {
    const imageAssets = [], 
    // Define a regex pattern to match the 'url()' part of inline styles
    urlPattern = /url\((.*?)\)/g, { startOffset, endOffset } = attrLocation, 
    // Extract the substring that contains the attribute (e.g., a 'style' attribute with inline CSS or <style></style> content)
    srcAttr = htmlSource.substring(startOffset, endOffset);
    // Initialize a variable to track the current parsing position
    let srcAttrStart = 0, match;
    // Loop through all matches of 'url(...)' in the inline style attribute
    while ((match = urlPattern.exec(srcAttr)) !== null) {
        // Extract the substring starting from the current position in srcAttr
        const currentStr = srcAttr.substring(srcAttrStart);
        imageAssets.push({
            // Clean up the URL by trimming quotes and spaces
            url: match[1].trim().replace(/^['"]|['"]$/g, ''),
            // Calculate the starting offset of the matched URL relative to the entire HTML source
            startOffset: startOffset + currentStr.indexOf(match[1]) + srcAttrStart,
            // Calculate the ending offset of the matched URL
            endOffset: startOffset + currentStr.indexOf(match[1]) + match[1].length + srcAttrStart,
        });
        // Move the srcAttrStart to the end of the currently matched URL to avoid picking up the already matched url
        srcAttrStart = currentStr.indexOf(match[1]) + match[1].length + srcAttrStart;
    }
    return imageAssets.map((asset) => {
        return {
            url: asset.url,
            tagName,
            relative: isRelative(asset.url),
            location: {
                startOffset: asset.startOffset,
                endOffset: asset.endOffset,
            },
        };
    });
}
// Detect if this is a relative URL
export function isRelative(url) {
    return !url?.match(isNotRelativeRegex);
}
const isNotRelativeRegex = /^(http(s)?:\/\/|\/)/i;
// Detect if this is just a self referential URL
export function isSelfUrl(url) {
    return !url || !!url.match(isSelfUrlRegex);
}
const isSelfUrlRegex = /^\s*(data:|#)/i;
function hasHydrationDirective(attrs = {}) {
    return Object.keys(attrs).some((attr) => attr === HYDRATE_DIRECTIVE);
}
function traverseHtmlTree(node, visitor) {
    for (const child of parse5.defaultTreeAdapter.getChildNodes(node)) {
        if (parse5.defaultTreeAdapter.isElementNode(child)) {
            visitor.enter?.(child);
            traverseHtmlTree(child, visitor);
            visitor.exit?.(child);
        }
    }
}
/**
 * Pull the custom elements and img tags out of an HTML string, to use as metadata
 * @param htmlSource - An HTML string to parse
 */
export function extractMetadataFromHtml(htmlSource, viewMetadata, appConfig) {
    const { customElements, assetReferences } = viewMetadata;
    const { bundleConfig: { external = {} }, } = appConfig;
    const externals = Object.keys(external);
    const root = parse5.parse(htmlSource, {
        sourceCodeLocationInfo: true,
        treeAdapter: parse5.defaultTreeAdapter,
    });
    let nestedIslands = false;
    let styleStartOffset;
    const openElements = new Set();
    const ceRefStack = [];
    traverseHtmlTree(root, {
        enter(node) {
            // Source code location is only available if the parser is configured with preserve
            // source location info.
            const { nodeName: tagName, attrs, sourceCodeLocation } = node;
            if (sourceCodeLocation &&
                tagName.includes('-') &&
                !openElements.has(tagName) &&
                !externals.includes(kebabCaseToModuleSpecifier(tagName))) {
                const { startOffset, endOffset } = sourceCodeLocation;
                // transform attributes [{ name: 'some-attr', value: 'the value' }] into properties { someAttr: 'the value' }
                // leave props as undefined if there are no attributes
                // set boolean attribute values to "true", or lwc will see them as falsy
                const props = attrs.length
                    ? attrs.reduce((obj, { name, value }) => {
                        obj[getPropFromAttrName(name)] = value === '' ? 'true' : value;
                        return obj;
                    }, {})
                    : undefined;
                const ceRef = { tagName, location: { startOffset, endOffset }, props };
                openElements.add(tagName);
                if (ceRefStack.length) {
                    // nested CE
                    const last = ceRefStack[ceRefStack.length - 1];
                    last.children = last.children ? [...last.children, ceRef] : [ceRef];
                    // nested CEs are collected if they have a hydration directive
                    if (hasHydrationDirective(props)) {
                        customElements.push(ceRef);
                        nestedIslands = true;
                    }
                }
                else {
                    // collect all top-level CEs
                    customElements.push(ceRef);
                }
                ceRefStack.push(ceRef);
            }
            // <img src="asset-url"/>
            // <script type="text/javascript" src="asset-url"></script>
            if ((tagName === 'img' || tagName === 'script') && sourceCodeLocation?.attrs?.src) {
                assetReferences.push(parseAssetLocation(htmlSource, tagName, sourceCodeLocation.attrs.src));
            }
            // <link rel="stylesheet" href="asset-url">
            if (tagName === 'link' && sourceCodeLocation?.attrs?.href) {
                assetReferences.push(parseAssetLocation(htmlSource, tagName, sourceCodeLocation.attrs.href));
            }
            if (tagName === 'style') {
                styleStartOffset = sourceCodeLocation?.startOffset;
            }
            if (sourceCodeLocation?.attrs?.style) {
                assetReferences.push(...parseInlineStyleImages(htmlSource, tagName, sourceCodeLocation.attrs.style));
            }
        },
        exit(node) {
            const { nodeName: tagName, sourceCodeLocation } = node;
            if (openElements.has(tagName)) {
                const ceRef = ceRefStack.pop();
                openElements.delete(tagName);
                if (!ceRef) {
                    throw new Error(`Error extracting metadata: Unmatched custom element close tag for ${tagName}`);
                }
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                ceRef.location.endOffset = sourceCodeLocation.endOffset;
            }
            if (tagName === 'style' && styleStartOffset && sourceCodeLocation?.endOffset) {
                assetReferences.push(...parseInlineStyleImages(htmlSource, 'style', {
                    startOffset: styleStartOffset,
                    endOffset: sourceCodeLocation.endOffset,
                }));
                styleStartOffset = undefined;
            }
        },
    });
    return {
        ...viewMetadata,
        customElements: customElements.filter((ce) => !nestedIslands || hasHydrationDirective(ce.props)),
        assetReferences,
    };
}
export const HYDRATE_DIRECTIVE = 'lwr:hydrate';
export const HYDRATE_LOAD_VALUE = 'load';
export const HYDRATE_CLIENT_VALUE = 'client-only';
const HYDRATION_VALUES = [HYDRATE_LOAD_VALUE, HYDRATE_CLIENT_VALUE];
export function getHydrateDirective(props = {}) {
    const rawValue = props[HYDRATE_DIRECTIVE];
    const value = rawValue === 'true' ? HYDRATE_LOAD_VALUE : rawValue; // valueless hyration directives => lwr:hydrate="load"
    if (HYDRATION_VALUES.includes(value))
        return value;
}
export function isHydrateOnLoad(props = {}) {
    return getHydrateDirective(props) === HYDRATE_LOAD_VALUE;
}
export function isCsrIsland(props = {}) {
    return getHydrateDirective(props) === HYDRATE_CLIENT_VALUE;
}
//# sourceMappingURL=html-meta.js.map