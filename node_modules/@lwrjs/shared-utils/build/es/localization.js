// Utilities for working with localized content
export function getFallbackLocale(localeId, i18n) {
    const locale = i18n.locales.find((l) => l.id === localeId);
    return locale?.fallback;
}
// Utilities to walk locale fallback logic
export async function walkLocaleFallbacks(initialLocale, i18n, test) {
    // Walk the locales
    const visited = new Set();
    let localeId = initialLocale;
    while (localeId && !visited.has(localeId)) {
        // eslint-disable-next-line no-await-in-loop
        const result = await test(localeId);
        if (result) {
            return result;
        }
        visited.add(localeId);
        const config = i18n.locales.find((l) => l.id === localeId);
        localeId = config && config.fallback;
    }
    // If we did not already visit the default locale give that a try
    if (!visited.has(i18n.defaultLocale)) {
        return test(i18n.defaultLocale);
    }
    // Did not find what we were looking for
    return undefined;
}
// Sort locales with fallbacks based on fallback relationships
export function sortLocalesByFallback(i18n) {
    const sortedLocales = [...i18n.locales];
    return sortedLocales.sort((a, b) => {
        if (a.id === i18n.defaultLocale)
            return -1; // Move the default locales to the front.
        if (b.id === i18n.defaultLocale)
            return 1;
        if (a.fallback && !b.fallback)
            return 1; // Move locales with no fallback before the ones that do
        if (b.fallback && !a.fallback)
            return -1;
        if (a.fallback && b.id === a.fallback)
            return 1; // Move 'a' before 'b' if 'a' is a fallback for 'b'.
        if (b.fallback && a.id === b.fallback)
            return -1; // Move 'b' before 'a' if 'b' is a fallback for 'a'.
        return 0;
    });
}
//# sourceMappingURL=localization.js.map