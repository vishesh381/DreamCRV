import { getModuleGraphs, GraphDepth } from './graph.js';
import { explodeSpecifier, getSpecifier, isBundleDefinition, VERSION_NOT_PROVIDED } from './identity.js';
import { PROTOCOL_FILE } from './fs.js';
/**
 * Get the Import Metadata for the LWR Mapping Api (https://rfcs.lwc.dev/rfcs/lwr/0000-mapping-api)
 */
export async function getImportMetadataMappings(moduleIds, runtimeEnvironment, runtimeParams, moduleRegistry, moduleBundler) {
    const visitedCache = new Map();
    let importMetadata = {
        imports: {},
        index: {},
    };
    for (const moduleId of moduleIds) {
        const requestedSpecifier = getSpecifier(moduleId);
        // eslint-disable-next-line no-await-in-loop
        const specifier = await getVersionedSpecifier(moduleId, moduleRegistry, runtimeParams);
        // Check if we have already visited
        if (!visitedCache.has(specifier)) {
            // Traversal of the Module Graph is done to get all the URLs for discoverable dependencies.
            // AMD gathers static imports while ESM gathers dynamic imports
            const depth = {
                static: runtimeEnvironment.format === 'esm' ? GraphDepth.NONE : GraphDepth.ALL,
                dynamic: runtimeEnvironment.format === 'esm' ? 1 : 0,
            };
            // eslint-disable-next-line no-await-in-loop
            const moduleGraph = await getModuleGraphs(specifier, 
            // include uris and linked definitions
            { includeUris: true, includeLinkedDefinitions: true, depth }, moduleRegistry, runtimeEnvironment.bundle ? moduleBundler : moduleRegistry, runtimeEnvironment, runtimeParams, visitedCache);
            // Root module
            // eslint-disable-next-line no-await-in-loop
            importMetadata = await toImportMetadata(moduleGraph, importMetadata, moduleRegistry, runtimeEnvironment, runtimeParams);
        }
        // If the requested specifier is not the same as the versioned specifier, include the requested specifier's importer.
        if (moduleId.importer && requestedSpecifier !== specifier) {
            const requestedSpecifierPlusImporter = `${requestedSpecifier}?importer=${moduleId.importer}`;
            const specifiersArray = Object.values(importMetadata.imports).find((a) => a.includes(specifier));
            if (!specifiersArray) {
                throw new Error('Could not find: ' + specifier + ' in ' + JSON.stringify(importMetadata.imports));
            }
            specifiersArray.push(requestedSpecifierPlusImporter);
        }
    }
    return importMetadata;
}
/**
 * Generate the import mapping metadata for a module graph.
 *
 * The graph must have set includeUris and includeLinkedDefinitions to link specifiers to uris.
 *
 * You can pass in an existing set of import metadata and the result will merge the imports.
 * If there is a duplicate uri the merge will keep the one from the existing metadata.
 *
 * @param moduleGraph FlattenedModuleGraphs created by the graph shared util
 * @param existingImportMetadata Optional existing ImportMetadata.  If provided the results will be a merge the two sets of URI mappings.
 * @returns Returns ImportMetadata from a module graph in the format here -> https://rfcs.lwc.dev/rfcs/lwr/0000-mapping-api#uri-mapping-resource-specification
 */
export async function toImportMetadata(moduleGraph, existingImportMetadata = { imports: {}, index: {} }, moduleRegistry, runtimeEnvironment, runtimeParams = {}) {
    // root module specifier
    const specifier = moduleGraph.graphs[0].specifier;
    const uri = lookupValueIgnoringVersion(moduleGraph.uriMap, specifier);
    const definition = lookupValueIgnoringVersion(moduleGraph.linkedDefinitions, specifier);
    if (!uri) {
        throw new Error('URI was not included in the graph: ' + specifier);
    }
    if (!definition) {
        throw new Error('Linked module definition was not included in the graph: ' + specifier);
    }
    // Add a single entry for an external
    if (isExternalSpecifier(specifier, moduleRegistry.getConfig().bundleConfig)) {
        const externalMapping = { imports: {}, index: {} };
        externalMapping.imports[uri] = [specifier];
        externalMapping.index[specifier] = uri;
        return externalMapping;
    }
    // Merge in the existing metadata with imports for the root specifier
    const rootMetadata = await normalizeImportMetadata(specifier, uri, definition, moduleRegistry, runtimeEnvironment, runtimeParams);
    let importMetadata = mergeImportMetadata(existingImportMetadata, rootMetadata);
    // root module dependencies:
    //  - static for AMD; dynamic dependencies require a new mapping request
    //  - dynamic for ESM; static dependencies are imported via fully qualified URLs
    const depSpecifiers = runtimeEnvironment.format === 'esm'
        ? moduleGraph.graphs[0].dynamicRefs
        : moduleGraph.graphs[0].static;
    for (const depSpecifier of depSpecifiers) {
        if (isExternalSpecifier(depSpecifier, moduleRegistry.getConfig().bundleConfig)) {
            // Ignore Externals
            continue;
        }
        const depUri = lookupValueIgnoringVersion(moduleGraph.uriMap, depSpecifier);
        const depDef = lookupValueIgnoringVersion(moduleGraph.linkedDefinitions, depSpecifier);
        const depMissing = !depUri || !depDef;
        if (depMissing && runtimeEnvironment.format !== 'esm') {
            if (!depUri) {
                throw new Error('URI was not included in the graph for dependent: ' + depSpecifier);
            }
            if (!depDef) {
                throw new Error('Linked dependent module definition was not included in the graph: ' + depSpecifier);
            }
        }
        else if (depMissing) {
            // Ignore variable dynamic imports
            continue;
        }
        if (!importMetadata.imports[depUri]) {
            const depDefSpecifier = getSpecifier(depDef);
            if (!isExternalSpecifier(depDefSpecifier, moduleRegistry.getConfig().bundleConfig)) {
                // eslint-disable-next-line no-await-in-loop
                const depMetadata = await normalizeImportMetadata(depDefSpecifier, depUri, depDef, moduleRegistry, runtimeEnvironment, runtimeParams);
                importMetadata = mergeImportMetadata(importMetadata, depMetadata);
            }
        }
    }
    return importMetadata;
}
// Function to look up values ignoring the version part
function lookupValueIgnoringVersion(map, specifier) {
    // early out on exact match
    const val = map[specifier];
    if (val) {
        return val;
    }
    const cleanedKey = explodeSpecifier(specifier).specifier;
    // Iterate over the map to find the first matching key without version
    for (const mapKey of Object.keys(map)) {
        if (explodeSpecifier(mapKey).specifier === cleanedKey) {
            return map[mapKey];
        }
    }
}
function mergeImportMetadata(existing, newMetadata) {
    // TODO should there be an error if the metadata conflicts?
    return {
        imports: {
            ...existing.imports,
            ...newMetadata.imports,
        },
        index: {
            ...existing.index,
            ...newMetadata.index,
        },
    };
}
async function normalizeImportMetadata(specifier, uri, definition, moduleRegistry, moduleRuntimeEnvironment, runtimeParams) {
    const specifiers = normalizedIncludedModules(definition);
    const imports = {};
    imports[uri] = specifiers;
    // The index info for the modules included in a bundle
    const index = await createIndex(specifiers, moduleRegistry, moduleRuntimeEnvironment, runtimeParams);
    // If root specifier was not included in createIndex add an entry where the uri is the index
    if (!(specifier in index)) {
        index[specifier] = uri;
    }
    // return imports and index objects created above
    return {
        imports,
        index,
    };
}
// Normalized the included modules associated with either an individual module definition or Bundle definition
function normalizedIncludedModules(definition) {
    return isBundleDefinition(definition)
        ? [getSpecifier(definition), ...definition.bundleRecord.includedModules]
        : [getSpecifier(definition)];
}
async function createIndex(specifiers, moduleRegistry, runtimeEnvironment, runtimeParams) {
    const index = {};
    // We need a runtime environment for modules when building the index for a bundle
    const moduleRuntimeEnvironment = { ...runtimeEnvironment, bundle: false };
    async function getUri(specifier) {
        const moduleId = explodeSpecifier(specifier);
        // Do not use replace with the moduleBundler.  Otherwise we will create a bundle from every
        // root just to get the URL.
        index[specifier] = await moduleRegistry.resolveModuleUri({ ...moduleId, version: moduleId.version || VERSION_NOT_PROVIDED }, moduleRuntimeEnvironment, runtimeParams);
    }
    // Queue up uri requests
    const promises = [];
    for (const specifier of specifiers) {
        if (!isExternalSpecifier(specifier, moduleRegistry.getConfig().bundleConfig)) {
            promises.push(getUri(specifier));
        }
    }
    // Wait for them to finish
    await Promise.all(promises);
    return index;
}
async function getVersionedSpecifier(moduleId, moduleRegistry, runtimeParams) {
    if (moduleId.version) {
        return getSpecifier(moduleId);
    }
    const versionedModuleEntry = await moduleRegistry.getModuleEntry({
        ...moduleId,
    }, runtimeParams);
    return getSpecifier(versionedModuleEntry);
}
export function isExternalSpecifier(id, bundleConfig) {
    const { specifier } = explodeSpecifier(id);
    return !!(bundleConfig?.external && Object.prototype.hasOwnProperty.call(bundleConfig.external, specifier));
}
export function isExternalFileSpecifier(id, bundleConfig) {
    const { specifier } = explodeSpecifier(id);
    return !!(bundleConfig?.external &&
        bundleConfig.external[specifier] &&
        bundleConfig.external[specifier].startsWith(PROTOCOL_FILE));
}
//# sourceMappingURL=mappings.js.map