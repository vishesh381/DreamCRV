import slugifyText from 'slugify';
import getCacheKeyFromJson from 'fast-json-stable-stringify';
export const VERSION_SIGIL = 'v';
export const VERSION_PREFIX = `/${VERSION_SIGIL}/`;
export const LOCALE_SIGIL = 'l';
export const ENVIRONMENT_SIGIL = 'e';
export const BUNDLE_SIGIL = 'bi';
export const LATEST_SIGNATURE = 'latest';
export const DEFAULT_TITLE = 'LWR App';
export const IMMUTABLE_ASSET_PREFIX = '/_immutable/';
export const ASSETS_CACHE_DIR = 'assetsCache';
export const VERSION_NOT_PROVIDED = 'version-not-provided';
export const SSR_SIGIL = 'ssr';
// Locker trusted components
export const DEFAULT_LOCKER_TRUSTED_CMP = ['@locker/*', 'lwr/*', '@lwrjs/*', 'lwc', '@lwc/*'];
export const DEFAULT_LWR_LOCKER_CONFIG = {
    enabled: false,
    trustedComponents: DEFAULT_LOCKER_TRUSTED_CMP,
};
/**
 * Turn the dots in a version into underscores
 * @param version
 * @example '1.0.0' => '1_0_0'
 */
export function normalizeVersionToUri(version) {
    return version.replace(/\./g, '_');
}
/**
 * Turn the underscores in a URI version into dots
 * @param version
 * @example '1_0_0' => '1.0.0'
 */
export function normalizeVersionFromUri(version) {
    return version.replace(/_/g, '.');
}
/**
 * Create the last token for a module URL.  Readable specifier for a URI
 *
 * examples/app/scoped/css?scoped=true => examples_app_scoped_css_scoped=true
 */
export function prettyModuleUriSuffix(specifier) {
    // eslint-disable-next-line no-useless-escape
    return `${specifier.replace(/[\/\.\?\#]/g, '_')}`;
}
export function explodeSpecifier(rawSpecifier) {
    const decodedSpecifier = decodeURIComponent(rawSpecifier);
    // Split up the version and bare specifier
    const versionMatch = decodedSpecifier.match(/(.+)\/v\/([a-zA-Z0-9-_.]+)$/);
    const version = versionMatch ? versionMatch[2] : undefined;
    const importee = versionMatch ? versionMatch[1] : decodedSpecifier;
    // Pull out the namespace and name
    const [rawNamespace, rawName, ...remaining] = importee.split('/');
    const namespace = rawName ? rawNamespace : undefined;
    const name = rawName ? [rawName, ...remaining].join('/') : rawNamespace;
    // Return an abstract ModuleIdentifier
    return {
        specifier: importee,
        namespace,
        name,
        version: version ? normalizeVersionFromUri(version) : version,
    };
}
export function explodeSpecifiers(rawSpecifiers) {
    const exploder = explodeSpecifier;
    if (!rawSpecifiers) {
        return [];
    }
    return rawSpecifiers.split(',').map(function (rawSpecifier) {
        return exploder(rawSpecifier);
    });
}
/**
 * Create a specifier with a namespace (optional), name and version (optional)
 * @param param0 - namespace and name
 * @example - { specifier: 'c/form', namespace: 'c', name: 'form' } => 'c/form'
 * @example - { specifier: 'c/form', version: '5000' } => 'c/form/v/5000'
 * @example - { name: 'lwc' } => 'lwc'
 * @example - { namespace: 'c', name: 'app' } => 'c/app'
 * @example - { namespace: '@salesforce', name: 'label/my.label' } => '@salesforce/label/my.label'
 * @example - { name: 'lwc', version: '1.7' } => 'lwc/v/1.7'
 * @example - { namespace: 'c', name: 'navMenu', version: '2.0' } => 'c/navMenu/v/2.0'
 * @example - { namespace: '@salesforce', name: 'label/my.label', version: '1' } => '@salesforce/label/my.label/v/1'
 * @example - { namespace: '@salesforce', name: 'label/my.label', version: 'version-not-provided' } => '@salesforce/label/my.label'
 */
export function getSpecifier({ specifier, namespace, name = '', version }) {
    if (specifier) {
        // Remove any versioning from the specifier
        const versionMatch = specifier.match(/(.+)\/v\/[a-zA-Z0-9-_.]+$/);
        specifier = versionMatch ? versionMatch[1] : specifier;
        // If a module has an explicit 'version-not-provided' version this will not be reflected in the specifier
        return version && version !== VERSION_NOT_PROVIDED
            ? `${specifier}${VERSION_PREFIX}${normalizeVersionToUri(version)}`
            : specifier;
    }
    const bareSpecifier = namespace ? `${namespace}/${name}` : name;
    // If a module has an explicit 'version-not-provided' version this will not be reflected in the specifier
    return version && version !== VERSION_NOT_PROVIDED
        ? `${bareSpecifier}${VERSION_PREFIX}${normalizeVersionToUri(version)}`
        : bareSpecifier;
}
/**
 * Create a AbstractModuleId using the module registry to resolve the version
 * if a version is not provided in the `rawSpecifier`
 *
 * The returned ModuleId properties (specifically version) conforms to the format
 * expected by Module registry (e.g. version semver format -- major.minor.patch)
 *
 * @remarks
 * If the incoming specifier is already versioned, the version value will be normalized
 * to semver format.
 *
 * @param specifier - the module specifier
 * @param moduleRegistry - the public module registry
 *
 * @returns the specifier for the latest version
 *
 * @example - 'c/form' => {specifier: "c/form", version: "0.0.1"}
 * @example - 'c/form/v/0.0.2' => {specifier: "c/form", version: "0.0.2"}
 * @example - 'c/form/v/0_0_2' => {specifier: "c/form", version: "0.0.2"}
 */
export async function getVersionedModuleId(rawSpecifier, moduleRegistry, runtimeParams) {
    const moduleId = explodeSpecifier(rawSpecifier);
    if (moduleId.version) {
        return { ...moduleId, version: normalizeVersionFromUri(moduleId.version) };
    }
    // Get version from Module Registry
    const moduleEntry = await moduleRegistry.getModuleEntry(moduleId, runtimeParams);
    return { ...moduleId, version: moduleEntry.version };
}
export function isSpecifier(specifier) {
    return !!specifier && /^@?[\w-]+(\/[\w-]+)*$/.test(specifier);
}
const RE_SCOPED = /^(@[^/]+\/[^/@]+)(?:\/([^@]+))?(?:@([\s\S]+))?/;
const RE_NORMAL = /^([^/@]+)(?:\/([^@]+))?(?:@([\s\S]+))?/;
/**
 * Parses an npm-style specifier
 * modified from https://github.com/egoist/parse-package-name#readme
 *
 * @param specifier - String to parse
 *
 * @example "@angular/core" => { scope: "@angular", packageName: "@angular/core", subResource: "" }
 * @example "@lwr/core/some/path" => { scope: "@lwr", packageName: "@lwr/core", subResource: "some/path" }
 * @example "my/app" => { packageName: "my", subResource: "app" }
 * @example "my/app/utils" => { packageName: "my", subResource: "app/utils" }
 * @example "lwc" => { packageName: "lwc", subResource: "" }
 */
export function parsePackageSpecifier(specifier) {
    const isScoped = specifier.charAt(0) === '@';
    const matched = isScoped ? specifier.match(RE_SCOPED) : specifier.match(RE_NORMAL);
    if (!matched) {
        throw new Error(`[parse-package-name] "${specifier}" is not a valid string`);
    }
    const scope = isScoped ? matched[1].split('/')[0] : undefined;
    if (isScoped) {
        return {
            scope,
            packageName: matched[1],
            subResource: matched[2] || '',
        };
    }
    return {
        packageName: matched[1],
        subResource: matched[2] || '',
    };
}
/**
 * Turn a string from kebab case to "specifier case": namespace/camelCaseName
 * @param name A string in kebab case
 * @example - 'name-of-something' => 'name/ofSomething'
 */
export function kebabCaseToModuleSpecifier(name) {
    const newName = [];
    let nsFound = false;
    let upper = false;
    for (const currChar of name) {
        if (currChar === '-') {
            if (!nsFound) {
                nsFound = true;
                newName.push('/');
            }
            else {
                upper = true;
            }
        }
        else {
            newName.push(upper ? currChar.toUpperCase() : currChar);
            upper = false;
        }
    }
    return newName.join('');
}
/**
 * Clone of lwr/init, reverse of kebabCaseToModuleSpecifier, strips off versions
 * @param specifier
 * @example - 'name/ofSomething/v/1.0.0' => 'name-of-something'
 */
export function moduleSpecifierToKebabCase(specifier) {
    return specifier
        .replace(/\/v\/[a-zA-Z0-9-_.]+$/, '')
        .replace('/', '-')
        .replace(/([A-Z])/g, (c) => `-${c.toLowerCase()}`);
}
/**
 * Turn a string into a slug
 * @param name a string to slugify
 * @example - 'This IS a sentence' => 'this-is-a-sentence'
 */
export function slugify(name) {
    return slugifyText(name, {
        lower: true,
    });
}
/**
 * Turn an html attribute into a LWC property, eg: 'best-property-ever' => 'bestPropertyEver'
 * @param propName - a string in kebab case (lowercase)
 * @returns - a string in camel case
 */
export function getPropFromAttrName(propName) {
    return propName.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
}
/**
 * Create a module URI prefix, stopping where the specifier would be (at "mi/")
 * @param param0 - URI props from the Runtime Environment
 * @param param1 - URI props from the Runtime Params
 */
export function getModuleUriPrefix({ apiVersion, bundle, format, compat, basePath }, { locale, environment } = {}, bundleId) {
    const localePart = locale ? `/${LOCALE_SIGIL}/${locale}` : '';
    const environmentPart = environment ? `/${ENVIRONMENT_SIGIL}/${environment}` : '';
    if (bundle) {
        return `${basePath}/${apiVersion}/bundle/${format}${localePart}${environmentPart}/${BUNDLE_SIGIL}/${bundleId || '0'}/module/mi/`;
    }
    else {
        return `${basePath}/${apiVersion}/module/${format}/${compat}${localePart}${environmentPart}/mi/`;
    }
}
/**
 * Create a URI Mapping API URI prefix, stopping where the specifiers would be (at "mp/")
 * @param param0 - URI props from the Runtime Environment
 * @param param1 - URI props from the Runtime Params
 */
export function getMappingUriPrefix({ apiVersion, bundle, format, compat, basePath }, { locale, environment } = {}) {
    const localePart = locale ? `/${LOCALE_SIGIL}/${locale}` : '';
    const environmentPart = environment ? `/${ENVIRONMENT_SIGIL}/${environment}` : '';
    const bundlePart = bundle ? `/${BUNDLE_SIGIL}/0` : '';
    return `${basePath}/${apiVersion}/mapping/${format}/${compat}${localePart}${environmentPart}${bundlePart}/mp/`;
}
export { getCacheKeyFromJson };
const REGEX_URL_SCHEMA_PREFIX = /^(https?|\/\/)/;
export function isExternalUrl(url) {
    return REGEX_URL_SCHEMA_PREFIX.test(url);
}
export function isAssetSourceExternal(assetSource) {
    return assetSource.type === 'external' || (!!assetSource.uri && isExternalUrl(assetSource.uri));
}
// type guard for ViewDef responses
export function isBundleDefinition(definition) {
    return definition.bundleRecord !== undefined;
}
/**
 * Create a js safe variable name
 * @param name - Proposed name
 */
export function stringToVariableName(inputString) {
    // Remove at symbols (@)
    // Remove non-alphanumeric characters except for underscore (_) and dollar sign ($)
    const cleanedString = inputString.replace(/@/g, '').replace(/[^a-zA-Z0-9_$]/g, '_');
    // Prepend an underscore if the resulting name is empty or starts with a number, underscore (_) and dollar sign ($)
    if (!cleanedString || /^[0-9$]+/.test(cleanedString)) {
        return `_${cleanedString}`;
    }
    return cleanedString;
}
//# sourceMappingURL=identity.js.map