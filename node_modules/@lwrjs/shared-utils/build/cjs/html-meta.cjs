var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/shared-utils/src/html-meta.ts
__markAsModule(exports);
__export(exports, {
  HYDRATE_CLIENT_VALUE: () => HYDRATE_CLIENT_VALUE,
  HYDRATE_DIRECTIVE: () => HYDRATE_DIRECTIVE,
  HYDRATE_LOAD_VALUE: () => HYDRATE_LOAD_VALUE,
  extractMetadataFromHtml: () => extractMetadataFromHtml,
  getHydrateDirective: () => getHydrateDirective,
  isCsrIsland: () => isCsrIsland,
  isHydrateOnLoad: () => isHydrateOnLoad,
  isRelative: () => isRelative,
  isSelfUrl: () => isSelfUrl
});
var parse5 = __toModule(require("parse5"));
var import_identity = __toModule(require("./identity.cjs"));
function parseAssetLocation(htmlSource, tagName, attrLocation) {
  const {startOffset, endOffset} = attrLocation;
  const srcAttr = htmlSource.substring(startOffset, endOffset);
  const split = srcAttr.indexOf("=");
  const keyAttr = srcAttr.substr(0, split);
  const url = srcAttr.slice(split + 2, -1);
  return {
    url,
    tagName,
    relative: isRelative(url),
    location: {
      startOffset: startOffset + keyAttr.length + 2,
      endOffset: endOffset - 1
    }
  };
}
function parseInlineStyleImages(htmlSource, tagName, attrLocation) {
  const imageAssets = [], urlPattern = /url\((.*?)\)/g, {startOffset, endOffset} = attrLocation, srcAttr = htmlSource.substring(startOffset, endOffset);
  let srcAttrStart = 0, match;
  while ((match = urlPattern.exec(srcAttr)) !== null) {
    const currentStr = srcAttr.substring(srcAttrStart);
    imageAssets.push({
      url: match[1].trim().replace(/^['"]|['"]$/g, ""),
      startOffset: startOffset + currentStr.indexOf(match[1]) + srcAttrStart,
      endOffset: startOffset + currentStr.indexOf(match[1]) + match[1].length + srcAttrStart
    });
    srcAttrStart = currentStr.indexOf(match[1]) + match[1].length + srcAttrStart;
  }
  return imageAssets.map((asset) => {
    return {
      url: asset.url,
      tagName,
      relative: isRelative(asset.url),
      location: {
        startOffset: asset.startOffset,
        endOffset: asset.endOffset
      }
    };
  });
}
function isRelative(url) {
  return !url?.match(isNotRelativeRegex);
}
var isNotRelativeRegex = /^(http(s)?:\/\/|\/)/i;
function isSelfUrl(url) {
  return !url || !!url.match(isSelfUrlRegex);
}
var isSelfUrlRegex = /^\s*(data:|#)/i;
function hasHydrationDirective(attrs = {}) {
  return Object.keys(attrs).some((attr) => attr === HYDRATE_DIRECTIVE);
}
function traverseHtmlTree(node, visitor) {
  for (const child of parse5.defaultTreeAdapter.getChildNodes(node)) {
    if (parse5.defaultTreeAdapter.isElementNode(child)) {
      visitor.enter?.(child);
      traverseHtmlTree(child, visitor);
      visitor.exit?.(child);
    }
  }
}
function extractMetadataFromHtml(htmlSource, viewMetadata, appConfig) {
  const {customElements, assetReferences} = viewMetadata;
  const {
    bundleConfig: {external = {}}
  } = appConfig;
  const externals = Object.keys(external);
  const root = parse5.parse(htmlSource, {
    sourceCodeLocationInfo: true,
    treeAdapter: parse5.defaultTreeAdapter
  });
  let nestedIslands = false;
  let styleStartOffset;
  const openElements = new Set();
  const ceRefStack = [];
  traverseHtmlTree(root, {
    enter(node) {
      const {nodeName: tagName, attrs, sourceCodeLocation} = node;
      if (sourceCodeLocation && tagName.includes("-") && !openElements.has(tagName) && !externals.includes((0, import_identity.kebabCaseToModuleSpecifier)(tagName))) {
        const {startOffset, endOffset} = sourceCodeLocation;
        const props = attrs.length ? attrs.reduce((obj, {name, value}) => {
          obj[(0, import_identity.getPropFromAttrName)(name)] = value === "" ? "true" : value;
          return obj;
        }, {}) : void 0;
        const ceRef = {tagName, location: {startOffset, endOffset}, props};
        openElements.add(tagName);
        if (ceRefStack.length) {
          const last = ceRefStack[ceRefStack.length - 1];
          last.children = last.children ? [...last.children, ceRef] : [ceRef];
          if (hasHydrationDirective(props)) {
            customElements.push(ceRef);
            nestedIslands = true;
          }
        } else {
          customElements.push(ceRef);
        }
        ceRefStack.push(ceRef);
      }
      if ((tagName === "img" || tagName === "script") && sourceCodeLocation?.attrs?.src) {
        assetReferences.push(parseAssetLocation(htmlSource, tagName, sourceCodeLocation.attrs.src));
      }
      if (tagName === "link" && sourceCodeLocation?.attrs?.href) {
        assetReferences.push(parseAssetLocation(htmlSource, tagName, sourceCodeLocation.attrs.href));
      }
      if (tagName === "style") {
        styleStartOffset = sourceCodeLocation?.startOffset;
      }
      if (sourceCodeLocation?.attrs?.style) {
        assetReferences.push(...parseInlineStyleImages(htmlSource, tagName, sourceCodeLocation.attrs.style));
      }
    },
    exit(node) {
      const {nodeName: tagName, sourceCodeLocation} = node;
      if (openElements.has(tagName)) {
        const ceRef = ceRefStack.pop();
        openElements.delete(tagName);
        if (!ceRef) {
          throw new Error(`Error extracting metadata: Unmatched custom element close tag for ${tagName}`);
        }
        ceRef.location.endOffset = sourceCodeLocation.endOffset;
      }
      if (tagName === "style" && styleStartOffset && sourceCodeLocation?.endOffset) {
        assetReferences.push(...parseInlineStyleImages(htmlSource, "style", {
          startOffset: styleStartOffset,
          endOffset: sourceCodeLocation.endOffset
        }));
        styleStartOffset = void 0;
      }
    }
  });
  return {
    ...viewMetadata,
    customElements: customElements.filter((ce) => !nestedIslands || hasHydrationDirective(ce.props)),
    assetReferences
  };
}
var HYDRATE_DIRECTIVE = "lwr:hydrate";
var HYDRATE_LOAD_VALUE = "load";
var HYDRATE_CLIENT_VALUE = "client-only";
var HYDRATION_VALUES = [HYDRATE_LOAD_VALUE, HYDRATE_CLIENT_VALUE];
function getHydrateDirective(props = {}) {
  const rawValue = props[HYDRATE_DIRECTIVE];
  const value = rawValue === "true" ? HYDRATE_LOAD_VALUE : rawValue;
  if (HYDRATION_VALUES.includes(value))
    return value;
}
function isHydrateOnLoad(props = {}) {
  return getHydrateDirective(props) === HYDRATE_LOAD_VALUE;
}
function isCsrIsland(props = {}) {
  return getHydrateDirective(props) === HYDRATE_CLIENT_VALUE;
}
