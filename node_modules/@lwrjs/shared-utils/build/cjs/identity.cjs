var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/shared-utils/src/identity.ts
__markAsModule(exports);
__export(exports, {
  ASSETS_CACHE_DIR: () => ASSETS_CACHE_DIR,
  BUNDLE_SIGIL: () => BUNDLE_SIGIL,
  DEFAULT_LOCKER_TRUSTED_CMP: () => DEFAULT_LOCKER_TRUSTED_CMP,
  DEFAULT_LWR_LOCKER_CONFIG: () => DEFAULT_LWR_LOCKER_CONFIG,
  DEFAULT_TITLE: () => DEFAULT_TITLE,
  ENVIRONMENT_SIGIL: () => ENVIRONMENT_SIGIL,
  IMMUTABLE_ASSET_PREFIX: () => IMMUTABLE_ASSET_PREFIX,
  LATEST_SIGNATURE: () => LATEST_SIGNATURE,
  LOCALE_SIGIL: () => LOCALE_SIGIL,
  SSR_SIGIL: () => SSR_SIGIL,
  VERSION_NOT_PROVIDED: () => VERSION_NOT_PROVIDED,
  VERSION_PREFIX: () => VERSION_PREFIX,
  VERSION_SIGIL: () => VERSION_SIGIL,
  explodeSpecifier: () => explodeSpecifier,
  explodeSpecifiers: () => explodeSpecifiers,
  getCacheKeyFromJson: () => import_fast_json_stable_stringify.default,
  getMappingUriPrefix: () => getMappingUriPrefix,
  getModuleUriPrefix: () => getModuleUriPrefix,
  getPropFromAttrName: () => getPropFromAttrName,
  getSpecifier: () => getSpecifier,
  getVersionedModuleId: () => getVersionedModuleId,
  isAssetSourceExternal: () => isAssetSourceExternal,
  isBundleDefinition: () => isBundleDefinition,
  isExternalUrl: () => isExternalUrl,
  isSpecifier: () => isSpecifier,
  kebabCaseToModuleSpecifier: () => kebabCaseToModuleSpecifier,
  moduleSpecifierToKebabCase: () => moduleSpecifierToKebabCase,
  normalizeVersionFromUri: () => normalizeVersionFromUri,
  normalizeVersionToUri: () => normalizeVersionToUri,
  parsePackageSpecifier: () => parsePackageSpecifier,
  prettyModuleUriSuffix: () => prettyModuleUriSuffix,
  slugify: () => slugify,
  stringToVariableName: () => stringToVariableName
});
var import_slugify = __toModule(require("slugify"));
var import_fast_json_stable_stringify = __toModule(require("fast-json-stable-stringify"));
var VERSION_SIGIL = "v";
var VERSION_PREFIX = `/${VERSION_SIGIL}/`;
var LOCALE_SIGIL = "l";
var ENVIRONMENT_SIGIL = "e";
var BUNDLE_SIGIL = "bi";
var LATEST_SIGNATURE = "latest";
var DEFAULT_TITLE = "LWR App";
var IMMUTABLE_ASSET_PREFIX = "/_immutable/";
var ASSETS_CACHE_DIR = "assetsCache";
var VERSION_NOT_PROVIDED = "version-not-provided";
var SSR_SIGIL = "ssr";
var DEFAULT_LOCKER_TRUSTED_CMP = ["@locker/*", "lwr/*", "@lwrjs/*", "lwc", "@lwc/*"];
var DEFAULT_LWR_LOCKER_CONFIG = {
  enabled: false,
  trustedComponents: DEFAULT_LOCKER_TRUSTED_CMP
};
function normalizeVersionToUri(version) {
  return version.replace(/\./g, "_");
}
function normalizeVersionFromUri(version) {
  return version.replace(/_/g, ".");
}
function prettyModuleUriSuffix(specifier) {
  return `${specifier.replace(/[\/\.\?\#]/g, "_")}`;
}
function explodeSpecifier(rawSpecifier) {
  const decodedSpecifier = decodeURIComponent(rawSpecifier);
  const versionMatch = decodedSpecifier.match(/(.+)\/v\/([a-zA-Z0-9-_.]+)$/);
  const version = versionMatch ? versionMatch[2] : void 0;
  const importee = versionMatch ? versionMatch[1] : decodedSpecifier;
  const [rawNamespace, rawName, ...remaining] = importee.split("/");
  const namespace = rawName ? rawNamespace : void 0;
  const name = rawName ? [rawName, ...remaining].join("/") : rawNamespace;
  return {
    specifier: importee,
    namespace,
    name,
    version: version ? normalizeVersionFromUri(version) : version
  };
}
function explodeSpecifiers(rawSpecifiers) {
  const exploder = explodeSpecifier;
  if (!rawSpecifiers) {
    return [];
  }
  return rawSpecifiers.split(",").map(function(rawSpecifier) {
    return exploder(rawSpecifier);
  });
}
function getSpecifier({specifier, namespace, name = "", version}) {
  if (specifier) {
    const versionMatch = specifier.match(/(.+)\/v\/[a-zA-Z0-9-_.]+$/);
    specifier = versionMatch ? versionMatch[1] : specifier;
    return version && version !== VERSION_NOT_PROVIDED ? `${specifier}${VERSION_PREFIX}${normalizeVersionToUri(version)}` : specifier;
  }
  const bareSpecifier = namespace ? `${namespace}/${name}` : name;
  return version && version !== VERSION_NOT_PROVIDED ? `${bareSpecifier}${VERSION_PREFIX}${normalizeVersionToUri(version)}` : bareSpecifier;
}
async function getVersionedModuleId(rawSpecifier, moduleRegistry, runtimeParams) {
  const moduleId = explodeSpecifier(rawSpecifier);
  if (moduleId.version) {
    return {...moduleId, version: normalizeVersionFromUri(moduleId.version)};
  }
  const moduleEntry = await moduleRegistry.getModuleEntry(moduleId, runtimeParams);
  return {...moduleId, version: moduleEntry.version};
}
function isSpecifier(specifier) {
  return !!specifier && /^@?[\w-]+(\/[\w-]+)*$/.test(specifier);
}
var RE_SCOPED = /^(@[^/]+\/[^/@]+)(?:\/([^@]+))?(?:@([\s\S]+))?/;
var RE_NORMAL = /^([^/@]+)(?:\/([^@]+))?(?:@([\s\S]+))?/;
function parsePackageSpecifier(specifier) {
  const isScoped = specifier.charAt(0) === "@";
  const matched = isScoped ? specifier.match(RE_SCOPED) : specifier.match(RE_NORMAL);
  if (!matched) {
    throw new Error(`[parse-package-name] "${specifier}" is not a valid string`);
  }
  const scope = isScoped ? matched[1].split("/")[0] : void 0;
  if (isScoped) {
    return {
      scope,
      packageName: matched[1],
      subResource: matched[2] || ""
    };
  }
  return {
    packageName: matched[1],
    subResource: matched[2] || ""
  };
}
function kebabCaseToModuleSpecifier(name) {
  const newName = [];
  let nsFound = false;
  let upper = false;
  for (const currChar of name) {
    if (currChar === "-") {
      if (!nsFound) {
        nsFound = true;
        newName.push("/");
      } else {
        upper = true;
      }
    } else {
      newName.push(upper ? currChar.toUpperCase() : currChar);
      upper = false;
    }
  }
  return newName.join("");
}
function moduleSpecifierToKebabCase(specifier) {
  return specifier.replace(/\/v\/[a-zA-Z0-9-_.]+$/, "").replace("/", "-").replace(/([A-Z])/g, (c) => `-${c.toLowerCase()}`);
}
function slugify(name) {
  return (0, import_slugify.default)(name, {
    lower: true
  });
}
function getPropFromAttrName(propName) {
  return propName.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
}
function getModuleUriPrefix({apiVersion, bundle, format, compat, basePath}, {locale, environment} = {}, bundleId) {
  const localePart = locale ? `/${LOCALE_SIGIL}/${locale}` : "";
  const environmentPart = environment ? `/${ENVIRONMENT_SIGIL}/${environment}` : "";
  if (bundle) {
    return `${basePath}/${apiVersion}/bundle/${format}${localePart}${environmentPart}/${BUNDLE_SIGIL}/${bundleId || "0"}/module/mi/`;
  } else {
    return `${basePath}/${apiVersion}/module/${format}/${compat}${localePart}${environmentPart}/mi/`;
  }
}
function getMappingUriPrefix({apiVersion, bundle, format, compat, basePath}, {locale, environment} = {}) {
  const localePart = locale ? `/${LOCALE_SIGIL}/${locale}` : "";
  const environmentPart = environment ? `/${ENVIRONMENT_SIGIL}/${environment}` : "";
  const bundlePart = bundle ? `/${BUNDLE_SIGIL}/0` : "";
  return `${basePath}/${apiVersion}/mapping/${format}/${compat}${localePart}${environmentPart}${bundlePart}/mp/`;
}
var REGEX_URL_SCHEMA_PREFIX = /^(https?|\/\/)/;
function isExternalUrl(url) {
  return REGEX_URL_SCHEMA_PREFIX.test(url);
}
function isAssetSourceExternal(assetSource) {
  return assetSource.type === "external" || !!assetSource.uri && isExternalUrl(assetSource.uri);
}
function isBundleDefinition(definition) {
  return definition.bundleRecord !== void 0;
}
function stringToVariableName(inputString) {
  const cleanedString = inputString.replace(/@/g, "").replace(/[^a-zA-Z0-9_$]/g, "_");
  if (!cleanedString || /^[0-9$]+/.test(cleanedString)) {
    return `_${cleanedString}`;
  }
  return cleanedString;
}
