import { createProxyMiddleware } from 'http-proxy-middleware';
import { logger } from '@lwrjs/diagnostics';
// Header constants
const HOST = 'host';
// Log levels enumeration
var ProxyLogLevels;
(function (ProxyLogLevels) {
    ProxyLogLevels["Debug"] = "debug";
    ProxyLogLevels["Info"] = "info";
    ProxyLogLevels["Warn"] = "warn";
    ProxyLogLevels["Error"] = "error";
    ProxyLogLevels["Silent"] = "silent";
})(ProxyLogLevels || (ProxyLogLevels = {}));
// Regular expression to extract the protocol and host from a remote proxy URL.
// Example matches:
//   Input: "https://example.com/path"
//   Matches: ["https://example.com", "https", "example.com"]
// Explanation:
//   ^                - Match the start of the string.
//   ([a-z][a-z0-9+\-.]*) - Capture the protocol (e.g., "http", "https"), which must start with a letter and may include alphanumeric characters, "+", "-", or ".".
//   :\/\/            - Match "://" to separate the protocol from the host.
//   ([^/]+)          - Capture the host (everything until the first "/" or end of string).
//   i                - Case-insensitive flag.
const PROXY_URL_REGEX = /^([a-z][a-z0-9+\-.]*):\/\/([^/]+)/i;
/**
 * Constructs the `Forwarded` header value for an HTTP request.
 *
 * In a production environment, this header is usually added by the CDN and references the configured site domain URL.
 * This function allows for customization by optionally overriding the protocol and host with a remote origin.
 *
 * @param incomingRequest - The incoming HTTP request object, contains details about the original express request.
 * @param remoteOrigin - Optional. A remote origin URL to override the default protocol and host values.
 * @returns The constructed `Forwarded` header string.
 */
function getForwardedHeader(incomingRequest, remoteOrigin) {
    const { host: remoteHost, proto: remoteProto } = remoteOrigin
        ? parseHostAndProto(remoteOrigin)
        : { host: undefined, proto: undefined };
    const host = remoteHost ?? incomingRequest.headers.host;
    const proto = remoteProto ?? incomingRequest.protocol;
    return `host=${host};proto=${proto}`;
}
/**
 * Parses the protocol and host from a given URL string.
 *
 * If the URL matches the expected format, it extracts the protocol and host.
 * If the URL is invalid, it logs a warning and returns a default protocol (`https`)
 * and the original string as the host.
 *
 * @param urlString - The URL string to parse.
 * @returns An object containing `proto` (protocol) and `host` values.
 *          If the URL is invalid, a default protocol (`https`) and the original
 *          string as the host are returned.
 */
function parseHostAndProto(urlString) {
    if (!urlString) {
        return {};
    }
    const match = PROXY_URL_REGEX.exec(urlString);
    if (match) {
        const [, proto, host] = match;
        return { proto, host };
    }
    logger.warn({
        label: 'dev-proxy-server',
        message: `Invalid remoteOrigin format: ${urlString}`,
    });
    return {
        host: urlString,
        proto: 'https',
    };
}
/**
 * Proxy middleware for handling requests that are served by the LWR server or lambda.
 *
 * @param app - The Express app instance to which the middleware is attached.
 * @param defaultHost - A URL string pointing to the local proxy server for handling requests.
 * @param remoteOrigin - A URL string representing the value of the first entry in the `_proxy` configuration file.
 */
export function addLocalProxyMiddleware(app, defaultHost, remoteOrigin) {
    // Extract the domain and port from the defaultHost URL string.
    const domainAndPort = parseHostAndProto(defaultHost).host;
    app.use('/', createProxyMiddleware({
        target: defaultHost,
        changeOrigin: true,
        onProxyReq: (proxyRequest, incomingRequest) => {
            // Set the Host header to the target
            const hostHeader = incomingRequest.headers.host;
            // This will be any time we have a proxy config
            if (hostHeader !== domainAndPort) {
                // Setting the Host Header to the domain and port for the proxy server URL
                proxyRequest.setHeader(HOST, domainAndPort);
                // Add the `Forwarded` header if it is not already set.
                const forwarded = incomingRequest.headers.forwarded;
                proxyRequest.setHeader('Forwarded', 
                // Set the `Forwarded` header using the first entry from the proxy configuration.
                forwarded ? forwarded : getForwardedHeader(incomingRequest, remoteOrigin));
                // Add auth token to cookies; used in the fetchController during local preview
                if (process.env.AUTH_TOKEN && !proxyRequest.path.startsWith('/mobify/bundle/')) {
                    addAuthCookie(proxyRequest, process.env.AUTH_TOKEN);
                }
            }
        },
    }));
}
/**
 * Middleware to handle API request proxying to a configured remote origin.
 *
 * This middleware forwards API requests to the specified remote origin
 * as defined in the proxy configuration.
 *
 * @param app - The Express app instance to which the middleware is attached.
 * @param proxyConfig - Configuration details initialized when the proxy server starts.
 */
export function addRemoteProxyMiddleware(app, proxyConfig) {
    const mobifyRules = process.env.ADD_MOBIFY_PROXY_RULES === 'true';
    const { proxyConfigs } = proxyConfig;
    for (const entry of proxyConfigs) {
        const [path, target] = entry;
        // Extract the domain and port from the API target URL string.
        const targetHost = parseHostAndProto(target).host;
        // TODO: Ask Commerce if this rewrite logic can be removed
        // Needed for commerce local-dev when running MRT bundles without a configured Cloudflare CDN
        // Rewrites /mobify/proxy/core and /mobify/caching/core paths (this is what pwa-kit does)
        const pathRewrite = mobifyRules && (path.indexOf('/mobify/proxy') === 0 || path.indexOf('/mobify/caching') === 0)
            ? { [path]: '' }
            : undefined;
        app.use(path, createProxyMiddleware({
            target,
            pathRewrite,
            logLevel: resolveLogLevel(logger.getLogLevel()),
            logProvider: () => {
                return logger;
            },
            followRedirects: false,
            changeOrigin: true,
            autoRewrite: false,
            ignorePath: false,
            onProxyReq: (proxyRequest, incomingRequest) => {
                // Fix up any Host header. We ignore any current value and
                // always replace it with the target host.
                // Host: <host>:<port>
                const hostHeader = incomingRequest.headers.host;
                if (hostHeader !== target) {
                    proxyRequest.setHeader(HOST, targetHost);
                }
                // Add Forwarded header per https://git.soma.salesforce.com/pages/benjamin-fry/lwr-on-mrt-designs/request_path.html
                // Based on the incoming request's host and protocol. Is this necessary for API calls?
                proxyRequest.setHeader('Forwarded', getForwardedHeader(incomingRequest));
                // Preserve the original path, including double slashes
                const originalPath = incomingRequest.url;
                proxyRequest.path = originalPath;
                // Add auth token in cookies
                // Retrieve the current cookie header
                if (process.env.AUTH_TOKEN) {
                    addAuthCookie(proxyRequest, process.env.AUTH_TOKEN);
                }
            },
        }));
    }
}
function resolveLogLevel(currentLevel) {
    // uplift VERBOSE to DEBUG; otherwise using runtime loglevel;
    if (logger.isDebugEnabled())
        return ProxyLogLevels.Debug;
    if (logger.isInfoEnabled())
        return ProxyLogLevels.Info;
    if (logger.isWarnEnabled())
        return ProxyLogLevels.Warn;
    if (logger.isErrorEnabled())
        return ProxyLogLevels.Error;
    // default log level
    return ProxyLogLevels.Silent;
}
function addAuthCookie(req, authToken) {
    let cookies = req.getHeader('cookie') || '';
    // Append the SID token to the cookies
    const sidCookie = `__Secure-has-sid=1; sid=${authToken};`;
    if (cookies) {
        cookies += `; ${sidCookie}`;
    }
    else {
        cookies = sidCookie;
    }
    // Set our auth cookies on the proxied request
    req.setHeader('cookie', cookies);
}
//# sourceMappingURL=middleware.js.map