import { getSpecifier, stringToVariableName } from '@lwrjs/shared-utils';
function getDefaultImportName(service) {
    return stringToVariableName(`loaderService_${service}`);
}
function createServicesSource(services) {
    const imports = services.map((service) => {
        const serviceId = getSpecifier(service);
        const defaultImportName = getDefaultImportName(serviceId);
        return `import ${defaultImportName} from '${serviceId}'`;
    });
    const body = services.map((service) => {
        const serviceId = getSpecifier(service);
        const defaultImportName = getDefaultImportName(serviceId);
        return `${defaultImportName}({...services, addServerDataCallback: registerServerDataCallbacks })`;
    });
    return [...imports, ...body].join(';\n') + ';';
}
/**
 * Create the virtual source for the application bootstrap module with a worker root
 * @returns the generated source
 */
export function createAppWorkerBootstrapModule(workerSpecifier, route, options) {
    // app the route's bootstrap configuration to the worker bootstrap module
    const { bootstrap: { services, syntheticShadow }, } = route;
    const servicesSource = services && createServicesSource(services);
    const serviceApiModule = getServiceApiModule(options.format, options.moduleLoader);
    return [
        '/* This module is generated */',
        // conditional shadow
        syntheticShadow && `import '@lwc/synthetic-shadow';`,
        // Import loader services
        services && services.length && `import { services } from '${serviceApiModule}';`,
        // import and register the configured services
        servicesSource,
        // init module
        `import { init, toKebabCase } from 'lwr/init';`,
        // Import the worker ( no need to initialize the worker )
        `import Worker from "${workerSpecifier}";`,
    ]
        .filter(Boolean)
        .join('\n');
}
function getServiceApiModule(format, moduleLoader) {
    if (format == 'esm') {
        // import ESM version of ServiceAPI
        return 'lwr/servicesESM';
    }
    else {
        // AMD Loader
        return moduleLoader;
    }
}
/**
 * Create the virtual source for the application bootstrap module
 * @returns the generated source
 */
export function createAppRouteViewBootstrapModule(route, options, lockerConfig) {
    const { bootstrap } = route;
    const { services, syntheticShadow, ssr } = bootstrap;
    const isAMD = options.format === 'amd';
    const isESM = options.format === 'esm';
    const servicesSource = bootstrap.services && createServicesSource(bootstrap.services);
    const serviceApiModule = getServiceApiModule(options.format, options.moduleLoader);
    return [
        '/* This module is generated */',
        // pre app initialization step
        `import { getClientBootstrapConfig } from 'lwr/preInit';`,
        // conditional shadow
        syntheticShadow && `import '@lwc/synthetic-shadow';`,
        // Declarative ShadowDOM polyfill
        ssr && `import { polyfillDeclarativeShadowDom } from 'lwr/declarativeShadow';`,
        // Import bootstrap services
        // Note: in AMD, only part of the ServiceAPI contract is implemented by the AMD loader
        services && services.length && `import { services } from '${serviceApiModule}';`,
        services &&
            services.length &&
            `import { registerServerDataCallbacks, evaluateServerDataCallbacks } from 'lwr/serverDataCallback';`,
        // import and register the configured services
        servicesSource,
        // HMR (ESM format only)
        isESM && options.hmrEnabled && `import { initHMR } from 'lwr/hmr';`,
        // Import the ESM module initializer
        isESM && `import { init as esmLoaderInit } from 'lwr/esmLoader';`,
        // init module
        `import { init, toKebabCase } from 'lwr/init';`,
        // locker
        isAMD &&
            lockerConfig &&
            lockerConfig.enabled &&
            `
import { registerLockerDefine } from 'lwr/lockerDefine';
registerLockerDefine(${JSON.stringify(lockerConfig.trustedComponents)});
        `,
        // grab client bootstrap config
        `const clientBootstrapConfig = getClientBootstrapConfig();`,
        `const { serverData, rootComponents } = clientBootstrapConfig;`,
        // Initialize the ESM loader with the Client Bootstrap Config
        isESM &&
            `
const { imports, index, importMappings, endpoints } = clientBootstrapConfig;
esmLoaderInit({ imports, index, importMappings, endpoints });`,
        // Invoke the Declarative ShadowDOM polyfill
        ssr && `polyfillDeclarativeShadowDom();`,
        // Invoke `serverDataCallback` bootstrap services
        services && services.length && `evaluateServerDataCallbacks(serverData)`,
        `
// initialize additional non-configured root components
Promise.all(rootComponents.map(async (rootSpecifier) => {
    const element = toKebabCase(rootSpecifier);
    const { default: Ctor } = await import(rootSpecifier);
    return [element, Ctor];
})).then((rootModules) => {
    return init(rootModules, serverData);
}).then(() => {
    globalThis?.lwcRuntimeFlags?.ENABLE_WIRE_SYNC_EMIT &&
        (globalThis.lwcRuntimeFlags = {
            ...globalThis.lwcRuntimeFlags,
            ENABLE_WIRE_SYNC_EMIT: false,
        });
});`,
        isESM &&
            options.hmrEnabled &&
            `
// HMR related initialization
const viewMetadata = globalThis._lwrRuntimeDebug.viewMetadata;
const hmrEndpoint = clientBootstrapConfig.endpoints.uris.hmr;
initHMR(hmrEndpoint, viewMetadata);`,
    ]
        .filter(Boolean)
        .join('\n');
}
//# sourceMappingURL=utils.js.map