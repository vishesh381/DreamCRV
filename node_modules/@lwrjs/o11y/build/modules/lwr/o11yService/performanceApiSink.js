import { BOOTSTRAP_DURATION, BOOTSTRAP_END, BOOTSTRAP_ERROR, BOOTSTRAP_ERROR_COUNT, INIT, INIT_DURATION, INIT_MODULE, INIT_MODULE_DURATION, INIT_MODULE_COUNT, MAPPINGS_ERROR, MAPPINGS_ERROR_COUNT, MAPPINGS_FETCH, MAPPINGS_FETCH_COUNT, MAPPINGS_FETCH_DURATION, MODULE_DEFINE, MODULE_DEFINE_COUNT, MODULE_ERROR, MODULE_ERROR_COUNT, MODULE_DYNAMIC_LOAD, MODULE_DYNAMIC_LOAD_COUNT, MODULE_FETCH, MODULE_FETCH_COUNT, MODULE_FETCH_DURATION, ROUTER_ERROR, ROUTER_ERROR_COUNT, ROUTER_NAV, ROUTER_NAV_COUNT, ROUTER_NAV_DURATION, ROUTER_VIEW, ROUTER_VIEW_DURATION } from 'lwr/metrics';
const doNotClear = [MODULE_DYNAMIC_LOAD, MODULE_FETCH, MAPPINGS_FETCH, INIT, INIT_MODULE, ROUTER_NAV, ROUTER_VIEW];
const durationMap = {
  [INIT]: INIT_DURATION,
  [INIT_MODULE]: INIT_MODULE_DURATION,
  [ROUTER_NAV]: ROUTER_NAV_DURATION,
  [ROUTER_VIEW]: ROUTER_VIEW_DURATION
};
const metricsToTrack = Object.keys(durationMap);
const countMap = {
  [BOOTSTRAP_ERROR]: BOOTSTRAP_ERROR_COUNT,
  [INIT_MODULE]: INIT_MODULE_COUNT,
  [MODULE_DEFINE]: MODULE_DEFINE_COUNT,
  [MODULE_FETCH]: MODULE_FETCH_COUNT,
  [MODULE_ERROR]: MODULE_ERROR_COUNT,
  [MODULE_DYNAMIC_LOAD]: MODULE_DYNAMIC_LOAD_COUNT,
  [MAPPINGS_FETCH]: MAPPINGS_FETCH_COUNT,
  [MAPPINGS_ERROR]: MAPPINGS_ERROR_COUNT,
  [ROUTER_NAV]: ROUTER_NAV_COUNT,
  [ROUTER_ERROR]: ROUTER_ERROR_COUNT
};
const metricsToCount = Object.keys(countMap);
export class PerformanceApiSink {
  constructor(instrumentation, config) {
    this.config = config || {};
    this.instrumentation = instrumentation;
  }
  track() {
    this.trackExistingMarks();
    this.setupObserver();
  }

  // Retrieve existing loader define metrics to this point
  trackExistingMarks() {
    const defineMarks = performance.getEntriesByType('mark').filter(e => e.name.startsWith(MODULE_DEFINE));
    const dynamicLoadMarks = performance.getEntriesByType('mark').filter(e => e.name.startsWith(MODULE_DYNAMIC_LOAD));

    // Initialize the module define count
    // At this point in time, the count will include modules NOT fetched by the loader:
    //      - required modules
    //      - preload modules
    //      - the application bootstrap module
    //      - the loader module itself
    if (defineMarks.length > 0) {
      this.instrumentation.incrementCounter(MODULE_DEFINE_COUNT, defineMarks.length);
    }
    if (dynamicLoadMarks.length > 0) {
      this.instrumentation.incrementCounter(MODULE_DYNAMIC_LOAD_COUNT, dynamicLoadMarks.length);
    }
  }

  // Add observer to log future metrics
  setupObserver() {
    const observer = new PerformanceObserver(list => {
      list.getEntries().forEach(entry => {
        const {
          name,
          duration,
          startTime,
          entryType
        } = entry;
        const id = name.split('-')[0];

        // Track the bootstrap duration from navigation.start to lwr.bootstrap.end
        if (name === BOOTSTRAP_END) {
          this.instrumentation.trackValue(BOOTSTRAP_DURATION, startTime);
        }

        // Increment count metrics
        if (entryType === 'mark') {
          const metadata = entry.detail || {};
          const metricToCount = metricsToCount.find(c => c === id);
          if (metricToCount) {
            this.instrumentation.incrementCounter(countMap[metricToCount], 1, false, metadata);
          }
        }

        // Record duration metrics
        if (entryType === 'measure') {
          const tags = entry.detail || {};
          if (this.config.enableModuleFetchTracking && name.startsWith(MODULE_FETCH)) {
            this.instrumentation.trackValue(MODULE_FETCH_DURATION, duration, false, tags);
          }
          if (this.config.enableMappingFetchTracking && name.startsWith(MAPPINGS_FETCH)) {
            this.instrumentation.trackValue(MAPPINGS_FETCH_DURATION, duration, false, tags);
          }
          const metricToTrack = metricsToTrack.find(d => d === id);
          if (metricToTrack) {
            this.instrumentation.trackValue(durationMap[metricToTrack], duration, false, tags);
          }
        }

        // Remove clearable marks
        // A mark is clearable if it does not have a corresponding logOperationEnd / measure
        if (!doNotClear.some(m => name.startsWith(m))) {
          performance.clearMarks(name);
        }
      });
    });
    observer.observe({
      entryTypes: ['mark', 'measure']
    });
  }
}