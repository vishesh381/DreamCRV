var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/api/src/localdev/providers/override-bundle-provider.ts
__markAsModule(exports);
__export(exports, {
  default: () => override_bundle_provider_default
});
var import_bundle_provider = __toModule(require("@lwrjs/static/bundle-provider"));
var import_fs_extra = __toModule(require("fs-extra"));
var import_path = __toModule(require("path"));
var import_diagnostics = __toModule(require("@lwrjs/diagnostics"));
var LWR_DEFINE_REGEX = /LWR\.define\(["']([^"']+)["']/g;
var StaticOverrideBundleProvider = class extends import_bundle_provider.default {
  constructor(options, context) {
    super({
      ...options,
      bundleCacheSize: 0
    }, context);
    if (!context.siteMetadata) {
      throw new Error(`[${this.name}] Site metadata was not found`);
    }
    this.debug = context.runtimeEnvironment.debug;
    this.overrideDir = options.overrideDir || "app";
    this.inlineUpdate = options.inlineUpdate || false;
    this.moduleRegistry = context.moduleRegistry;
    this.moduleBundler = context.moduleBundler;
    this.cacheDir = context.config.cacheDir;
    this.staticBundles = Object.keys(context.siteMetadata.getSiteBundles().bundles);
  }
  findIndex(index1, index2) {
    let startIndex;
    if (index1 !== -1) {
      if (index2 !== -1) {
        startIndex = index1 > index2 ? index2 : index1;
      } else {
        startIndex = index1;
      }
    } else {
      startIndex = index2;
    }
    return startIndex;
  }
  getLocalDevOverrideUrl(overridesDir, specifier, filepath) {
    const overrideFilePath = import_path.default.join(overridesDir, filepath);
    const overrideDirPath = import_path.default.dirname(overrideFilePath);
    if (!import_fs_extra.default.existsSync(overrideDirPath)) {
      import_fs_extra.default.ensureDirSync(overrideDirPath);
    }
    return overrideFilePath;
  }
  async bundle(moduleId, runtimeEnvironment, runtimeParams) {
    const bundleDef = await super.bundle(moduleId, runtimeEnvironment, runtimeParams);
    const code = await bundleDef?.getCode();
    if (!code || !moduleId.specifier.startsWith("@view")) {
      return bundleDef;
    }
    const matches = Array.from(code.matchAll(LWR_DEFINE_REGEX), (match) => match[1]);
    const numOfLwrDefines = matches.length;
    if (!numOfLwrDefines) {
      return bundleDef;
    }
    const locals = (await Promise.all(matches.map(async (specifier) => {
      try {
        if (specifier === "lwr/environment")
          return void 0;
        const entry = await this.moduleRegistry.getModuleEntry({specifier}, runtimeParams);
        if (!entry.scope)
          return void 0;
        const isSymLink = import_fs_extra.default.lstatSync(entry.scope).isSymbolicLink();
        return entry?.scope === process.cwd() || isSymLink ? specifier : void 0;
      } catch (err) {
        return void 0;
      }
    }))).filter((s) => s !== void 0);
    const codes = await Promise.all(locals.map(async (specifier) => {
      try {
        const local = await this.moduleBundler.getModuleBundle({specifier}, runtimeEnvironment, runtimeParams, {
          exclude: matches.concat(this.staticBundles)
        });
        return {specifier, code: "(function() { " + await local.getCode() + "})();"};
      } catch (err) {
        import_diagnostics.logger.warn(`Failed to override "${specifier}"`);
        throw err;
      }
    }));
    await this.updateBundleCode(codes, bundleDef, numOfLwrDefines);
    const overrideSourcePath = await this.writeBundle(moduleId, bundleDef);
    bundleDef.srcOverride = overrideSourcePath;
    return bundleDef;
  }
  async writeBundle(moduleId, bundleDef) {
    const ssr = false;
    const metadata = super.getBundleMetadata({moduleId, localeId: "en-US", debug: this.debug, ssr});
    const fullPath = metadata?.path || "";
    const cachePath = this.getLocalDevOverrideUrl(import_path.default.join(this.overrideDir), moduleId.specifier, fullPath);
    const code = await bundleDef.getCode();
    import_fs_extra.default.writeFileSync(cachePath, code);
    return cachePath;
  }
  async updateBundleCode(codes, bundleDef, numOfLwrDefines) {
    if (this.inlineUpdate) {
      for (let i = 0; i < codes.length; i++) {
        const obj = codes[i];
        await this.updateBundleCodeInline(obj.specifier, obj.code, bundleDef);
      }
      const code = await bundleDef.getCode();
      const newNumOfLwrDefines = Array.from(code.matchAll(LWR_DEFINE_REGEX), (match) => match[1]).length;
      if (numOfLwrDefines !== newNumOfLwrDefines) {
        import_diagnostics.logger.error(`Warning - numOfLwrDefines: ${numOfLwrDefines} doesn't match newNumOfLwrDefines ${newNumOfLwrDefines}.`);
      }
    } else {
      const code = await bundleDef.getCode();
      bundleDef.getCode = () => Promise.resolve(codes.map((obj) => obj.code).join("") + code);
    }
  }
  async updateBundleCodeInline(specifier, newCode, bundleDef) {
    const code = await bundleDef.getCode();
    const startMarker = `LWR.define("${specifier}",`;
    const startMarkerAlt = `LWR.define('${specifier}',`;
    const endMarker = `(function() { LWR.define(`;
    const endMarkerAlt = `LWR.define(`;
    const startIndex1 = code.indexOf(startMarker);
    const startIndex2 = code.indexOf(startMarkerAlt);
    let startIndex = this.findIndex(startIndex1, startIndex2);
    if (startIndex === -1) {
      throw new Error(`Module '${specifier}' not found.`);
    }
    const endIndex1 = code.indexOf(endMarker, startIndex + startMarker.length);
    const endIndex2 = code.indexOf(endMarkerAlt, startIndex + startMarker.length);
    const endIndex = this.findIndex(endIndex1, endIndex2);
    const moduleEndIndex = endIndex !== -1 ? endIndex : code.length;
    if (startIndex - 14 >= 0) {
      const startsWithFunc = code.substring(startIndex - 14, startIndex);
      if (startsWithFunc === "(function() { ") {
        startIndex = startIndex - 14;
      }
    }
    bundleDef.getCode = () => Promise.resolve(code.substring(0, startIndex) + newCode + code.substring(moduleEndIndex));
  }
};
var override_bundle_provider_default = StaticOverrideBundleProvider;
