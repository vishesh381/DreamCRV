var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/api/src/localdev/dev-server.ts
__markAsModule(exports);
__export(exports, {
  createDevServer: () => createDevServer
});
var import_path = __toModule(require("path"));
var import_fs = __toModule(require("fs"));
var import_url = __toModule(require("url"));
var import_core = __toModule(require("@lwrjs/core"));
var import_express = __toModule(require("express"));
var import_config = __toModule(require("@lwrjs/config"));
var import_dev_proxy_server = __toModule(require("@lwrjs/dev-proxy-server"));
var import_diagnostics = __toModule(require("@lwrjs/diagnostics"));
var import_shared_utils = __toModule(require("@lwrjs/shared-utils"));
var import_meta = {};
async function createDevServer(options) {
  const {siteDir = ".", inlineUpdate, writeSrcFilesToBundle, mode = "dev"} = options;
  const appDir = import_path.default.join(siteDir, "app");
  import_diagnostics.logger.debug(`appDir: ${appDir}`);
  const fullPathAppDir = import_path.default.join(process.cwd(), appDir);
  import_diagnostics.logger.debug(`fullPathAppDir: ${fullPathAppDir}`);
  const cacheDir = import_path.default.join(fullPathAppDir, "__lwr_cache__");
  const overrideDir = writeSrcFilesToBundle ? import_path.default.join(fullPathAppDir, "site") : import_path.default.join(fullPathAppDir, "__overrides__");
  process.env.MRT_BUNDLE_ROOT = appDir;
  process.env.ENABLE_NONCE = "false";
  process.env.LOCAL = "true";
  process.env.PROXY_FOR_SSR = "false";
  process.env.REEVALUATE_MODULES = "true";
  const configPath = (0, import_shared_utils.crossEnvFileURL)(import_path.default.join(fullPathAppDir, "ssr.js"));
  const {
    MRT_APP_CONFIG: {appConfig}
  } = await Promise.resolve().then(() => __toModule(require(configPath)));
  const staticSiteGenerator = {
    ...appConfig.staticSiteGenerator,
    outputDir: import_path.default.join(appDir, appConfig.staticSiteGenerator.outputDir)
  };
  if (mode === "prod") {
    try {
      const aConfig = (0, import_config.loadConfig)({rootDir: process.cwd()});
      staticSiteGenerator._additionalRoutePaths = aConfig.appConfig?.staticSiteGenerator?._additionalRoutePaths || [];
    } catch (e) {
      import_diagnostics.logger.info({
        label: "local-dev server",
        message: "no additional route paths to load"
      });
    }
  }
  const __dirname = import_path.default.dirname((0, import_url.fileURLToPath)(import_meta.url));
  if (options.sfCLI)
    process.env.SF_CLI_ROOT_DIR = __dirname;
  let lwcCompiler;
  const lwcCompilerPath = import_path.default.join(fullPathAppDir, "localdev", "lwc-compiler.js");
  if (import_fs.default.existsSync(lwcCompilerPath)) {
    try {
      lwcCompiler = await Promise.resolve().then(() => __toModule(require((0, import_shared_utils.crossEnvFileURL)(lwcCompilerPath))));
    } catch (e) {
      import_diagnostics.logger.warn({
        label: "local-dev server",
        message: "Could not import @lwc/compiler from the MRT bundle",
        additionalInfo: e
      });
    }
  } else {
    import_diagnostics.logger.warn({
      label: "local-dev server",
      message: "Application does not contain a bundled @lwc/compiler"
    });
  }
  if (import_fs.default.existsSync(cacheDir)) {
    import_diagnostics.logger.debug(`deleting pre-existing cache dir: ${cacheDir}`);
    import_fs.default.rmSync(cacheDir, {recursive: true, force: true});
  }
  const app = (0, import_core.createServer)({
    ...appConfig,
    basePath: options.basePath,
    ignoreLwrConfigFile: true,
    rootDir: process.cwd(),
    cacheDir,
    lwc: {modules: [...appConfig.lwc.modules, {dir: import_path.default.join(__dirname, "modules")}]},
    moduleProviders: [
      import_path.default.join(__dirname, "providers", "alias-static-module-provider.js"),
      "@lwrjs/module-registry/externals-module-provider",
      [import_path.default.join(__dirname, "providers", "evergreen-lwc-module-provider.js"), {lwcCompiler}],
      [import_path.default.join(__dirname, "providers", "sfdx-module-provider.js"), {lwcCompiler}],
      import_path.default.join(__dirname, "providers", "fallthrough-module-provider.js")
    ],
    bundleProviders: [
      [import_path.default.join(__dirname, "providers", "override-bundle-provider.js"), {inlineUpdate, overrideDir}],
      "@lwrjs/module-bundler/amd-bundle-provider"
    ],
    assetProviders: ["@lwrjs/static/asset-provider"],
    assetTransformers: [],
    resourceProviders: ["@lwrjs/static/resource-provider"],
    uriTransformers: ["@lwrjs/static/mrt-static-uri-transformer"],
    hooks: [import_path.default.join(__dirname, "hooks", mode + "-context-hook.js")],
    staticSiteGenerator,
    port: options.port,
    routeHandlers: {},
    routes: []
  });
  const server = app.getInternalServer();
  if (options.basePath) {
    server.use(`/assets`, import_express.default.static(import_path.default.join(fullPathAppDir, "site", "assets")));
  }
  const staticMiddlewareUrl = `/mobify/bundle/development/${appDir}`.replace(/\\/g, "/");
  import_diagnostics.logger.debug(`Static middleware URL: ${staticMiddlewareUrl}`);
  if (!writeSrcFilesToBundle) {
    import_diagnostics.logger.debug(`Overrides dir: ${overrideDir}`);
    server.use(`${staticMiddlewareUrl}/site/prod`, import_express.default.static(import_path.default.join(overrideDir, "prod")));
    server.use(`${staticMiddlewareUrl}/site/dev`, import_express.default.static(import_path.default.join(overrideDir, "dev")));
  }
  server.use(`${staticMiddlewareUrl}/site`, import_express.default.static(import_path.default.join(fullPathAppDir, "site")));
  await createDevProxy(server, fullPathAppDir);
  return app;
}
var PROXY_PATHS = ["/services", "/webruntime", "/sfsites", "/vforcesite", "/favicon.ico", "/cdn-cgi"];
function createDevProxy(server, rootDir) {
  const proxyConfig = (0, import_dev_proxy_server.findProxyConfiguration)(rootDir);
  if (proxyConfig) {
    const proxyRules = proxyConfig.proxyConfigs;
    const missingRules = PROXY_PATHS.filter((entryPath) => !proxyRules.find(([p]) => entryPath === p));
    if (missingRules.length > 0) {
      const fixRules = process.env.MRT_PROXY_FIXUP !== "false";
      import_diagnostics.logger[fixRules ? "info" : "warn"]({
        label: "local-dev",
        message: `The proxy configuration is incomplete.${fixRules ? " Adding missing rules now..." : " The site may not function properly."}`,
        additionalInfo: missingRules
      });
      if (proxyRules.length > 0 && fixRules) {
        const target = proxyRules[0][1];
        missingRules.forEach((entryPath) => proxyRules.push([entryPath, target]));
      }
    }
    (0, import_dev_proxy_server.addRemoteProxyMiddleware)(server, proxyConfig);
  }
}
