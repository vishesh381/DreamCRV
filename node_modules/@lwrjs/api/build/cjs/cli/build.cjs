var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/api/src/cli/build.ts
__markAsModule(exports);
__export(exports, {
  build: () => build
});
var import_fs_extra = __toModule(require("fs-extra"));
var import_path = __toModule(require("path"));
var import_diagnostics = __toModule(require("@lwrjs/diagnostics"));
var import_utils = __toModule(require("./utils.cjs"));
var import_config = __toModule(require("@lwrjs/config"));
var import_tools = __toModule(require("@lwrjs/tools"));
var RUNTIME_CONFIG_SRC_DIR = "config";
async function build(options) {
  const {rootDir, config, output, mode, clean, target, minify, routes, modules, locales, logLevel} = options;
  process.env.LWR_LOG_LEVEL = logLevel;
  const outputDir = output ? output : (0, import_utils.getDefaultBuildDirectory)(rootDir, config, target);
  const aConfig = (0, import_config.loadConfig)({rootDir, lwrConfigFile: config});
  let ssrFunctionNodeVersion;
  if (target === "mrt") {
    process.env.SINGLE_RENDER_MODE = "true";
    process.env.REEVALUATE_MODULES = "true";
    process.env.LEGACY_LOADER = "true";
    ssrFunctionNodeVersion = getSuggestedNodeVersion();
  }
  if (clean) {
    import_diagnostics.logger.info({label: `build`, message: `Clearing output directory: ${outputDir}`});
    import_fs_extra.default.rmSync(outputDir, {recursive: true, force: true});
  } else {
    if (import_fs_extra.default.existsSync(`${outputDir}`)) {
      import_diagnostics.logger.warn({
        label: `build`,
        message: `Output directory already exists. Previously generated files will not be deleted. If you did not intend to do this, re-run with --clean true`
      });
    }
  }
  const generatedSitePath = target === "mrt" ? import_path.default.join(outputDir, "site") : outputDir;
  const {generateStaticSite} = await Promise.resolve().then(() => __toModule(require("@lwrjs/core")));
  const theLocales = locales ? locales.map((l) => {
    return {id: l};
  }) : aConfig.appConfig.i18n?.locales || [];
  const i18n = {
    ...aConfig.appConfig.i18n,
    locales: theLocales
  };
  try {
    const _additionalRoutePaths = routes || aConfig.appConfig.staticSiteGenerator._additionalRoutePaths || [];
    const _additionalModules = modules || aConfig.appConfig.staticSiteGenerator._additionalModules || [];
    const staticSiteGenerator = {
      outputDir: generatedSitePath,
      skipCleanOutputDir: true,
      _additionalRoutePaths,
      _additionalModules
    };
    await generateStaticSite({
      serverMode: mode,
      staticSiteGenerator,
      i18n
    });
    stageProxyConfig(rootDir, outputDir);
  } catch (error) {
    import_diagnostics.logger.error(error);
  }
  let mainScriptName;
  if (target === "mrt") {
    await (0, import_tools.dedupeBundles)(generatedSitePath, i18n);
    const config2 = aConfig.appConfig;
    const rootDir2 = config2.rootDir;
    try {
      import_diagnostics.logger.info({label: `build`, message: `Generating ssr.js`});
      const {buildServer, REQUEST_SCRIPT_NAME} = await Promise.resolve().then(() => __toModule(require("@lwrjs/tools")));
      mainScriptName = REQUEST_SCRIPT_NAME;
      const castMinify = minify == "false" ? false : !!minify;
      await buildServer({rootDir: rootDir2, serverMode: mode, staticSiteGenerator: {outputDir: "site"}}, {outputDir, minify: castMinify});
    } catch (error) {
      import_diagnostics.logger.error(error);
    }
    const dirsInConfig = [];
    try {
      import_fs_extra.default.writeFileSync(import_path.default.join(outputDir, "loader.js"), "");
      const packageJson = JSON.parse(import_fs_extra.default.readFileSync(import_path.default.join(rootDir2, "package.json"), "utf-8"));
      if (!packageJson.main) {
        createMainScript(outputDir);
      }
      import_fs_extra.default.writeFileSync(import_path.default.join(outputDir, "package.json"), JSON.stringify({
        name: packageJson.name ? packageJson.name : "lwr-app",
        version: packageJson.version ? packageJson.version : "1.0.0",
        license: packageJson.license ? packageJson.license : "MIT",
        main: packageJson.main ? packageJson.main : mainScriptName,
        scripts: mainScriptName && !packageJson.main ? {request: `node ${mainScriptName}`} : {}
      }, null, 4));
      import_diagnostics.logger.info({label: `build`, message: `copying source files`});
      const contentDir = config2.contentDir;
      if (import_fs_extra.default.existsSync(contentDir)) {
        const relPath = contentDir.substring(rootDir2.length);
        dirsInConfig.push(import_path.default.join(".", relPath, "**"));
        const contentOutputDir = import_path.default.join(outputDir, relPath);
        import_fs_extra.default.copySync(contentDir, contentOutputDir);
      }
      const layoutDir = config2.layoutsDir;
      if (import_fs_extra.default.existsSync(layoutDir)) {
        const relPath = layoutDir.substring(rootDir2.length);
        dirsInConfig.push(import_path.default.join(".", relPath, "**"));
        const layoutOutputDir = import_path.default.join(outputDir, relPath);
        import_fs_extra.default.copySync(layoutDir, layoutOutputDir);
      }
      const globalDataDir = config2.globalDataDir;
      if (import_fs_extra.default.existsSync(globalDataDir)) {
        const relPath = globalDataDir.substring(rootDir2.length);
        dirsInConfig.push(import_path.default.join(".", relPath, "**"));
        const globalDataOutputDir = import_path.default.join(outputDir, relPath);
        import_fs_extra.default.copySync(globalDataDir, globalDataOutputDir);
      }
    } catch (e) {
      import_diagnostics.logger.error(e);
    }
    import_diagnostics.logger.info({label: `build`, message: `generating default.json`});
    try {
      const configFile = import_path.default.join(rootDir2, RUNTIME_CONFIG_SRC_DIR, "default.json");
      const outputConfigFile = import_path.default.join(outputDir, RUNTIME_CONFIG_SRC_DIR, "default.json");
      import_fs_extra.default.ensureDirSync(import_path.default.join(outputDir, RUNTIME_CONFIG_SRC_DIR));
      if (import_fs_extra.default.existsSync(configFile)) {
        import_diagnostics.logger.warn({
          label: `build`,
          message: `You have a config file already defined, using that rather than generating one.`
        });
        import_fs_extra.default.copyFileSync(configFile, outputConfigFile);
      } else {
        const defaultConfigContent = {
          ssrEnabled: true,
          ssrOnly: [
            "config/**",
            "package.json",
            "ssr.js",
            "ssr.js.map",
            "site/.metadata/**",
            "site/1/bundle-server/**"
          ],
          ssrShared: ["site/1/application/**", "site/1/resource/**"],
          ssrParameters: {
            ssrFunctionNodeVersion,
            proxyConfigs: []
          }
        };
        defaultConfigContent.ssrOnly.push(...dirsInConfig);
        if (process.env.SSR_ONLY_DIRS) {
          defaultConfigContent.ssrOnly.push(...process.env.SSR_ONLY_DIRS.split(",").map((value) => value.trim()));
        }
        if (process.env.ASSETS_ON_LAMBDA) {
          defaultConfigContent.ssrShared.push("site/1/asset/**");
        }
        if (process.env.SSR_SHARED_DIRS) {
          defaultConfigContent.ssrShared.push(...process.env.SSR_SHARED_DIRS.split(",").map((value) => value.trim()));
        }
        import_fs_extra.default.writeFileSync(outputConfigFile, JSON.stringify(defaultConfigContent, null, 4));
      }
    } catch (e) {
      import_diagnostics.logger.error(e);
    }
    import_diagnostics.logger.info({label: `build`, message: `complete`});
  }
}
function getSuggestedNodeVersion() {
  const nodeVersion = process.version;
  const majorVersion = parseInt(nodeVersion.slice(1).split(".")[0]);
  return `${majorVersion}.x`;
}
function stageProxyConfig(rootDir, outputDir) {
  try {
    const configFile = import_path.default.join(rootDir, RUNTIME_CONFIG_SRC_DIR, "_proxy");
    const outputConfigFile = import_path.default.join(outputDir, RUNTIME_CONFIG_SRC_DIR, "_proxy");
    if (import_fs_extra.default.existsSync(configFile)) {
      import_diagnostics.logger.info({label: `build`, message: `staging proxy configuration`});
      import_fs_extra.default.ensureDirSync(import_path.default.join(outputDir, RUNTIME_CONFIG_SRC_DIR));
      import_fs_extra.default.copyFileSync(configFile, outputConfigFile);
    }
  } catch (e) {
    import_diagnostics.logger.error(e);
  }
}
function createMainScript(outputDir) {
  createLockFile(outputDir);
}
function detectPackageManager() {
  const userAgent = process.env.npm_config_user_agent || "";
  if (userAgent.includes("yarn")) {
    return "yarn";
  } else if (userAgent.includes("npm")) {
    return "npm";
  }
  return "npm";
}
function createLockFile(outputDir) {
  const packageManager = detectPackageManager();
  const lockFileName = packageManager === "yarn" ? "yarn.lock" : "package-lock.json";
  const lockFilePath = import_path.default.join(outputDir, lockFileName);
  if (!import_fs_extra.default.existsSync(lockFilePath)) {
    import_fs_extra.default.writeFileSync(lockFilePath, "");
  }
  if (packageManager === "yarn") {
    const rcFilePath = import_path.default.join(outputDir, ".yarnrc.yml");
    if (!import_fs_extra.default.existsSync(rcFilePath)) {
      import_fs_extra.default.writeFileSync(rcFilePath, "nodeLinker: node-modules");
    }
  }
}
