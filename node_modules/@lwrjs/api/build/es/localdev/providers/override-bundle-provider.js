import StaticBundler from '@lwrjs/static/bundle-provider';
import fs from 'fs-extra';
import path from 'path';
import { logger } from '@lwrjs/diagnostics';
const LWR_DEFINE_REGEX = /LWR\.define\(["']([^"']+)["']/g;
export default class StaticOverrideBundleProvider extends StaticBundler {
    constructor(options, context) {
        super({
            ...options,
            // Override the bundle code cache since we are depending on overwriting local bundles
            bundleCacheSize: 0,
        }, context);
        if (!context.siteMetadata) {
            throw new Error(`[${this.name}] Site metadata was not found`);
        }
        this.debug = context.runtimeEnvironment.debug;
        this.overrideDir = options.overrideDir || 'app';
        this.inlineUpdate = options.inlineUpdate || false;
        this.moduleRegistry = context.moduleRegistry;
        this.moduleBundler = context.moduleBundler;
        this.cacheDir = context.config.cacheDir;
        this.staticBundles = Object.keys(context.siteMetadata.getSiteBundles().bundles);
    }
    findIndex(index1, index2) {
        let startIndex;
        if (index1 !== -1) {
            if (index2 !== -1) {
                // Use the lowest value for start index
                startIndex = index1 > index2 ? index2 : index1;
            }
            else {
                startIndex = index1;
            }
        }
        else {
            startIndex = index2;
        }
        return startIndex;
    }
    // TODO update to include standalone component paths
    getLocalDevOverrideUrl(overridesDir, specifier, filepath) {
        const overrideFilePath = path.join(overridesDir, filepath);
        const overrideDirPath = path.dirname(overrideFilePath);
        // ensure override directory exists
        if (!fs.existsSync(overrideDirPath)) {
            fs.ensureDirSync(overrideDirPath);
        }
        return overrideFilePath;
    }
    async bundle(moduleId, runtimeEnvironment, runtimeParams) {
        const bundleDef = (await super.bundle(moduleId, runtimeEnvironment, runtimeParams));
        const code = await bundleDef?.getCode();
        // check if the requested module is a view bundle
        if (!code || !moduleId.specifier.startsWith('@view')) {
            return bundleDef;
        }
        // scrape all "LWR.define"s
        const matches = Array.from(code.matchAll(LWR_DEFINE_REGEX), (match) => match[1]);
        const numOfLwrDefines = matches.length;
        if (!numOfLwrDefines) {
            return bundleDef;
        }
        // treat current directory and symlinks as local source
        const locals = (await Promise.all(matches.map(async (specifier) => {
            try {
                // Skip lwr/environment for now to rule out other issues
                // TODO figure out why this has started happening for lwr components
                if (specifier === 'lwr/environment')
                    return undefined;
                const entry = await this.moduleRegistry.getModuleEntry({ specifier }, runtimeParams);
                if (!entry.scope)
                    return undefined;
                const isSymLink = fs.lstatSync(entry.scope).isSymbolicLink();
                return entry?.scope === process.cwd() || isSymLink ? specifier : undefined;
            }
            catch (err) {
                return undefined;
            }
        }))).filter((s) => s !== undefined);
        // Generate updated bundle code for each LWR.define that has local source code
        const codes = await Promise.all(locals.map(async (specifier) => {
            try {
                const local = await this.moduleBundler.getModuleBundle({ specifier }, runtimeEnvironment, runtimeParams, {
                    exclude: matches.concat(this.staticBundles),
                });
                return { specifier, code: '(function() { ' + (await local.getCode()) + '})();' };
            }
            catch (err) {
                logger.warn(`Failed to override "${specifier}"`);
                throw err;
            }
        }));
        // Update the bundled code with our local source
        await this.updateBundleCode(codes, bundleDef, numOfLwrDefines);
        // Write out the new bundle code to the file system
        const overrideSourcePath = await this.writeBundle(moduleId, bundleDef);
        // Update the bundle def source url - TODO verify this works in moduleLoader.ts
        bundleDef.srcOverride = overrideSourcePath;
        return bundleDef;
    }
    // MRT bundle paths have now changed from: '/app/site/dev/view/en-US/home_view.js'
    // to
    // '/app/site/dev/view/en-US/d92d8534792105b9a0e09b87fc32ddec/home_view.js'
    // TODO investigate a more clean way to do this across the bundle providers
    async writeBundle(moduleId, bundleDef) {
        // TODO For now we are just overriding default value for now
        // Need to support local dev for ssr as part of https://gus.lightning.force.com/lightning/r/ADM_Epic__c/a3QEE000001F2Dp2AK/view
        // Wen we have a dev model for SSR variants
        const ssr = false;
        const metadata = super.getBundleMetadata({ moduleId, localeId: 'en-US', debug: this.debug, ssr });
        // TODO we need the fullPath to the static file so we can properly put it in overrides
        const fullPath = metadata?.path || '';
        // write overridden view bundles to cache for client hydration
        const cachePath = this.getLocalDevOverrideUrl(path.join(this.overrideDir), moduleId.specifier, fullPath);
        const code = await bundleDef.getCode();
        fs.writeFileSync(cachePath, code);
        return cachePath;
    }
    async updateBundleCode(codes, bundleDef, numOfLwrDefines) {
        // if we have inlineUpdate set, we will attempt to overwrite each individual LWR.define statement
        // with the updated local source
        if (this.inlineUpdate) {
            for (let i = 0; i < codes.length; i++) {
                const obj = codes[i];
                // eslint-disable-next-line no-await-in-loop
                await this.updateBundleCodeInline(obj.specifier, obj.code, bundleDef);
            }
            const code = await bundleDef.getCode();
            // Verify the number of defines in the file match what we previously had
            const newNumOfLwrDefines = Array.from(code.matchAll(LWR_DEFINE_REGEX), (match) => match[1]).length;
            if (numOfLwrDefines !== newNumOfLwrDefines) {
                logger.error(`Warning - numOfLwrDefines: ${numOfLwrDefines} doesn't match newNumOfLwrDefines ${newNumOfLwrDefines}.`);
            }
        }
        else {
            // Just prepend our LWR.define statements to the top of the bundle
            const code = await bundleDef.getCode();
            bundleDef.getCode = () => Promise.resolve(codes.map((obj) => obj.code).join('') + code);
        }
    }
    async updateBundleCodeInline(specifier, newCode, bundleDef) {
        const code = await bundleDef.getCode();
        // Define the start of the module to replace
        const startMarker = `LWR.define("${specifier}",`;
        const startMarkerAlt = `LWR.define('${specifier}',`;
        // Define the end marker, assuming the next module definition starts with "LWR.define"
        const endMarker = `(function() { LWR.define(`;
        const endMarkerAlt = `LWR.define(`;
        // Find the start index, which will always be the lesser of the two possible indexes
        const startIndex1 = code.indexOf(startMarker);
        const startIndex2 = code.indexOf(startMarkerAlt);
        let startIndex = this.findIndex(startIndex1, startIndex2);
        if (startIndex === -1) {
            throw new Error(`Module '${specifier}' not found.`);
        }
        // Find the endIndex of the module by locating the start of the next module
        const endIndex1 = code.indexOf(endMarker, startIndex + startMarker.length);
        const endIndex2 = code.indexOf(endMarkerAlt, startIndex + startMarker.length);
        const endIndex = this.findIndex(endIndex1, endIndex2);
        // If we can't find another module after this one, assume this is the last module defined in the file
        const moduleEndIndex = endIndex !== -1 ? endIndex : code.length;
        // Check if our start index begins with a function wrapper
        if (startIndex - 14 >= 0) {
            const startsWithFunc = code.substring(startIndex - 14, startIndex);
            // If it does, make sure we replace that as well
            if (startsWithFunc === '(function() { ') {
                startIndex = startIndex - 14;
            }
        }
        // Update the code
        bundleDef.getCode = () => Promise.resolve(code.substring(0, startIndex) + newCode + code.substring(moduleEndIndex));
    }
}
//# sourceMappingURL=override-bundle-provider.js.map