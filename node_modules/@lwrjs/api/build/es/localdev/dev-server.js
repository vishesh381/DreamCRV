import path from 'path';
import fs from 'fs';
import { fileURLToPath } from 'url';
import { createServer } from '@lwrjs/core';
import express from 'express';
import { loadConfig } from '@lwrjs/config';
import { addRemoteProxyMiddleware, findProxyConfiguration } from '@lwrjs/dev-proxy-server';
import { logger } from '@lwrjs/diagnostics';
import { crossEnvFileURL } from '@lwrjs/shared-utils';
export async function createDevServer(options) {
    const { siteDir = '.', inlineUpdate, writeSrcFilesToBundle, mode = 'dev' } = options;
    // The siteDir is now just the top level directory which contains the extracted MRT app directory
    // ${siteDir}/app/site/view
    const appDir = path.join(siteDir, 'app');
    logger.debug(`appDir: ${appDir}`);
    // Full file system path to the appDir
    const fullPathAppDir = path.join(process.cwd(), appDir);
    logger.debug(`fullPathAppDir: ${fullPathAppDir}`);
    // LWR Cache Dir
    const cacheDir = path.join(fullPathAppDir, '__lwr_cache__');
    // Define which directory we will use to write out our source files
    const overrideDir = writeSrcFilesToBundle
        ? path.join(fullPathAppDir, 'site') // Overwrite files directly in the site bundle
        : path.join(fullPathAppDir, '__overrides__'); // Write files to separate __overrides dir
    // TEMP: need to define official directory name for local LWR@MRT bundle
    process.env.MRT_BUNDLE_ROOT = appDir;
    process.env.ENABLE_NONCE = 'false';
    // disables `createHandler` invocation while loading application build output
    process.env.LOCAL = 'true';
    // disable direct-to-core routing during local dev
    process.env.PROXY_FOR_SSR = 'false';
    // there is only 1 SSR loader/context and it is cleared between requests
    process.env.REEVALUATE_MODULES = 'true';
    const configPath = crossEnvFileURL(path.join(fullPathAppDir, 'ssr.js'));
    const { MRT_APP_CONFIG: { appConfig }, } = await import(configPath);
    // outputDir needs to match MRT_BUNDLE_ROOT for static-module-provider to find metadata
    const staticSiteGenerator = {
        ...appConfig.staticSiteGenerator,
        outputDir: path.join(appDir, appConfig.staticSiteGenerator.outputDir),
    };
    // Experimental: allow a local lwr.config.json file to specify the additional route paths for bundling
    // If we are packaging new dev/prod files, we need to load the additional route paths from the lwr.config.json file
    if (mode === 'prod') {
        try {
            const aConfig = loadConfig({ rootDir: process.cwd() });
            staticSiteGenerator._additionalRoutePaths =
                aConfig.appConfig?.staticSiteGenerator?._additionalRoutePaths || [];
        }
        catch (e) {
            logger.info({
                label: 'local-dev server',
                message: 'no additional route paths to load',
            });
        }
    }
    // TEMP: need to move providers(and maybe the dev server) out to a new package
    const __dirname = path.dirname(fileURLToPath(import.meta.url));
    // Set a root dir to resolve LWC modules against for the SF CLI case
    // TODO this needs a better solution - will be addressed in W-17095631
    if (options.sfCLI)
        process.env.SF_CLI_ROOT_DIR = __dirname;
    // Try to import the LWC compiler from the MRT bundle, so we can compile hot modules with a matching LWC version
    let lwcCompiler;
    const lwcCompilerPath = path.join(fullPathAppDir, 'localdev', 'lwc-compiler.js');
    if (fs.existsSync(lwcCompilerPath)) {
        try {
            // TODO this always fails when run from an installed SF CLI plugin because its missing babel dependencies.
            // The SF CLI uses the sfdx project as the root for node module discovery rather than the installed global CLI node modules
            lwcCompiler = await import(crossEnvFileURL(lwcCompilerPath));
        }
        catch (e) {
            // Fallback to use the @lwc/compiler imported by the @lwr/lwc-module-provider package
            logger.warn({
                label: 'local-dev server',
                message: 'Could not import @lwc/compiler from the MRT bundle',
                additionalInfo: e,
            });
        }
    }
    else {
        logger.warn({
            label: 'local-dev server',
            message: 'Application does not contain a bundled @lwc/compiler',
        });
    }
    // Delete our local cache on each startup until we can resolve issues
    if (fs.existsSync(cacheDir)) {
        logger.debug(`deleting pre-existing cache dir: ${cacheDir}`);
        fs.rmSync(cacheDir, { recursive: true, force: true });
    }
    const app = createServer({
        ...appConfig,
        basePath: options.basePath,
        // TODO should we allow some subset of LWR config here
        ignoreLwrConfigFile: true,
        // TODO retest these values out
        rootDir: process.cwd(),
        cacheDir,
        lwc: { modules: [...appConfig.lwc.modules, { dir: path.join(__dirname, 'modules') }] },
        moduleProviders: [
            path.join(__dirname, 'providers', 'alias-static-module-provider.js'),
            '@lwrjs/module-registry/externals-module-provider',
            [path.join(__dirname, 'providers', 'evergreen-lwc-module-provider.js'), { lwcCompiler }],
            [path.join(__dirname, 'providers', 'sfdx-module-provider.js'), { lwcCompiler }],
            path.join(__dirname, 'providers', 'fallthrough-module-provider.js'),
        ],
        bundleProviders: [
            [path.join(__dirname, 'providers', 'override-bundle-provider.js'), { inlineUpdate, overrideDir }],
            '@lwrjs/module-bundler/amd-bundle-provider',
        ],
        assetProviders: ['@lwrjs/static/asset-provider'],
        assetTransformers: [],
        resourceProviders: ['@lwrjs/static/resource-provider'],
        uriTransformers: ['@lwrjs/static/mrt-static-uri-transformer'],
        // Dev vs Prod context hook based on mode
        hooks: [path.join(__dirname, 'hooks', mode + '-context-hook.js')],
        staticSiteGenerator,
        port: options.port,
        routeHandlers: {},
        routes: [],
    });
    // Add middleware for overrides / proxy
    const server = app.getInternalServer();
    // Static middleware
    // Proxy assets correctly
    if (options.basePath) {
        server.use(`/assets`, express.static(path.join(fullPathAppDir, 'site', 'assets')));
    }
    // Construct base static path that our site will be served from
    const staticMiddlewareUrl = `/mobify/bundle/development/${appDir}`.replace(/\\/g, '/'); // backslashes in URLs are bad (windows)
    logger.debug(`Static middleware URL: ${staticMiddlewareUrl}`);
    // If we are overriding site bundles directly (rather than an overrides dir), we don't need to include this extra middleware
    if (!writeSrcFilesToBundle) {
        logger.debug(`Overrides dir: ${overrideDir}`);
        // Add override middleware
        server.use(`${staticMiddlewareUrl}/site/prod`, express.static(path.join(overrideDir, 'prod')));
        server.use(`${staticMiddlewareUrl}/site/dev`, express.static(path.join(overrideDir, 'dev')));
    }
    // Default middleware - forward any requests we aren't handling to the pre-built site folder
    server.use(`${staticMiddlewareUrl}/site`, express.static(path.join(fullPathAppDir, 'site')));
    // Proxy middleware to handle requests to core
    await createDevProxy(server, fullPathAppDir);
    return app;
}
const PROXY_PATHS = ['/services', '/webruntime', '/sfsites', '/vforcesite', '/favicon.ico', '/cdn-cgi'];
function createDevProxy(server, rootDir) {
    const proxyConfig = findProxyConfiguration(rootDir);
    if (proxyConfig) {
        // Find missing proxy rules
        const proxyRules = proxyConfig.proxyConfigs;
        const missingRules = PROXY_PATHS.filter((entryPath) => !proxyRules.find(([p]) => entryPath === p));
        if (missingRules.length > 0) {
            const fixRules = process.env.MRT_PROXY_FIXUP !== 'false';
            logger[fixRules ? 'info' : 'warn']({
                label: 'local-dev',
                message: `The proxy configuration is incomplete.${fixRules ? ' Adding missing rules now...' : ' The site may not function properly.'}`,
                additionalInfo: missingRules,
            });
            if (proxyRules.length > 0 && fixRules) {
                const target = proxyRules[0][1];
                missingRules.forEach((entryPath) => proxyRules.push([entryPath, target]));
            }
        }
        // Add proxy routes to the given server
        addRemoteProxyMiddleware(server, proxyConfig);
    }
}
//# sourceMappingURL=dev-server.js.map