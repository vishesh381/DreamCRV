import fs from 'fs-extra';
import path from 'path';
import { logger } from '@lwrjs/diagnostics';
import { getDefaultBuildDirectory } from './utils.js';
import { loadConfig } from '@lwrjs/config';
import { dedupeBundles } from '@lwrjs/tools';
const RUNTIME_CONFIG_SRC_DIR = 'config';
// TODO validate how build option values come into the CLI from oclif vs SFDX CLI
export async function build(options) {
    const { rootDir, config, output, mode, clean, target, minify, routes, modules, locales, logLevel } = options;
    process.env.LWR_LOG_LEVEL = logLevel; // Set the log level
    const outputDir = output ? output : getDefaultBuildDirectory(rootDir, config, target);
    const aConfig = loadConfig({ rootDir, lwrConfigFile: config });
    let ssrFunctionNodeVersion;
    if (target === 'mrt') {
        // Lambda always runs one request at a time
        process.env.SINGLE_RENDER_MODE = 'true';
        // Module re-evaluation is the default for LWR@MRT.
        process.env.REEVALUATE_MODULES = 'true';
        // Module re-evaluation is only supported with the "legacy" loader
        process.env.LEGACY_LOADER = 'true';
        // Check the node version (to fail early)
        ssrFunctionNodeVersion = getSuggestedNodeVersion();
    }
    if (clean) {
        logger.info({ label: `build`, message: `Clearing output directory: ${outputDir}` });
        fs.rmSync(outputDir, { recursive: true, force: true });
    }
    else {
        if (fs.existsSync(`${outputDir}`)) {
            logger.warn({
                label: `build`,
                message: `Output directory already exists. Previously generated files will not be deleted. If you did not intend to do this, re-run with --clean true`,
            });
        }
    }
    const generatedSitePath = target === 'mrt' ? path.join(outputDir, 'site') : outputDir;
    const { generateStaticSite } = await import('@lwrjs/core');
    const theLocales = locales
        ? locales.map((l) => {
            return { id: l };
        })
        : aConfig.appConfig.i18n?.locales || [];
    const i18n = {
        ...aConfig.appConfig.i18n,
        locales: theLocales,
    };
    try {
        // Use existing staticSiteGenerator config as defaults for now until we finish spikes on new design
        const _additionalRoutePaths = routes || aConfig.appConfig.staticSiteGenerator._additionalRoutePaths || [];
        const _additionalModules = modules || aConfig.appConfig.staticSiteGenerator._additionalModules || [];
        const staticSiteGenerator = {
            outputDir: generatedSitePath,
            skipCleanOutputDir: true,
            _additionalRoutePaths,
            _additionalModules,
        };
        await generateStaticSite({
            serverMode: mode,
            staticSiteGenerator,
            i18n,
        });
        // Stage runtime configuration
        stageProxyConfig(rootDir, outputDir);
    }
    catch (error) {
        logger.error(error);
    }
    // If target === MRT - we will always deploy to "app" dir
    let mainScriptName;
    if (target === 'mrt') {
        // De-duplicate localized bundles
        await dedupeBundles(generatedSitePath, i18n);
        const config = aConfig.appConfig;
        const rootDir = config.rootDir;
        try {
            // copy over source files we need on the server
            logger.info({ label: `build`, message: `Generating ssr.js` });
            const { buildServer, REQUEST_SCRIPT_NAME } = await import('@lwrjs/tools');
            mainScriptName = REQUEST_SCRIPT_NAME;
            // Catch minify flag is the literal 'false'
            const castMinify = minify == 'false' ? false : !!minify;
            await buildServer(
            // TODO not sure why but we reference staticSiteGenerator.outputDir somewhere in our buildServer plugin
            // hardcoding outputDir to 'site' since this no longer changes
            { rootDir, serverMode: mode, staticSiteGenerator: { outputDir: 'site' } }, { outputDir: outputDir, minify: castMinify });
        }
        catch (error) {
            logger.error(error);
        }
        // Keep track of directories to add to mrt config
        const dirsInConfig = [];
        try {
            // TODO - hack for loader.js
            fs.writeFileSync(path.join(outputDir, 'loader.js'), '');
            // No longer needed if we aren't modifying package.json
            const packageJson = JSON.parse(fs.readFileSync(path.join(rootDir, 'package.json'), 'utf-8'));
            // Create a default main process if one is not provided
            if (!packageJson.main) {
                createMainScript(outputDir);
            }
            // write the new package.json into the MRT output directory
            fs.writeFileSync(path.join(outputDir, 'package.json'), JSON.stringify({
                name: packageJson.name ? packageJson.name : 'lwr-app',
                version: packageJson.version ? packageJson.version : '1.0.0',
                license: packageJson.license ? packageJson.license : 'MIT',
                main: packageJson.main ? packageJson.main : mainScriptName,
                scripts: mainScriptName && !packageJson.main ? { request: `node ${mainScriptName}` } : {},
            }, null, 4));
            // Copy needed source files
            logger.info({ label: `build`, message: `copying source files` });
            // Content
            const contentDir = config.contentDir;
            if (fs.existsSync(contentDir)) {
                const relPath = contentDir.substring(rootDir.length);
                dirsInConfig.push(path.join('.', relPath, '**'));
                const contentOutputDir = path.join(outputDir, relPath);
                fs.copySync(contentDir, contentOutputDir);
            }
            // Layouts
            const layoutDir = config.layoutsDir;
            if (fs.existsSync(layoutDir)) {
                const relPath = layoutDir.substring(rootDir.length);
                dirsInConfig.push(path.join('.', relPath, '**'));
                const layoutOutputDir = path.join(outputDir, relPath);
                fs.copySync(layoutDir, layoutOutputDir);
            }
            // Data
            const globalDataDir = config.globalDataDir;
            if (fs.existsSync(globalDataDir)) {
                const relPath = globalDataDir.substring(rootDir.length);
                dirsInConfig.push(path.join('.', relPath, '**'));
                const globalDataOutputDir = path.join(outputDir, relPath);
                fs.copySync(globalDataDir, globalDataOutputDir);
            }
        }
        catch (e) {
            logger.error(e);
        }
        // generate config/default.js/json
        logger.info({ label: `build`, message: `generating default.json` });
        try {
            // TODO we could add some kind of merging later, but I think its too complex and not really worth it
            const configFile = path.join(rootDir, RUNTIME_CONFIG_SRC_DIR, 'default.json');
            const outputConfigFile = path.join(outputDir, RUNTIME_CONFIG_SRC_DIR, 'default.json');
            fs.ensureDirSync(path.join(outputDir, RUNTIME_CONFIG_SRC_DIR));
            if (fs.existsSync(configFile)) {
                // If they have defined their own config, use that, but display a warning
                logger.warn({
                    label: `build`,
                    message: `You have a config file already defined, using that rather than generating one.`,
                });
                fs.copyFileSync(configFile, outputConfigFile);
            }
            else {
                // Otherwise create a new config
                const defaultConfigContent = {
                    // Enables building the files necessary for server-side rendering.
                    ssrEnabled: true,
                    // Files available to the server-side rendering system and NOT through the /mobify/bundle/ path.
                    ssrOnly: [
                        'config/**',
                        'package.json',
                        'ssr.js',
                        'ssr.js.map',
                        'site/.metadata/**',
                        'site/1/bundle-server/**',
                    ],
                    // Files available to the server-side rendering system AND through the /mobify/bundle/ path.
                    // The site metadata folder starts with a ".", so it is automatically excluded
                    ssrShared: ['site/1/application/**', 'site/1/resource/**'],
                    // Additional parameters that configure Express app behavior.
                    ssrParameters: {
                        ssrFunctionNodeVersion,
                        proxyConfigs: [],
                    },
                };
                // Add our source directories to the ssrOnly config
                defaultConfigContent.ssrOnly.push(...dirsInConfig);
                // Allow unofficial configuration of ssrOnly dirs via environment variable for now until we settle the official api
                if (process.env.SSR_ONLY_DIRS) {
                    defaultConfigContent.ssrOnly.push(...process.env.SSR_ONLY_DIRS.split(',').map((value) => value.trim()));
                }
                // Configure ssrShared for assets
                if (process.env.ASSETS_ON_LAMBDA) {
                    defaultConfigContent.ssrShared.push('site/1/asset/**');
                }
                // Allow unofficial configuration of ssrShared dirs via environment variable for now until we settle the official api
                if (process.env.SSR_SHARED_DIRS) {
                    defaultConfigContent.ssrShared.push(...process.env.SSR_SHARED_DIRS.split(',').map((value) => value.trim()));
                }
                // If not, lets create them a default config that works with LWR
                fs.writeFileSync(outputConfigFile, JSON.stringify(defaultConfigContent, null, 4));
            }
        }
        catch (e) {
            logger.error(e);
        }
        logger.info({ label: `build`, message: `complete` });
    }
}
function getSuggestedNodeVersion() {
    const nodeVersion = process.version;
    const majorVersion = parseInt(nodeVersion.slice(1).split('.')[0]);
    return `${majorVersion}.x`;
}
function stageProxyConfig(rootDir, outputDir) {
    // stage config/_proxy configuration
    try {
        const configFile = path.join(rootDir, RUNTIME_CONFIG_SRC_DIR, '_proxy');
        const outputConfigFile = path.join(outputDir, RUNTIME_CONFIG_SRC_DIR, '_proxy');
        if (fs.existsSync(configFile)) {
            logger.info({ label: `build`, message: `staging proxy configuration` });
            fs.ensureDirSync(path.join(outputDir, RUNTIME_CONFIG_SRC_DIR));
            fs.copyFileSync(configFile, outputConfigFile);
        }
    }
    catch (e) {
        logger.error(e);
    }
}
function createMainScript(outputDir) {
    // Create a yarn lock so you can go ahead and install and run
    createLockFile(outputDir);
}
function detectPackageManager() {
    const userAgent = process.env.npm_config_user_agent || '';
    if (userAgent.includes('yarn')) {
        return 'yarn';
    }
    else if (userAgent.includes('npm')) {
        return 'npm';
    }
    // Default to npm if neither is detected
    return 'npm';
}
// Helper function to create a lock file
function createLockFile(outputDir) {
    const packageManager = detectPackageManager();
    const lockFileName = packageManager === 'yarn' ? 'yarn.lock' : 'package-lock.json';
    const lockFilePath = path.join(outputDir, lockFileName);
    if (!fs.existsSync(lockFilePath)) {
        // Create empty lock file
        fs.writeFileSync(lockFilePath, '');
    }
    // if yarn also set nodeLinker: node-modules
    if (packageManager === 'yarn') {
        const rcFilePath = path.join(outputDir, '.yarnrc.yml');
        if (!fs.existsSync(rcFilePath)) {
            fs.writeFileSync(rcFilePath, 'nodeLinker: node-modules');
        }
    }
}
//# sourceMappingURL=build.js.map