import fs from 'fs-extra';
import path from 'path';
import { logger } from '@lwrjs/diagnostics';
import * as tar from 'tar';
import { getVersions, isMaxVersionCompatible, isMinVersionCompatible } from './utils.js';
/**
 * MIN_SUPPORTED_VERSION
 * The minimum LWR Version this package can support. Anytime we believe we are checking in a breaking change (i.e. metadata, loader apis, ssr, etc),
 * we need to bump the MIN_SUPPORTED_VERSION to be equal to the current LWR version. Also, if we discover a CLWR breaking change upon updating
 * our integration tests (i.e. CLWR have changed the build output, metadata, etc), we should also bump the MIN_SUPPORTED_VERSION.
 */
export const MIN_SUPPORTED_VERSION = '0.13.0';
/**
 * MAX_SUPPORTED_VERSION
 * This is not as essential but exists as a safeguard to help ensure local-dev consumers stay up to date with the latest versions of LWR.
 * The goal here is that MAX_SUPPORTED_VERSION should always be equal to the next major release of LWR. If a user downloads an MRT bundle
 * from next release without having updated their CLI tools, they will get a strongly worded message to update their CLI.
 */
import { LWR_VERSION as MAX_SUPPORTED_VERSION } from '@lwrjs/config';
function hasSsrJS(sitePath) {
    return fs.existsSync(path.join(sitePath, 'ssr.js'));
}
function getBasePath(localDevMetaPath) {
    if (fs.existsSync(localDevMetaPath)) {
        const rawData = fs.readFileSync(localDevMetaPath, 'utf8');
        const retVal = JSON.parse(rawData).basePath;
        if (retVal)
            return retVal;
    }
    logger.warn(`no basepath found in local-dev-metadata.json at ${localDevMetaPath}. Site may not function as expected.`);
    return undefined;
}
export function replaceSecureHasSid(filePath) {
    try {
        const fileContent = fs.readFileSync(filePath, 'utf8');
        const updatedContent = fileContent.replace(/(__Secure-has-sid|isLocalDev)/g, 'LocalAuthenticationEnabled');
        fs.writeFileSync(filePath, updatedContent, 'utf8');
    }
    catch (error) {
        logger.error(`Error occurred while updating auth token for local development: ${filePath}`, error);
    }
}
/**
 * Generic api for automated setup of an MRT bundle.
 *
 * @param options
 */
export async function setupDev(options) {
    const { siteDir = '.', siteZip } = options;
    const pathToAppFolder = path.join(siteDir, 'app');
    const pathToBldFolder = path.join(siteDir, 'bld');
    logger.debug({
        label: `local-dev`,
        message: `setup()'`,
        additionalInfo: {
            siteDir,
            pathToAppFolder,
            pathToBldFolder,
            siteZip,
        },
    });
    // 1. Verify we have a bundle or a zip file to extract
    if ((!siteZip || !fs.existsSync(siteZip)) && !hasSsrJS(pathToAppFolder)) {
        // If we don't have a bundle or a zip file to extract, error
        throw new Error(`Local Dev could not find a valid site to run. Please retry with a valid site.`);
    }
    // 2. Extract a zip if one was supplied
    if (siteZip) {
        if (fs.existsSync(siteZip)) {
            if (!hasSsrJS(pathToAppFolder)) {
                logger.info(`Extracting -> '${siteZip}'`);
                try {
                    // Ensure our extract directory exists
                    fs.ensureDirSync(siteDir);
                    // Delete potentially problematic directories
                    fs.rmSync(pathToAppFolder, { recursive: true, force: true });
                    fs.rmSync(pathToBldFolder, { recursive: true, force: true });
                    // Extract site (which will be named 'bld')
                    await tar.x({
                        file: siteZip,
                        cwd: siteDir,
                    });
                    // Rename 'bld' directory to 'app'
                    fs.renameSync(pathToBldFolder, pathToAppFolder);
                }
                catch (error) {
                    logger.warn({
                        label: `local-dev`,
                        message: `Error extracting site bundle '${siteZip}' to directory '${pathToAppFolder}'`,
                    });
                    throw error;
                }
                // Verify we have an ssr.js where we expect
                if (!hasSsrJS(pathToAppFolder)) {
                    // We either failed to rename the folder or the
                    logger.warn({
                        label: `local-dev`,
                        message: `Error extracting site bundle '${siteZip}' to directory '${pathToAppFolder}'`,
                    });
                }
            }
            else {
                // TODO should we override in certain error cases
                logger.info(`Already have a valid siteDir, skipping extraction of '${siteZip}'`);
            }
        }
        else {
            // Supplied site zip doesn't exist
            logger.warn({
                label: `local-dev`,
                message: `Could not find site zip: '${siteZip}' - Skipping extraction`,
            });
        }
    }
    // 3. At this point, we should either already have an extracted site or there should be one extracted already
    if (!hasSsrJS(pathToAppFolder)) {
        throw new Error(`Local Dev could not find a valid site to run at ${siteDir}. Please retry with a valid site.`);
    }
    // 4. Verify our generated site proxy is correct
    const proxyPath = path.join(pathToAppFolder, 'config', '_proxy');
    if (!fs.existsSync(proxyPath)) {
        // If the proxy doesn't exist this means that we have a really old MRT bundle, throw an error
        logger.error({
            label: `local-dev`,
            message: `${proxyPath} does not exist.`,
        });
        throw new Error(`LWR version is not compatible with minimum supported version ${MIN_SUPPORTED_VERSION}. Please re-publish your site then re-run this command.`);
    }
    // 5. Verify localdev/versions.json exists
    const versionsPath = path.join(pathToAppFolder, 'localdev', 'versions.json');
    if (!fs.existsSync(versionsPath)) {
        // If the versions file doesn't exist this means that we have a really old MRT bundle, throw an error
        logger.error({
            label: `local-dev`,
            message: `${versionsPath} does not exist.`,
        });
        throw new Error(`LWR version is not compatible with minimum supported version ${MIN_SUPPORTED_VERSION}. Please re-publish your site then re-run this command.`);
    }
    // 6. Verify localdev/local-dev-metadata.json exists
    const localDevMeta = path.join(pathToAppFolder, 'localdev', 'local-dev-metadata.json');
    if (!fs.existsSync(localDevMeta)) {
        logger.warn({
            label: `local-dev`,
            message: `no local-dev-metadata.json found at ${localDevMeta}. Site may not function as expected.`,
        });
    }
    else {
        // Set the basepath based on the local dev metadata
        options.basePath = getBasePath(localDevMeta);
    }
    // 7. Verify MRT Bundle version is compatible with this LWR version
    const versions = getVersions(versionsPath);
    const lwrVerison = versions.lwrVersion;
    const minVersionCompatible = isMinVersionCompatible(lwrVerison, MIN_SUPPORTED_VERSION);
    if (!minVersionCompatible) {
        const message = `The version of your site '${lwrVerison}' is not compatible with the minimum supported version of local development '${MIN_SUPPORTED_VERSION}'. Please re-publish your site and then re-run this command.`;
        if (process.env.IGNORE_VERSION_MISMATCH === 'true') {
            logger.warn({ label: `local-dev`, message });
        }
        else {
            throw new Error(message);
        }
    }
    // 8. Verify LWR supports the current bundle version
    const maxVersionCompatible = isMaxVersionCompatible(lwrVerison, MAX_SUPPORTED_VERSION);
    if (!maxVersionCompatible) {
        // log a strongly worded message but allow users to continue at your own risk
        logger.warn({
            label: `local-dev`,
            message: `The installed version of Local Dev is out of date and may not support your current lwr site version '${lwrVerison}'. Please run 'sf update' and then rerun this command.`,
        });
    }
    // 9. TODO HACKS FOR AUTHENTICATION
    // This overrides the __Secure_has_id cookie when running a site locally
    // This is needed because chrome will not allow secure cookies to be set in a non-secure context (http)
    replaceSecureHasSid(path.join(pathToAppFolder, 'experience', 'index_csr.html'));
    replaceSecureHasSid(path.join(pathToAppFolder, 'experience', 'index.html'));
}
//# sourceMappingURL=setup-dev.js.map