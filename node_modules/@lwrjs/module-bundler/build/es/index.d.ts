import type { AbstractModuleId, BundleConfig, BundleConfigOverrides, BundleDefinition, BundleProvider, LwrAppObserver, ModuleBundler, ModuleId, ModuleRegistry, NormalizedLwrGlobalConfig, PublicModuleBundler, RuntimeEnvironment, RuntimeParams, SourceMapRuntimeEnvironment, UriTransformPlugin } from '@lwrjs/types';
import { LRUCache } from 'lru-cache';
interface LwrModuleBundlerConfig {
    moduleRegistry: ModuleRegistry;
    appObserver?: LwrAppObserver;
}
export declare class LwrModuleBundler implements ModuleBundler {
    moduleRegistry: ModuleRegistry;
    appObserver: LwrAppObserver | undefined;
    cache: LRUCache<string, BundleDefinition, unknown>;
    providers: BundleProvider[];
    transformers: UriTransformPlugin[];
    bundleConfig: BundleConfig;
    private inflightBundleDefinitions;
    constructor(config: LwrModuleBundlerConfig, globalConfig: NormalizedLwrGlobalConfig);
    addBundleProviders(providers: BundleProvider[]): void;
    addBundleTransformers(transformers: UriTransformPlugin[]): void;
    getConfig(): BundleConfig;
    getModuleBundle<T extends AbstractModuleId>(moduleId: T, runtimeEnvironment: SourceMapRuntimeEnvironment, runtimeParams?: RuntimeParams, bundleConfigOverrides?: BundleConfigOverrides): Promise<BundleDefinition>;
    /**
     * Resolve the URI to the bundle rooted at the `moduleId`
     * @param moduleId - The id of the root module for the bundle
     * @param runtimeEnvironment  - The runtime operating environment
     * @param runtimeParams  - The available runtime parameters provided in context to the request
     * @param signature - The signature of the bundle instance being referenced
     * @returns the URI
     */
    resolveModuleUri(moduleId: Required<Pick<ModuleId, 'specifier' | 'version'>>, runtimeEnvironment: RuntimeEnvironment, runtimeParams: RuntimeParams, signature?: string): Promise<string>;
    getPublicApi(): PublicModuleBundler;
}
export {};
//# sourceMappingURL=index.d.ts.map