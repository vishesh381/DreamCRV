import { GraphDepth, createAmdAlias, explodeSpecifier, getModuleGraphs, getSpecifier, getGroupName, isGroupie, getCacheKeyFromJson, VERSION_NOT_PROVIDED, isExternalSpecifier, PROTOCOL_FILE, isLocalDev, } from '@lwrjs/shared-utils';
import { rollup } from 'rollup';
import replace from '@rollup/plugin-replace';
import { BundleSpan, getTracer } from '@lwrjs/instrumentation';
import { bundleDefinitions } from './rollup-amd-bundler-plugin.js';
import { overrideBundleConfig } from './bundle-common.js';
const AMD_DEFINE = 'LWR.define';
const groupieCodeCache = new Map();
function includeIdFactory(graphSpecifier, external, exclude = [], requiredImports, groups) {
    return (moduleRef) => {
        const moduleIsNotRoot = graphSpecifier !== moduleRef.specifier;
        // Do not bundle externals, including the loader module, which is auto bundled
        // with the shim + loader combo
        if (isExternalSpecifier(moduleRef.specifier, { external })) {
            // Include externals just mark them as such
            moduleRef.externalSrc = external[moduleRef.specifier];
            moduleRef.external = true;
            if (moduleIsNotRoot) {
                // Include externals in the required imports
                requiredImports.set(`${moduleRef.specifier}_${moduleRef.version || VERSION_NOT_PROVIDED}`, moduleRef);
                // return false to indicate it should not be in the bundle
                return false;
            }
        }
        const moduleRefIsGroupie = isGroupie(moduleRef.specifier, groups);
        const rootModuleIsGroupie = isGroupie(graphSpecifier, groups);
        if (moduleRefIsGroupie) {
            // If this is part of bundle group return false to indicate it should not be in the bundle
            // but add it to the requiredImports so it shows up as a static dependency of the bundle.
            // However, skip this if the requested specifier is also part of the same group.
            if (moduleIsNotRoot && !rootModuleIsGroupie) {
                requiredImports.set(`${moduleRef.specifier}_${moduleRef.version || VERSION_NOT_PROVIDED}`, moduleRef);
            }
            return false;
        }
        else if (exclude?.includes(moduleRef.specifier)) {
            // If this is a bundle exclude return false to indicate it should not be in the bundle
            // but add it to the requiredImports so it shows up as a static dependency of the bundle.
            if (moduleIsNotRoot) {
                requiredImports.set(`${moduleRef.specifier}_${moduleRef.version || VERSION_NOT_PROVIDED}`, moduleRef);
            }
            return false;
        }
        return true;
    };
}
async function bundle(id, moduleGraphs, minify = false, unVersionedAliases = false) {
    const plugins = [bundleDefinitions({ moduleGraphs })];
    minify &&
        plugins.push(
        // terser(), // Do not minify until needed for client modules. Server/SSR modules do not need to be minified.
        replace({
            'process.env.NODE_ENV': JSON.stringify('production'),
            preventAssignment: false,
        }));
    const { output } = await getTracer().trace({
        name: BundleSpan.Rollup,
        attributes: {
            specifier: id,
            format: 'amd',
        },
    }, async () => {
        const bundler = await rollup({ input: id, plugins });
        return bundler.generate({
            amd: { id, define: AMD_DEFINE },
            exports: 'named',
            format: 'amd',
        });
    });
    let code = output[0].code;
    if (unVersionedAliases) {
        const idObject = explodeSpecifier(id);
        const specifier = idObject.specifier;
        const aliasModule = createAmdAlias(specifier, id);
        code += aliasModule;
    }
    return code;
}
async function getBundleCode(rootModule, moduleGraphs, includedModules, bundleGroupsIncludedModules, dynamicImports, minify, unVersionedAliases, includeId, moduleRegistry, runtimeEnvironment, runtimeParams, visitedSpecifiers) {
    const modules = [rootModule, ...moduleGraphs.graphs[0].static];
    const { moduleRecord } = await moduleRegistry.getModule(explodeSpecifier(rootModule), runtimeParams);
    // add static imports from the LinkedModuleDefinitions added during module linking
    // they're not in the ModuleGraph imports b/c those are based on raw module source
    if (moduleRecord.importMeta && !isLocalDev()) {
        // the only use case for this is "lwr/environment", so skip the logic when it's not needed
        for (const specifier of modules) {
            const linkedDefinition = moduleGraphs.linkedDefinitions[specifier];
            const imports = linkedDefinition?.linkedModuleRecord.imports || [];
            for (const imp of imports) {
                const modId = explodeSpecifier(imp.specifier);
                if (!modules.includes(imp.specifier) && includeId(modId)) {
                    modules.push(imp.specifier);
                    if (!moduleGraphs.linkedDefinitions[imp.specifier]) {
                        // eslint-disable-next-line no-await-in-loop
                        const missingLinkedModule = await moduleRegistry.getLinkedModule({ specifier: modId.specifier, version: modId.version }, runtimeEnvironment, runtimeParams);
                        moduleGraphs.linkedDefinitions[imp.specifier] = missingLinkedModule;
                    }
                }
            }
        }
    }
    const bundles = (await Promise.all(modules
        .reduce((filteredModules, specifier) => {
        const linkedDefinition = moduleGraphs.linkedDefinitions[specifier];
        // skip modules that do not have a linked definition
        if (!linkedDefinition) {
            return filteredModules;
        }
        // add any dynamic imports from each of the linked definitions in the module graph
        linkedDefinition.linkedModuleRecord.dynamicImports?.forEach((dynamicImport) => {
            if (dynamicImport.moduleNameType !== 'unresolved') {
                // Linked specifiers add a version to them  We do not want this in the bundle record specifier
                const moduleId = explodeSpecifier(dynamicImport.specifier);
                const importReference = {
                    ...dynamicImport,
                    specifier: moduleId.specifier,
                };
                dynamicImports.set(getSpecifier(importReference), importReference);
            }
        });
        // skip relative dependencies
        if (specifier.includes('#')) {
            return filteredModules;
        }
        // prepend the linked definition for the correct order
        filteredModules.unshift(linkedDefinition);
        return filteredModules;
    }, [])
        .map((linkedDefinition) => {
        const id = getSpecifier(linkedDefinition);
        // Calling includeId will set external and external source as a side effect
        includeId(linkedDefinition);
        const isExternal = linkedDefinition.external;
        const isExternalFile = linkedDefinition.externalSrc &&
            linkedDefinition.externalSrc.startsWith(PROTOCOL_FILE);
        if (visitedSpecifiers?.has(id)) {
            return false;
        }
        else {
            visitedSpecifiers?.set(id, true);
        }
        // If this is the root module we do not include it in the included modules
        if (id !== rootModule) {
            // If this is an external module do not include it as included
            if (!isExternal) {
                includedModules.push(id);
            }
        }
        else {
            // we need to still keep track of roots for bundle groups
            bundleGroupsIncludedModules.push(id);
        }
        // If this is a external from a static file no need to bundle.
        if (isExternalFile) {
            return linkedDefinition.linkedSource;
        }
        // bundle all dependencies for the linked definition and convert to AMD
        return bundle(id, moduleGraphs, minify, unVersionedAliases);
    }))).filter((x) => typeof x === 'string');
    return bundles;
}
export async function amdBundler(rootModuleId, moduleRegistry, minify = false, runtimeEnvironment, runtimeParams = {}, { bundleConfig }, bundleConfigOverrides) {
    const { exclude, external = {}, groups = {} } = overrideBundleConfig(bundleConfig, bundleConfigOverrides);
    // Note: the maps must be cleared each time we call getModuleGraph
    const requiredImports = new Map();
    const dynamicImports = new Map();
    const groupName = getGroupName(rootModuleId.specifier, groups);
    const groupies = groupName && groups[groupName];
    // Note: in reality, bundleConfig cannot change at runtime, but
    // use it as a cacheKey anyways in case we want to support it in the future
    const cacheKey = getCacheKeyFromJson({ groupName, exclude, external });
    const cachedGroupieCode = groupName && groupieCodeCache.get(cacheKey);
    const getModuleGraphsWrapper = (graphSpecifier) => {
        const graphOptions = {
            includeLinkedDefinitions: true,
            depth: {
                static: GraphDepth.ALL,
                dynamic: 0,
                includeId: includeIdFactory(graphSpecifier, external, exclude, requiredImports, groups),
            },
        };
        return getModuleGraphs(graphSpecifier, graphOptions, moduleRegistry, moduleRegistry, runtimeEnvironment, runtimeParams);
    };
    const versionedSpecifier = getSpecifier(rootModuleId);
    const moduleGraphs = await getModuleGraphsWrapper(versionedSpecifier);
    const rootModule = moduleGraphs.graphs[0];
    // we also need to get moduleGraphs for any group members this module belongs to
    const groupModuleGraphsMap = new Map();
    if (!cachedGroupieCode && groupies && groupies.length) {
        for (const specifier of groupies) {
            if (specifier !== rootModuleId.specifier) {
                // eslint-disable-next-line no-await-in-loop
                const groupieModuleGraph = await getModuleGraphsWrapper(specifier);
                groupModuleGraphsMap.set(specifier, groupieModuleGraph);
            }
        }
    }
    let bundleCode, includedModules, bundleGroupsIncludedModules;
    // we don't need to recompute the bundle code if it already exists for this group
    const cachedBundleGroupCode = cachedGroupieCode;
    const bundledSpecifiersMap = new Map();
    if (!cachedBundleGroupCode) {
        (includedModules = []), (bundleGroupsIncludedModules = []);
        const bundles = await getBundleCode(rootModule.specifier, moduleGraphs, includedModules, bundleGroupsIncludedModules, dynamicImports, minify, !!runtimeEnvironment.featureFlags?.EXPERIMENTAL_UNVERSIONED_ALIASES, includeIdFactory(rootModuleId.specifier, external, exclude, requiredImports, groups), moduleRegistry, runtimeEnvironment, runtimeParams, bundledSpecifiersMap);
        if (groupName) {
            // add groupies to bundles
            for (const rawGroupieSpecifier of groupies) {
                if (rawGroupieSpecifier !== rootModuleId.specifier) {
                    const groupieModuleGraph = groupModuleGraphsMap.get(rawGroupieSpecifier);
                    const groupieSpecifier = groupieModuleGraph.graphs[0].specifier;
                    // eslint-disable-next-line no-await-in-loop
                    const groupieBundles = await getBundleCode(groupieSpecifier, groupieModuleGraph, includedModules, bundleGroupsIncludedModules, dynamicImports, minify, !!runtimeEnvironment.featureFlags?.EXPERIMENTAL_UNVERSIONED_ALIASES, includeIdFactory(rawGroupieSpecifier, external, exclude, requiredImports, groups), moduleRegistry, runtimeEnvironment, runtimeParams, bundledSpecifiersMap);
                    bundles.push(...groupieBundles);
                }
            }
        }
        bundleCode = bundles.join('');
        if (groupName) {
            includedModules.push(...bundleGroupsIncludedModules);
            groupieCodeCache.set(groupName, { code: bundleCode, includedModules });
        }
    }
    else {
        bundleCode = cachedBundleGroupCode.code;
        includedModules = cachedBundleGroupCode.includedModules;
    }
    const { id, name, namespace, version, specifier } = moduleGraphs.linkedDefinitions[rootModule.specifier];
    const getCode = () => Promise.resolve(bundleCode);
    return {
        id,
        name,
        namespace,
        version,
        specifier,
        getCode,
        config: { external, exclude },
        bundleRecord: {
            imports: Array.from(requiredImports.values()),
            dynamicImports: Array.from(dynamicImports.values()),
            includedModules,
        },
    };
}
//# sourceMappingURL=amd-common.js.map