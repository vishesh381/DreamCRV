import { rollup } from 'rollup';
import { BundleSpan, getTracer } from '@lwrjs/instrumentation';
import { bundleDefinitions } from './utils/rollup-esm-bundler-plugin.js';
import { minifyJavascript } from './utils/esbuild-utils.js';
import { overrideBundleConfig } from './utils/bundle-common.js';
import { PROTOCOL_HTTP, PROTOCOL_HTTPS, createIntegrityHash } from '@lwrjs/shared-utils';
export default class EsmBundlerProvider {
    constructor(_options, { config, moduleRegistry }) {
        this.name = 'esm-bundle-provider';
        this.config = config;
        this.moduleRegistry = moduleRegistry;
    }
    async bundle(moduleId, runtimeEnvironment, runtimeParams = {}, bundleConfigOverrides) {
        if (runtimeEnvironment.format === 'esm') {
            const { moduleRegistry, config } = this;
            return await esmBundler(moduleId, moduleRegistry, runtimeEnvironment, runtimeParams, config, bundleConfigOverrides);
        }
    }
}
async function esmBundler(moduleId, moduleRegistry, runtimeEnvironment, runtimeParams = {}, { bundleConfig }, bundleConfigOverrides) {
    const { exclude, external = {}, alias = {} } = overrideBundleConfig(bundleConfig, bundleConfigOverrides);
    const { sourceMapUrl } = runtimeEnvironment;
    const requiredImports = new Map();
    const dynamicImports = new Map();
    const rootModuleDef = await moduleRegistry.getLinkedModule(moduleId, runtimeEnvironment, runtimeParams);
    const result = await getTracer().trace({
        name: BundleSpan.Rollup,
        attributes: {
            specifier: moduleId.specifier,
            format: 'esm',
        },
    }, async () => {
        const bundle = await rollup({
            input: moduleId.specifier,
            plugins: [
                bundleDefinitions({
                    rootModuleDef,
                    runtimeEnvironment,
                    moduleRegistry,
                    exclude,
                    alias,
                    runtimeParams,
                    requiredImports,
                    dynamicImports,
                }),
            ],
            external: Object.keys(external),
            makeAbsoluteExternalsRelative: 'ifRelativeSource', // Fix for breaking changes in https://github.com/rollup/rollup/pull/4021
        });
        return bundle.generate({
            paths: (id) => {
                // The fallback on id is important due to a rollup semantic issue:
                // https://github.com/rollup/rollup/issues/3831
                // If external is an http:// URL use that in the ESM Module
                if (external[id] &&
                    (external[id].startsWith(PROTOCOL_HTTP) || external[id].startsWith(PROTOCOL_HTTPS))) {
                    return external[id];
                }
                return id;
            },
            sourcemap: true,
        });
    });
    const bundleCode = result.output[0].code;
    const bundleMap = result.output[0].map;
    let code = sourceMapUrl ? `${bundleCode}\n//# sourceMappingURL=${sourceMapUrl}` : bundleCode;
    const { id, specifier, namespace, name, version } = rootModuleDef;
    const { minify, debug } = runtimeEnvironment;
    const minified = !!minify && !debug;
    if (minified) {
        code = await minifyJavascript(code);
    }
    return {
        id,
        specifier,
        namespace,
        name,
        version,
        getCode: () => Promise.resolve(code),
        config: { external, exclude },
        map: bundleMap,
        integrity: createIntegrityHash(code),
        bundleRecord: {
            imports: Array.from(requiredImports.values()),
            dynamicImports: Array.from(dynamicImports.values()),
            includedModules: [],
        },
    };
}
//# sourceMappingURL=esm-bundle-provider.js.map