import { join } from 'path';
import { LRUCache } from 'lru-cache';
import { LwrUnresolvableError, createSingleDiagnosticError, descriptions, logger } from '@lwrjs/diagnostics';
import { signBundle, getCacheKeyFromJson, InflightTasks, TaskPool, isLambdaEnv } from '@lwrjs/shared-utils';
import { getTracer, BundleSpan, cacheCountStore } from '@lwrjs/instrumentation';
const TASK_POOL = new TaskPool();
export class LwrModuleBundler {
    constructor(config, globalConfig) {
        this.cache = new LRUCache({
            max: parseInt(process.env.BUNDLE_CACHE_SIZE ?? '500', 10),
            dispose: (_value, key) => {
                if (isLambdaEnv()) {
                    logger.warn(`Bundle evicted from cache: "${key}"`);
                }
                else {
                    logger.verbose(`Bundle evicted from cache: "${key}"`);
                }
            },
        });
        this.providers = [];
        this.transformers = [];
        // Pending bundle definitions are tracked to prevent concurrent resolution of the same bundle.
        // Subsequent requests for the same bundle will await the original promise.
        // Cache entries will be removed once the bundle is resolved.
        this.inflightBundleDefinitions = new InflightTasks();
        this.moduleRegistry = config.moduleRegistry;
        this.appObserver = config.appObserver;
        // Freeze the bundle config to make sure it is not modified
        this.bundleConfig = Object.freeze(globalConfig.bundleConfig);
        this.appObserver?.onModuleDefinitionChange(() => {
            // TODO: This is a very naive approach however
            // this would only happen in non-prod environments
            this.cache.clear();
        });
    }
    addBundleProviders(providers) {
        this.providers.push(...providers);
    }
    addBundleTransformers(transformers) {
        this.transformers.push(...transformers);
    }
    getConfig() {
        return this.bundleConfig;
    }
    async getModuleBundle(moduleId, runtimeEnvironment, runtimeParams = {}, bundleConfigOverrides) {
        const { format, minify, debug } = runtimeEnvironment;
        const ssr = runtimeParams.ssr;
        const cacheKey = `${moduleId.specifier}|${moduleId.version}|${getCacheKeyFromJson({
            locale: runtimeParams.locale,
            format,
            minify,
            debug,
            bundleConfigOverrides,
            ssr,
        })}`;
        const cacheDisabled = process.env.NOCACHE === 'true';
        if (!cacheDisabled) {
            // Return the cached bundle definition
            if (this.cache.has(cacheKey)) {
                const bundleDef = this.cache.get(cacheKey);
                return bundleDef;
            }
        }
        return this.inflightBundleDefinitions.execute(cacheKey, () => {
            // Run theses tasks in a task pool to throttle parallel requests.
            return TASK_POOL.execute(async () => {
                return getTracer().trace({
                    name: BundleSpan.GetBundle,
                    attributes: {
                        specifier: moduleId.specifier,
                        version: moduleId.version ?? '',
                        locale: runtimeParams.locale ?? '',
                        ssr: ssr ? 'TRUE' : 'FALSE',
                        debug: debug ? 'TRUE' : 'FALSE',
                    },
                }, async () => {
                    // Increment the async def miss counter setup by top level metrics interested in bundle definition misses
                    cacheCountStore.incrementCacheKey('missedDefs');
                    for (const bundler of this.providers) {
                        // eslint-disable-next-line no-await-in-loop
                        const bundleDef = await bundler.bundle(moduleId, runtimeEnvironment, runtimeParams, bundleConfigOverrides);
                        if (bundleDef) {
                            if (!cacheDisabled) {
                                this.cache.set(cacheKey, bundleDef);
                            }
                            return bundleDef;
                        }
                    }
                    throw createSingleDiagnosticError({
                        description: descriptions.UNRESOLVABLE.BUNDLE(moduleId.specifier),
                    }, LwrUnresolvableError);
                });
            }, this);
        });
    }
    /**
     * Resolve the URI to the bundle rooted at the `moduleId`
     * @param moduleId - The id of the root module for the bundle
     * @param runtimeEnvironment  - The runtime operating environment
     * @param runtimeParams  - The available runtime parameters provided in context to the request
     * @param signature - The signature of the bundle instance being referenced
     * @returns the URI
     */
    async resolveModuleUri(moduleId, runtimeEnvironment, runtimeParams, signature) {
        // First get the bundle definition to see if a src attribute is set.
        const bundleDefinition = await this.getModuleBundle(moduleId, runtimeEnvironment, runtimeParams);
        if (!bundleDefinition) {
            throw createSingleDiagnosticError({
                description: descriptions.UNRESOLVABLE.BUNDLE(moduleId.specifier),
            }, LwrUnresolvableError);
        }
        let uri;
        if (bundleDefinition.src) {
            // If source is provided on the bundle definition use that
            uri = bundleDefinition.src;
        }
        else {
            let resolvedVersion = moduleId.version || bundleDefinition.version;
            // If we do not know the version, look it up.
            if (!resolvedVersion) {
                const { version } = await this.moduleRegistry.getModuleEntry(moduleId, runtimeParams);
                resolvedVersion = version;
            }
            if (!signature) {
                signature = signBundle(bundleDefinition);
            }
            uri = String(await this.moduleRegistry.resolveModuleUri({ ...moduleId, version: resolvedVersion }, runtimeEnvironment, runtimeParams, signature));
        }
        const bundleUri = {
            artifactType: 'bundle',
            uri: join(runtimeEnvironment.basePath || '', uri),
            immutable: runtimeEnvironment.immutableAssets,
            entry: uri,
        };
        // Perform any transforms
        for (const transformPlugin of this.transformers) {
            // eslint-disable-next-line no-await-in-loop
            const resolveUriResult = await transformPlugin.transformUri?.(bundleUri, bundleDefinition, runtimeEnvironment);
            if (resolveUriResult?.uri) {
                uri = resolveUriResult.uri;
            }
        }
        return uri;
    }
    getPublicApi() {
        return {
            getConfig: this.getConfig.bind(this),
            getModuleBundle: this.getModuleBundle.bind(this),
            resolveModuleUri: this.resolveModuleUri.bind(this),
        };
    }
}
//# sourceMappingURL=index.js.map