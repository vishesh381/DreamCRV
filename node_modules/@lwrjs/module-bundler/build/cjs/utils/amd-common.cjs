var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/module-bundler/src/utils/amd-common.ts
__markAsModule(exports);
__export(exports, {
  amdBundler: () => amdBundler
});
var import_shared_utils = __toModule(require("@lwrjs/shared-utils"));
var import_rollup = __toModule(require("rollup"));
var import_plugin_replace = __toModule(require("@rollup/plugin-replace"));
var import_instrumentation = __toModule(require("@lwrjs/instrumentation"));
var import_rollup_amd_bundler_plugin = __toModule(require("./rollup-amd-bundler-plugin.cjs"));
var import_bundle_common = __toModule(require("./bundle-common.cjs"));
var AMD_DEFINE = "LWR.define";
var groupieCodeCache = new Map();
function includeIdFactory(graphSpecifier, external, exclude = [], requiredImports, groups) {
  return (moduleRef) => {
    const moduleIsNotRoot = graphSpecifier !== moduleRef.specifier;
    if ((0, import_shared_utils.isExternalSpecifier)(moduleRef.specifier, {external})) {
      moduleRef.externalSrc = external[moduleRef.specifier];
      moduleRef.external = true;
      if (moduleIsNotRoot) {
        requiredImports.set(`${moduleRef.specifier}_${moduleRef.version || import_shared_utils.VERSION_NOT_PROVIDED}`, moduleRef);
        return false;
      }
    }
    const moduleRefIsGroupie = (0, import_shared_utils.isGroupie)(moduleRef.specifier, groups);
    const rootModuleIsGroupie = (0, import_shared_utils.isGroupie)(graphSpecifier, groups);
    if (moduleRefIsGroupie) {
      if (moduleIsNotRoot && !rootModuleIsGroupie) {
        requiredImports.set(`${moduleRef.specifier}_${moduleRef.version || import_shared_utils.VERSION_NOT_PROVIDED}`, moduleRef);
      }
      return false;
    } else if (exclude?.includes(moduleRef.specifier)) {
      if (moduleIsNotRoot) {
        requiredImports.set(`${moduleRef.specifier}_${moduleRef.version || import_shared_utils.VERSION_NOT_PROVIDED}`, moduleRef);
      }
      return false;
    }
    return true;
  };
}
async function bundle(id, moduleGraphs, minify = false, unVersionedAliases = false) {
  const plugins = [(0, import_rollup_amd_bundler_plugin.bundleDefinitions)({moduleGraphs})];
  minify && plugins.push((0, import_plugin_replace.default)({
    "process.env.NODE_ENV": JSON.stringify("production"),
    preventAssignment: false
  }));
  const {output} = await (0, import_instrumentation.getTracer)().trace({
    name: import_instrumentation.BundleSpan.Rollup,
    attributes: {
      specifier: id,
      format: "amd"
    }
  }, async () => {
    const bundler = await (0, import_rollup.rollup)({input: id, plugins});
    return bundler.generate({
      amd: {id, define: AMD_DEFINE},
      exports: "named",
      format: "amd"
    });
  });
  let code = output[0].code;
  if (unVersionedAliases) {
    const idObject = (0, import_shared_utils.explodeSpecifier)(id);
    const specifier = idObject.specifier;
    const aliasModule = (0, import_shared_utils.createAmdAlias)(specifier, id);
    code += aliasModule;
  }
  return code;
}
async function getBundleCode(rootModule, moduleGraphs, includedModules, bundleGroupsIncludedModules, dynamicImports, minify, unVersionedAliases, includeId, moduleRegistry, runtimeEnvironment, runtimeParams, visitedSpecifiers) {
  const modules = [rootModule, ...moduleGraphs.graphs[0].static];
  const {moduleRecord} = await moduleRegistry.getModule((0, import_shared_utils.explodeSpecifier)(rootModule), runtimeParams);
  if (moduleRecord.importMeta && !(0, import_shared_utils.isLocalDev)()) {
    for (const specifier of modules) {
      const linkedDefinition = moduleGraphs.linkedDefinitions[specifier];
      const imports = linkedDefinition?.linkedModuleRecord.imports || [];
      for (const imp of imports) {
        const modId = (0, import_shared_utils.explodeSpecifier)(imp.specifier);
        if (!modules.includes(imp.specifier) && includeId(modId)) {
          modules.push(imp.specifier);
          if (!moduleGraphs.linkedDefinitions[imp.specifier]) {
            const missingLinkedModule = await moduleRegistry.getLinkedModule({specifier: modId.specifier, version: modId.version}, runtimeEnvironment, runtimeParams);
            moduleGraphs.linkedDefinitions[imp.specifier] = missingLinkedModule;
          }
        }
      }
    }
  }
  const bundles = (await Promise.all(modules.reduce((filteredModules, specifier) => {
    const linkedDefinition = moduleGraphs.linkedDefinitions[specifier];
    if (!linkedDefinition) {
      return filteredModules;
    }
    linkedDefinition.linkedModuleRecord.dynamicImports?.forEach((dynamicImport) => {
      if (dynamicImport.moduleNameType !== "unresolved") {
        const moduleId = (0, import_shared_utils.explodeSpecifier)(dynamicImport.specifier);
        const importReference = {
          ...dynamicImport,
          specifier: moduleId.specifier
        };
        dynamicImports.set((0, import_shared_utils.getSpecifier)(importReference), importReference);
      }
    });
    if (specifier.includes("#")) {
      return filteredModules;
    }
    filteredModules.unshift(linkedDefinition);
    return filteredModules;
  }, []).map((linkedDefinition) => {
    const id = (0, import_shared_utils.getSpecifier)(linkedDefinition);
    includeId(linkedDefinition);
    const isExternal = linkedDefinition.external;
    const isExternalFile = linkedDefinition.externalSrc && linkedDefinition.externalSrc.startsWith(import_shared_utils.PROTOCOL_FILE);
    if (visitedSpecifiers?.has(id)) {
      return false;
    } else {
      visitedSpecifiers?.set(id, true);
    }
    if (id !== rootModule) {
      if (!isExternal) {
        includedModules.push(id);
      }
    } else {
      bundleGroupsIncludedModules.push(id);
    }
    if (isExternalFile) {
      return linkedDefinition.linkedSource;
    }
    return bundle(id, moduleGraphs, minify, unVersionedAliases);
  }))).filter((x) => typeof x === "string");
  return bundles;
}
async function amdBundler(rootModuleId, moduleRegistry, minify = false, runtimeEnvironment, runtimeParams = {}, {bundleConfig}, bundleConfigOverrides) {
  const {exclude, external = {}, groups = {}} = (0, import_bundle_common.overrideBundleConfig)(bundleConfig, bundleConfigOverrides);
  const requiredImports = new Map();
  const dynamicImports = new Map();
  const groupName = (0, import_shared_utils.getGroupName)(rootModuleId.specifier, groups);
  const groupies = groupName && groups[groupName];
  const cacheKey = (0, import_shared_utils.getCacheKeyFromJson)({groupName, exclude, external});
  const cachedGroupieCode = groupName && groupieCodeCache.get(cacheKey);
  const getModuleGraphsWrapper = (graphSpecifier) => {
    const graphOptions = {
      includeLinkedDefinitions: true,
      depth: {
        static: import_shared_utils.GraphDepth.ALL,
        dynamic: 0,
        includeId: includeIdFactory(graphSpecifier, external, exclude, requiredImports, groups)
      }
    };
    return (0, import_shared_utils.getModuleGraphs)(graphSpecifier, graphOptions, moduleRegistry, moduleRegistry, runtimeEnvironment, runtimeParams);
  };
  const versionedSpecifier = (0, import_shared_utils.getSpecifier)(rootModuleId);
  const moduleGraphs = await getModuleGraphsWrapper(versionedSpecifier);
  const rootModule = moduleGraphs.graphs[0];
  const groupModuleGraphsMap = new Map();
  if (!cachedGroupieCode && groupies && groupies.length) {
    for (const specifier2 of groupies) {
      if (specifier2 !== rootModuleId.specifier) {
        const groupieModuleGraph = await getModuleGraphsWrapper(specifier2);
        groupModuleGraphsMap.set(specifier2, groupieModuleGraph);
      }
    }
  }
  let bundleCode, includedModules, bundleGroupsIncludedModules;
  const cachedBundleGroupCode = cachedGroupieCode;
  const bundledSpecifiersMap = new Map();
  if (!cachedBundleGroupCode) {
    includedModules = [], bundleGroupsIncludedModules = [];
    const bundles = await getBundleCode(rootModule.specifier, moduleGraphs, includedModules, bundleGroupsIncludedModules, dynamicImports, minify, !!runtimeEnvironment.featureFlags?.EXPERIMENTAL_UNVERSIONED_ALIASES, includeIdFactory(rootModuleId.specifier, external, exclude, requiredImports, groups), moduleRegistry, runtimeEnvironment, runtimeParams, bundledSpecifiersMap);
    if (groupName) {
      for (const rawGroupieSpecifier of groupies) {
        if (rawGroupieSpecifier !== rootModuleId.specifier) {
          const groupieModuleGraph = groupModuleGraphsMap.get(rawGroupieSpecifier);
          const groupieSpecifier = groupieModuleGraph.graphs[0].specifier;
          const groupieBundles = await getBundleCode(groupieSpecifier, groupieModuleGraph, includedModules, bundleGroupsIncludedModules, dynamicImports, minify, !!runtimeEnvironment.featureFlags?.EXPERIMENTAL_UNVERSIONED_ALIASES, includeIdFactory(rawGroupieSpecifier, external, exclude, requiredImports, groups), moduleRegistry, runtimeEnvironment, runtimeParams, bundledSpecifiersMap);
          bundles.push(...groupieBundles);
        }
      }
    }
    bundleCode = bundles.join("");
    if (groupName) {
      includedModules.push(...bundleGroupsIncludedModules);
      groupieCodeCache.set(groupName, {code: bundleCode, includedModules});
    }
  } else {
    bundleCode = cachedBundleGroupCode.code;
    includedModules = cachedBundleGroupCode.includedModules;
  }
  const {id, name, namespace, version, specifier} = moduleGraphs.linkedDefinitions[rootModule.specifier];
  const getCode = () => Promise.resolve(bundleCode);
  return {
    id,
    name,
    namespace,
    version,
    specifier,
    getCode,
    config: {external, exclude},
    bundleRecord: {
      imports: Array.from(requiredImports.values()),
      dynamicImports: Array.from(dynamicImports.values()),
      includedModules
    }
  };
}
