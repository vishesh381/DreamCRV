/**
 * Simplified version of the AMD Import Metadata Resolver.
 * Just reads the ImportMetadata at construction time.
 */
export default class ImportResolver {
    constructor(config) {
        this.importURICache = new Map();
        this.modifiers = '';
        this.normalizeMetadata(config);
        // only fetch mappings if fingerprints is ON
        this.mappingEndpoint = config?.importMappings ? undefined : config?.endpoints?.uris.mapping;
        if (config?.endpoints?.modifiers) {
            // Add URI modifiers to mapping endpoint query
            this.modifiers = Object.entries(config.endpoints.modifiers).reduce((q, [k, v]) => (q += `${k}=${v}&`), '?');
        }
    }
    normalizeMetadata(importMetada) {
        // Normalize the URI cache to optimize retrieval
        if (importMetada && importMetada.imports) {
            for (const [uri, value] of Object.entries(importMetada.imports)) {
                if (uri && value) {
                    const specifiers = Array.isArray(value) ? value : [];
                    specifiers.forEach((specifier) => {
                        this.importURICache.set(specifier, uri);
                    });
                }
            }
        }
    }
    async fetchMappings(specifier) {
        const mappingUri = `${this.mappingEndpoint}${encodeURIComponent(specifier)}${this.modifiers}`;
        const res = await globalThis.fetch(mappingUri);
        if (res.ok) {
            const mappings = await res.json();
            this.normalizeMetadata(mappings);
        }
    }
    async resolve(specifier) {
        let uri = this.importURICache.get(specifier);
        if (!uri && this.mappingEndpoint) {
            await this.fetchMappings(specifier);
            uri = this.importURICache.get(specifier);
        }
        return uri;
    }
}
//# sourceMappingURL=importResolver.js.map