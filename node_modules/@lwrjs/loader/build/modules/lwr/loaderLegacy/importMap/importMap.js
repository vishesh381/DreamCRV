/**
 * Import map support for LWR based on the spec: https://github.com/WICG/import-maps
 *
 * This implementation is adapted from https://github.com/systemjs/systemjs/blob/master/src/features/import-map.js
 */
import { resolveUrl, resolveIfNotPlainOrUrl, isUrl } from '../utils/url.js';
import { getMatch, targetWarning } from './utils.js';
// Resolves an import map package entry
function applyPackages(id, packages, defaultUri) {
    const pkgName = getMatch(id, packages);
    if (pkgName) {
        const pkg = packages[pkgName];
        if (pkg === null) {
            return;
        }
        if (id.length > pkgName.length && pkg[pkg.length - 1] !== '/') {
            targetWarning(pkgName, pkg, "should have a trailing '/'");
        }
        else {
            const isPackage = id.length > pkgName.length &&
                pkg[pkg.length - 1] === '/' &&
                pkg.lastIndexOf(pkgName) === pkg.length - pkgName.length;
            if (isPackage) {
                // Encode the specifier to create a well-formed LWR module URI
                const uri = pkg.substring(0, pkg.lastIndexOf(pkgName)) + encodeURIComponent(id);
                return { uri };
            }
            const uri = pkg + id.slice(pkgName.length);
            return { uri };
        }
    }
    else if (defaultUri) {
        // When a specifier's URI cannot be resolved via the imports, fallback to "default".
        //     -> https://rfcs.lwc.dev/rfcs/lwr/0000-import-metadata#json-schema
        // However, if `id` is already a fully resolved url,
        // we cannot prepend the defaultUri -> https://github.com/salesforce-experience-platform-emu/lwr/issues/378.
        // In this case we do not apply any package mappings and allow the caller (resolveImportMapEntry) to handle it.
        if (!isUrl(id)) {
            const uri = defaultUri + encodeURIComponent(id);
            return {
                uri,
                defaultUri: true,
            };
        }
    }
}
// Resolves an entry in the import map
function resolveImportMapEntry(importMap, resolvedOrPlain, parentUrl) {
    if (!importMap.scopes) {
        importMap.scopes = {};
    }
    if (!importMap.imports) {
        importMap.imports = {};
    }
    const scopes = importMap.scopes;
    let scopeUrl = parentUrl && getMatch(parentUrl, scopes);
    while (scopeUrl) {
        const packageResolution = applyPackages(resolvedOrPlain, scopes[scopeUrl]);
        if (packageResolution) {
            return packageResolution;
        }
        scopeUrl = getMatch(scopeUrl.slice(0, scopeUrl.lastIndexOf('/')), scopes);
    }
    return (applyPackages(resolvedOrPlain, importMap.imports, importMap.default) ||
        (isUrl(resolvedOrPlain) && { uri: resolvedOrPlain }) ||
        undefined);
}
// In place transformation of the ImportMap object
function resolveAndComposePackages(packages, outPackages, baseUrl, parentMap, parentUrl) {
    for (const p in packages) {
        const resolvedLhs = resolveIfNotPlainOrUrl(p, baseUrl) || p;
        const rhs = packages[p];
        // package fallbacks not currently supported
        if (typeof rhs !== 'string') {
            continue;
        }
        const mapped = resolveImportMapEntry(parentMap, resolveIfNotPlainOrUrl(rhs, baseUrl) || rhs, parentUrl);
        if (!mapped) {
            targetWarning(p, rhs, 'bare specifier did not resolve');
        }
        else {
            outPackages[resolvedLhs] = mapped.uri;
        }
    }
}
// Composes a single import map object given a child and parent import map
function resolveAndComposeImportMap(json, baseUrl, parentMap = { imports: {}, scopes: {} }) {
    const outMap = {
        imports: Object.assign({}, parentMap.imports),
        scopes: Object.assign({}, parentMap.scopes),
        default: json.default,
    };
    if (json.imports) {
        resolveAndComposePackages(json.imports, outMap.imports, baseUrl, parentMap);
    }
    if (json.scopes) {
        for (const s in json.scopes) {
            const resolvedScope = resolveUrl(s, baseUrl);
            resolveAndComposePackages(json.scopes[s], outMap.scopes[resolvedScope] || (outMap.scopes[resolvedScope] = {}), baseUrl, parentMap, resolvedScope);
        }
    }
    if (json.default) {
        outMap.default = resolveIfNotPlainOrUrl(json.default, baseUrl);
    }
    return outMap;
}
export { resolveAndComposeImportMap, resolveImportMapEntry };
//# sourceMappingURL=importMap.js.map