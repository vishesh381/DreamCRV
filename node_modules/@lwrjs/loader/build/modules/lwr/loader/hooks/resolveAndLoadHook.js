/* global console,process */
import { LoaderError, INVALID_LOADER_SERVICE_RESPONSE, FAIL_LOAD, HTTP_FAIL_LOAD, MODULE_LOAD_TIMEOUT, FAIL_HOOK_LOAD, } from '../errors/messages.js';
import { MODULE_LOAD_TIMEOUT_TIMER } from '../constants/constants.js';
import { hasDocument, hasSetTimeout, hasConsole } from '../utils/dom.js';
// eslint-disable-next-line lwr/only-allowed-imports
import { trusted } from '@locker/trusted-types';
let lastWindowError;
if (hasDocument) {
    globalThis.addEventListener('error', (evt) => {
        lastWindowError = evt.error;
    });
}
// eslint-disable-next-line lwr/no-unguarded-apis
if (process.env.NODE_ENV !== 'production') {
    if (!hasSetTimeout && hasConsole) {
        // eslint-disable-next-line lwr/no-unguarded-apis
        console.warn('setTimeout API is not available, watchdog timer on load hook will not be set');
    }
}
export function isCustomResponse(response) {
    return (Object.prototype.hasOwnProperty.call(response, 'data') &&
        !Object.prototype.hasOwnProperty.call(response, 'blob'));
}
export function isFetchResponse(response) {
    // if it quacks like a duck...
    return typeof response.blob === 'function';
}
export function isResponseAPromise(response) {
    return !!(response && response.then);
}
export async function evaluateLoadHookResponse(response, id) {
    return Promise.resolve().then(async () => {
        if (!response || !response.status) {
            throw new LoaderError(INVALID_LOADER_SERVICE_RESPONSE);
        }
        if (response.status !== 200) {
            throw new LoaderError(HTTP_FAIL_LOAD, [id, `${response.status}`]);
        }
        const isResponse = isFetchResponse(response);
        let code;
        if (isCustomResponse(response)) {
            code = response.data;
        }
        else if (isResponse) {
            // handle fetch response
            code = await response.text();
        }
        else {
            throw new LoaderError(INVALID_LOADER_SERVICE_RESPONSE);
        }
        if (!code) {
            throw new LoaderError(FAIL_LOAD, [id]);
        }
        code = `${code}\n//# sourceURL=${id}`; // append sourceURL for debugging
        try {
            // TODO eval source maps for debugging
            eval(trusted.createScript(code));
        }
        catch (e) {
            // eslint-disable-next-line lwr/no-unguarded-apis
            if (process.env.NODE_ENV !== 'production' && hasConsole) {
                // eslint-disable-next-line lwr/no-unguarded-apis
                console.error(e);
            }
            throw new LoaderError(FAIL_LOAD, [id]);
        }
        if (lastWindowError) {
            throw new LoaderError(FAIL_LOAD, [id]);
        }
        return true;
    });
}
export async function evaluateLoadHook(id, hookPromise) {
    if (!hasSetTimeout) {
        return hookPromise;
    }
    return new Promise((resolve, reject) => {
        // wrap the hook in a watchdog timer
        // eslint-disable-next-line lwr/no-unguarded-apis, no-undef
        const timer = setTimeout(() => {
            reject(new LoaderError(MODULE_LOAD_TIMEOUT, [id]));
        }, MODULE_LOAD_TIMEOUT_TIMER);
        hookPromise
            .then((response) => {
            resolve(response);
        })
            .catch(() => {
            reject(new LoaderError(FAIL_HOOK_LOAD, [id]));
        })
            .finally(() => {
            // eslint-disable-next-line lwr/no-unguarded-apis, no-undef
            clearTimeout(timer);
        });
    });
}
//# sourceMappingURL=resolveAndLoadHook.js.map