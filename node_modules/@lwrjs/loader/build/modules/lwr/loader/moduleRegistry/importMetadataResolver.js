import { LoaderError, BAD_IMPORT_METADATA, UNRESOLVED, UNRESOLVEABLE_MAPPING_ERROR, } from '../errors/messages.js';
import { isUrl, resolveUrl } from '../utils/url.js';
import { MAPPINGS_ERROR, MAPPINGS_FETCH } from 'lwr/metrics';
/* spec based import map resolver */
export class ImportMetadataResolver {
    constructor(config, invalidationCallback) {
        // Default to empty mappings
        this.importURICache = new Map();
        this.pendingURICache = new Map();
        this.loadMappingHooks = [];
        this.config = config;
        this.invalidationCallback = invalidationCallback;
    }
    addLoadMappingHook(hook) {
        this.loadMappingHooks.push(hook);
    }
    getMappingEndpoint() {
        return this.config.endpoints && this.config.endpoints.uris
            ? this.config.endpoints.uris.mapping
            : undefined;
    }
    getModifiersAsUrlParams() {
        const modifiers = this.config.endpoints ? this.config.endpoints.modifiers : undefined;
        if (!modifiers) {
            // No modifiers return an empty string to append to the URL
            return '';
        }
        else {
            const qs = Object.keys(modifiers)
                .map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(modifiers[key])}`)
                .join('&');
            return `?${qs}`;
        }
    }
    buildMappingUrl(specifier) {
        const mappingEndpoint = this.getMappingEndpoint();
        const specifiers = encodeURIComponent(specifier);
        const modifiers = this.getModifiersAsUrlParams();
        return `${mappingEndpoint}${specifiers}${modifiers}`;
    }
    getBaseUrl() {
        return this.config.baseUrl || '';
    }
    registerImportMappings(newImportMetadata, rootSpecifiers) {
        if (!rootSpecifiers || rootSpecifiers.length === 0) {
            const imports = newImportMetadata ? JSON.stringify(newImportMetadata) : 'undefined';
            throw new LoaderError(BAD_IMPORT_METADATA, [imports, rootSpecifiers ? '[]' : 'undefined']);
        }
        if (!newImportMetadata) {
            throw new LoaderError(BAD_IMPORT_METADATA, ['undefined', JSON.stringify(rootSpecifiers)]);
        }
        if (!newImportMetadata.imports || Object.keys(newImportMetadata.imports).length === 0) {
            throw new LoaderError(BAD_IMPORT_METADATA, [
                JSON.stringify(newImportMetadata),
                JSON.stringify(rootSpecifiers),
            ]);
        }
        const index = newImportMetadata.index || {};
        for (const [uri, specifiers] of Object.entries(newImportMetadata.imports)) {
            specifiers.forEach((specifier) => {
                const indexValue = index[specifier];
                const existing = this.importURICache.get(specifier);
                if (!existing) {
                    this.saveImportURIRecord(specifier, uri, indexValue, rootSpecifiers.includes(specifier));
                }
                else {
                    const identity = indexValue || uri;
                    const existingIdentity = existing.identity || existing.uri;
                    if (existingIdentity !== identity) {
                        this.invalidationCallback({
                            name: specifier,
                            oldUrl: existingIdentity,
                            newUrl: identity,
                        });
                    }
                }
            });
        }
    }
    // Get URL from the local cache or return undefiend
    getURI(specifier) {
        return this.importURICache && this.importURICache.has(specifier)
            ? resolveUrl(this.importURICache.get(specifier).uri, this.getBaseUrl())
            : undefined;
    }
    resolveLocal(specifier) {
        const uri = this.getURI(specifier);
        if (uri) {
            return uri;
        }
        else if (isUrl(specifier) || specifier.startsWith('/')) {
            return specifier;
        }
        return undefined;
    }
    /**
     *  Resolves a the URI for a specified module.  It will return the value in this order:
     *
     *  1) Mapping from local URI cache
     *  2) The URI if a specifier is already an absolute URI
     *  3) Mapping fetched from a registered loader hook
     *  4)
     *  @param specifier
     *  @returns module URI
     */
    async resolve(specifier) {
        let uri = this.getURI(specifier);
        if (uri) {
            return uri;
        }
        else if (isUrl(specifier) || specifier.startsWith('/')) {
            return specifier;
        }
        else {
            const pending = this.pendingURICache.get(specifier);
            if (pending) {
                return pending;
            }
            this.config.profiler.logOperationStart({ id: MAPPINGS_FETCH, specifier });
            const fetchMappingService = this.hasMappingHooks()
                ? this.evaluateMappingHooks
                : this.fetchNewMappings;
            const promise = fetchMappingService
                .bind(this)(specifier)
                .then((importMetadata) => {
                if (!importMetadata || !importMetadata.imports) {
                    throw new LoaderError(UNRESOLVED, [specifier]);
                }
                this.registerImportMappings(importMetadata, [specifier]);
                uri = this.getURI(specifier);
                if (!uri) {
                    throw new LoaderError(UNRESOLVED, [specifier]);
                }
                this.config.profiler.logOperationEnd({ id: MAPPINGS_FETCH, specifier });
                return uri;
            })
                .finally(() => {
                this.pendingURICache.delete(specifier);
            });
            this.pendingURICache.set(specifier, promise);
            return promise;
        }
    }
    hasMappingHooks() {
        return this.loadMappingHooks.length > 0;
    }
    /**
     *  Evaluates mapping hooks.  Returns first match. If all hooks return null call the mapping service.
     *  @param specifier Request module identifier
     *  @returns Import Metadata from the module root
     */
    async evaluateMappingHooks(specifier) {
        // Check with any registered loadMappingHooks
        const loadMappingHooks = this.loadMappingHooks;
        if (loadMappingHooks.length) {
            const knownModules = Array.from(this.importURICache.keys());
            for (let i = 0; i < loadMappingHooks.length; i++) {
                const loadMappingHook = loadMappingHooks[i];
                // eslint-disable-next-line no-await-in-loop
                const response = await loadMappingHook(specifier, { knownModules });
                // undefined (but not null) is considered an un expected response so we will stop processing hooks here and throw an error
                if (response || response === undefined) {
                    return response;
                }
            }
        }
        // If we still do not have a match call the mapping service
        return this.fetchNewMappings(specifier);
    }
    async fetchNewMappings(specifier) {
        if (typeof globalThis.fetch !== 'function') {
            throw new LoaderError(UNRESOLVED, [specifier]);
        }
        // TODO For module invalidation with bundles it is recommended we have to send back all loaded root specified
        // to ensure we detect all conflicts.
        const uri = resolveUrl(this.buildMappingUrl(specifier), this.getBaseUrl());
        if (!uri) {
            throw new LoaderError(UNRESOLVEABLE_MAPPING_ERROR, [specifier]);
        }
        return globalThis.fetch(uri).then((res) => {
            if (!res.ok) {
                this.config.profiler.logOperationStart({ id: MAPPINGS_ERROR, specifier });
                throw new LoaderError(UNRESOLVED, [specifier]);
            }
            return res
                .json()
                .then((ret) => {
                return ret;
            })
                .catch((err) => {
                throw new LoaderError(UNRESOLVED, [specifier]);
            });
        });
    }
    saveImportURIRecord(specifier, uri, identity, isRoot) {
        if (!identity || uri === identity) {
            this.importURICache.set(specifier, {
                uri,
                isRoot: isRoot,
            });
        }
        else {
            this.importURICache.set(specifier, {
                uri,
                identity,
                isRoot: isRoot,
            });
        }
    }
}
//# sourceMappingURL=importMetadataResolver.js.map