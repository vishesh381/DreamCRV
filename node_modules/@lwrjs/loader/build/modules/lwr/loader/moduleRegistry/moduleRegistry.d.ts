import { ImportMetadataResolver } from './importMetadataResolver.js';
import type { HandleStaleModuleHook, LoaderHooks, ResolveHookResponse } from '@lwrjs/types';
import type { LoaderConfig } from '../../../../types.js';
export type Module = {
    [key: string]: any;
    __useDefault?: boolean;
};
export declare class ModuleRegistry {
    private profiler;
    constructor(config: LoaderConfig);
    load(id: string, importer?: string): Promise<Module>;
    resolve(id: string, importer?: string): Promise<string>;
    has(id: string): boolean;
    define(name: string, dependencies: string[], exporter: Function): void;
    /**
     * Marks modules as "externally" loaded/provided, so that the loader does not attempt to fetch them.
     *
     * @param modules - list of module identifiers
     */
    registerExternalModules(modules: string[]): void;
    private resolver;
    private namedDefineRegistry;
    private moduleRegistry;
    aliases: Map<string, string>;
    private lastDefine;
    getImportMetadataResolver(): ImportMetadataResolver;
    private getExistingModuleRecord;
    private getModuleRecord;
    private storeModuleAlias;
    private getModuleDependencyRecord;
    private topLevelEvaluation;
    private instantiateAll;
    private evaluateModule;
    private isNamedExportDefaultOnly;
    private getCircularDependencyWrapper;
    private evaluateModuleDependencies;
    private getModuleDef;
    private resolveHook?;
    private loadHook?;
    private loadMappingHooks?;
    addLoaderPlugin(hooks: LoaderHooks): void;
    private importMetadataInvalidationCallback;
    private handleStaleModuleHook?;
    registerHandleStaleModuleHook(handleStaleModule: HandleStaleModuleHook): void;
    isValidResolveResponse(res: ResolveHookResponse): boolean;
}
//# sourceMappingURL=moduleRegistry.d.ts.map