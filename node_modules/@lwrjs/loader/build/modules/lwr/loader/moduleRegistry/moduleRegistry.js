/* global console,process */
import { invariant, NO_AMD_REQUIRE, LoaderError, FAIL_INSTANTIATE, FAILED_DEP, UNRESOLVED, INVALID_HOOK, INVALID_LOADER_SERVICE_RESPONSE, MODULE_ALREADY_LOADED, MODULE_LOAD_TIMEOUT, EXPORTER_ERROR, } from '../errors/messages.js';
import { resolveIfNotPlainOrUrl, isUrl } from '../utils/url.js';
import { hasDocument, hasConsole, hasProcessEnv } from '../utils/dom.js';
import { loadModuleDef } from './scriptLoad.js';
import { ImportMetadataResolver } from './importMetadataResolver.js';
import { evaluateHandleStaleModuleHooks } from '../hooks/moduleInvalidation.js';
import { evaluateLoadHookResponse, evaluateLoadHook, isResponseAPromise, } from '../hooks/resolveAndLoadHook.js';
import { MODULE_DEFINE, MODULE_ERROR, MODULE_FETCH, MODULE_DYNAMIC_LOAD } from 'lwr/metrics';
import { MODULE_LOAD_TIMEOUT_TIMER } from '../constants/constants.js';
export class ModuleRegistry {
    constructor(config) {
        // A registry for named AMD defines containing the *metadata* of AMD module
        this.namedDefineRegistry = new Map();
        // The evaluated module registry where the module identifier (name or URL?) is the key
        this.moduleRegistry = new Map();
        // Aliases of modules in the registry
        this.aliases = new Map();
        this.profiler = config.profiler;
        this.resolver = new ImportMetadataResolver(config, this.importMetadataInvalidationCallback.bind(this));
    }
    async load(id, importer) {
        const metadata = importer ? { importer } : {};
        this.profiler.logOperationStart({
            id: MODULE_DYNAMIC_LOAD,
            specifier: id,
            metadata,
        });
        const resolvedId = await this.resolve(id, importer);
        const moduleRecord = await this.getModuleRecord(resolvedId, id);
        if (moduleRecord.evaluated) {
            return moduleRecord.module;
        }
        else {
            if (!moduleRecord.evaluationPromise) {
                moduleRecord.evaluationPromise = this.topLevelEvaluation(moduleRecord);
            }
            return moduleRecord.evaluationPromise;
        }
    }
    async resolve(id, importer) {
        const parentUrl = this.resolver.getBaseUrl(); // only support baseUrl for now
        let resolved;
        let aliasedId = id;
        const resolveHooks = this.resolveHook;
        if (resolveHooks) {
            for (let i = 0; i < resolveHooks.length; i++) {
                const resolveHook = resolveHooks[i];
                const response = resolveHook(aliasedId, { parentUrl });
                let result;
                if (response || response === null) {
                    // eslint-disable-next-line no-await-in-loop
                    result = isResponseAPromise(response) ? await response : response;
                }
                if (!this.isValidResolveResponse(result)) {
                    throw new LoaderError(INVALID_LOADER_SERVICE_RESPONSE);
                }
                // if result is not null, attempt resolution
                if (result !== null) {
                    if (typeof result === 'string') {
                        if (resolveIfNotPlainOrUrl(result, parentUrl)) {
                            // string response can't be a URL
                            throw new LoaderError(INVALID_LOADER_SERVICE_RESPONSE);
                        }
                        aliasedId = result; // the next hook will receive the new id
                        continue;
                    }
                    resolved =
                        result && result.url && (resolveIfNotPlainOrUrl(result.url, parentUrl) || result.url);
                    if (!resolved) {
                        throw new LoaderError(INVALID_LOADER_SERVICE_RESPONSE);
                    }
                    // Don't process any more hooks if we have resolved
                    break;
                }
            }
            if (aliasedId !== id) {
                // resolved module id is the aliased module if it has already been defined
                if (!resolved && this.namedDefineRegistry.has(aliasedId)) {
                    return aliasedId;
                }
                else {
                    id = aliasedId;
                }
            }
        }
        if (!resolved) {
            const resolvedOrPlain = resolveIfNotPlainOrUrl(id, parentUrl) || id;
            // if module registry already has named module the resolved id is the plain id
            if (this.moduleRegistry.has(resolvedOrPlain)) {
                return resolvedOrPlain;
            }
            const resolvedUrl = this.resolver.resolveLocal(resolvedOrPlain);
            if (resolvedUrl) {
                // resolve to the bare specifier if conditions are met
                if (this.namedDefineRegistry.has(resolvedOrPlain)) {
                    const namedDefineRecord = this.namedDefineRegistry.get(resolvedOrPlain);
                    if (namedDefineRecord.external || namedDefineRecord.defined) {
                        const record = this.moduleRegistry.get(resolvedUrl);
                        if (!record || !this.aliases.has(resolvedOrPlain)) {
                            return resolvedOrPlain;
                        }
                    }
                }
                return resolvedUrl;
            }
            if (this.namedDefineRegistry.has(resolvedOrPlain)) {
                return resolvedOrPlain;
            }
            try {
                resolved = await this.resolver.resolve(resolvedOrPlain);
            }
            catch (e) {
                // defer to error handling below for unresolved
            }
        }
        if (!resolved || !isUrl(resolved)) {
            if (this.namedDefineRegistry.has(id)) {
                return id;
            }
            throw new LoaderError(UNRESOLVED, [id]);
        }
        if (importer && isUrl(resolved)) {
            resolved += `?importer=${encodeURIComponent(importer)}`;
        }
        return resolved;
    }
    has(id) {
        return this.moduleRegistry.has(id);
    }
    define(name, dependencies, exporter) {
        const mod = this.namedDefineRegistry.get(name);
        // Don't allow redefining a module.
        if (mod && mod.defined) {
            if (hasProcessEnv &&
                // eslint-disable-next-line lwr/no-unguarded-apis
                process.env.NODE_ENV !== 'production' &&
                // eslint-disable-next-line lwr/no-unguarded-apis
                process.env.MRT_HMR !== 'true' &&
                hasConsole) {
                // eslint-disable-next-line lwr/no-unguarded-apis
                console.warn(`Module redefine attempted: ${name}`);
            }
            this.lastDefine = mod;
            return;
        }
        const moduleDef = {
            name,
            dependencies,
            exporter,
            defined: true,
        };
        if (mod && mod.external) {
            // if module is "external", resolve the external promise to notify any dependees
            mod.external.resolveExternal(moduleDef);
        }
        this.profiler.logOperationStart({ id: MODULE_DEFINE, specifier: name });
        this.namedDefineRegistry.set(name, moduleDef);
        this.lastDefine = moduleDef;
    }
    /**
     * Marks modules as "externally" loaded/provided, so that the loader does not attempt to fetch them.
     *
     * @param modules - list of module identifiers
     */
    registerExternalModules(modules) {
        modules.map((id) => {
            if (!this.namedDefineRegistry.has(id)) {
                let resolveExternal;
                let timer;
                const moduleDefPromise = new Promise((resolve, reject) => {
                    resolveExternal = resolve;
                    // watch the external for timeout
                    // eslint-disable-next-line lwr/no-unguarded-apis, no-undef
                    timer = setTimeout(() => {
                        reject(new LoaderError(MODULE_LOAD_TIMEOUT, [id]));
                    }, MODULE_LOAD_TIMEOUT_TIMER);
                }).finally(() => {
                    // eslint-disable-next-line lwr/no-unguarded-apis, no-undef
                    clearTimeout(timer);
                });
                const moduleDef = {
                    name: id,
                    defined: false,
                    external: {
                        resolveExternal,
                        moduleDefPromise,
                    },
                };
                this.namedDefineRegistry.set(id, moduleDef);
                // eslint-disable-next-line lwr/no-unguarded-apis
            }
            else if (process.env.NODE_ENV !== 'production' && hasConsole) {
                // eslint-disable-next-line lwr/no-unguarded-apis
                console.warn(MODULE_ALREADY_LOADED.message, id);
            }
        });
    }
    getImportMetadataResolver() {
        return this.resolver;
    }
    // Returns an existing module record by the resolvedId or aliased id
    getExistingModuleRecord(resolvedId, aliasId) {
        const moduleRecord = this.moduleRegistry.get(resolvedId);
        if (moduleRecord) {
            this.storeModuleAlias(aliasId, resolvedId);
            return moduleRecord;
        }
        // Check if this is a known alias
        if (resolvedId !== aliasId) {
            const alias = this.aliases.get(aliasId);
            if (alias) {
                const aliasedModule = this.moduleRegistry.get(alias);
                if (aliasedModule) {
                    return aliasedModule;
                }
            }
        }
        return moduleRecord;
    }
    async getModuleRecord(resolvedId, id) {
        // Look for an existing record
        const existingRecord = this.getExistingModuleRecord(resolvedId, id);
        if (existingRecord) {
            // return existing
            return existingRecord;
        }
        // Create a new Module Record
        const instantiation = this.getModuleDef(resolvedId, id);
        const dependencyRecords = instantiation.then((moduleDef) => {
            const dependencies = moduleDef.dependencies || [];
            // get dep and filter out exports
            const filtered = dependencies
                .map((dep) => {
                if (dep === 'exports') {
                    return;
                }
                invariant(dep !== 'require', NO_AMD_REQUIRE);
                return this.getModuleDependencyRecord.call(this, dep);
            })
                .filter((depRecord) => depRecord !== undefined);
            return Promise.all(filtered);
        });
        const newModuleRecord = {
            id: resolvedId,
            module: Object.create(null),
            dependencyRecords,
            instantiation,
            evaluated: false,
            evaluationPromise: null,
        };
        this.moduleRegistry.set(resolvedId, newModuleRecord);
        this.storeModuleAlias(id, resolvedId);
        // Wait for the dependencies to resolve the return the moduleRecord
        return dependencyRecords.then(() => newModuleRecord);
    }
    storeModuleAlias(aliasId, resolvedId) {
        if (aliasId !== resolvedId) {
            if (!this.aliases.has(aliasId)) {
                this.aliases.set(aliasId, resolvedId);
                // eslint-disable-next-line lwr/no-unguarded-apis, no-undef
            }
            else if (process.env.NODE_ENV !== 'production' && hasConsole) {
                // Warn the user if they were not aliasing to the resolvedId
                const currentResolvedId = this.aliases.get(aliasId);
                if (currentResolvedId !== resolvedId) {
                    // eslint-disable-next-line lwr/no-unguarded-apis, no-undef
                    if (process.env.NODE_ENV !== 'production' && hasConsole) {
                        // eslint-disable-next-line lwr/no-unguarded-apis, no-undef
                        console.warn(`Alias update attempt: ${aliasId}=>${currentResolvedId}, ${resolvedId}`);
                    }
                }
            }
        }
    }
    async getModuleDependencyRecord(dependency) {
        const resolvedDepId = await this.resolve(dependency);
        return this.getModuleRecord(resolvedDepId, dependency);
    }
    // execute the "top-level code" (the code outside of functions) of a module
    async topLevelEvaluation(moduleRecord) {
        await this.instantiateAll(moduleRecord, {});
        return this.evaluateModule(moduleRecord, {});
    }
    // Returns a promise when a module and all of it's dependencies have finished instantiation
    async instantiateAll(moduleRecord, instantiatedMap) {
        if (!instantiatedMap[moduleRecord.id]) {
            instantiatedMap[moduleRecord.id] = true;
            const dependencyModuleRecords = await moduleRecord.dependencyRecords;
            if (dependencyModuleRecords) {
                for (let i = 0; i < dependencyModuleRecords.length; i++) {
                    const depRecord = dependencyModuleRecords[i];
                    // eslint-disable-next-line no-await-in-loop
                    await this.instantiateAll(depRecord, instantiatedMap);
                }
            }
        }
    }
    async evaluateModule(moduleRecord, evaluationMap) {
        const dependencyModuleRecords = await moduleRecord.dependencyRecords;
        if (dependencyModuleRecords.length > 0) {
            evaluationMap[moduleRecord.id] = true;
            // evaluate dependencies first
            await this.evaluateModuleDependencies(dependencyModuleRecords, evaluationMap);
        }
        const { exporter, dependencies } = await moduleRecord.instantiation;
        // The exports object automatically gets filled in by the exporter evaluation
        const exports = {};
        const depsMapped = dependencies
            ? await Promise.all(dependencies.map(async (dep) => {
                if (dep === 'exports') {
                    return exports;
                }
                const resolvedDepId = await this.resolve(dep);
                const moduleRecord = this.moduleRegistry.get(resolvedDepId);
                if (!moduleRecord) {
                    throw new LoaderError(FAILED_DEP, [resolvedDepId]);
                }
                const module = moduleRecord.module;
                /**
                 * Circular dependencies are handled properly when named exports are used,
                 * however, for default exports there is a bug: https://github.com/rollup/rollup/issues/3384
                 *
                 * The workaround below applies for circular dependencies (!moduleRecord.evaluated)
                 */
                if (!moduleRecord.evaluated) {
                    return this.getCircularDependencyWrapper(module);
                }
                if (module) {
                    return module.__defaultInterop ? module.default : module;
                }
                throw new LoaderError(FAILED_DEP, [resolvedDepId]);
            }))
            : [];
        // W-10029836 - In the case where we could be instantiating multiple graphs at the same time lets make sure the module have not already been evaluated
        if (moduleRecord.evaluated) {
            return moduleRecord.module;
        }
        // evaluates the module function
        let moduleDefault;
        try {
            moduleDefault = exporter(...depsMapped);
        }
        catch (e) {
            throw new LoaderError(EXPORTER_ERROR, [moduleRecord.id, e.message || e]);
        }
        // value is returned from exporter, then we are not using named exports
        if (moduleDefault !== undefined) {
            moduleDefault = { default: moduleDefault };
            // __defaultInterop is ONLY used to support backwards compatibility
            // of importing default exports the "wrong" way (when not using named exports).
            // See https://github.com/salesforce-experience-platform-emu/lwr/pull/816
            Object.defineProperty(moduleDefault, '__defaultInterop', { value: true });
        }
        // if no return value, then we are using the exports object
        else {
            // handle only default export with Rollup forced named exports
            if (this.isNamedExportDefaultOnly(exports)) {
                Object.defineProperty(exports, '__useDefault', { value: true });
            }
        }
        const moduleExports = moduleDefault || exports;
        // update the module record
        // copy over enumerable public methods to module
        for (const key in moduleExports) {
            Object.defineProperty(moduleRecord.module, key, {
                enumerable: true,
                set(value) {
                    moduleExports[key] = value;
                },
                get() {
                    return moduleExports[key];
                },
            });
        }
        // copy non-enumerable to module
        if (moduleExports.__useDefault) {
            Object.defineProperty(moduleRecord.module, '__useDefault', { value: true });
        }
        if (moduleExports.__defaultInterop) {
            Object.defineProperty(moduleRecord.module, '__defaultInterop', { value: true });
        }
        if (moduleExports.__esModule) {
            Object.defineProperty(moduleRecord.module, '__esModule', { value: true });
        }
        moduleRecord.evaluated = true;
        Object.freeze(moduleRecord.module);
        return moduleRecord.module;
    }
    // Determines if named exports module has only default export
    isNamedExportDefaultOnly(exports) {
        return (exports !== undefined &&
            Object.getOwnPropertyNames(exports).length === 2 &&
            Object.prototype.hasOwnProperty.call(exports, 'default') &&
            Object.prototype.hasOwnProperty.call(exports, '__esModule'));
    }
    // Wrap the dependency in a function that can be called and detected by __circular__ property.
    // The LWC engine checks for __circular__ to detect circular dependencies.
    getCircularDependencyWrapper(module) {
        const tmp = () => {
            return module.__useDefault || module.__defaultInterop ? module.default : module;
        };
        tmp.__circular__ = true;
        return tmp;
    }
    async evaluateModuleDependencies(dependencyModuleRecords, evaluationMap) {
        for (let i = 0; i < dependencyModuleRecords.length; i++) {
            const depRecord = dependencyModuleRecords[i];
            if (!depRecord.evaluated && !evaluationMap[depRecord.id]) {
                evaluationMap[depRecord.id] = true;
                // eslint-disable-next-line no-await-in-loop
                await this.evaluateModule(depRecord, evaluationMap);
            }
        }
    }
    async getModuleDef(resolvedId, originalId) {
        // reset lastDefine
        this.lastDefine = undefined;
        // the module name can be the resolved ID or the original ID if neither are URL's.
        const moduleName = !isUrl(resolvedId)
            ? resolvedId
            : originalId !== resolvedId
                ? originalId
                : undefined;
        let moduleDef = moduleName && this.namedDefineRegistry.get(moduleName);
        if (moduleDef && moduleDef.external) {
            return moduleDef.external.moduleDefPromise;
        }
        if (moduleDef && moduleDef.defined) {
            return moduleDef;
        }
        const parentUrl = this.resolver.getBaseUrl(); // only support baseUrl for now
        const specifier = moduleName || originalId;
        this.profiler.logOperationStart({ id: MODULE_FETCH, specifier });
        return Promise.resolve()
            .then(async () => {
            const loadHooks = this.loadHook;
            if (loadHooks) {
                for (let i = 0; i < loadHooks.length; i++) {
                    const loadHook = loadHooks[i];
                    const response = loadHook(resolvedId, parentUrl);
                    const result = (isResponseAPromise(response)
                        ? // eslint-disable-next-line no-await-in-loop
                            await evaluateLoadHook(resolvedId, response)
                        : response);
                    if (result === undefined) {
                        throw new LoaderError(INVALID_LOADER_SERVICE_RESPONSE);
                    }
                    if (result && result !== null) {
                        return evaluateLoadHookResponse(result, resolvedId);
                    }
                }
            }
            return false;
        })
            .then((result) => {
            if (result !== true && hasDocument) {
                return loadModuleDef(resolvedId);
            }
        })
            .then(() => {
            // Attempt to retrieve the module definition by name first
            moduleDef = moduleName && this.namedDefineRegistry.get(moduleName);
            // Fallback to the last loader.define call
            if (!moduleDef) {
                moduleDef = this.lastDefine;
            }
            // This should not happen
            if (!moduleDef) {
                throw new LoaderError(FAIL_INSTANTIATE, [resolvedId]);
            }
            this.profiler.logOperationEnd({ id: MODULE_FETCH, specifier });
            return moduleDef;
        })
            .catch((e) => {
            // Create module error marks for all errors caused by the loader
            // Note: these marks do not include errors caused by invalid server responses or loader hooks
            if (!(e instanceof LoaderError)) {
                this.profiler.logOperationStart({ id: MODULE_ERROR, specifier });
            }
            throw e;
        });
    }
    addLoaderPlugin(hooks) {
        if (typeof hooks !== 'object') {
            throw new LoaderError(INVALID_HOOK);
        }
        const { loadModule: loadHook, resolveModule: resolveHook, loadMapping } = hooks;
        if (resolveHook) {
            if (this.resolveHook) {
                this.resolveHook.push(resolveHook);
            }
            else {
                this.resolveHook = [resolveHook];
            }
        }
        if (loadHook) {
            if (this.loadHook) {
                this.loadHook.push(loadHook);
            }
            else {
                this.loadHook = [loadHook];
            }
        }
        if (loadMapping) {
            this.resolver.addLoadMappingHook(loadMapping);
        }
    }
    importMetadataInvalidationCallback({ name, oldUrl, newUrl }) {
        const handleStaleModuleHooks = this.handleStaleModuleHook;
        if (handleStaleModuleHooks) {
            evaluateHandleStaleModuleHooks(handleStaleModuleHooks, {
                name,
                oldUrl,
                newUrl,
            });
        }
        else {
            // eslint-disable-next-line lwr/no-unguarded-apis
            if (process.env.NODE_ENV !== 'production' && hasConsole) {
                // eslint-disable-next-line lwr/no-unguarded-apis, no-undef
                console.warn(`stale module detected ${name}, current URL:${oldUrl}, new URL:${newUrl}`);
            }
        }
    }
    registerHandleStaleModuleHook(handleStaleModule) {
        if (this.handleStaleModuleHook) {
            this.handleStaleModuleHook.push(handleStaleModule);
        }
        else {
            this.handleStaleModuleHook = [handleStaleModule];
        }
    }
    isValidResolveResponse(res) {
        return (res === null || typeof res === 'string' || (res && typeof res.url === 'string'));
    }
}
//# sourceMappingURL=moduleRegistry.js.map