import type { ImportMetadata, LoadMappingHook } from '@lwrjs/types';
import type { FingerprintsLoaderConfig as LoaderConfig } from '../../../../types.js';
export type InvalidationCallback = (details: {
    name: string;
    oldUrl: string;
    newUrl: string;
}) => void;
export declare class ImportMetadataResolver {
    private importURICache;
    private pendingURICache;
    private config;
    private invalidationCallback;
    private loadMappingHooks;
    constructor(config: LoaderConfig, invalidationCallback: Function);
    addLoadMappingHook(hook: LoadMappingHook): void;
    getMappingEndpoint(): string | undefined;
    getModifiersAsUrlParams(): string;
    buildMappingUrl(specifier: string): string;
    getBaseUrl(): string;
    registerImportMappings(newImportMetadata: ImportMetadata, rootSpecifiers: string[]): void;
    private getURI;
    resolveLocal(specifier: string): string | undefined;
    /**
     *  Resolves a the URI for a specified module.  It will return the value in this order:
     *
     *  1) Mapping from local URI cache
     *  2) The URI if a specifier is already an absolute URI
     *  3) Mapping fetched from a registered loader hook
     *  4)
     *  @param specifier
     *  @returns module URI
     */
    resolve(specifier: string): Promise<string>;
    private hasMappingHooks;
    /**
     *  Evaluates mapping hooks.  Returns first match. If all hooks return null call the mapping service.
     *  @param specifier Request module identifier
     *  @returns Import Metadata from the module root
     */
    private evaluateMappingHooks;
    private fetchNewMappings;
    private saveImportURIRecord;
}
//# sourceMappingURL=importMetadataResolver.d.ts.map