import { hasDocument } from './dom.js';
export function getBaseUrl() {
    let baseUrl = undefined;
    if (hasDocument) {
        // eslint-disable-next-line lwr/no-unguarded-apis, no-undef
        const baseEl = document.querySelector('base[href]');
        baseUrl = baseEl && baseEl.href;
    }
    // eslint-disable-next-line lwr/no-unguarded-apis
    if (!baseUrl && typeof location !== 'undefined') {
        // eslint-disable-next-line lwr/no-unguarded-apis, no-undef
        baseUrl = location.href.split('#')[0].split('?')[0];
        const lastSepIndex = baseUrl.lastIndexOf('/');
        if (lastSepIndex !== -1) {
            baseUrl = baseUrl.slice(0, lastSepIndex + 1);
        }
    }
    return baseUrl;
}
/**
 * Check if a string is a URL based on Common Internet Scheme Syntax
 * https://www.ietf.org/rfc/rfc1738.txt
 *
 * URL Format:
 *  <scheme>:<scheme-specific-part>
 * Common Internet Scheme Syntax:
 *  The scheme specific part starts with a double slash('//')
 *
 * A valid URL has a colon that is followed by a double slash.
 *
 * @param url - the url that is being checked
 * @returns boolean
 *
 * @example Valid URLs
 * 'https://salesforce.com'
 * 'http://localhost:3000'
 *
 * @example Invalid URLs
 * 'salesforce.com'
 * 'localhost:3000'
 * '@salesforce/label/type:namespace:name'
 */
export function isUrl(url) {
    return url.indexOf('://') !== -1;
}
// Borrowed and adapted from https://github.com/systemjs/systemjs/blob/master/src/common.js
// Resolves the first path segment relative to the second/parent URL
// eg: resolveIfNotPlainOrUrl('../test', 'http://www.site.com/one/two') => 'http://www.site.com/test'
// eg: resolveIfNotPlainOrUrl('./x/y/z', 'https://my.com/segment')).toBe('https://my.com/x/y/z')
export function resolveIfNotPlainOrUrl(relUrl, parentUrl) {
    const backslashRegEx = /\\/g;
    if (relUrl.indexOf('\\') !== -1)
        relUrl = relUrl.replace(backslashRegEx, '/');
    // protocol-relative
    if (relUrl[0] === '/' && relUrl[1] === '/') {
        return parentUrl.slice(0, parentUrl.indexOf(':') + 1) + relUrl;
    }
    // relative-url
    else if ((relUrl[0] === '.' &&
        (relUrl[1] === '/' ||
            (relUrl[1] === '.' && (relUrl[2] === '/' || (relUrl.length === 2 && (relUrl += '/')))) ||
            (relUrl.length === 1 && (relUrl += '/')))) ||
        relUrl[0] === '/') {
        const parentProtocol = parentUrl.slice(0, parentUrl.indexOf(':') + 1);
        let pathname;
        if (parentUrl[parentProtocol.length + 1] === '/') {
            // resolving to a :// so we need to read out the auth and host
            if (parentProtocol !== 'file:') {
                pathname = parentUrl.slice(parentProtocol.length + 2);
                pathname = pathname.slice(pathname.indexOf('/') + 1);
            }
            else {
                pathname = parentUrl.slice(8);
            }
        }
        else {
            // resolving to :/ so pathname is the /... part
            pathname = parentUrl.slice(parentProtocol.length + (parentUrl[parentProtocol.length] === '/' ? 1 : 0));
        }
        if (relUrl[0] === '/')
            return parentUrl.slice(0, parentUrl.length - pathname.length - 1) + relUrl;
        // join together and split for removal of .. and . segments
        // looping the string instead of anything fancy for perf reasons
        // '../../../../../z' resolved to 'x/y' is just 'z'
        const segmented = pathname.slice(0, pathname.lastIndexOf('/') + 1) + relUrl;
        const output = [];
        let segmentIndex = -1;
        for (let i = 0; i < segmented.length; i++) {
            // busy reading a segment - only terminate on '/'
            if (segmentIndex !== -1) {
                if (segmented[i] === '/') {
                    output.push(segmented.slice(segmentIndex, i + 1));
                    segmentIndex = -1;
                }
            }
            // new segment - check if it is relative
            else if (segmented[i] === '.') {
                // ../ segment
                if (segmented[i + 1] === '.' && (segmented[i + 2] === '/' || i + 2 === segmented.length)) {
                    output.pop();
                    i += 2;
                }
                // ./ segment
                else if (segmented[i + 1] === '/' || i + 1 === segmented.length) {
                    i += 1;
                }
                else {
                    // the start of a new segment as below
                    segmentIndex = i;
                }
            }
            // it is the start of a new segment
            else {
                segmentIndex = i;
            }
        }
        // finish reading out the last segment
        if (segmentIndex !== -1)
            output.push(segmented.slice(segmentIndex));
        return parentUrl.slice(0, parentUrl.length - pathname.length) + output.join('');
    }
}
export function resolveUrl(relUrl, parentUrl) {
    const resolvedUrl = resolveIfNotPlainOrUrl(relUrl, parentUrl) ||
        (isUrl(relUrl) ? relUrl : resolveIfNotPlainOrUrl('./' + relUrl, parentUrl));
    return resolvedUrl;
}
//# sourceMappingURL=url.js.map