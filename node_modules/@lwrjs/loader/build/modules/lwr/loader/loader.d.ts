import { Module } from './moduleRegistry/moduleRegistry.js';
import type { ServiceAPI, ImportMetadata } from '@lwrjs/types';
import type { FingerprintsLoaderConfig as LoaderConfig } from '../../../types.js';
/**
 * The LWR loader is inspired and borrows from the algorithms and native browser principles of https://github.com/systemjs/systemjs
 */
export declare class Loader {
    private registry;
    readonly services: Readonly<Pick<ServiceAPI, 'addLoaderPlugin' | 'handleStaleModule' | 'appMetadata'>>;
    constructor(config: LoaderConfig);
    /**
     * Defines/registers a single named AMD module definition.
     *
     * @param {string} name The module name
     * @param {string[]} dependencies A list of module dependencies (module imports)
     * @param {Function} execute The function containing the module code. AKA exporter as it also returns the modules exports when executed
     * @return {void}
     */
    define(name: string, dependencies: string[], execute: Function): void;
    /**
     * Retrieves/loads a module, returning it from the registry if it exists and fetching it if it doesn't.
     *
     * @param {string} id - A module identifier or URL
     * @param {string} importer - The versioned specifier of the module importer
     *                            Used when the ID is not versioned (eg: variable dynamic imports)
     * @return {Promise<Module>}
     */
    load(id: string, importer?: string): Promise<Module>;
    /**
     * Checks if a Module exists in the registry.  Note, returns false even if the ModuleDefinition exists but the Module has not been instantiated yet (executed).
     *
     * @param {string} id - A module identifier or URL
     * @return {boolean}
     */
    has(id: string): boolean;
    /**
     * Resolves the module identifier or URL.  Returns the module identifier if the moduleDefinition exists, or the full resolved URL if a URL is given.
     *
     * @param {string} id - A module identifier or URL
     * @param {string} importer - The versioned specifier of the module importer
     *                            Used when the ID is not versioned (eg: variable dynamic imports)
     * @return {string}
     */
    resolve(id: string, importer?: string): Promise<string>;
    registerImportMappings(mappings: ImportMetadata, rootSpecifiers: string[]): Promise<void>;
    /**
     * Marks modules as "externally" loaded/provided (e.g. preloaded), so that the loader does not attempt to load them.
     *
     * @param modules - list of module identifiers
     */
    registerExternalModules(modules: string[]): void;
}
//# sourceMappingURL=loader.d.ts.map